
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title> - Sunrise-shine的博客</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="Just do it!,title: The-core-of-Javadate: 2022-01-01 15:57:57tags: 核心卷一
第四章 对象与类第一节 面向对象程序设计概述类类使构造对象的模板或蓝图。可以将类,"> 
    <meta name="author" content="Sunrise-shine"> 
    <link rel="alternative" href="atom.xml" title="Sunrise-shine的博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.4.1"></head>

<body class="loading">
    <span id="config-title" style="display:none">Sunrise-shine的博客</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://Sunrise-shine.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle"></h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title"></h1>
        <div class="stuff">
            <span>一月 01, 2022</span>
            

        </div>
        <div class="content markdown">
            <p>title: The-core-of-Java<br>date: 2022-01-01 15:57:57<br>tags: 核心卷一</p>
<h1 id="第四章-对象与类"><a href="#第四章-对象与类" class="headerlink" title="第四章 对象与类"></a>第四章 对象与类</h1><h2 id="第一节-面向对象程序设计概述"><a href="#第一节-面向对象程序设计概述" class="headerlink" title="第一节 面向对象程序设计概述"></a>第一节 面向对象程序设计概述</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类使构造对象的模板或蓝图。可以将类想象成制作小甜饼的切割机，将对象想象为小甜饼。由类构造对象的过程称为创建类的实例。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>(有时称为数据隐藏)是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在一个包里，并对对象的使用者隐藏了数据的实现方式。对象中的数据称为实例域，操纵数据的过程成为方法。对每个特定的类实例(对象)都有一组特定的实例域值。这些值的集合就是这个对象的当前状态。不管何时，只要向对象发送一个消息，他的状态就有可能发生改变。</p>
<p><strong>实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。</strong></p>
<p>这意味着一个类可以全面地改变存储数据的方式，只要仍然使用同样的方法操作数据，其他对象就不会知道或介意所发生的变化。</p>
<p>OOP的另一个原则会让用户自定义Java类变得轻而易举，这就是：可以通过扩展一个类来建立另一个新的类。事实上，在Java中，所有的类都源自于一个“超类”，他就是Object。</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="对象的三个主要特性："><a href="#对象的三个主要特性：" class="headerlink" title="对象的三个主要特性："></a>对象的三个主要特性：</h4><ul>
<li>对象的行为(behavior) —— 可以对对象施加哪些操作，或可以对对象施法哪些方法？</li>
<li>对象的状态(state) —— 当施加那些方法时，对象如何响应？</li>
<li>对象标识(identity) —— 如何辨别具有相同行为与状态的不同对象？</li>
</ul>
<p>同一个类的所有对象实例，由于支持相同的行为而具有家族式的相似性。对象的行为是用可调用的方法定义的。</p>
<p>此外，每个对象都保存着描述当前特征的信息。这就是对象的装填。对象状态的改变必须通过调用方法实现(如果不经过方法调用就可以改变对象的状态，只能说明封装性遭到了破坏)。</p>
<p>但是，对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份(identity)。也就是说，作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。</p>
<h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>在类之间，最常见的关系有</p>
<ul>
<li>依赖(“uses-a”)</li>
<li>聚合(“has-a”)</li>
<li>继承(“is-a”)</li>
</ul>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>即”uses-a”关系，是一种最明显的、最常见的关系。例如，Order(订单)类使用Account(账户)类是因为Order对象需要访问Account对象查看信用状态。但是Item类不依赖于Account类，这是因为Item对象与客户账户无关。因此，如果一个类的方法操纵另一个类的对象，就说一个类依赖于另一个类。</p>
<p>应该尽可能地将相互依赖的类减至最少。就是让类之间的耦合度最小。</p>
<h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>即”has-a”关系，是一种具体且易于理解的关系。例如，一个Order对象包含一些Item(商品)类。</p>
<p>聚合关系意味着类A的对象包含类B的对象。</p>
<blockquote>
<p>有些方法学家，会更喜欢使用“关联”这个术语，而不喜欢聚合这个概念。</p>
</blockquote>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>即“is-a”关系，是一种用于表示特殊与一般关系的。例如，RushOrder类由Order类继承而来。在具有特殊性的RushOrder类中包含了一些用于优先处理的特殊方法，以及一个计算运费的不同方法。</p>
<h2 id="第二讲-使用预定义类"><a href="#第二讲-使用预定义类" class="headerlink" title="第二讲 使用预定义类"></a>第二讲 使用预定义类</h2><h3 id="更改器方法与访问器方法"><a href="#更改器方法与访问器方法" class="headerlink" title="更改器方法与访问器方法"></a>更改器方法与访问器方法</h3><p><code>LocalDate aThousandDaysLater = newYearsEve.plusDays(1000);</code></p>
<p>这个调用之后newYearsEve会有什么变化？他会改为1000天之后的日期吗？事实上，并没有。plusDays方法会生成一个新的LocalDate对象，然后把这个新对象赋给aThousandDaysLater变量。原来的对象不做任何改动。也就是说plusDays方法没有更改调用这个方法的对象。</p>
<p>则称，只访问对象而不修改对象的方法为<strong>访问器方法</strong>(accessor method)。</p>
<p><strong>更改器方法</strong>(mutator method)调用后，对象的状态会发生改变。</p>
<h2 id="第三讲-用户自定义类"><a href="#第三讲-用户自定义类" class="headerlink" title="第三讲 用户自定义类"></a>第三讲 用户自定义类</h2><h3 id="隐式参数与显式参数"><a href="#隐式参数与显式参数" class="headerlink" title="隐式参数与显式参数"></a>隐式参数与显式参数</h3><p>方法用于操作对象以及存取它们的实例域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">raiseSalary</span> <span class="params">(<span class="type">double</span> byPercent)</span> &#123;</span><br><span class="line">	<span class="type">double</span> <span class="variable">raise</span> <span class="operator">=</span> salary * byPercent/ <span class="number">100</span>;</span><br><span class="line">    salary = raise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有两个参数。第一个参数称为隐式(implicit)参数，是出现在方法名前面Employee对象。第二个参数是位于方法名后面括号中的数值，这是一个显式(explicit)参数。(隐式参数也就是方法调用的目标或接收者)</p>
<h3 id="封装的优点"><a href="#封装的优点" class="headerlink" title="封装的优点"></a>封装的优点</h3><p><code>public double getSalary() &#123;return salary;&#125;</code></p>
<p>如上是典型的访问器方法。由于它们只返回实例域值，因此又称为域访问器。</p>
<p>那将salary域标记为public，以此来取代独立的访问器方法呢？</p>
<p>假如salary是一个只读域，那么一旦在构造器中设置完毕，就没有任何一个方法可以对它进行修改，这样来确保salary域不会受到外界的破坏。</p>
<p>不过，虽然salary不是只读域，但是它只能用raiseSalary方法修改。特别是一旦这个域值出现了错误，只要调试这个方法就可以了。如果salary域是public的，破坏这个域值的捣乱者有可能会出没在任何地方。</p>
<p>在有些时候，需要获得或设置实例域的值。因此，应该提供下面三项内容：</p>
<ul>
<li>一个私有的数据域；</li>
<li>一个公有的域访问器方法；</li>
<li>一个公有的域更改器方法。</li>
</ul>
<p>这样做要比提供一个简单的公有数据域复杂些。但是却有着下列明显的好处：</p>
<p>首先，可以改变内部实现，除了该类的方法之外，不会影响其他代码。</p>
<p>其次，更改器可以进行错误检查，防止一些不合理的赋值。</p>
<h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><p>尽管大多数方法都被设计为公有的，但在某些特殊的情况下，也可能将它们设定为私有的。有时，可能希望将一个计算代码划分成若干独立的辅助方法。通常，这些辅助方法不应该成为公有方法的一部分，这是由于它们往往与当前的实现机制非常紧密，或者需要一个特别的协议以及一个特别的调用次序，最好将这样的方法设计为private的。</p>
<p>对于私有方法，如果改用其它方法实现相应的操作，则不必保留原有方法。如果数据的表达方式发生了变化，这个方法可能就变得难以实现，或者不再需要。然而，只要方法是private，类的设计者就可以确认，<strong>它不会被外部的其他类操作调用，可以将其删除。</strong></p>
<h3 id="final实例域"><a href="#final实例域" class="headerlink" title="final实例域"></a>final实例域</h3><p>可以将一个实例域定义为final，构建对象时，必须初始化这样的域。也就是说，必须在确保一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。</p>
<p>final修饰符大都应用于基本(primitive)类型域，或不可变(immutable)类的域(如果类中的每个方法都不会改变其对象，这种类就是不可变的类。)。</p>
<p>如果final修饰的是类的话，也就表示，该引用变量不能再指向其他对象，但对象的值可以发生改变。</p>
<h2 id="第四讲-静态域与静态方法"><a href="#第四讲-静态域与静态方法" class="headerlink" title="第四讲 静态域与静态方法"></a>第四讲 静态域与静态方法</h2><h3 id="静态域-类域"><a href="#静态域-类域" class="headerlink" title="静态域(类域)"></a>静态域(类域)</h3><p>如果将域定义为static，每个类中只有一个这样的域。它属于类，而不属于任何一个独立的对象。</p>
<p>每个对象对于类的实例域都有自己的一份拷贝。如，100个对象，会有100个实例域，但只有1个静态域。</p>
<h3 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h3><p>静态变量用的比较少，但静态常量却用的多。例如：</p>
<p><img src="https://s2.loli.net/2022/01/03/A5zFJnPmtY7h64w.png" alt="image-20220103161658620"></p>
<p>一般来说，由于任何对象都可以对公有域进行修改，所以，最好不要将域设计为public，但公有常量(final域)却没有关系，因为此时，不允许再赋其他值给它。</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><strong>静态方法是一种不能向对象实施的方法</strong>。例如，Math类中的pow：<code>Math.pow(x,a)</code>，在运算时，不使用任何的Math对象。换句话说，没有隐式的参数。</p>
<h3 id="使用静态方法"><a href="#使用静态方法" class="headerlink" title="使用静态方法"></a>使用静态方法</h3><p>在下面两种情况下使用静态方法：</p>
<ul>
<li>一个方法不需要访问对象状态，其所需的参数都是通过显示参数提供的</li>
<li>一个方法只需要访问类的静态域</li>
</ul>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>静态方法还有另一个用途，类似LocalDate和NumberFormat的类使用静态工厂方法(factory method)来构造对象。如下所示，生成不同风格的格式化对象：</p>
<p><img src="https://s2.loli.net/2022/01/03/YHGeydBEaxTtRFn.png" alt="image-20220103163937139"></p>
<p>为什么不使用构造器？</p>
<ul>
<li>无法命名构造器。构造器的名字必须和类名相同。但是，这里希望将得到的货币实例和百分比实例采用不同的名字。</li>
<li>当使用构造器时，无法改变所构造的对象类型。而Factory方法将返回一个DecimalFormat类对象，这是NumberFormat的子类。</li>
</ul>
<h2 id="第五讲-方法参数"><a href="#第五讲-方法参数" class="headerlink" title="第五讲 方法参数"></a>第五讲 方法参数</h2><p>方法参数一共有两种类型：</p>
<ul>
<li>基本数据类型</li>
<li>对象引用</li>
</ul>
<p>对于Java而言，总是采用按值调用。</p>
<p>也就是说，一个方法不可能修改一个基本数据类型的参数。</p>
<p><img src="https://s2.loli.net/2022/01/03/py5Tt4QFhe6kUr3.png" alt="image-20220103165356193"></p>
<p>而对象引用作为参数就不同了。</p>
<p><img src="https://s2.loli.net/2022/01/03/gh1LAIFiPGyxBTu.png" alt="image-20220103165431987"></p>
<p>因为对象的空间是固定的，拷贝的是引用，二者同时引用同一个对象，即指向一个固定的堆空间。</p>
<p>但要记住，Java程序设计语言总是采用<strong>按值调用</strong>，不是类似C++中的引用。也就是说，传递的不是地址！若是直接将两个对象引用作为参数进行交换操作，并不能实现对象指向的交换。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>一个方法不能修改一个基本数据类型的参数(数值型或布尔型)</li>
<li>一个方法可以改变一个对象参数的状态</li>
<li>一个方法不能让对象参数引用一个新的对象</li>
</ul>
<h2 id="第六讲-对象构造"><a href="#第六讲-对象构造" class="headerlink" title="第六讲 对象构造"></a>第六讲 对象构造</h2><h3 id="显式域初始化"><a href="#显式域初始化" class="headerlink" title="显式域初始化"></a>显式域初始化</h3><p>通过重载类的构造器方法，可以采用多种形式设置类的实例域的初始状态。确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值，这是一种很好的设计习惯。</p>
<h3 id="调用另一个构造器"><a href="#调用另一个构造器" class="headerlink" title="调用另一个构造器"></a>调用另一个构造器</h3><p>关键字this引用方法的隐式参数。不过这个关键字还有另一个含义。</p>
<p>如果构造器的第一个语句形如this(…)，这个构造器将调用同一个类的另一个构造器。</p>
<p><img src="https://s2.loli.net/2022/01/03/INWmxkURs9B2tCY.png" alt="image-20220103202413693"></p>
<p>在调用这个方法时，该方法将去调用Employee(String, double)构造器。</p>
<p>这种方式使用this关键字非常有用，这样对公共的构造器代码部分只编写一次即可。</p>
<blockquote>
<p>但C++中，一个构造器不能调用另一个构造器。</p>
</blockquote>
<h3 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h3><h4 id="初始化数据域的方法"><a href="#初始化数据域的方法" class="headerlink" title="初始化数据域的方法"></a>初始化数据域的方法</h4><ul>
<li>在构造器中设置值</li>
<li>在声明中赋值</li>
<li>初始化块</li>
</ul>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。</p>
<p><img src="https://s2.loli.net/2022/01/03/7qXQc8sgJHDrL2w.png" alt="image-20220103203502225"></p>
<p>这种机制不是必需的，也不常见。通常会直接将初始化代码放在构造器中。</p>
<p><img src="https://s2.loli.net/2022/01/03/vYbOosAtuxQDmaX.png" alt="image-20220103204013531"></p>
<p>当然，应该精心地组织好初始化代码。</p>
<h3 id="静态域初始化"><a href="#静态域初始化" class="headerlink" title="静态域初始化"></a>静态域初始化</h3><ul>
<li>提供一个初始化值</li>
</ul>
<p><code>private static int nextId = 1;</code></p>
<ul>
<li>使用静态的初始化块</li>
</ul>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20220104011743662.png" alt="image-20220104011743662"></p>
<h3 id="对象析构与finalize方法"><a href="#对象析构与finalize方法" class="headerlink" title="对象析构与finalize方法"></a>对象析构与finalize方法</h3><p>在析构器中，最常见的操作是回收分配给对象的存储空间。由于Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器。</p>
<p>当然，某些对象使用了内存之外的其他资源，例如，文件或使用了系统资源的另一个对象的句柄。在这种情况下，当资源不再需要时，将其回收和再利用将显得十分重要。</p>
<p>可以为类添加一个finalize方法。finalize方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用finalize方法回收任何短缺资源，这是因为很难直到这个方法什么时候才能够调用。</p>
<p><strong>如果某个资源需要在使用完毕后立刻被关闭，那么就需要由人工来管理。对象用完时，可以应用一个close方法来完成相应的清理操作。</strong></p>
<h2 id="第七讲-包"><a href="#第七讲-包" class="headerlink" title="第七讲 包"></a>第七讲 包</h2><h3 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h3><p>Java允许将包(package)将类组织起来。</p>
<p>使用包的主要原因时去确保类名的唯一性。</p>
<p>在包中定位类是编译器(compiler)的工作。类文件中的字节码肯定使用完整的包名来引用其他类。</p>
<blockquote>
<p>关于C++中import和#include弄混。</p>
<p>实际上，这两者之间并没有共同之处。在C++中，必须使用#include将外部特性的声明加载进来，这是因为C++编译器无法查看任何文件的内部，除了正在编译的文件以及在头文件中明确包含的文件。Java编译器可以查看其他文件的内容，只要告诉它到哪里去查看就可以了。</p>
<p>在C++中，与包机制类似的是命名空间(namespace)。在Java中。package与import语句类似于C++中的namespace和using指令。</p>
</blockquote>
<h3 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h3><p>前面已经接触过访问修饰符public和private。标记为public的部分可以被任意的类使用，标记为private的部分只能被定义它们的类使用。</p>
<p><strong>如果没有指定public或private，这个部分(类、方法或变量)可以被同一个包的所有方法访问。</strong></p>
<h3 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1）把类放到一个目录中，例如/home/user/classdir。</p>
<p>需要注意，这个目录是包树状结构的基目录。如果希望将com.horstmann.corejava.Employee类添加到其中，这个Employee.class类文件就必须位于子目录/home/user/classdir/com/horstmann/corejava中。</p>
<p>2）将JAR文件放在一个目录中，例如：/home/user/archives。</p>
<p>3）设置类路径（class path）。类路径是所有包含类文件的路径的集合。</p>
<p>在UNIX环境中，类路径中的不同项目之间采用冒号（:)分隔：</p>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20220105154939555.png" alt="image-20220105154939555"></p>
<p>在上述两种情况中，句点（.）表示当前目录。</p>
<p>类路径包括：</p>
<p>●  基目录/home/user/classdir或c:\classes；</p>
<p>●  当前目录(.)；</p>
<p>●  JAR文件/home/user/archives/archive.jar或c:\archives\archive.jar。</p>
<h2 id="第九讲-文档注释"><a href="#第九讲-文档注释" class="headerlink" title="第九讲 文档注释"></a>第九讲 文档注释</h2><h3 id="1-方法注释"><a href="#1-方法注释" class="headerlink" title="1. 方法注释"></a>1. 方法注释</h3><p>每个方法注释必须放在所描述的方法之前。</p>
<p>除了通用标记之外，还可以使用下面的标记：</p>
<ul>
<li>@param 变量描述</li>
</ul>
<p>这个标记将对当前方法的“param”(参数)部分参加一个条目。这个描述可以占据多行，并可以使用HTML标记。一个方法的所有的@param标记必须放在一起。</p>
<ul>
<li>@return 描述</li>
</ul>
<p>这个标记将对当前添加”return”(返回)部分。这个描述可以跨越多行，并可以使用HTML标记。</p>
<ul>
<li>@throws 类描述</li>
</ul>
<p>这个标记将添加一个注释，用于表示这个方法可能抛出异常。</p>
<p><img src="https://s2.loli.net/2022/01/05/jDElf7oyhQ3ZTrv.png" alt="image-20220105160743393"></p>
<p><img src="https://s2.loli.net/2022/01/05/we6qAjmNELdGviu.png" alt="image-20220105161216316"></p>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20220105161131526.png" alt="image-20220105161131526"></p>
<h3 id="2-域注释"><a href="#2-域注释" class="headerlink" title="2. 域注释"></a>2. 域注释</h3><p><img src="https://s2.loli.net/2022/01/05/dGbf7SkvEDAqYpJ.png" alt="image-20220105161654770"></p>
<h3 id="3-通用注释"><a href="#3-通用注释" class="headerlink" title="3. 通用注释"></a>3. 通用注释</h3><ul>
<li>@author 姓名</li>
</ul>
<p>这个标记将产生一个”author”(作者)条目。可以使用多个@author标记，每个@author标记对应一个作者。</p>
<ul>
<li>@version 文本</li>
</ul>
<p>这个标记将产生一个“version”(版本)条目。这里的文本可以是对当前版本的任何描述。</p>
<h4 id="4-下面的标记可以用于所有的文档注释"><a href="#4-下面的标记可以用于所有的文档注释" class="headerlink" title="4. 下面的标记可以用于所有的文档注释"></a>4. 下面的标记可以用于所有的文档注释</h4><ul>
<li>@since 文本</li>
</ul>
<p>这个标记将产生一个“since”(始于)条目。这里的text可以是对引入特性的版本描述。例如，@since version 1.7.1。</p>
<ul>
<li>@deprecated文本</li>
</ul>
<p>这个标记将对类、方法或变量天机一个不再使用的注释。文本中给出了取代的建议。</p>
<p><img src="https://s2.loli.net/2022/01/05/kG4KaUy9HYEJdMR.png" alt="image-20220105162315965"></p>
<p><img src="https://s2.loli.net/2022/01/05/X3oF6BbLTYkrGgQ.png" alt="image-20220105162409646"></p>
<h2 id="类设计的技巧"><a href="#类设计的技巧" class="headerlink" title="类设计的技巧"></a>类设计的技巧</h2><h3 id="1-一定要保证数据私有"><a href="#1-一定要保证数据私有" class="headerlink" title="1. 一定要保证数据私有"></a>1. 一定要保证数据私有</h3><p>这是最重要的！</p>
<p><strong>绝对不要破坏封装性。有时候，需要编写一个访问器方法或更改器方法，但是最好还是保持实例域的私有性。</strong></p>
<p>很多惨痛的经验告诉我们，数据的表示形式很可能会改变，但他们的使用方式却不会经常发生变化。</p>
<p>当数据保持私有时，他们的表示形式的变化不会对类的使用者产生影响，即使出现bug也易于检测。</p>
<h3 id="2-一定要对数据初始化"><a href="#2-一定要对数据初始化" class="headerlink" title="2. 一定要对数据初始化"></a>2. 一定要对数据初始化</h3><p>Java不对局部变量进行初始化，但是会对对象的实力域进行初始化。最好不要依赖于系统的默认值，而是应该显式地初始化所有的数据。</p>
<p>具体的初始化方式可以是提供默认值，也可以是在所有构造器中设置默认值。</p>
<h3 id="3-不要在类中使用过多的基本类型"><a href="#3-不要在类中使用过多的基本类型" class="headerlink" title="3. 不要在类中使用过多的基本类型"></a>3. 不要在类中使用过多的基本类型</h3><p>就是说，用其他的类代替多个相关的基本类型的使用。</p>
<p>这样会使类更加易于理解且易于修改。</p>
<p><img src="https://s2.loli.net/2022/01/05/J4oiebVBCzvHKFk.png" alt="image-20220105163502555"></p>
<h3 id="4-不是所有的域都需要独立的域访问器和域更改器"><a href="#4-不是所有的域都需要独立的域访问器和域更改器" class="headerlink" title="4. 不是所有的域都需要独立的域访问器和域更改器"></a>4. 不是所有的域都需要独立的域访问器和域更改器</h3><p>或许，需要获得或设置雇员的薪金。而一旦构造了雇员对象，就应该禁止更改雇佣日期，并且在对象中，常常包含一些不希望别人获得或设置的实例域。</p>
<h3 id="5-将职责过多的类进行分解"><a href="#5-将职责过多的类进行分解" class="headerlink" title="5. 将职责过多的类进行分解"></a>5. 将职责过多的类进行分解</h3><p>这样说似乎有点含糊不清。</p>
<p>但是，如果明显地可以将一个复杂的类分解成两个更为简单的类，就应该将其分解。</p>
<h3 id="6-类名和方法名要能够体现它们的职责"><a href="#6-类名和方法名要能够体现它们的职责" class="headerlink" title="6. 类名和方法名要能够体现它们的职责"></a>6. 类名和方法名要能够体现它们的职责</h3><p>与变量应该有一个能够反映其含义的名字一样，类也能如此。</p>
<p>命名类名的良好习惯是采用一个名词(Order)、前面有形容词修饰的名词(RushOrder)或动名词(有“-ing”后缀)修饰名词(例如，BillingAddress)。</p>
<p>对于方法来说，习惯是访问器方法用小写get开头(getSalary)，更改器方法用小写的set开头(setSalary)。</p>
<h3 id="7-优先使用不可变的类"><a href="#7-优先使用不可变的类" class="headerlink" title="7. 优先使用不可变的类"></a>7. 优先使用不可变的类</h3><p>LocalDate类以及java.time包中的其他类是不可变的——没有方法能修改对象的状态。类似plusDays的方法并不是更改对象，而是返回状态已修改的新对象。</p>
<p>更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改。</p>
<p>其结果是不可预料的。如果类是不可变的，就可以安全地在多个线程间共享其对象。</p>
<p>因此，要尽可能让类是不可变的，这是一个很好的想法。对于表示值的类，如一个字符串或一个时间点，这尤其容易。计算会生成新值，而不是更新原来的值。</p>
<p>当然，并不是所有类都应当是不可变的。如果员工加薪时让raiseSalary方法返回一个新的Employee对象，这会很奇怪。</p>
<h1 id="第五章-继承"><a href="#第五章-继承" class="headerlink" title="第五章 继承"></a>第五章 继承</h1><h2 id="第一讲-类、超类和子类"><a href="#第一讲-类、超类和子类" class="headerlink" title="第一讲  类、超类和子类"></a>第一讲  类、超类和子类</h2><p>关键字extends表明正在构造的新类派生于一个已存在的类。</p>
<p><img src="https://s2.loli.net/2022/01/06/w4toM6dX5z7RUcm.png" alt="image-20220106213143904"></p>
<p>然而，这个方法并不能运行。这是因为Manager类的getSalary方法不能直接地访问超类的私有域。也就是说，尽管每个Manager对象都拥有一个名为salary的域，但在Manager类的getSalary方法中并不能够直接地访问salary域。只有Employee类的方法才能够访问私有部分。如果Manager类的方法一定要访问私有域，就必须借助于公有的接口，Employee类的公有方法getSalary正是这样一个接口。</p>
<p>这里需要指出：我们希望调用超类Employee的getSalary方法，而不是当前类的这个方法。为此，可以使用特定的关键字super解决这个问题：</p>
<p><img src="https://s2.loli.net/2022/01/06/qjSvxMA6JmKkXZi.png" alt="image-20220106213904248"></p>
<blockquote>
<h3 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h3><p>有些人认为super与this引用是类似的概念，实际上：</p>
<p><strong>super并不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。</strong></p>
<p>this两个用途：</p>
<ul>
<li>引用隐式参数</li>
<li>调用该类的其他的构造器(第一条语句)</li>
</ul>
<p>super两个用途：</p>
<ul>
<li>调用超类的方法</li>
<li>调用超类的构造器(第一条语句)</li>
</ul>
</blockquote>
<p><img src="https://s2.loli.net/2022/01/06/584HmLGXJPiYanW.png" alt="image-20220106214721586"></p>
<p>当e引用Employee对象时，e.getSalary( )调用的是Employee类中的getSalary方法；当e引用Manager对象时，e.getSalary( )调用的是Manager类中的getSalary方法。</p>
<p>虚拟机知道e实际引用的对象类型，因此能够正确地调用相应的方法。</p>
<p>一个对象变量（例如，变量e）可以指示多种实际类型的现象被称为<strong>多态</strong>（polymorphism）。</p>
<p>在运行时能够自动地选择调用哪个方法的现象称为<strong>动态绑定</strong>（dynamic binding）。</p>
<h3 id="第五节-多态"><a href="#第五节-多态" class="headerlink" title="第五节 多态"></a>第五节 多态</h3><p>在Java程序设计语言里，<strong>对象变量是多态的</strong>。一个Employee变量既可以引用一个Employee类的对象，也可以引用一个Employee类的任何一个子类的对象，如Manager对象。</p>
<p><img src="https://s2.loli.net/2022/01/06/GIFhMEeC9s247LB.png" alt="image-20220106215805539"></p>
<p><img src="https://s2.loli.net/2022/01/06/yJeQb6hGTlD2sfV.png" alt="image-20220106215854899"></p>
<p>因为，staff[0]声明的类型是Employee，而setBonus不是Employee类的方法。</p>
<p><img src="https://s2.loli.net/2022/01/06/8ytxkeBmWQTjna1.png" alt="image-20220106220145915"></p>
<p>在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。</p>
<p><img src="https://s2.loli.net/2022/01/06/GXA2CRPaQkOjech.png" alt="image-20220106220331459"></p>
<p>使用new Manager[10]创建的数组是一个经理数组，如果试图存储一个Employee类型的引用就会引发ArrayStoreException异常。</p>
<h3 id="第六节-理解方法调用"><a href="#第六节-理解方法调用" class="headerlink" title="第六节 理解方法调用"></a>第六节 理解方法调用</h3><p>弄清楚如何在对象上应用方法调用非常重要。</p>
<p>下面假设要调用x.f(args)，隐式参数x声明为类C的一个对象。</p>
<h4 id="1-下面是调用过程的详细描述："><a href="#1-下面是调用过程的详细描述：" class="headerlink" title="1. 下面是调用过程的详细描述："></a>1. 下面是调用过程的详细描述：</h4><p><strong>1）编译器查看对象的声明类型和方法名。</strong></p>
<p>假设调用x.f(param)，且隐式参数x声明为C类的对象。需要注意的是：有可能存在多个名字为f，但参数类型不一样的方法。例如，可能存在方法f(int)和方法f(String)。编译器将会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法（超类的私有方法不可访问）。至此，编译器已获得所有可能被调用的候选方法。</p>
<p><strong>2）接下来，编译器将查看调用方法时提供的参数类型。</strong></p>
<p>如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为重载解析（overloading resolution）。例如，对于调用x.f(“Hello”)来说，编译器将会挑选f(String)，而不是f(int)。由于允许类型转换（int可以转换成double, Manager可以转换成Employee，等等），所以这个过程可能很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。</p>
<p>至此，编译器已获得需要调用的方法名字和参数类型。</p>
<blockquote>
<h4 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h4><p>前面曾经说过，<strong>方法的名字和参数列表称为方法的签名。</strong></p>
<p>例如，f(int)和f(String)是两个具有相同名字，不同签名的方法。如果在子类中定义了一个与超类签名相同的方法，那么子类中的这个方法就覆盖了超类中的这个相同签名的方法。</p>
<p>不过，返回类型不是签名的一部分，因此，在覆盖方法时，一定要保证返回类型的兼容性。</p>
<p>允许子类将覆盖方法的返回类型定义为原返回类型的子类型</p>
</blockquote>
<p><strong>3）如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为静态绑定（static binding）。</strong></p>
<p>与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。在我们列举的示例中，编译器采用动态绑定的方式生成一条调用f (String)的指令。</p>
<p><strong>4）当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。</strong></p>
<p>假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就直接调用它；否则，将在D类的超类中寻找f(String)，以此类推。</p>
<h4 id="2-方法表"><a href="#2-方法表" class="headerlink" title="2. 方法表"></a>2. 方法表</h4><p>每次调用方法都要进行搜索，时间开销相当大。</p>
<p>因此，虚拟机预先为每个类创建了一个<strong>方法表（method table）</strong>，其中列出了所有方法的签名和实际调用的方法。</p>
<p>这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。</p>
<p>在前面的例子中，虚拟机搜索D类的方法表，以便寻找与调用f(Sting)相匹配的方法。这个方法既有可能是D.f(String)，也有可能是X.f(String)，这里的X是D的超类。这里需要提醒一点，如果调用super.f(param)，编译器将对隐式参数超类的方法表进行搜索。</p>
<p><img src="https://s2.loli.net/2022/01/06/vgGCnimSphPfyWJ.png" alt="image-20220106222122309"></p>
<p>动态绑定有个非常重要的特性：</p>
<p>无需对现存的代码进行修改，就可以对程序进行拓展。假设增加一个新类Executive，并且变量e有可能引用这个类的对象，我们不需要对包含调用e.getSalary()的代码进行重新编译。如果e恰好引用一个Executive类的对象，就会自动地调用Executive.getSalary()方法。</p>
<h3 id="第八讲-强制类型转换"><a href="#第八讲-强制类型转换" class="headerlink" title="第八讲 强制类型转换"></a>第八讲 强制类型转换</h3><p><img src="https://s2.loli.net/2022/01/06/HyVSjae4CBIZvrg.png" alt="image-20220106222959327"></p>
<h4 id="进行的唯一原因"><a href="#进行的唯一原因" class="headerlink" title="进行的唯一原因"></a>进行的唯一原因</h4><p>在暂时忽视对象的实际类型之后，使用对象的全部功能。</p>
<p>例如，我们需要将数组中引用经理的元素复原成Manager类，以便能够访问新增加的所有变量。</p>
<p><strong>将一个值存入变量时，编译器将检查是否允许该操作。</strong></p>
<p><strong>将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检查。</strong></p>
<h4 id="因此"><a href="#因此" class="headerlink" title="因此"></a>因此</h4><p>应该养成这样一个良好的程序设计习惯：</p>
<p>在进行类型转换之前，先查看一下是否能够成功地转换。这个过程简单地使用instanceof操作符就可以实现。</p>
<p><img src="https://s2.loli.net/2022/01/06/P6xaWHNV2iBznck.png" alt="image-20220106223351872"></p>
<p>在一般情况下，应当尽量少用强制类型转换和instanceof。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>只能在继承层次内进行类型转换。</li>
<li>再将超类转换成子类之前，应该使用instanceof进行检查。</li>
</ul>
<h3 id="第九节-抽象类"><a href="#第九节-抽象类" class="headerlink" title="第九节 抽象类"></a>第九节 抽象类</h3><p><img src="https://s2.loli.net/2022/01/06/n57lrmIu4kg2Q9C.png" alt="image-20220106223848993"></p>
<p>在Person中，</p>
<p><img src="https://s2.loli.net/2022/01/06/k9eO1AjQcEUxDNn.png" alt="image-20220106224101130"></p>
<p><strong>许多程序员认为，在抽象类中不能包含具体方法。建议尽量将通用的域和方法（不管是否是抽象的）放在超类（不管是否是抽象类）中。</strong></p>
<p>抽象方法充当着占位的角色，它们的具体实现在子类中。</p>
<h4 id="1-扩展抽象类可以有两种选择。"><a href="#1-扩展抽象类可以有两种选择。" class="headerlink" title="1. 扩展抽象类可以有两种选择。"></a>1. 扩展抽象类可以有两种选择。</h4><ul>
<li><p>一种是在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类；</p>
</li>
<li><p>另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。</p>
</li>
</ul>
<p>例如，通过扩展抽象Person类，并实现getDescription方法来定义Student类。由于在Student类中不再含有抽象方法，所以不必将这个类声明为抽象的。类即使不含抽象方法，也可以将类声明为抽象类。</p>
<h4 id="2-抽象类不能被实例化。"><a href="#2-抽象类不能被实例化。" class="headerlink" title="2. 抽象类不能被实例化。"></a>2. 抽象类不能被实例化。</h4><p>也就是说，如果将一个类声明为abstract，就不能创建这个类的对象。</p>
<p><strong>需要注意，可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。</strong>例如，</p>
<p><img src="https://s2.loli.net/2022/01/06/pZyfraxLwRIiOUE.png" alt="image-20220106224627968"></p>
<p>这里的p是一个抽象类Person的变量，Person引用了一个非抽象子类Student的实例。</p>
<h3 id="Java用于控制可见性的4个访问修饰符："><a href="#Java用于控制可见性的4个访问修饰符：" class="headerlink" title="Java用于控制可见性的4个访问修饰符："></a>Java用于控制可见性的4个访问修饰符：</h3><ul>
<li>仅对本类可见——private。</li>
<li>对所有类可见——public。</li>
<li>对本包和所有子类可见——protected。</li>
<li>对本包可见——默认（很遗憾），不需要修饰符。</li>
</ul>
<h2 id="第二讲-Object：所有类的超类"><a href="#第二讲-Object：所有类的超类" class="headerlink" title="第二讲 Object：所有类的超类"></a>第二讲 Object：所有类的超类</h2><p>在Java中，只有基本类型不是对象。</p>
<h3 id="第一节-equals-方法"><a href="#第一节-equals-方法" class="headerlink" title="第一节 equals 方法"></a>第一节 equals 方法</h3><p><img src="https://s2.loli.net/2022/01/17/zDTi9tMsyOCfbPg.png" alt="image-20220117213943571"></p>
<blockquote>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p><strong>为了防备name或hireDay可能为null的情况，需要使用Objects.equals方法。</strong></p>
<p>如果两个参数都为null, Objects.equals(a, b)调用将返回true；如果其中一个参数为null，则返回false；否则，如果两个参数都不为null，则调用a.equals(b)。利用这个方法，Employee.equals方法的最后一条语句要改写为：</p>
<p><img src="https://s2.loli.net/2022/01/17/VuKSeBdMj5lN2zc.png" alt="image-20220117225732398"></p>
</blockquote>
<p>在子类中定义equals方法时，首先调用超类的equals。如果检测失败，对象就不可能相等。如果超类中的域都相等，就需要比较子类中的实例域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object otherObject)</span> &#123;</span><br><span class="line">        <span class="comment">// super.equals checked that this and otherObject belong to the same class</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">super</span>.equals(otherObject))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">other</span> <span class="operator">=</span> (Manager) otherObject;</span><br><span class="line">        <span class="type">return</span> <span class="variable">bonus</span> <span class="operator">=</span>= other.bonus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java语言规范要求equals方法具有下列特性：</p>
<ol>
<li><strong>自反性</strong>：对于任何非空引用x,  x.equals(x)应该返回true。</li>
<li><strong>对称性</strong>：对于任何引用x和y，当且仅当y.equals(x)返回true， x.equals(y)也应该返回true。</li>
<li><strong>传递性</strong>：对于任何引用x、y和z，如果x.equals(y)返回true， y.equals(z)返回true， x.equals(z)也应该返回true。</li>
<li><strong>一致性</strong>：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果。</li>
<li><strong>对于任意非空引用x， x.equals(null)应该返回false。</strong></li>
</ol>
<p><img src="https://s2.loli.net/2022/01/17/2pbVS14yPh8EQfC.png" alt="image-20220117232952358"></p>
<h4 id="下面给出编写一个完美的equals方法的建议："><a href="#下面给出编写一个完美的equals方法的建议：" class="headerlink" title="下面给出编写一个完美的equals方法的建议："></a>下面给出编写一个完美的equals方法的建议：</h4><p>1）显式参数命名为otherObject，稍后需要将它转换成另一个叫做other的变量。</p>
<p>2）检测this与otherObject是否引用同一个对象：</p>
<p><code>if (this == otherObject) return true;</code></p>
<p>这条语句只是一个优化。实际上，这是一种经常采用的形式。</p>
<p><strong>因为计算这个等式要比一个一个地比较类中的域所付出的代价小得多。</strong></p>
<p>3）检测otherObject是否为null，如果为null，返回false。这项检测是很必要的。</p>
<p><code>if (otherObject == null) return false;</code></p>
<p>4）比较this与otherObject是否属于同一类。如果equals的语义在每个子类中有所改变，就使用getClass检测：</p>
<p><code>if (getClass() != otherObject.getClass()) return false;</code></p>
<p>如果所有的子类都拥有统一的语义，就使用instanceof检测：</p>
<p><code>if (!(otherObject instanceof ClassName)) return false;</code></p>
<p>5）将otherObject转换为相应的类类型变量：</p>
<p><code>ClassName other = (ClassName) otherObject</code></p>
<p>6）现在开始对所有需要比较的域进行比较了。使用==比较基本类型域，使用equals比较对象域。如果所有的域都匹配，就返回true；否则返回false。</p>
<p><code>return field1 == other.field1 &amp;&amp; Objects.equals(field2, other.fields) &amp;&amp; ...;</code></p>
<p>如果在子类中重新定义equals，就要在其中包含调用super.equals(other)。</p>
<blockquote>
<p>对于数组类型的域，可以使用静态的Arrays.equals方法检测相应的数组元素是否相等。</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/01/18/f19UtvBs7MEOdCH.png" alt="image-20220118001450380"></p>
<h3 id="第二节-hashcode方法"><a href="#第二节-hashcode方法" class="headerlink" title="第二节 hashcode方法"></a>第二节 hashcode方法</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><p>散列码(hashcode)是由对象导出的一个整型值。散列码是没有规律的。如果x和y是两个不同的对象，x.hashCode( )与y.hashCode( )基本上不会相同。</p>
<p><img src="https://s2.loli.net/2022/01/18/KBXh3gSZmtCG4Mx.png" alt="image-20220118003233455"></p>
<p><img src="https://s2.loli.net/2022/01/18/rRsCczkHXWQvZ5d.png" alt="image-20220118003328447"></p>
<h4 id="2-为什么要有hashCode"><a href="#2-为什么要有hashCode" class="headerlink" title="2. 为什么要有hashCode"></a>2. 为什么要有hashCode</h4><p>当你把对象加入HashSet时，HashSet会先计算对象的hashCode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashCode值作比较，如果没有相符的hashCode，HashSet会假设对象没有重复出现。</p>
<p>但是如果发现有相同hashCode值的对象，这是会调用equals( )方法来检查hashCode相等的对象是否真的相同。</p>
<p>若两者相同，HashSet就不会让其加入成功，如果不同的话，就会重新散列到不同的位置。这样就减少了调用equals( )方法的次数，提高了执行速度。</p>
<h4 id="3-equals-和hashCode"><a href="#3-equals-和hashCode" class="headerlink" title="3. equals( )和hashCode( )"></a>3. equals( )和hashCode( )</h4><p>其实，hashCode( )和equals( )都是用于比较两个对象是否相等。</p>
<h5 id="1-同时提供"><a href="#1-同时提供" class="headerlink" title="1. 同时提供"></a>1. 同时提供</h5><p>因为在一些容器中(如HashMap、HashSet)中，有hashCode( )之后，判断元素是否在对应容器中的效率会更高。</p>
<p>当然，如果获得的hashCode( )相同，会使用equals( )判断是否真的相同。</p>
<p>同时，因为hashCode( )所使用的哈希算法，也许刚好会让多个对象传回相同的哈希值(越糟糕的哈希算法越容易碰撞，不过这也与数据值域分布放入特性有关)，这也导致了<strong>两个对象的hashCode值相等，并不代表两个对象就相等</strong>。</p>
<h5 id="2-所以"><a href="#2-所以" class="headerlink" title="2. 所以"></a>2. 所以</h5><ol>
<li>如果两个对象的hashCode值不相等，那么两个对象直接可以认为是不相等的。</li>
<li>如果两个对象的hashCode值相等，那么两个对象也不一定相等(哈希碰撞)。</li>
<li>如果两个对象的hashCode值相等且equals( )方法的返回值为true，则可以认为这两个对象相等。</li>
</ol>
<h5 id="3-重写equals-必须重写hashCode"><a href="#3-重写equals-必须重写hashCode" class="headerlink" title="3. 重写equals()必须重写hashCode()"></a>3. 重写equals()必须重写hashCode()</h5><p><strong>因为两个相等对象的hashCode值必须是相等的。也就是说，如果equals( )方法判断两个对象是相等的，那么这两个对象的hashCode值也要相等。</strong></p>
<p>如果重写equals( )方法时，没有重写hashCode( )方法的话，就可能会导致equals方法判断是相等的两个对象，hashCode值却不相等。 </p>
<h5 id="4-其他佐证"><a href="#4-其他佐证" class="headerlink" title="4. 其他佐证"></a>4. 其他佐证</h5><p><img src="https://s2.loli.net/2022/02/21/xz6jTLfG4s31B5R.png" alt="image-20220221235707389"></p>
<p><img src="https://s2.loli.net/2022/02/21/jGTsLIKUr3Z2QN8.png" alt="image-20220221235746077"></p>
<h4 id="4-重写hashCode方法"><a href="#4-重写hashCode方法" class="headerlink" title="4. 重写hashCode方法"></a>4. 重写hashCode方法</h4><p>hashCode方法应该返回一个整型数值(可以是负数)，并合理地组合实例域的散列码，以便能够让不同的对象产生散列码更加均匀。</p>
<p>首先，最好使用null安全的Objects.hashCode。如果其参数为null，会返回0，否则返回对参数调用hashCode方法的结果。</p>
<p>另外，对double类型的对象，调用静态方法Double.hashCode方法来避免创建Double对象：</p>
<p><img src="https://s2.loli.net/2022/02/22/KMOxUAc7DV4uXbG.png" alt="image-20220222000820113"></p>
<p>同时，需要组合多个散列值时，可以调用Objects.hash并提供多个参数。这个方法会对各个参数调用Objects.hashCode，并组合这些散列值。</p>
<p><img src="https://s2.loli.net/2022/02/22/ln71gMSFscJN6Pv.png" alt="image-20220222000939436"></p>
<h2 id="第三讲-泛型数组列表"><a href="#第三讲-泛型数组列表" class="headerlink" title="第三讲 泛型数组列表"></a>第三讲 泛型数组列表</h2><p>在Java中，允许在运行时确定数组的大小，但并不能在运行时动态更改数组。所以，ArrayList得以广泛应用。</p>
<h3 id="引子-菱形语法"><a href="#引子-菱形语法" class="headerlink" title="引子 菱形语法"></a>引子 菱形语法</h3><p>ArrayList是个采用类型参数(type parameter)的泛型类(generic class)。为了指定数组列表保存的元素对象类型，需要用一堆尖括号将类名括起来加在后面。如：</p>
<p><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(); // 省略了右边的类型参数</code></p>
<p>这被称为菱形语法，因为空尖括号&lt;&gt;就像一个菱形。可以结合new操作符使用菱形语法。编译器会检查新值是什么。如果赋值给一个变量，或传递到某个方法，或者从这个方法返回，编译器会检查这个变量、参数或方法的泛型类型，然后将这个类型放在&lt;&gt;中。在这个例子中，new ArrayList&lt;&gt;()将赋至一个类型为ArrayList<Employee>的变量，所以泛型类型为Employee。</p>
<h3 id="第一节-方法"><a href="#第一节-方法" class="headerlink" title="第一节 方法"></a>第一节 方法</h3><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>在数组列表中，如果调用add并且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。</p>
<h4 id="capacity-和-size"><a href="#capacity-和-size" class="headerlink" title="capacity 和 size"></a>capacity 和 size</h4><p>数组的大小和数组列表的容量有一个非常重要的区别。</p>
<p>如果为数组分配100个元素的存储空间，数组就有100个空位置可以使用。</p>
<p>而容量为100个元素的数组列表只是拥有保存100个元素的潜力。但是在最初，甚至完成了初始化构造之后，数组列表根本就不含有任何元素。</p>
<p>一旦能够确认数组列表的长度不再变化，可以使用trimToSize的方法。这个方法将存储区域的大小调整为当前元素数量所需的存储空间变化。垃圾回收器将回收多余的空间。(此时再添加新元素就需要花时间再次移动存储块，所以应该再确认不会添加任何元素的情况下，再调用trimToSize。)</p>
<h3 id="第二节-访问数组列表元素"><a href="#第二节-访问数组列表元素" class="headerlink" title="第二节 访问数组列表元素"></a>第二节 访问数组列表元素</h3><p>不能使用[ ]语法格式，只能使用set或get方法来实现访问或改变数组元素的操作。</p>
<h5 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h5><p>只有i小于等于数组列表的大小时，才能使用 list.set(i, x) 方法。例如，下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">list.set(<span class="number">0</span>, x); <span class="comment">//no element 0 yet</span></span><br></pre></td></tr></table></figure>
<p>使用add方法添加元素，使用set方法只能改变已有元素的值，不能添加。</p>
<h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><p><code>Employee a = staff.get(i);</code></p>
<h5 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h5><p>可以先使用数组列表创建并添加元素，之后使用.toArray( )方法将其转化为数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Employee[] x = <span class="keyword">new</span> <span class="title class_">Employee</span>[list.size()];</span><br><span class="line">list.toArray(x);</span><br></pre></td></tr></table></figure>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E object)</span>;</span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E object)</span>; <span class="comment">// 可以不用加index</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>; <span class="comment">// 删除一个元素，并将其后的元素向前移动，被删除的元素由返回值返回。</span></span><br></pre></td></tr></table></figure>
<h3 id="第三节-类型化与原始数组列表的兼容性"><a href="#第三节-类型化与原始数组列表的兼容性" class="headerlink" title="第三节 类型化与原始数组列表的兼容性"></a>第三节 类型化与原始数组列表的兼容性</h3><p>与没有使用类型参数的遗留代码交互操作。</p>
<ol>
<li><p>可以将一个类型化的数组列表作为函数的参数赋值给原始的ArrayList对象，如：</p>
<p> ArrayList<Employee> staff 可以作为参数赋值给ArrayList list，且不需要任何的类型转换。</p>
</li>
<li><p>但是将一个原始的ArrayList赋给一个类型化的ArrayList会得到一个警告信息。如</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> ArrayList <span class="title function_">find</span><span class="params">(String query)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Employee&gt; list = find(query); <span class="comment">// yields warning</span></span><br><span class="line"><span class="comment">// 使用类型转化也无用</span></span><br><span class="line">ArrayList&lt;Employee&gt; list = (ArrayList&lt;Employee&gt;)find(query); <span class="comment">// 指出类型转换有误</span></span><br></pre></td></tr></table></figure>
<p> 这就是Java中不尽如人意的参数化类型的限制所带来的结果。</p>
<p> 鉴于兼容性的考虑，编译器在对类型转换进行检查之后，如果没有发现违反规则的现象，就将所有的类型化类数组列表转换成原始ArrayList对象。</p>
<p> 即，在程序运行时，所有的数组列表都是一样的，没有虚拟机中的类型参数。</p>
</li>
</ol>
<h2 id="第四讲-对象包装器与自动装箱"><a href="#第四讲-对象包装器与自动装箱" class="headerlink" title="第四讲 对象包装器与自动装箱"></a>第四讲 对象包装器与自动装箱</h2><p>&lt; &gt;中的类型参数不允许是基本类型。</p>
<h3 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">3</span>); <span class="comment">// 会自动将其变换成list.add(Integer.valueOf(3));</span></span><br></pre></td></tr></table></figure>
<h3 id="自动拆箱"><a href="#自动拆箱" class="headerlink" title="自动拆箱"></a>自动拆箱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.get(i); <span class="comment">// 自动变换成list.get(i).intValue();</span></span><br></pre></td></tr></table></figure>
<h2 id="第五讲-参数数量可变的方法"><a href="#第五讲-参数数量可变的方法" class="headerlink" title="第五讲 参数数量可变的方法"></a>第五讲 参数数量可变的方法</h2><p>printf方法是这样定义的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(String fmt, Object... args)</span> &#123; <span class="keyword">return</span> format(fmt, args); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的…是Java代码的一部分，表示可以接收任意数目的变量。</p>
<p>其实，printf方法接收两个参数，一个是格式化字符串，一个是Object[ ]数组。</p>
<p><strong>但是只允许其作为最后一个参数。</strong></p>
<h2 id="第六讲-枚举类"><a href="#第六讲-枚举类" class="headerlink" title="第六讲 枚举类"></a>第六讲 枚举类</h2><p>举个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> enmu Size &#123; SMALL, MEDIUM, LARGE, EXTRA_LARGE &#125;;</span><br></pre></td></tr></table></figure>
<p>这个声明定义的类型是一个类，它刚好有4个实例，在此尽量不要构造新对象。</p>
<p>因此，在比较两个枚举类型的值时，永远不需要调用equels方法，而直接使用”==”即可。</p>
<p>可以添加一些构造器、方法和域。构造器只是在构造枚举常量的时候被调用。</p>
<p><img src="https://s2.loli.net/2022/03/06/zroXSF2fg3sjTp8.png" alt="image-20220306103631328"></p>
<p>所有的枚举类型都是Enum类的子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Size.SMALL.toString() <span class="comment">// 返回&quot;SMALL&quot;</span></span><br><span class="line"><span class="type">Size</span> <span class="variable">s</span> <span class="operator">=</span> Eunm.valueOf(Size.class, <span class="string">&quot;SMALL&quot;</span>); <span class="comment">// 设置Size为Size.SMALL</span></span><br><span class="line"><span class="keyword">static</span> Enum <span class="title function_">valueOf</span><span class="params">(Class enumClass, String name)</span> <span class="comment">// 返回指定名字、给定类的枚举常量</span></span><br><span class="line">Size[] values = Size.values(); <span class="comment">// 返回包含全部枚举值的数组</span></span><br><span class="line">Size.SMALL.ordinal() <span class="comment">// 返回enum声明中枚举常量的位置，从0开始计数，返回0.</span></span><br></pre></td></tr></table></figure>
<h2 id="第七讲-反射"><a href="#第七讲-反射" class="headerlink" title="第七讲 反射"></a>第七讲 反射</h2><h3 id="第0节-概述"><a href="#第0节-概述" class="headerlink" title="第0节 概述"></a>第0节 概述</h3><p>能够分析类能力的程序称为反射(reflective)。</p>
<p>反射机制可以用来：</p>
<ul>
<li>在运行时分析类的能力</li>
<li>在运行时查看对象</li>
<li>实现通用的数组操作代码</li>
<li>利用Method对象，类似C++中的函数指针</li>
</ul>
<h3 id="第一节-Class类"><a href="#第一节-Class类" class="headerlink" title="第一节 Class类"></a>第一节 Class类</h3><p>在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。</p>
<p>这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。</p>
<p>可以通过专门的Java类访问这些信息。保存这些信息的类被称为Class。</p>
<p><strong>Object类中的getClass()将返回一个Class类型的实例。</strong></p>
<p><strong>一个Class对象将表示一个特定类的属性。</strong></p>
<p>最常用的是getName( )方法，这个方法将返回类的名字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> generator.getClass();</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> c1.getName(); <span class="comment">// name is &quot;java.util.Random&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="获取Class对象的方法"><a href="#获取Class对象的方法" class="headerlink" title="获取Class对象的方法"></a>获取Class对象的方法</h4><ul>
<li>对象.getClass( );</li>
<li>类名.class;</li>
<li>Class.forName(全类名);</li>
</ul>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 法一：</span></span><br><span class="line"><span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> e.getClass();</span><br><span class="line"><span class="comment">// 法二：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;java.util.Random&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"><span class="comment">// 法三：</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Random.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="type">int</span>.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> Double[].class;</span><br></pre></td></tr></table></figure>
<p>法二：如果类名保存在字符串里，并可在运行中改变，就可以使用这个方法。</p>
<p>当然，这个方法只有在className中保存的是类名或接口名时才能够执行。</p>
<p>注意：一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类。如int不是类，但是int.class表示的是一个Class类型的对象。</p>
<h4 id="其他特点"><a href="#其他特点" class="headerlink" title="其他特点"></a>其他特点</h4><h5 id=""><a href="#" class="headerlink" title="=="></a>==</h5><p>虚拟机为每个类型管理一个Class对象，可以利用==来实现两个类对象比较的操作。</p>
<p><code>if (e.getClass() == Employee.class)&#123;...&#125;</code></p>
<h5 id="newInstance"><a href="#newInstance" class="headerlink" title="newInstance( )"></a>newInstance( )</h5><p>可以用来动态的创建一个类的实例</p>
<p><code>Object m = e.getClass().newInstance();</code></p>
<p>或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;java.util.Random&quot;</span>;</span><br><span class="line"><span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> Class.forName(className).newInstance();</span><br></pre></td></tr></table></figure>
<p>创建了一个和e同类型的实例。newInstance()方法调用默认的构造器(没有参数的构造器)来初始化新创建的对象，如果这个类没有默认的构造器，就会抛出一个异常。</p>
<h3 id="第二节-捕获异常"><a href="#第二节-捕获异常" class="headerlink" title="第二节 捕获异常"></a>第二节 捕获异常</h3><p>异常有两种类型：未检查异常和已检查异常。</p>
<p>对于已检查异常，编译器将会检查是否提供了处理器。</p>
<p>有很多常见的异常，如，访问null引用，都属于未检查移仓。编译器不会查看是否为这些错误提供了处理器。毕竟，应该精心编写代码来避免这些错误的发生，而不要将精力花在编写异常处理器上。</p>
<p>将可能抛出已检查异常的代码放置在try块中，然后在catch子句中提供处理器代码。</p>
<p>如果抛出异常，就会跳过try块中的剩余代码，去执行catch子句(利用Throwable类的printStackTrace方法打印出栈的轨迹。Throwable是Exception类的超类)。如果没有抛出异常，就会跳过catch中的处理器代码。</p>
<p><code>void printStackTrace() // 将Throwable对象和栈的轨迹输出到标准错误流。</code></p>
<h3 id="第三节-利用反射分析类"><a href="#第三节-利用反射分析类" class="headerlink" title="第三节 利用反射分析类"></a>第三节 利用反射分析类</h3><h4 id="三个类"><a href="#三个类" class="headerlink" title="三个类"></a>三个类</h4><p>反射机制最重要的内容—检查类的结构。</p>
<p>在java.lang.reflect包中有三个类：Field、Method和Constructor，分别用于描述类的域、方法和构造器。 </p>
<ul>
<li>getName方法：返回项目的名称</li>
<li>getModifiers方法：返回一个整型数值，用不同的位开关描述public和static这样的修饰符使用状况。(可以使用Modifier类的静态方法来分析返回的整型数值。)</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>Class类中的getFields、getMethods、getConstructors方法将分别返回类提供的public域、方法和构造器数组，其中包括超类的公有成员。</p>
<p>Class类中的getDeclareFields、getDeclareMethods和getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器，其中包括私有成员和受保护成员，但不包括超类中的成员。</p>
<h3 id="第四节-运行时使用反射分析对象"><a href="#第四节-运行时使用反射分析对象" class="headerlink" title="第四节 运行时使用反射分析对象"></a>第四节 运行时使用反射分析对象</h3><p>进一步查看数据域的实际内容。</p>
<p>查看对象域的关键方法是Field类中的get方法。如例所示：</p>
<p><img src="https://s2.loli.net/2022/03/09/JeguiE7tO1Fnmyw.png" alt="image-20220309175410048"></p>
<p>实际上，由于name是个私有域，所以get方法将会抛出一个IllegalAccessException。只有利用get方法才能得到可访问域的值。除非拥有访问权限，否则Java安全机制只允许查看任意对象有哪些域，而不允许读取它们的值。</p>
<p>反射机制的默认行为受限于Java的访问控制。然而，如果一个Java程序没有受到安全管理器的控制，就可以覆盖访问控制。为了达到这个目的，需要调用Field、Method或Constructor对象的setAccessible方法。</p>
<p><img src="https://s2.loli.net/2022/03/09/xGJ91tVPBIga82p.png" alt="image-20220309180116987"></p>
<p>setAccessible方法是AccessibleObject类中的一个方法，它是Field、Method和Constructor类的公共超类。这个特性是为调试、持久存储和相似机制提供的。</p>
<h3 id="第五节-使用反射编写泛型数组代码"><a href="#第五节-使用反射编写泛型数组代码" class="headerlink" title="第五节 使用反射编写泛型数组代码"></a>第五节 使用反射编写泛型数组代码</h3><p>java.lang.reflect包中的Array类允许动态地创建数组。编写一个Array类中的copyOf方法实现中，如：</p>
<p><img src="https://s2.loli.net/2022/03/09/KwuPQ8AYZTFCbRa.png" alt="image-20220309182346217"></p>
<p>Java数组会记住每个元素的类型，即创建数组时new表达式中使用的元素类型。</p>
<p>将一个Employee[ ]临时地转换成Object[ ]数组，然后再把它转换回来是可以的，但一个从开始就是Object[ ]的数组，永远不能转换成Employee[ ]数组。</p>
<p>为了编写这类通用的数组代码，需要能够创建与原数组类型相同的新数组。为此需要调用Array类中的静态方法newInstance，它能够构造新数组。在调用它时必须提供两个参数，一个是数组的元素类型，一个是数组的长度。</p>
<p><code>Object newArray = Array.newInstance(componentType, newLength);</code></p>
<p>可以通过调用Array.getLength(a)获得数组的长度，也可以通过Array类的静态getLength方法的返回值得到任意数组的长度，而要获得新数组元素类型，就需要进行以下工作：</p>
<ol>
<li>首先获得a数组的类对象</li>
<li>确认它是一个数组</li>
<li>使用Class类(只能定义表示数组的类对象)的getComponentType方法确定数组对应的类型。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">goodCopyOf</span><span class="params">(Object a, <span class="type">int</span> newLength)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> a.getClass();</span><br><span class="line">    <span class="keyword">if</span> (!a.isArray())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">componentType</span> <span class="operator">=</span> c1.getComponentType();</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> Array.getLength(a);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">newArray</span> <span class="operator">=</span> Array.newInstance(componentType, newLength);</span><br><span class="line">    <span class="comment">// 原数组、原数组复制的起始索引、目标数组、复制的起始索引、复制长度</span></span><br><span class="line">    <span class="comment">// 原数组复制的起始索引+复制长度&lt;=原数组长度</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, newArray, <span class="number">0</span>, Math,min(length, newLength));</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这arraycopy()都是小写。</p>
<p>请注意，这个CopyOf方法可以用来扩展任意类型的数组，而不仅是对象数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] a = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">a = (int[]) goodCopyOf(a, 10);</span><br></pre></td></tr></table></figure>
<p>为了能够实现上述操作，应该将goodCopyOf的参数声明为Object类型，而不要声明为对象型数组(Object[ ])。整数型数组类型int[ ]可以被转换成Object，但不能转换成对象数组。</p>
<h3 id="第六节-调用任意方法"><a href="#第六节-调用任意方法" class="headerlink" title="第六节 调用任意方法"></a>第六节 调用任意方法</h3><p>反射机制允许你调用任意方法。</p>
<p>在Method类中，有一个invoke方法，它允许调用包装在当前Method对象中的方法。invoke方法的签名是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span></span><br></pre></td></tr></table></figure>
<p>第一个参数是隐式参数，其余的对象提供了显示参数。</p>
<p>对于静态方法，第一个参数可以被忽略，即可以将它设置为null。</p>
<p>如果返回类型是基本类型，invoke方法会返回其包装器类型。例如，假设m2表示Employee类的getSalary方法，那么返回的对象实际上Double，必须相应地完成类型转换。可以使用自动拆箱将它转换为一个double：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">s</span> <span class="operator">=</span> (Double)m2.invoke(harry);</span><br></pre></td></tr></table></figure>
<h4 id="得到Method对象"><a href="#得到Method对象" class="headerlink" title="得到Method对象"></a>得到Method对象</h4><ol>
<li><p>可以通过调用getDeclareMethods方法，然后对返回的Method对象数组进行查找，直到发现想要的方法为止。</p>
</li>
<li><p>通过调用Class类中的getMethod方法得到想要的方法。</p>
<p> 然而，有可能存在若干个相同名字的方法，<strong>因为还必须提供想要的方法的参数类型</strong>。getMethod的签名是：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Method <span class="title function_">getMethod</span><span class="params">(String name, Class... paramterTypes)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 举个例子，获得Employee类的getName方法和raiseSalary方法的方法指针</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> Employee.class.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> Employee.class.getMethod(<span class="string">&quot;raiseSalary&quot;</span>, <span class="type">double</span>.class);</span><br></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>invoke的参数和返回值必须是Object类型的。这就意味着必须进行多次的类型转换，这样做将会使编译器错过检查代码的机会。</p>
<p>不仅如此，使用反射获得方法指针的代码要比仅仅直接调用方法明显慢一点。</p>
<p><strong>建议仅在必要的时候才使用Method对象，而最好使用接口以及Java SE 8中的lambda表达式。</strong></p>
<h2 id="第八讲-继承的设计技巧"><a href="#第八讲-继承的设计技巧" class="headerlink" title="第八讲 继承的设计技巧"></a>第八讲 继承的设计技巧</h2><ol>
<li>将公共操作和域放在超类</li>
<li><p>不要使用受保护的域<img src="https://s2.loli.net/2022/03/09/CxbLDo4du6H7gw5.png" alt="image-20220309214543431"></p>
</li>
<li><p>使用继承实现”is-a”关系</p>
</li>
</ol>
<p>钟点工与雇员之间不属于”is-a”关系。因为钟点工不是特殊的雇员。</p>
<ol>
<li>除非所有继承的方法都有意义，否则不要使用继承</li>
<li>在覆盖方法时，不要改变预期的行为</li>
</ol>
<p>置换原则不仅应用于语法，而且也可以应用于行为，这似乎更加重要。在覆盖一个方法时，不应该毫无缘由地改变行为的内涵。  在覆盖子类中的方法时，不要偏离最初的设计想法。</p>
<p>(置换原则：继承必须确保超类所拥有的性质在子类中仍然成立。</p>
<p>表明程序中出现超类对象的任何地方，都可以用子类对象替换。)</p>
<ol>
<li>使用多态，而非类型信息</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/09/tNFMPLA76iCyDzE.png" alt="image-20220309222613601"></p>
<p>类似这种，都应该考虑多态性。定义一个方法，将其放置在两个类的超类或接口中，然后调用x.action( );</p>
<p>使用多态方法或接口编写的代码比使用对多种类型进行检测的代码更加易于维护和扩展。</p>
<ol>
<li>不要过多地使用反射</li>
</ol>
<p>反射机制使得人们可以通过在运行时查看域或方法，但这种功能不适用于编写应用程序。反射是很脆弱的，即编译器很难帮助人们发现程序中的错误。</p>
<h1 id="第六章-接口、lambda表达式与内部类"><a href="#第六章-接口、lambda表达式与内部类" class="headerlink" title="第六章 接口、lambda表达式与内部类"></a>第六章 接口、lambda表达式与内部类</h1><h2 id="第一讲-接口"><a href="#第一讲-接口" class="headerlink" title="第一讲 接口"></a>第一讲 接口</h2><p>主要用来描述类具有什么功能，而并不给出每个功能的具体实现。</p>
<p>接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。</p>
<h3 id="第一节-接口的概念"><a href="#第一节-接口的概念" class="headerlink" title="第一节 接口的概念"></a>第一节 接口的概念</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>Arrays类中的sort方法承诺可以对对象数组进行排序，但要满足下列前提：对象所属的类必须实现了Comparable接口。下面是Comparable接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object other)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何实现Comparable接口的类都需要包含compareTo方法，并且这个方法的参数必须是一个Object对象，返回一个整型数值。</p>
<h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span>; <span class="comment">// paramter has type T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口中的所有方法自动地属于public。因此，在接口中声明方法时，不必提供关键字public。</p>
<p>在调用x.compareTo(y)的时候，这个compareTo方法必须确实比较两个对象的内容，并返回比较的结果。当x小于y时，返回一个负数；当x等于y时，返回0；否则返回一个正数。</p>
<p>在接口中还可以定义常量。然而，更为重要的是，要知道接口不能提供哪些功能。接口绝不能含有实例域。</p>
<h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><ol>
<li>将类声明为实现给定的接口</li>
<li>实现接口中所有的方法(default方法可以不用实现)</li>
</ol>
<h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h5><p>实现接口时，必须把方法声明为public；否则，编译器将认为这个方法的访问属性是包可见性，即类的默认访问属性，之后编译器就会给出试图提供更严格的访问权限的警告信息。</p>
<h3 id="第二节-接口的特性"><a href="#第二节-接口的特性" class="headerlink" title="第二节 接口的特性"></a>第二节 接口的特性</h3><p>可以使用instance检查一个对象是否实现了某个特定的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> Comparable) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>尽管每个类都只能拥有一个超类，但却可以实现多个接口。Java程序设计语言中有一个非常重要的内置接口，称为Cloneable。如果某个类实现了这个Cloneable接口，Object类中的clone方法就可以创建类对象的一个拷贝。则如果希望自己设计的类可以克隆和比较的能力，就</p>
<p><code>class Employee implements Cloneable, Comparable</code></p>
<h3 id="第三节-接口与抽象类"><a href="#第三节-接口与抽象类" class="headerlink" title="第三节 接口与抽象类"></a>第三节 接口与抽象类</h3><p>使用抽象类表示通用属性存在一个问题：每个类只能扩展于一个类。</p>
<p>接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。</p>
<h3 id="第四节-静态方法"><a href="#第四节-静态方法" class="headerlink" title="第四节 静态方法"></a>第四节 静态方法</h3><p>在Java SE 8中，允许在接口中增加静态方法。</p>
<p>没有任何理由认为这是不合法的。只是这有违将接口作为抽象规范的初衷。</p>
<p>通常的做法都是将静态方法放在伴随类中。在标准库中，可以看到成对出现的接口和实用工具类，如Collection / Collections或Path / Paths。</p>
<p><img src="https://s2.loli.net/2022/03/10/YLAf6lMEXhdgQiB.png" alt="image-20220310001936145"></p>
<h3 id="第五节-默认方法"><a href="#第五节-默认方法" class="headerlink" title="第五节 默认方法"></a>第五节 默认方法</h3><p>可以为接口方法提供一个默认实现。必须用default修饰符标记这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，实现这个接口的程序员只需要为他们真正关心的事件覆盖方法。</p>
<h4 id="接口演化"><a href="#接口演化" class="headerlink" title="接口演化"></a>接口演化</h4><p>假如有一个类实现了Comparable接口，但是Java 8为该接口增加了一个新的方法stream，而且这个方法不是默认方法，那么这个类将由于没有实现这个方法，无法通过编译。</p>
<p>为接口增加一个非默认方法不能保证”源代码兼容(source compatible)”。</p>
<p>如果不重新编译，使用原先的一个包含该类的JAR文件。这个类仍能正常加载，正常构造实例，即可以保证”二进制兼容”，但是如果在该类上调用该方法，将会出现AbstractMethodError。</p>
<p>而将方法实现为一个默认方法，就可以使该类能够正常编译。而且如果没有重新编译而直接加载这个类，就可以直接Comparable.stream方法来调用。</p>
<h3 id="第六节-解决默认方法冲突"><a href="#第六节-解决默认方法冲突" class="headerlink" title="第六节 解决默认方法冲突"></a>第六节 解决默认方法冲突</h3><p>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法：</p>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ol>
<li>超类优先。如果超类提供了一个具体的方法，同名并且有相同参数类型的默认方法会被忽略。</li>
<li>接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型(不论是否是默认参数)相同的方法，必须覆盖这个方法来解决冲突。</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/10/Ur7D6TWkd4tmyAv.png" alt="image-20220310003432885"></p>
<p>两个接口如何冲突并不重要。如果至少有一个接口提供了一个实现，编译器就会报告错误，而程序员就必须解决这个二义性。</p>
<h4 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h4><p>千万不要让一个默认方法重新定义Object类中的某个方法，因为类优先。</p>
<h2 id="第二讲-接口示例"><a href="#第二讲-接口示例" class="headerlink" title="第二讲 接口示例"></a>第二讲 接口示例</h2><h3 id="第一节-接口与回调"><a href="#第一节-接口与回调" class="headerlink" title="第一节 接口与回调"></a>第一节 接口与回调</h3><p>回调（callback）是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。</p>
<h3 id="第二节-Comparator接口"><a href="#第二节-Comparator接口" class="headerlink" title="第二节 Comparator接口"></a>第二节 Comparator接口</h3><p>现在假设我们希望按长度递增的顺序对字符串进行排序，而不是按字典顺序进行排序。肯定不能让String类用两种不同的方式实现compareTo方法——更何况，String类也不应由我们来修改。</p>
<p>Arrays.sort方法还有第二个版本，有一个数组和一个比较器作为参数，比较器是实现了Comparator接口的类的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">compare</span><span class="params">(T first, T second)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LengthComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String first, String second)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first.length() - second.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体完成比较时，需要建立一个实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp = <span class="keyword">new</span> <span class="title class_">LengthComparator</span>();</span><br><span class="line"><span class="keyword">if</span> (comp.compare(word[i], word[j]) &gt; <span class="number">0</span>) ...</span><br></pre></td></tr></table></figure>
<p>与word[i].compareTo(word[j])作比较，这个compare方法要在比较器对象上调用，而不是在字符串本身调用。</p>
<p>尽管LengthComparator对象没有状态，不过还是需要建立这个对象的一个实例。我们需要这个实例来调用compare方法——它不是一个静态方法。</p>
<p>要对一个数组排序，需要为Arrays.sort方法传入一个LengthComparator对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] friends = &#123;<span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;Paul&quot;</span>, <span class="string">&quot;Mary&quot;</span> &#125;;</span><br><span class="line">Arrays.sort(friends, <span class="keyword">new</span> <span class="title class_">LengthComparator</span>());</span><br></pre></td></tr></table></figure>
<h3 id="第三节-对象克隆"><a href="#第三节-对象克隆" class="headerlink" title="第三节 对象克隆"></a>第三节 对象克隆</h3><p>Cloneable这个接口指示一个类提供了安全的clone方法。但克隆并不常见。</p>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>基本数据类型重新复制一份，即重新分配一块空间；</p>
<p>但对象只是新建了一个引用，指向原来的对象空间。</p>
<p>Object类默认就是浅拷贝。</p>
<p>拷贝域就会得到相同子对象的另一个引用，这样一来，原对象和克隆的对象仍然会共享一些信息。</p>
<p><img src="https://s2.loli.net/2022/03/11/oaV92OyJ51XU6qI.png" alt="image-20220311224035463"></p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>全部都重新分配一片空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportException &#123;</span><br><span class="line">        <span class="comment">// call Object.clone()</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">cloned</span> <span class="operator">=</span> (Employee) <span class="built_in">super</span>.clone();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// clone mutable fields</span></span><br><span class="line">        cloned.hiredDay = (Date) hireDay.clone();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在可变的子对象上调用clone来修补默认的clone方法。</p>
<h4 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h4><p>Cloneable接口是Java提供的一组标记接口之一，不包含任何方法，唯一作用就是允许在类型查询中使用instanceof。</p>
<p>将以自己的程序中不要使用标记接口。</p>
<p>克隆没有你想象中那么常用。标准库中只有不到5%的类实现了clone。程序清单6-4中的程序克隆了Employee类</p>
<p>所有数组类型都有一个public的clone方法，而不是protected。可以用这个方法建立一个新数组，包含原数组所有元素的副本。</p>
<h2 id="第三讲-lambda表达式"><a href="#第三讲-lambda表达式" class="headerlink" title="第三讲 lambda表达式"></a>第三讲 lambda表达式</h2><h3 id="第一节-lambda表达式的语法"><a href="#第一节-lambda表达式的语法" class="headerlink" title="第一节 lambda表达式的语法"></a>第一节 lambda表达式的语法</h3><p>lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。</p>
<p>考虑讨论过的排序的例子：传入代码来检查一个字符串是否比另一个字符串短。要计算：first.length() - second.length()</p>
<p>first和second都是字符串，Java是一种强类型语言，所以要指定它们的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second)</span><br><span class="line">	-&gt; first.length() - second.length()</span><br></pre></td></tr></table></figure>
<p><strong>lambda表达式就是一个代码块，以及必须传入代码的变量规范！</strong></p>
<h4 id="表达形式"><a href="#表达形式" class="headerlink" title="表达形式"></a>表达形式</h4><p>这种表达形式：<strong>参数，-&gt;，表达式</strong>。</p>
<ol>
<li>如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在{}中，并包含显式的return语句。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (first.length() &lt; second.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (first.length() &gt; second.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>即使lambda表达式没有参数，仍然要提供空括号，就像无参数方法一样：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) System.out.println(i); &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp = </span><br><span class="line">    (first, second) <span class="comment">// same as(String first, String second)</span></span><br><span class="line">    	-&gt; first.length() - second.length();</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果方法只有一个参数，而且这个参数的类型可以推导出，那么还可以省略小括号：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> event -&gt; <span class="comment">// instead of (ActionEvent event)-&gt; or (event)-&gt;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;The time is&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure>
</li>
<li><p>无需指定lambda表达式的返回类型。可由上下文推出。</p>
</li>
<li><p>如果一个lambda表达式只在某些分支返回一个值，而在其他分支不返回值，这是不合法的。</p>
</li>
</ol>
<h3 id="第三节-函数式接口"><a href="#第三节-函数式接口" class="headerlink" title="第三节 函数式接口"></a>第三节 函数式接口</h3><p><strong>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式</strong>，这种接口称为函数式接口(function interface)。</p>
<p>Arrays.sort方法，<strong>它的第二个参数需要一个Comparator实例</strong>，Comparator就是只有一个方法的接口，所以可以提供一个lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(words, </span><br><span class="line">            (first, second) -&gt; first.length() - second.length());</span><br></pre></td></tr></table></figure>
<p>在底层，Arrays.sort方法会接收实现了Comparator<String>的某个类的对象。在这个对象上调用compare方法会执行这个lambda表达式的体。</p>
<h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><p>实际上，在Java中，<strong>对lambda表达式所能做的，也只是能转换为函数式接口。</strong></p>
<p><strong>最好把lambda表达式看作是一个函数，而不是一个对象，另外要接受lambda表达式可以传递到函数式接口。</strong></p>
<p>JavaAPI在java.util.function包中定义了很多非常通用的函数式接口。</p>
<p>想用lambda表达式做某些处理，还是要谨记表达式的用途，为他建立一个特定的函数式接口。</p>
<h3 id="第四节-方法引用"><a href="#第四节-方法引用" class="headerlink" title="第四节 方法引用"></a>第四节 方法引用</h3><p>有时，可能已经有现成的方法可以完成你想要传递到其他代码的动作。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, System.out::println);</span><br></pre></td></tr></table></figure>
<p>表达式System.out::println是一个方法引用(method reference)，等价于lambda表达式：</p>
<p><code>x -&gt; System.out.println(x)</code></p>
<p>要用 :: 操作符分割方法名与对象或类名。</p>
<h4 id="三种情况"><a href="#三种情况" class="headerlink" title="三种情况"></a>三种情况</h4><p>主要有三种情况：</p>
<ul>
<li>object::instanceMethod</li>
<li>Class::staticMethod</li>
<li>Class::instanceMethod</li>
</ul>
<p>在前两种情况中，方法引用等价于提供方法参数的lambda表达式。</p>
<p>类似的，Math::pow等价于(x, y) -&gt; Math.pow(x, y).</p>
<p>对于第三种情况，第一个参数会成为方法的目标。例如，</p>
<p><code>String::compareToIgnoreCase 等同于(x, y) -&gt; x.compareToIgnoreCase(y)</code></p>
<h4 id="注释-2"><a href="#注释-2" class="headerlink" title="注释"></a>注释</h4><ol>
<li><p>如果有多个同名的重载方法，编译器就会尝试从上下文中找出指的是哪一个方法，这取决于转换为哪个函数式接口的方法参数。</p>
</li>
<li><p>方法引用不能独立存在，总是会转换为函数式接口的实例。</p>
</li>
<li>可以使用this参数和super参数：this::equals(x -&gt; this.equals(x)); super::instanceMethod.</li>
</ol>
<h3 id="第五节-构造器引用"><a href="#第五节-构造器引用" class="headerlink" title="第五节 构造器引用"></a>第五节 构造器引用</h3><p>构造器引用与方法引用很类似，只不过方法名为new。例如，Person::new是Person构造器的一个引用。</p>
<p><img src="https://s2.loli.net/2022/03/12/35LA7Yqymd1oUJx.png" alt="image-20220312153116486"></p>
<h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>可以使用数组类型建立构造器引用。例如，int[]::new是一个构造器引用，他有一个参数，即数组的长度。这等价于lambda表达式x -&gt; new int[x]。</p>
<p>Java中有一个限制，无法构造泛型类型T的数组。即表达式new T[n]会产生错误。</p>
<p>但是，流库利用构造器引用解决了这个问题。</p>
<p>Person[] people = stream.toArray(Person[]::new);</p>
<h3 id="第六节-变量作用域"><a href="#第六节-变量作用域" class="headerlink" title="第六节 变量作用域"></a>第六节 变量作用域</h3><p>通常，你可能希望能够在lambda表达式中访问外围方法或类中的变量。举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">repeatMessage</span><span class="params">(String text, <span class="type">int</span> delay)</span> &#123;</span><br><span class="line">    <span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> event -&gt; &#123;</span><br><span class="line">        System.out.println(text);</span><br><span class="line">        Toolkit.getDefaultToolkit().beep();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Timer</span>(delay, listener).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">repeatMessage(<span class="string">&quot;Hello&quot;</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>显然，lambda表达式中的text变量并不是在表达式中定义的，而是repeatMessage的一个参数变量。</p>
<p>lambda表达式有3个部分：</p>
<ul>
<li>一个代码块；</li>
<li>参数</li>
<li>自由变量(非参数且不在lambda表达式中定义的变量)</li>
</ul>
<p>在例子中，这个lambda表达式有1个自由变量text。表示lambda表达式的数据结构必须存储自由变量的值，也就是字符串“Hello“。它被lambda表达式捕获。</p>
<h4 id="注释-3"><a href="#注释-3" class="headerlink" title="注释"></a>注释</h4><p>关于代码块以及自由变量值有一个术语：闭包（closure）。</p>
<h4 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h4><ol>
<li>可以看到，lambda表达式可以捕获外围作用域中变量的值。在Java中，要确保所捕获的值是明确定义的，这里有一个重要的限制。在lambda表达式中，只能引用值不会改变的变量。</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/12/QExd3YS9Ve1IBUw.png" alt="image-20220312162245127"></p>
<p>之所以有这个限制，是有原因的。如果在lambda表达式中改变变量，并发执行多个动作时就会不安全。</p>
<ol>
<li>如果在lambda表达式中引用变量，而这个变量可能在外部改变，这也是不合法的。</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/12/r6miYVUcqI3wkFu.png" alt="image-20220312162403203"></p>
<ol>
<li><p>lambda表达式捕获的变量必须实际上是最终变量(effectively final)。</p>
<p> 实际上的最终变量是指：这个变量初始化后就不会再为它赋新值。</p>
</li>
<li><p>在lambda表达式中声明与一个局部变量同名的参数或局部变量是不合法的。</p>
</li>
<li><p>在方法中，不能有两个同名的局部变量，因此，lambda表达式中同样也不能有同名的局部变量。</p>
</li>
<li><p>在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数。<img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220312162815795.png" alt="image-20220312162815795"></p>
</li>
</ol>
<p>是指，Application对象的toString方法，而不是ActionListener实例的方法。</p>
<h3 id="第七节-处理lambda表达式"><a href="#第七节-处理lambda表达式" class="headerlink" title="第七节 处理lambda表达式"></a>第七节 处理lambda表达式</h3><p>使用lambda表达式的重点是延迟执行(deferred execution)。之所以希望以后再执行代码，这有很多原因，如：</p>
<ul>
<li>在一个单独的线程中运行代码；</li>
<li>多次运行代码；</li>
<li>在算法的适当位置运行代码；</li>
<li>发生某种情况时执行代码；</li>
<li>只在必要时才运行代码。</li>
</ul>
<h3 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h3><p><img src="https://s2.loli.net/2022/03/13/viJ7xyHeopdQIEK.png" alt="image-20220313203803851"></p>
<p><img src="https://s2.loli.net/2022/03/13/Er76df34NKhgRZe.png" alt="image-20220313204036989"></p>
<h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>最好使用以上两表中的接口。</p>
<p>例如，假设要编写一个方法来处理满足某个特定条件的文件。对此有一个遗留接口java.io.FileFilter，不过最好使用标准的Predicate<File>。</p>
<p>如果设计你自己的接口，其中只有一个抽象方法，可以用@FunctionalInterface注解来标记这个接口。</p>
<p>这样做有两个优点，如果你无意中增加了另一个非抽象方法，编译器会产生一个错误消息。另外javadoc页里会指出你的借口是一个函数式接口。</p>
<h3 id="第八节-再谈Comparator"><a href="#第八节-再谈Comparator" class="headerlink" title="第八节 再谈Comparator"></a>第八节 再谈Comparator</h3><p>略</p>
<h2 id="第四讲-内部类"><a href="#第四讲-内部类" class="headerlink" title="第四讲 内部类"></a>第四讲 内部类</h2><p>内部类是定义在另一个类中的类。</p>
<p>使用内部类的原因：</p>
<ul>
<li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。</li>
<li>内部类可以对同一包中的其它类隐藏起来。</li>
<li>当想要定义一个回调函数且不想编写大量的代码时，使用匿名内部类比较便捷。</li>
</ul>
<h3 id="第一节-使用内部类访问对象状态"><a href="#第一节-使用内部类访问对象状态" class="headerlink" title="第一节 使用内部类访问对象状态"></a>第一节 使用内部类访问对象状态</h3><p>内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。</p>
<p>内部类的对象，总有一个隐式引用，它指向了创建它的外部类对象。</p>
<p><img src="https://s2.loli.net/2022/03/13/aprg4X2oNSd5GBk.png" alt="image-20220313210816733"></p>
<p>这个引用在内部类的定义中是不可见的。</p>
<p>外围类的引用在构造器中设置。编译器修改了所有的内部类的构造器，添加了一个外围类引用的参数。因为TimePrinter类没有定义构造器，所以编译器为这个类生成了一个默认的构造器。其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TimePrinter</span><span class="params">(TalkingClock clock)</span> <span class="comment">// automatically generated code </span></span><br><span class="line">&#123;</span><br><span class="line">	outer = clock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><p>outer不是Java的关键字，只是用它说明内部类的机制。</p>
<h4 id="注释-4"><a href="#注释-4" class="headerlink" title="注释"></a>注释</h4><p>TimePrinter类声明为私有的。这样一来，只有TalkingClock的方法才能够构造TimePrinter对象。只有内部类可以是私有类，而常规类只可以具有包可见性，或公有可见性。</p>
<h3 id="第二节-内部类的特殊语法规则"><a href="#第二节-内部类的特殊语法规则" class="headerlink" title="第二节 内部类的特殊语法规则"></a>第二节 内部类的特殊语法规则</h3><h2 id="第五讲-代理"><a href="#第五讲-代理" class="headerlink" title="第五讲 代理"></a>第五讲 代理</h2><p>利用代理可以在运行时创建一个实现了一组给定接口的新类。</p>
<p>这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用。</p>
<p>对应用程序设计人员来说，遇到这种情况的机会很少。</p>
<h3 id="第一节-何时使用代理"><a href="#第一节-何时使用代理" class="headerlink" title="第一节 何时使用代理"></a>第一节 何时使用代理</h3><p>代理类可以在运行时创建全新的类。这样的代理类能够实现指定的接口。尤其是，它具有下列方法：</p>
<ul>
<li>指定接口所需要的全部方法。</li>
<li>Object类中的全部方法，例如，toString、equals等。</li>
</ul>
<p>然而，不能在运行时定义这些方法的新代码，而是要提供一个调用处理器(invocation handler)。调用处理器是实现了InvocationHandler接口的类对象。这个接口只有一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br></pre></td></tr></table></figure>
<p>无论何时调用代理对象的方法，调用处理器的invoke方法都会被调用，并向其传递Method对象和原始的调用参数。调用处理器必须给出处理调用的方式。</p>
<h1 id="第九章-集合"><a href="#第九章-集合" class="headerlink" title="第九章 集合"></a>第九章 集合</h1><h2 id="第一讲-集合框架"><a href="#第一讲-集合框架" class="headerlink" title="第一讲 集合框架"></a>第一讲 集合框架</h2><h3 id="第一节-分离集合的接口和实现"><a href="#第一节-分离集合的接口和实现" class="headerlink" title="第一节 分离集合的接口和实现"></a>第一节 分离集合的接口和实现</h3><p>Java集合类库将接口(interface)与实现(implementation)分离。</p>
<h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>队列接口的最简形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt; &#123; <span class="comment">// a simplified form of the interface in the standard library</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span>;</span><br><span class="line">    E <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种实现形式：</p>
<ul>
<li>循环数组</li>
<li>使用链表</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/14/gfJ9LtUqxmZ4WTp.png" alt="image-20220314005548688"></p>
<h5 id="注释-5"><a href="#注释-5" class="headerlink" title="注释"></a>注释</h5><p>如果需要一个循环数组队列，就可以使用ArrayDeque类。如果需要一个链表队列，就直接使用LinkedList类，这个类实现了Queue接口。</p>
<p>可以使用接口类型存放集合的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> <span class="title class_">CircularArrayQueue</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">expressLane.add(<span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Harry&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>如果想要修改，可以轻松使用另一种实现，因为只需要修改构造器即可，别的都无需修改。</p>
<h3 id="第二节-Collection接口"><a href="#第二节-Collection接口" class="headerlink" title="第二节 Collection接口"></a>第二节 Collection接口</h3><p>在Java类库中，集合类的基本接口是Collection接口。有两个基本方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E element)</span>;</span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的元素不允许重复。如果添加成功，就返回true。</p>
<h3 id="第三节-迭代器"><a href="#第三节-迭代器" class="headerlink" title="第三节 迭代器"></a>第三节 迭代器</h3><p>Iterator接口包含4个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法浅析"><a href="#方法浅析" class="headerlink" title="方法浅析"></a>方法浅析</h4><h5 id="next和hasNext方法"><a href="#next和hasNext方法" class="headerlink" title="next和hasNext方法"></a>next和hasNext方法</h5><p>通过反复调用next方法，可以逐个访问集合中的每个元素。</p>
<p>但是，如果到达了集合的末尾，next方法将抛出一个NoSuchElementException。</p>
<p>因此，需要在调用next之前调用hasNext方法。如果迭代器对象还有多个供访问的元素，这个方法就返回true。</p>
<p>如果想要查看集合中的所有元素，就请求一个迭代器，并<strong>在hasNext返回true时反复地调用next方法</strong>。</p>
<p><img src="https://s2.loli.net/2022/03/14/RdvDjMHwOi5u2V3.png" alt="image-20220314010906021"></p>
<h4 id="补充next"><a href="#补充next" class="headerlink" title="补充next"></a>补充next</h4><p>因此，应该将Java迭代器认为是位于两个元素之间。当调用next时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。</p>
<p><img src="https://s2.loli.net/2022/03/14/7JSQzp3dvemwkj2.png" alt="image-20220314011328728"></p>
<h5 id="forEachRemaining方法"><a href="#forEachRemaining方法" class="headerlink" title="forEachRemaining方法"></a>forEachRemaining方法</h5><p>在Java SE 8中，甚至不用写循环。可以调用forEachRemaining方法并提供一个lambda表达式（它会处理一个元素）。</p>
<p>将对迭代器的每一个元素调用这个lambda表达式，直到再没有元素为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator.forEachRemaining(element -&gt; <span class="keyword">do</span> something with element);</span><br></pre></td></tr></table></figure>
<p>元素被访问的顺序取决于集合类型。</p>
<p>如果访问HashSet中的元素，每个元素将会按照某种随机的次序出现。虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预知元素被访问的次序。</p>
<h5 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h5><p>Iterator接口的remove方法将会删除调用next方法时返回的元素。</p>
<p>在大多数情况下，在决定删除某个元素之前应该先看一下这个元素是很具有实际意义的。</p>
<p><strong>然而，如果想要删除指定位置上的元素，仍然需要越过这个元素</strong>。</p>
<p>例如，下面是如何删除字符串集合中第一个元素的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line">it.next(); <span class="comment">// skip over the first element</span></span><br><span class="line">it.remove(); <span class="comment">// now remove it</span></span><br></pre></td></tr></table></figure>
<h5 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h5><p>更重要的是，<strong>对next方法和remove方法的调用具有互相依赖性。如果调用remove之前没有调用next将是不合法的。</strong>如果这样做，将会抛出一个IllegalStateException异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除两个相邻元素</span></span><br><span class="line"><span class="comment">// 不能这样调用</span></span><br><span class="line">it.remove();</span><br><span class="line">it.remove(); <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须先调用next越过将要删除的元素</span></span><br><span class="line">it.remove();</span><br><span class="line">it.next();</span><br><span class="line">it.remove(); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<h3 id="第四节-泛型实用方法"><a href="#第四节-泛型实用方法" class="headerlink" title="第四节 泛型实用方法"></a>第四节 泛型实用方法</h3><p>由于Collection和Iterator都是泛型接口，可以编写操作任何集合类型的使用方法。</p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>事实上，Collection接口声明了很多有用的方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collection接口</span></span><br><span class="line">Iterator&lt;E&gt; iterator <span class="comment">// 返回一个用于访问集合中每一个元素的迭代器</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">// 返回当前存储的元素个数</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">// 如果集合中没有元素，返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object obj)</span> <span class="comment">// 如果集合中包含了一个与obj相等的对象，返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;? &gt; other)</span> <span class="comment">// 如果这个集合包含other集合中的全部元素，返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Object element)</span> <span class="comment">// 将一个元素添加到集合中，如果集合因此发生了改变，返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collecion&lt;? extends E&gt; other)</span> <span class="comment">// 将other集合中的所有元素添加到这个集合。如果由于这个调用改变了集合，返回true。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object obj)</span> <span class="comment">// 从这个集合中删除等于obj的对象。如果有匹配的对象被删除，返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;? &gt; other)</span> <span class="comment">// 从这个集合中删除other集合中存在的所有元素。如果由于这个调用改变了集合，返回true</span></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span> <span class="comment">// 从这个集合删除filter返回true的所有元素。如果由于这个调用改变了集合，则返回true</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="comment">// 从这个集合中删除所有的元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;? &gt; other)</span> <span class="comment">// 从这个集合中删除所有与other集合中的元素不同的元素。如果由于这个调用改变了集合，返回true</span></span><br><span class="line">Object[] toArray() <span class="comment">// 返回这个集合的对象数组</span></span><br><span class="line">&lt;T&gt; T[] toArray(T[] arrayToFill) <span class="comment">/* 返回这个集合的对象数组。如果arrayToFill足够大，就将集合中的元素填入这个数组中。剩余空间填补null；否则，分配一个新数组，其成员类型与arrayToFill的成员类型相同，其长度等于集合的大小，并填充集合元素。*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Iterator接口    </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> <span class="comment">// 删除上次访问的对象。这个方法必须紧跟在访问一个元素之后执行。如果上次访问之后，集合已经发生了变化，这个方法将抛出一个IllegalStateException。</span></span><br></pre></td></tr></table></figure>
<h3 id="第五节-集合框架中的接口"><a href="#第五节-集合框架中的接口" class="headerlink" title="第五节 集合框架中的接口"></a>第五节 集合框架中的接口</h3><p>Java集合框架为不同类型的集合定义了大量接口。</p>
<p><img src="https://s2.loli.net/2022/03/14/2X4t6qxWeUi5o3u.png" alt="image-20220314123844954"></p>
<p>集合有两个基本接口：Collection和Map。</p>
<p>List是一个有序集合。元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器方法，或者使用一个整数索引来访问。后一种方法称为随机访问，因为这样可以按任意顺序访问元素。List接口定义了多个用于随机访问的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span></span><br></pre></td></tr></table></figure>
<h4 id="RandomAccess接口"><a href="#RandomAccess接口" class="headerlink" title="RandomAccess接口"></a>RandomAccess接口</h4><p>实际中有两种有序集合，其性能开销有很大差异。</p>
<p>由数组支持的有序集合可以快速地随机访问，因此适合使用List方法并提供一个整数索引来访问。</p>
<p>与之不同，链表尽管也是有序的，但是随机访问很慢，所以最好使用迭代器来遍历。</p>
<p><strong>为了避免对链表完成随机访问操作</strong>，Java SE 1.4引入了一个标记接口RandomAccess。这个接口不包含任何方法，不过可以用它来测试一个特定的集合是否支持高效的随机访问：</p>
<p><img src="https://s2.loli.net/2022/03/14/jiRhUT9B3FNXeHy.png" alt="image-20220314143156671"></p>
<h4 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h4><p>Set接口等同于Collection接口，不过其方法的行为有更严谨的定义。</p>
<p>集（set）的add方法不允许增加重复的元素。要</p>
<p>适当地定义集的equals方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。hashCode方法的定义要保证包含相同元素的两个集会得到相同的散列码。</p>
<p>既然方法签名是一样的，为什么还要建立一个单独的接口呢？从概念上讲，并不是所有集合都是集。建立一个Set接口可以让程序员编写只接受集的方法。</p>
<h2 id="第二讲-具体的集合"><a href="#第二讲-具体的集合" class="headerlink" title="第二讲 具体的集合"></a>第二讲 具体的集合</h2><p><img src="https://s2.loli.net/2022/03/14/EmT3ku6SHeoLbJ5.png" alt="image-20220314143318070"></p>
<h3 id="第一节-链表"><a href="#第一节-链表" class="headerlink" title="第一节 链表"></a>第一节 链表</h3><p>Java集合类库提供了一个类LinkedList。</p>
<p>但是链表和泛型集合之间有一个重要的区别，链表是一个有序集合(ordered collection)。</p>
<p>LinkedList.add方法将对象添加到链表的尾部。</p>
<p>为了将元素添加到链表的中间，由于迭代器是描述集合中位置的，因此这种依赖位置的add方法将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有意义。</p>
<h4 id="ListIterator接口"><a href="#ListIterator接口" class="headerlink" title="ListIterator接口"></a>ListIterator接口</h4><p>对应于集合类库提供了子接口ListIterator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ListIterator</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span>;</span><br><span class="line">    <span class="comment">// 反向遍历链表</span></span><br><span class="line">    E <span class="title function_">previous</span><span class="params">()</span>; <span class="comment">// 返回越过的对象</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add方法在迭代器位置之前添加一个新对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">staff.add(<span class="string">&quot;Amy&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;Carl&quot;</span>);</span><br><span class="line">ListIterator&lt;String&gt; iter = staff.listIterator();</span><br><span class="line">iter.next(); <span class="comment">// skip past first element</span></span><br><span class="line">iter.add(<span class="string">&quot;Juliet&quot;</span>).</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/16/PmdHjKVkrNJ5uX6.png" alt="image-20220316192828055"></p>
<h5 id="并发修改"><a href="#并发修改" class="headerlink" title="并发修改"></a>并发修改</h5><p><img src="https://s2.loli.net/2022/03/16/RIk394JNtCM1PVD.png" alt="image-20220316194023136"></p>
<p>由于iter2检测出这个链表被外部修改了，所以对iter2.next的调用抛出了一个Concurrent ModificationException异常。</p>
<p>为了避免发生并发修改的异常，请遵循下述简单规则：</p>
<p>可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表。</p>
<p>另外，再单独附加一个既能读又能写的迭代器。</p>
<h5 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h5><p>不应该使用让人误解的随机访问方法来遍历链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">    <span class="keyword">do</span> something with list.get(i);</span><br></pre></td></tr></table></figure>
<p>每次查找一个元素都要从列表的头部重新开始搜索。</p>
<p>LinkedList对象根本不做任何缓存位置信息的操作。</p>
<p>我们建议避免使用以整数索引表示链表中位置的所有方法。如果需要对集合进行随机访问，就使用数组或ArrayList，而不要使用链表。</p>
<h3 id="第二节-数组列表"><a href="#第二节-数组列表" class="headerlink" title="第二节 数组列表"></a>第二节 数组列表</h3><p>Vector类的所有方法都是同步的，可以有两个线程安全地访问一个Vector对象，但是如果一个线程访问Vector，代码要再同步操作上耗费大量的时间。</p>
<p>ArrayList方法不是同步的，所以建议在不需要同步时使用ArrayList，而不要使用Vector。</p>
<h3 id="第三节-散列集"><a href="#第三节-散列集" class="headerlink" title="第三节 散列集"></a>第三节 散列集</h3><p>散列表(hash table)可以快速查找出需要的对象。</p>
<h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><p>散列表为每个对象计算一个整数，称为散列码(hash code)。散列码是由对象的实例域产生的一个整数。</p>
<p>散列码只与要散列的对象状态有关，与其他对象无关。</p>
<h4 id="桶"><a href="#桶" class="headerlink" title="桶"></a>桶</h4><p>Java中，散列表用链表数组实现。每个列表被称为桶(bucket)。要想查找表中对象的位置，就要先计算散列码，再对桶的总数取余，即可得该元素的索引。</p>
<p><img src="https://s2.loli.net/2022/03/16/EMFhWBeNrul8qL9.png" alt="image-20220316211952949"></p>
<h4 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h4><p>当然，有时候会遇到桶被占满的情况，即所谓散列冲突。</p>
<p>这时，需要用新对象与桶中所有的对象进行比较，查看这个对象是否已经存在。</p>
<p>如果想更多地控制散列表的运行性能，就要指定一个初始的桶数。如果大致知道最终会有多少个元素要插入到散列表中，就可以设置桶数。通常，将桶数设置为预计元素个数的75%～150%。</p>
<h4 id="再散列"><a href="#再散列" class="headerlink" title="再散列"></a>再散列</h4><p>当然，并不是总能够知道需要存储多少个元素的，也有可能最初的估计过低。</p>
<p>如果散列表太满，就需要再散列（rehashed）。</p>
<p>如果要对散列表再散列，就需要创建一个桶数更多的表，并将所有元素插入到这个新表中，然后丢弃原来的表。</p>
<p>装填因子（load factor）决定何时对散列表进行再散列。</p>
<p>例如，如果装填因子为0.75（默认值），而表中超过75%的位置已经填入元素，这个表就会用双倍的桶数自动地进行再散列。对于大多数应用程序来说，装填因子为0.75是比较合理的。</p>
<h4 id="HashSet类"><a href="#HashSet类" class="headerlink" title="HashSet类"></a>HashSet类</h4><p>实现了基于散列表的集。</p>
<p>可以用add方法添加元素。contains方法已经被重新定义，用来快速地查看是否某个元素已经出现在集中。</p>
<p>散列集迭代器将依次访问所有的桶。由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。<strong>只有不关心集合中元素的顺序时才应该使用HashSet。</strong></p>
<h3 id="第四节-树集"><a href="#第四节-树集" class="headerlink" title="第四节 树集"></a>第四节 树集</h3><p>TreeSet类是一个有序集合。</p>
<p>可以以任意顺序将元素插入到集合中，在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现。</p>
<p>每次将一个元素添加到树中时，都被放置在正确的排序位置上。因此，迭代器总是以排好序的顺序访问每个元素。将一个元素添加到树中要比添加到散列表中慢。</p>
<p><strong>要使用树集，必须能够比较元素</strong>。这些元素必须实现Comparable接口，或者构造集时必须提供一个Comparator</p>
<h3 id="二者比较"><a href="#二者比较" class="headerlink" title="二者比较"></a>二者比较</h3><p>当然了，如果不需要对数据进行排序，就没有必要付出排序的开销。更重要的是，对于某些数据来说，对其排序要比散列函数更加困难。散列函数只是将对象适当地打乱存放，而比较却要精确地判别每个对象。</p>
<h3 id="第五节-队列与双端队列"><a href="#第五节-队列与双端队列" class="headerlink" title="第五节 队列与双端队列"></a>第五节 队列与双端队列</h3><p>有两个端头的队列，即双端队列。</p>
<p>可以有效地在头部和尾部同时添加或删除元素，不支持在队列中间添加元素。</p>
<p>在Java SE 6中引入了Deque接口，并由ArrayDeque和LinkedList类实现。这两个类提供了双端队列，而且在必要时可以增加队列的长度。</p>
<h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><ul>
<li><p>boolean add(E element)</p>
</li>
<li><p>boolean offer(E element)</p>
<p> 如果队列没有满，将给定的元素添加到这个双端队列的尾部并返回true。如果队列满了，第一个方法将抛出一个IllegalStateException，而第二个方法返回false。</p>
</li>
<li><p>E remove()</p>
</li>
<li><p>E poll()</p>
<p> 假如队列不空，删除并返回这个队列头部的元素。如果队列是空的，第一个方法抛出NoSuchElementException，而第二个方法返回null。</p>
</li>
<li><p>E element()</p>
</li>
<li><p>E peek()</p>
<p>  如果队列不空，返回这个队列头部的元素，但不删除。如果队列空，第一个方法将抛出一个NoSuchElementException，而第二个方法返回null。</p>
</li>
</ul>
<p>至于双端队列，addLast和addFirst，替换element，新增一个getLast和getFirst。</p>
<h3 id="第六节-优先级队列"><a href="#第六节-优先级队列" class="headerlink" title="第六节 优先级队列"></a>第六节 优先级队列</h3><p>优先级队列(priority queue)中的元素可以按照任意的顺序插入，却总是按照排序的顺序进行检索。无论何时调用remove方法，总会获得当前优先级队列中最小的元素。</p>
<p>然而，优先级队列并没有对所有的元素进行排序，而是使用了一个优雅且高效的数据结构，称为堆(heap)。</p>
<p>堆是一个可以自我调整的二叉树，对树执行添加(add)和删除(remove)操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。</p>
<p>与TreeSet一样，一个优先级队列既可以保存实现了Comparable接口的类对象，也可以保存在构造器中提供的Comparator对象。</p>
<p>使用优先级队列的典型示例是任务调度。每一个任务有一个优先级，任务以随机顺序添加到队列中。每当启动一个新的任务时，都将<strong>优先级最高的任务从队列中删除</strong>（由于习惯上将1设为“最高”优先级，所以会将最小的元素删除）。</p>
<h2 id="第三讲-映射"><a href="#第三讲-映射" class="headerlink" title="第三讲 映射"></a>第三讲 映射</h2><h3 id="第一节-基本映射操作"><a href="#第一节-基本映射操作" class="headerlink" title="第一节 基本映射操作"></a>第一节 基本映射操作</h3><p>Java类库为映射提供了两个通用的实现，HashMap和TreeMap。这两个类都实现了Map接口。</p>
<p>散列映射对键进行散列，树映射用键的整体顺序对元素进行排列，并将其组织成搜索树。</p>
<p>散列或比较函数只能作用于键，与键关联的值不能进行散列或比较。</p>
<h4 id="键"><a href="#键" class="headerlink" title="键"></a>键</h4><h4 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h4><p>每当往映射中添加对象时，必须同时提供一个键。在这里，键id是一个字符串，对应的值是Employee对象。</p>
<p>要想检索一个对象，必须使用（因而，必须记住）一个键。</p>
<p>如果在映射中没有与给定键对应的信息，get将返回null。</p>
<p>null返回值可能并不方便。有时可以有一个好的默认值，对应映射中不存在的键，即使用getOrDefault方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; scores = ...;</span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scores.get(id, <span class="number">0</span>); <span class="comment">// Gets 0 if the id is not present</span></span><br></pre></td></tr></table></figure>
<h5 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h5><p>键必须是唯一的。不能对同一个键存放两个值。</p>
<p>如果对同一个键两次调用put方法，第二个值就会取代第一个值。实际上，put将返回用这个键参数存储的上一个值。</p>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul>
<li><p>default V getOrDefault(Object key, V defaultValue)获得与键关联的值；返回与键关联的对象，或者如果未在映射中找到这个键，则返回defaultValue。</p>
</li>
<li><p>boolean containsKey(Object key)如果在映射中已经有这个键，返回true。</p>
</li>
<li>default void forEach(BiConsumer&lt;? super K, ? superV&gt; action) 8对这个映射中的所有键/值对应用这个动作。(可以使用一个lambda表达式。)</li>
</ul>
<h3 id="第二节-更新映射项"><a href="#第二节-更新映射项" class="headerlink" title="第二节 更新映射项"></a>第二节 更新映射项</h3><p>正常情况下，可以得到与一个键关联的原值，完成更新，再放回更新后的值。不过，必须考虑一个特殊情况，即键第一次出现。</p>
<p><img src="https://s2.loli.net/2022/03/17/Jdh7qmuGU8crH2l.png" alt="image-20220317235933970"></p>
<p>这种语句完全可以，但是如果是第一次看到word时，get会返回null，因此会出现一个NullPointException异常。</p>
<h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><p>可以使用getOrDefault方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counts.put(word, counts.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><p>merge方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counts.merge(word, <span class="number">1</span>, Integer::sum);</span><br></pre></td></tr></table></figure>
<p>如果键原先不存在，将把word与1关联，否则使用Integer::sum函数组合原值和1(原值+1)。</p>
<h3 id="第三节-映射视图"><a href="#第三节-映射视图" class="headerlink" title="第三节 映射视图"></a>第三节 映射视图</h3><p>可以得到映射的视图(view)——这是实现了Collection接口或某个子接口的对象。</p>
<p>有三种视图：键集、值集合(不是一个集)以及键/值对集。对应的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span></span><br><span class="line">Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span></span><br><span class="line">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</span><br></pre></td></tr></table></figure>
<p>条目集的元素是实现Map.Entry接口的类的对象。</p>
<p><img src="https://s2.loli.net/2022/03/18/GQj5hAJOnqVgoE3.png" alt="image-20220318001553502"></p>
<p><img src="https://s2.loli.net/2022/03/18/6cZRnSNOwDGt1aJ.png" alt="image-20220318001730611"></p>
<p>如果在键集视图上调用迭代器的remove方法，实际上会从映射中删除这个键和与它关联的值。不过，不能向键集视图增加元素。另外，如果增加一个键而没有同时增加值也是没有意义的。</p>
<h2 id="第四讲-视图与包装器"><a href="#第四讲-视图与包装器" class="headerlink" title="第四讲 视图与包装器"></a>第四讲 视图与包装器</h2><p>keySet方法返回一个实现Set接口的类对象，这个类的方法对原映射进行操作。这种集合称为视图。</p>
<h2 id="第五讲-算法"><a href="#第五讲-算法" class="headerlink" title="第五讲 算法"></a>第五讲 算法</h2><p>泛型集合接口有一个很大的优点，即算法只需要实现一次。</p>
<p><img src="https://s2.loli.net/2022/03/18/lg7ADb6VphtKwGT.png" alt="image-20220318003309044"></p>
<h3 id="第一节-排序与混排"><a href="#第一节-排序与混排" class="headerlink" title="第一节 排序与混排"></a>第一节 排序与混排</h3><p>Collections类中的sort方法可以对实现了List接口的集合进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">fill collection</span><br><span class="line">Collections.sort(staff);</span><br></pre></td></tr></table></figure>
<p>这个方法假定列表元素实现了Comparable接口。如果想采用其他方式对列表进行排序，可以使用List接口的sort方法并传入一个Comparator对象。可以如下按工资对一个员工列表排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary);</span><br></pre></td></tr></table></figure>
<h4 id="降序排序"><a href="#降序排序" class="headerlink" title="降序排序"></a>降序排序</h4><p><img src="https://s2.loli.net/2022/03/18/8KyiGAhtd9JENxO.png" alt="image-20220318003625944"></p>
<h4 id="混排"><a href="#混排" class="headerlink" title="混排"></a>混排</h4><p>Collections类有一个算法<strong>shuffle</strong>，其功能与排序刚好相反，即随机地混排列表中元素的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Card&gt; cards = ...;</span><br><span class="line">Collections.shuffle(cards);</span><br></pre></td></tr></table></figure>
<p>如果提供的列表没有实现RandomAccess接口，shuffle方法将元素复制到数组中，然后打乱数组元素的顺序，最后再将打乱顺序后的元素复制回列表。</p>
<h3 id="第二节-二分查找"><a href="#第二节-二分查找" class="headerlink" title="第二节 二分查找"></a>第二节 二分查找</h3><p>Collections类的binarySearch方法实现了这个算法。</p>
<p>注意，集合必须是排好序的，否则算法将返回错误的答案。要想查找某个元素，必须提供集合（这个集合要实现List接口）以及要查找的元素。如果集合没有采用Comparable接口的compareTo方法进行排序，就还要提供一个比较器对象。</p>
<p><img src="https://s2.loli.net/2022/03/18/PTHabqeAvR1JIt5.png" alt="image-20220318004020199"></p>
<p>如果binarySearch方法返回的数值大于等于0，则表示匹配对象的索引。</p>
<p>也就是说，c.get(i)等于在这个比较顺序下的element。</p>
<p>如果返回负值，则表示没有匹配的元素。</p>
<h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><p>只有采用随机访问，二分查找才有意义。如果必须利用迭代方式一次次地遍历链表的一半元素来找到中间位置的元素，二分查找就完全失去了优势。因此，如果为binarySearch算法提供一个链表，它将自动地变为线性查找。</p>
<h3 id="第三节-简单算法"><a href="#第三节-简单算法" class="headerlink" title="第三节 简单算法"></a>第三节 简单算法</h3><p>● static int frequency(Collection&lt;? &gt; c, Object o) 5.0返回c中与对象o相同的元素个数。</p>
<p>● boolean disjoint(Collection&lt;? &gt; c1, Collection&lt;? &gt; c2) 5.0如果两个集合没有共同的元素，则返回true。</p>
<p>● static void swap(List&lt;? &gt; l, int i, int j) 1.4交换给定偏移量的两个元素。</p>
<p>● static void reverse(List&lt;? &gt; l)逆置列表中元素的顺序。例如，逆置列表[t, a, r]后将得到列表[r, a, t]。这个方法的时间复杂度为O (n), n为列表的长度。</p>
<h3 id="第四节-批操作"><a href="#第四节-批操作" class="headerlink" title="第四节 批操作"></a>第四节 批操作</h3><p>很多操作会“成批”复制或删除元素。以下调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coll1.removeAll(coll2);</span><br></pre></td></tr></table></figure>
<p>将从coll1中删除coll2中出现的所有元素。与之相反，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coll1.retainAll(coll2;)</span><br></pre></td></tr></table></figure>
<p>会从coll1中删除所有未在coll2中出现的元素。</p>
<h4 id="寻找交集"><a href="#寻找交集" class="headerlink" title="寻找交集"></a>寻找交集</h4><p><img src="https://s2.loli.net/2022/03/18/xzKQB51bg4cWXwE.png" alt="image-20220318004605897"></p>
<h3 id="第五节-集合与数组的转换"><a href="#第五节-集合与数组的转换" class="headerlink" title="第五节 集合与数组的转换"></a>第五节 集合与数组的转换</h3><h4 id="数组转换为集合"><a href="#数组转换为集合" class="headerlink" title="数组转换为集合"></a>数组转换为集合</h4><p>Arrays.asList包装器可以实现。</p>
<p><img src="https://s2.loli.net/2022/03/18/sbgIZ6P37hapj2U.png" alt="image-20220318004804802"></p>
<h4 id="集合得到数组"><a href="#集合得到数组" class="headerlink" title="集合得到数组"></a>集合得到数组</h4><p><img src="https://s2.loli.net/2022/03/18/3oCSrFPfamsHqJQ.png" alt="image-20220318004854386"></p>
<h4 id="注释-6"><a href="#注释-6" class="headerlink" title="注释"></a>注释</h4><p>你可能奇怪为什么不能直接将一个Class对象（如String.class）传递到toArray方法。原因是这个方法有“双重职责”，不仅要填充一个已有的数组（如果它足够长），还要创建一个新数组。</p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>Java平台的BitSet类用于存放一个位序列（它不是数学上的集，称为位向量或位数组更为合适）。如果需要高效地存储位序列（例如，标志）就可以使用位集。</p>
<p>由于位集将位包装在字节里，所以，使用位集要比使用Boolean对象的ArrayList更加高效。</p>
<p>BitSet类提供了一个便于读取、设置或清除各个位的接口。使用这个接口可以避免屏蔽和其他麻烦的位操作。如果将这些位存储在int或long变量中就必须进行这些繁琐的操作。</p>
<p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220318005146339.png" alt="image-20220318005146339"></p>
<h1 id="Chapter-14-并发"><a href="#Chapter-14-并发" class="headerlink" title="Chapter 14 并发"></a>Chapter 14 并发</h1><p>多线程和多进程的本质区别在于，每个进程拥有自己的一整套变量，而线程则共享数据。共享变量使线程之间的通信更加有效容易。与进程相比，线程更”轻量级”，创建、撤销一个线程比启动新进程的开销要小得多。</p>
<h2 id="第一讲-什么是线程"><a href="#第一讲-什么是线程" class="headerlink" title="第一讲 什么是线程"></a>第一讲 什么是线程</h2><h3 id="第一节-使用线程给其他任务提供机会"><a href="#第一节-使用线程给其他任务提供机会" class="headerlink" title="第一节 使用线程给其他任务提供机会"></a>第一节 使用线程给其他任务提供机会</h3>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">第四章 对象与类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">第一节 面向对象程序设计概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">封装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.2.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E4%B8%AA%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">对象的三个主要特性：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.3.</span> <span class="toc-text">类之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E5%90%88"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">聚合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E4%BD%BF%E7%94%A8%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">第二讲 使用预定义类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E5%99%A8%E6%96%B9%E6%B3%95%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%99%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">更改器方法与访问器方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%AE%B2-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">第三讲 用户自定义类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0%E4%B8%8E%E6%98%BE%E5%BC%8F%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">隐式参数与显式参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.3.2.</span> <span class="toc-text">封装的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">私有方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%AE%9E%E4%BE%8B%E5%9F%9F"><span class="toc-number">1.3.4.</span> <span class="toc-text">final实例域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E9%9D%99%E6%80%81%E5%9F%9F%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">第四讲 静态域与静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%9F%9F-%E7%B1%BB%E5%9F%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">静态域(类域)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">静态常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.4.</span> <span class="toc-text">使用静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.5.</span> <span class="toc-text">工厂方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%AE%B2-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">第五讲 方法参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E8%AE%B2-%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0"><span class="toc-number">1.6.</span> <span class="toc-text">第六讲 对象构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%9F%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.6.1.</span> <span class="toc-text">显式域初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">调用另一个构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97"><span class="toc-number">1.6.3.</span> <span class="toc-text">初始化块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">初始化数据域的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.6.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%9F%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.6.5.</span> <span class="toc-text">静态域初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%9E%90%E6%9E%84%E4%B8%8Efinalize%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.6.</span> <span class="toc-text">对象析构与finalize方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E8%AE%B2-%E5%8C%85"><span class="toc-number">1.7.</span> <span class="toc-text">第七讲 包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5"><span class="toc-number">1.7.1.</span> <span class="toc-text">包的导入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.7.2.</span> <span class="toc-text">包作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E8%B7%AF%E5%BE%84"><span class="toc-number">1.7.3.</span> <span class="toc-text">类路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E8%AE%B2-%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-number">1.8.</span> <span class="toc-text">第九讲 文档注释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A"><span class="toc-number">1.8.1.</span> <span class="toc-text">1. 方法注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9F%9F%E6%B3%A8%E9%87%8A"><span class="toc-number">1.8.2.</span> <span class="toc-text">2. 域注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%9A%E7%94%A8%E6%B3%A8%E9%87%8A"><span class="toc-number">1.8.3.</span> <span class="toc-text">3. 通用注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%A0%87%E8%AE%B0%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E6%89%80%E6%9C%89%E7%9A%84%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">4. 下面的标记可以用于所有的文档注释</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="toc-number">1.9.</span> <span class="toc-text">类设计的技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%80%E5%AE%9A%E8%A6%81%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%A7%81%E6%9C%89"><span class="toc-number">1.9.1.</span> <span class="toc-text">1. 一定要保证数据私有</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%80%E5%AE%9A%E8%A6%81%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.9.2.</span> <span class="toc-text">2. 一定要对数据初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%8D%E8%A6%81%E5%9C%A8%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%BF%87%E5%A4%9A%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.3.</span> <span class="toc-text">3. 不要在类中使用过多的基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E7%9A%84%E5%9F%9F%E9%83%BD%E9%9C%80%E8%A6%81%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%9F%9F%E8%AE%BF%E9%97%AE%E5%99%A8%E5%92%8C%E5%9F%9F%E6%9B%B4%E6%94%B9%E5%99%A8"><span class="toc-number">1.9.4.</span> <span class="toc-text">4. 不是所有的域都需要独立的域访问器和域更改器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%86%E8%81%8C%E8%B4%A3%E8%BF%87%E5%A4%9A%E7%9A%84%E7%B1%BB%E8%BF%9B%E8%A1%8C%E5%88%86%E8%A7%A3"><span class="toc-number">1.9.5.</span> <span class="toc-text">5. 将职责过多的类进行分解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%B1%BB%E5%90%8D%E5%92%8C%E6%96%B9%E6%B3%95%E5%90%8D%E8%A6%81%E8%83%BD%E5%A4%9F%E4%BD%93%E7%8E%B0%E5%AE%83%E4%BB%AC%E7%9A%84%E8%81%8C%E8%B4%A3"><span class="toc-number">1.9.6.</span> <span class="toc-text">6. 类名和方法名要能够体现它们的职责</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E7%B1%BB"><span class="toc-number">1.9.7.</span> <span class="toc-text">7. 优先使用不可变的类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BB%A7%E6%89%BF"><span class="toc-number">2.</span> <span class="toc-text">第五章 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%AE%B2-%E7%B1%BB%E3%80%81%E8%B6%85%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">第一讲  类、超类和子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%EF%BC%9A"><span class="toc-number">2.1.1.</span> <span class="toc-text">对比：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%A4%9A%E6%80%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">第五节 多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E8%8A%82-%E7%90%86%E8%A7%A3%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">2.1.3.</span> <span class="toc-text">第六节 理解方法调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%8B%E9%9D%A2%E6%98%AF%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0%EF%BC%9A"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">1. 下面是调用过程的详细描述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%EF%BC%9A"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">注释：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">2. 方法表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E8%AE%B2-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.4.</span> <span class="toc-text">第八讲 强制类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E8%A1%8C%E7%9A%84%E5%94%AF%E4%B8%80%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">进行的唯一原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%A0%E6%AD%A4"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">因此</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">2.1.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E8%8A%82-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">2.1.6.</span> <span class="toc-text">第九节 抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%89%A9%E5%B1%95%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%AF%E4%BB%A5%E6%9C%89%E4%B8%A4%E7%A7%8D%E9%80%89%E6%8B%A9%E3%80%82"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">1. 扩展抽象类可以有两种选择。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%82"><span class="toc-number">2.1.6.2.</span> <span class="toc-text">2. 抽象类不能被实例化。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%94%A8%E4%BA%8E%E6%8E%A7%E5%88%B6%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%844%E4%B8%AA%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A"><span class="toc-number">2.1.7.</span> <span class="toc-text">Java用于控制可见性的4个访问修饰符：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%AE%B2-Object%EF%BC%9A%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E8%B6%85%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">第二讲 Object：所有类的超类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-equals-%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">第一节 equals 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-number">2.2.2.</span> <span class="toc-text">注意：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E7%BB%99%E5%87%BA%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E7%9A%84equals%E6%96%B9%E6%B3%95%E7%9A%84%E5%BB%BA%E8%AE%AE%EF%BC%9A"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">下面给出编写一个完美的equals方法的建议：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-hashcode%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.3.</span> <span class="toc-text">第二节 hashcode方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">1. 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89hashCode"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">2. 为什么要有hashCode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-equals-%E5%92%8ChashCode"><span class="toc-number">2.2.3.3.</span> <span class="toc-text">3. equals( )和hashCode( )</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%90%8C%E6%97%B6%E6%8F%90%E4%BE%9B"><span class="toc-number">2.2.3.3.1.</span> <span class="toc-text">1. 同时提供</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%89%80%E4%BB%A5"><span class="toc-number">2.2.3.3.2.</span> <span class="toc-text">2. 所以</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%87%8D%E5%86%99equals-%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99hashCode"><span class="toc-number">2.2.3.3.3.</span> <span class="toc-text">3. 重写equals()必须重写hashCode()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%85%B6%E4%BB%96%E4%BD%90%E8%AF%81"><span class="toc-number">2.2.3.3.4.</span> <span class="toc-text">4. 其他佐证</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%87%8D%E5%86%99hashCode%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.3.4.</span> <span class="toc-text">4. 重写hashCode方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text">第三讲 泛型数组列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%AD%90-%E8%8F%B1%E5%BD%A2%E8%AF%AD%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">引子 菱形语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.2.</span> <span class="toc-text">第一节 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#add%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">add方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#capacity-%E5%92%8C-size"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">capacity 和 size</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.3.</span> <span class="toc-text">第二节 访问数组列表元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#set%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.3.0.1.</span> <span class="toc-text">set方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#get%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.3.0.2.</span> <span class="toc-text">get方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-number">2.3.3.0.3.</span> <span class="toc-text">小技巧</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-%E7%B1%BB%E5%9E%8B%E5%8C%96%E4%B8%8E%E5%8E%9F%E5%A7%8B%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">2.3.4.</span> <span class="toc-text">第三节 类型化与原始数组列表的兼容性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1"><span class="toc-number">2.4.</span> <span class="toc-text">第四讲 对象包装器与自动装箱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1"><span class="toc-number">2.4.1.</span> <span class="toc-text">自动装箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1"><span class="toc-number">2.4.2.</span> <span class="toc-text">自动拆箱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%AE%B2-%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F%E5%8F%AF%E5%8F%98%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text">第五讲 参数数量可变的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E8%AE%B2-%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">2.6.</span> <span class="toc-text">第六讲 枚举类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E8%AE%B2-%E5%8F%8D%E5%B0%84"><span class="toc-number">2.7.</span> <span class="toc-text">第七讲 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC0%E8%8A%82-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.7.1.</span> <span class="toc-text">第0节 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-Class%E7%B1%BB"><span class="toc-number">2.7.2.</span> <span class="toc-text">第一节 Class类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">获取Class对象的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">2.7.2.2.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%89%B9%E7%82%B9"><span class="toc-number">2.7.2.3.</span> <span class="toc-text">其他特点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.7.2.3.1.</span> <span class="toc-text">&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#newInstance"><span class="toc-number">2.7.2.3.2.</span> <span class="toc-text">newInstance( )</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">2.7.3.</span> <span class="toc-text">第二节 捕获异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E5%88%86%E6%9E%90%E7%B1%BB"><span class="toc-number">2.7.4.</span> <span class="toc-text">第三节 利用反射分析类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E7%B1%BB"><span class="toc-number">2.7.4.1.</span> <span class="toc-text">三个类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.4.2.</span> <span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%8A%82-%E8%BF%90%E8%A1%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E5%88%86%E6%9E%90%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.7.5.</span> <span class="toc-text">第四节 运行时使用反射分析对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%8A%82-%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E7%BC%96%E5%86%99%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81"><span class="toc-number">2.7.6.</span> <span class="toc-text">第五节 使用反射编写泛型数组代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E8%8A%82-%E8%B0%83%E7%94%A8%E4%BB%BB%E6%84%8F%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.7.</span> <span class="toc-text">第六节 调用任意方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%97%E5%88%B0Method%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.7.7.1.</span> <span class="toc-text">得到Method对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">2.7.7.2.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E8%AE%B2-%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7"><span class="toc-number">2.8.</span> <span class="toc-text">第八讲 继承的设计技巧</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">第六章 接口、lambda表达式与内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%AE%B2-%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.1.</span> <span class="toc-text">第一讲 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.1.</span> <span class="toc-text">第一节 接口的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">3.1.1.1.1.</span> <span class="toc-text">注释</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">实现接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-1"><span class="toc-number">3.1.1.2.1.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">3.1.2.</span> <span class="toc-text">第二节 接口的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">3.1.3.</span> <span class="toc-text">第三节 接口与抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%8A%82-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.4.</span> <span class="toc-text">第四节 静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%8A%82-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.5.</span> <span class="toc-text">第五节 默认方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%BC%94%E5%8C%96"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">接口演化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E8%8A%82-%E8%A7%A3%E5%86%B3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%86%B2%E7%AA%81"><span class="toc-number">3.1.6.</span> <span class="toc-text">第六节 解决默认方法冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E5%88%99"><span class="toc-number">3.1.6.1.</span> <span class="toc-text">规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AD%A6%E5%91%8A"><span class="toc-number">3.1.6.2.</span> <span class="toc-text">警告</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%8E%A5%E5%8F%A3%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.2.</span> <span class="toc-text">第二讲 接口示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%9B%9E%E8%B0%83"><span class="toc-number">3.2.1.</span> <span class="toc-text">第一节 接口与回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-Comparator%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.2.2.</span> <span class="toc-text">第二节 Comparator接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86"><span class="toc-number">3.2.3.</span> <span class="toc-text">第三节 对象克隆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">深拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A-1"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">注释</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%AE%B2-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">第三讲 lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">第一节 lambda表达式的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BD%A2%E5%BC%8F"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">表达形式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.3.2.</span> <span class="toc-text">第三节 函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tips"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">tips</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%8A%82-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.3.</span> <span class="toc-text">第四节 方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">三种情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A-2"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">注释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%8A%82-%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.4.</span> <span class="toc-text">第五节 构造器引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">数组类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E8%8A%82-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.3.5.</span> <span class="toc-text">第六节 变量作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A-3"><span class="toc-number">3.3.5.1.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E5%88%99-1"><span class="toc-number">3.3.5.2.</span> <span class="toc-text">规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E8%8A%82-%E5%A4%84%E7%90%86lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.3.6.</span> <span class="toc-text">第七节 处理lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.3.7.</span> <span class="toc-text">常用函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA"><span class="toc-number">3.3.7.1.</span> <span class="toc-text">提示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E8%8A%82-%E5%86%8D%E8%B0%88Comparator"><span class="toc-number">3.3.8.</span> <span class="toc-text">第八节 再谈Comparator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">3.4.</span> <span class="toc-text">第四讲 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81"><span class="toc-number">3.4.1.</span> <span class="toc-text">第一节 使用内部类访问对象状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-2"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A-4"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">注释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%89%B9%E6%AE%8A%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">3.4.2.</span> <span class="toc-text">第二节 内部类的特殊语法规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%AE%B2-%E4%BB%A3%E7%90%86"><span class="toc-number">3.5.</span> <span class="toc-text">第五讲 代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86"><span class="toc-number">3.5.1.</span> <span class="toc-text">第一节 何时使用代理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%9B%86%E5%90%88"><span class="toc-number">4.</span> <span class="toc-text">第九章 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%AE%B2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">4.1.</span> <span class="toc-text">第一讲 集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%88%86%E7%A6%BB%E9%9B%86%E5%90%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.1.</span> <span class="toc-text">第一节 分离集合的接口和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B-1"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">举例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A-5"><span class="toc-number">4.1.1.1.1.</span> <span class="toc-text">注释</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-Collection%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.2.</span> <span class="toc-text">第二节 Collection接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.1.3.</span> <span class="toc-text">第三节 迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%B5%85%E6%9E%90"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">方法浅析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#next%E5%92%8ChasNext%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.3.1.1.</span> <span class="toc-text">next和hasNext方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85next"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">补充next</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#forEachRemaining%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.3.2.1.</span> <span class="toc-text">forEachRemaining方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#remove%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.3.2.2.</span> <span class="toc-text">remove方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-3"><span class="toc-number">4.1.3.2.3.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%8A%82-%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.4.</span> <span class="toc-text">第四节 泛型实用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API"><span class="toc-number">4.1.4.1.</span> <span class="toc-text">API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%8A%82-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.5.</span> <span class="toc-text">第五节 集合框架中的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RandomAccess%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.5.1.</span> <span class="toc-text">RandomAccess接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.5.2.</span> <span class="toc-text">Set接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E5%85%B7%E4%BD%93%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">4.2.</span> <span class="toc-text">第二讲 具体的集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E9%93%BE%E8%A1%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">第一节 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ListIterator%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">ListIterator接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9"><span class="toc-number">4.2.1.1.1.</span> <span class="toc-text">并发修改</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE"><span class="toc-number">4.2.1.1.2.</span> <span class="toc-text">随机访问</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">第二节 数组列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-%E6%95%A3%E5%88%97%E9%9B%86"><span class="toc-number">4.2.3.</span> <span class="toc-text">第三节 散列集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">散列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%B6"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">桶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E5%86%B2%E7%AA%81"><span class="toc-number">4.2.3.3.</span> <span class="toc-text">散列冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%8D%E6%95%A3%E5%88%97"><span class="toc-number">4.2.3.4.</span> <span class="toc-text">再散列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet%E7%B1%BB"><span class="toc-number">4.2.3.5.</span> <span class="toc-text">HashSet类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%8A%82-%E6%A0%91%E9%9B%86"><span class="toc-number">4.2.4.</span> <span class="toc-text">第四节 树集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E6%AF%94%E8%BE%83"><span class="toc-number">4.2.5.</span> <span class="toc-text">二者比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%8A%82-%E9%98%9F%E5%88%97%E4%B8%8E%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.2.6.</span> <span class="toc-text">第五节 队列与双端队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.6.1.</span> <span class="toc-text">常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E8%8A%82-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">4.2.7.</span> <span class="toc-text">第六节 优先级队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%98%A0%E5%B0%84"><span class="toc-number">4.3.</span> <span class="toc-text">第三讲 映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%9F%BA%E6%9C%AC%E6%98%A0%E5%B0%84%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.1.</span> <span class="toc-text">第一节 基本映射操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%AE"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">必要性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E6%80%A7"><span class="toc-number">4.3.1.2.1.</span> <span class="toc-text">唯一性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-%E6%9B%B4%E6%96%B0%E6%98%A0%E5%B0%84%E9%A1%B9"><span class="toc-number">4.3.2.</span> <span class="toc-text">第二节 更新映射项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%95%E4%B8%80"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">法一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%95%E4%BA%8C"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">法二</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-%E6%98%A0%E5%B0%84%E8%A7%86%E5%9B%BE"><span class="toc-number">4.3.3.</span> <span class="toc-text">第三节 映射视图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E8%A7%86%E5%9B%BE%E4%B8%8E%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">4.4.</span> <span class="toc-text">第四讲 视图与包装器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%AE%B2-%E7%AE%97%E6%B3%95"><span class="toc-number">4.5.</span> <span class="toc-text">第五讲 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%B7%B7%E6%8E%92"><span class="toc-number">4.5.1.</span> <span class="toc-text">第一节 排序与混排</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%8D%E5%BA%8F%E6%8E%92%E5%BA%8F"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">降序排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E6%8E%92"><span class="toc-number">4.5.1.2.</span> <span class="toc-text">混排</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">4.5.2.</span> <span class="toc-text">第二节 二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-1"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">提示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95"><span class="toc-number">4.5.3.</span> <span class="toc-text">第三节 简单算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%8A%82-%E6%89%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">4.5.4.</span> <span class="toc-text">第四节 批操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E4%BA%A4%E9%9B%86"><span class="toc-number">4.5.4.1.</span> <span class="toc-text">寻找交集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%8A%82-%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.5.5.</span> <span class="toc-text">第五节 集合与数组的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E9%9B%86%E5%90%88"><span class="toc-number">4.5.5.1.</span> <span class="toc-text">数组转换为集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%BE%97%E5%88%B0%E6%95%B0%E7%BB%84"><span class="toc-number">4.5.5.2.</span> <span class="toc-text">集合得到数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A-6"><span class="toc-number">4.5.5.3.</span> <span class="toc-text">注释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95"><span class="toc-number">4.5.6.</span> <span class="toc-text">拓展</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-14-%E5%B9%B6%E5%8F%91"><span class="toc-number">5.</span> <span class="toc-text">Chapter 14 并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%AE%B2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">第一讲 什么是线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%BB%99%E5%85%B6%E4%BB%96%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BE%9B%E6%9C%BA%E4%BC%9A"><span class="toc-number">5.1.1.</span> <span class="toc-text">第一节 使用线程给其他任务提供机会</span></a></li></ol></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
