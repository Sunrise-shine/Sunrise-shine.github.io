
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Head_First_设计模式 - Sunrise-shine的博客</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="Just do it!,Chapter 1 设计模式入门建立可维护的OO系统，要诀就在于随时想到一同以后可能需要的变化以及应付变化的原则。
1. 第一个设计原则封装变化
找出应用中可能需要变化之处，把它们独立起来，不要和那,"> 
    <meta name="author" content="Sunrise-shine"> 
    <link rel="alternative" href="atom.xml" title="Sunrise-shine的博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.4.1"></head>

<body class="loading">
    <span id="config-title" style="display:none">Sunrise-shine的博客</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://Sunrise-shine.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Head_First_设计模式</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Head_First_设计模式</h1>
        <div class="stuff">
            <span>二月 22, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Head-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">Head First 设计模式</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="Chapter-1-设计模式入门"><a href="#Chapter-1-设计模式入门" class="headerlink" title="Chapter 1 设计模式入门"></a>Chapter 1 设计模式入门</h1><p>建立可维护的OO系统，要诀就在于随时想到一同以后可能需要的变化以及应付变化的原则。</p>
<h2 id="1-第一个设计原则"><a href="#1-第一个设计原则" class="headerlink" title="1. 第一个设计原则"></a>1. 第一个设计原则</h2><p><strong>封装变化</strong></p>
<p>找出应用中可能需要变化之处，把它们独立起来，不要和那些不需要变化的代码混在一起。</p>
<h2 id="2-第二个设计原则"><a href="#2-第二个设计原则" class="headerlink" title="2. 第二个设计原则"></a>2. 第二个设计原则</h2><p><strong>针对接口编程，而不是针对实现编程。</strong></p>
<p>行为是通过Duck超类的具体实现或继承某个接口的子类自行实现而来，即所谓针对实现编程。</p>
<p>鸭子的子类将使用接口所表示的行为，便是一种意义上的针对接口编程。</p>
<p>其实，针对接口，实际上是针对超类型编程，并不是直观意义上的Java interface类型。</p>
<p>而针对接口编程，关键就在多态。利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为，而不会被绑死在超类型的行为上。”针对超类型编程”，可以更明确说成”变量的声明类型应该是超类型，通常是一个抽象类或者是一个接口，如此，只要是具体实现此超类型的类所产生的对象，都可以指定给这个变量。这也意味着，声明类时不用理会以后执行时的真正对象类型！”</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>针对实现编程：Dog d = new Dog(); d.bark();</p>
<p>针对接口编程：Animal a = new Dog(); a.makeSound();</p>
<p><img src="https://s2.loli.net/2022/03/12/qUXn9Y7HkoA35Sl.png" alt="image-20220312194627080" style="zoom:80%;" /></p>
<p>在运行时，才指定具体的实现的对象。</p>
<h4 id="动态设定行为"><a href="#动态设定行为" class="headerlink" title="动态设定行为"></a>动态设定行为</h4><p>可以通过”设定方法(setter method)”来在方法内部设定鸭子的行为。</p>
<h2 id="3-第三个设计原则"><a href="#3-第三个设计原则" class="headerlink" title="3. 第三个设计原则"></a>3. 第三个设计原则</h2><p><strong>多用组合，少用继承。</strong></p>
<p>不再把鸭子的行为说成是”一组行为”，而开始把行为想成是”一族算法”。再SimUDuck的设计中，算法代表鸭子能做的事。</p>
<h4 id="“有一个”可能比”是一个”更好"><a href="#“有一个”可能比”是一个”更好" class="headerlink" title="“有一个”可能比”是一个”更好"></a>“有一个”可能比”是一个”更好</h4><p>每个鸭子都有一个FlyBehavior和一个QuarkBehavior，好将飞行和呱呱叫委托给它们代为处理。</p>
<p>当你将两个类结合起来使用，如同本例一样，这就是组合。</p>
<p>使用组合建立系统具有很大的弹性，不仅可将算法族封装成类，更可以在运行时动态地改变行为。</p>
<h2 id="4-策略模式"><a href="#4-策略模式" class="headerlink" title="4. 策略模式"></a>4. 策略模式</h2><p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>
<p><img src="https://s2.loli.net/2022/03/12/VrCsmPQFBw32nMJ.png" alt="image-20220312200432241"></p>
<p>模式不是代码，而是针对设计问题的通用解决方法。</p>
<h2 id="5-tips"><a href="#5-tips" class="headerlink" title="5. tips"></a>5. tips</h2><h4 id="OO基础"><a href="#OO基础" class="headerlink" title="OO基础"></a>OO基础</h4><ul>
<li>抽象</li>
<li>封装</li>
<li>多态</li>
<li>继承</li>
</ul>
<h4 id="OO原则"><a href="#OO原则" class="headerlink" title="OO原则"></a>OO原则</h4><ul>
<li>封装变化</li>
<li>多用组合，少用继承</li>
<li>针对接口编程，不针对实现编程</li>
</ul>
<h2 id="6-总结过程"><a href="#6-总结过程" class="headerlink" title="6. 总结过程"></a>6. 总结过程</h2><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><p>在原有系统的基础上，给鸭子增加会飞这一行为。</p>
<p> <a href="E:\CS\鸭子行为.xmind">鸭子行为.xmind</a> </p>
<p><img src="https://s2.loli.net/2022/03/14/l8Eyksr4ovcTm2b.png" alt="鸭子行为"></p>
<h3 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MiniDuckSimulator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Duck</span> <span class="variable">mallard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MallardDuck</span>();</span><br><span class="line">        mallard.performFly();</span><br><span class="line">        mallard.performQuark();</span><br><span class="line">        mallard.setFlyBehavior(<span class="keyword">new</span> <span class="title class_">FlyNoWay</span>());</span><br><span class="line">        mallard.setQuackBehavior(<span class="keyword">new</span> <span class="title class_">MuteQuark</span>());</span><br><span class="line">        mallard.performQuark();</span><br><span class="line">        mallard.performFly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Chapter-2-观察者-Observer-模式"><a href="#Chapter-2-观察者-Observer-模式" class="headerlink" title="Chapter 2 观察者(Observer)模式"></a>Chapter 2 观察者(Observer)模式</h1><h2 id="1-定义观察者模式"><a href="#1-定义观察者模式" class="headerlink" title="1. 定义观察者模式"></a>1. 定义观察者模式</h2><p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p>
<p><img src="https://s2.loli.net/2022/03/15/tczoSCNpTxsjl4A.png" alt="image-20220315171227252"></p>
<p>实现观察者模式的方法不止一种，但是以包含Subject和Observer接口的类设计的做法最常见。</p>
<h2 id="2-松耦合"><a href="#2-松耦合" class="headerlink" title="2. 松耦合"></a>2. 松耦合</h2><p>当两个对象松耦合时，它们依然可以交互，但是不太清楚彼此的细节。</p>
<p>观察者模式提供了一种对象设计，让主题和观察者之间松耦合。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>关于观察者的一切，主题只知道观察者实现了某个接口(Observer接口)。主题不需要知道观察者的具体类以及做了什么。</p>
<p>任何时候，我们都可以新增观察者。因为主题唯一依赖的是一个实现了Observer接口的对象列表。事实上，就算在运行时用心地观察着取代现有的观察者，主题不会受到任何影响。</p>
<p>有新类型的观察者出现时，主题的代码不需要修改。所有要做的只是在新的类里实现观察者接口，然后注册为观察者即可。</p>
<h2 id="3-第四个设计原则"><a href="#3-第四个设计原则" class="headerlink" title="3. 第四个设计原则"></a>3. 第四个设计原则</h2><p>为了交互对象的松耦合设计而努力。</p>
<p>松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低。</p>
<h2 id="4-气象站"><a href="#4-气象站" class="headerlink" title="4. 气象站"></a>4. 气象站</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://s2.loli.net/2022/03/15/mgf5ciDBNqFYnCX.png" alt="image-20220315172330150"></p>
<p>在主题接口中，需要方法来注册观察者、删除观察者和通知观察者状态。</p>
<p>在WeatherData类中，需要有一个列表ArrayList，在构造器中建立，记录当前的所有观察者，以便push改变后的状态给所有观察者。</p>
<p>布告板要实现Observer接口和DisplayElement接口，以获取更新(update()方法)并展示当前的内容(display()方法)</p>
<h3 id="代码展示-1"><a href="#代码展示-1" class="headerlink" title="代码展示"></a>代码展示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherDatas</span> <span class="keyword">implements</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc: 记录观察者，在构造器中建立</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/15 0:13</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList observers;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherDatas</span><span class="params">()</span> &#123;</span><br><span class="line">        observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; observers.size(); i++) &#123;</span><br><span class="line">            <span class="type">Observer</span> <span class="variable">observer</span> <span class="operator">=</span> (Observer) observers.get(i);</span><br><span class="line">            observer.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc: 当气象站得到更新观测值时，通知观察者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/14 18:38</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measurementsChanged</span><span class="params">()</span> &#123;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMeasurements</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-Java内置的观察者模式"><a href="#5-Java内置的观察者模式" class="headerlink" title="5. Java内置的观察者模式"></a>5. Java内置的观察者模式</h2><p>Java API中有内置的观察者模式。java.util包中包含最基本的Observer接口和Observable类。</p>
<h3 id="1-修改后的类图"><a href="#1-修改后的类图" class="headerlink" title="1. 修改后的类图"></a>1. 修改后的类图</h3><p><img src="https://s2.loli.net/2022/03/15/rPdnWUevOwSg7Xc.png" alt="image-20220315174217295"></p>
<h4 id="1-把对象变为观察者"><a href="#1-把对象变为观察者" class="headerlink" title="1. 把对象变为观察者"></a>1. 把对象变为观察者</h4><ol>
<li>实现观察者接口</li>
<li>调用Observable对象的addObserver方法</li>
<li>不想当观察者时，调用deleteObservable方法</li>
</ol>
<h4 id="2-观察者送出通知"><a href="#2-观察者送出通知" class="headerlink" title="2. 观察者送出通知"></a>2. 观察者送出通知</h4><ol>
<li>扩展java.util.Observable接口产生”可观察者”类</li>
<li>调用setChanged()方法，标记状态改变的事实</li>
<li>调用notifyObservers()(观察者自己pull数据)或notifyObservers(Object arg)(主题push数据给观察者)</li>
</ol>
<h4 id="3-观察者接收数据"><a href="#3-观察者接收数据" class="headerlink" title="3. 观察者接收数据"></a>3. 观察者接收数据</h4><p>观察者实现了更新的方法，但是方法签名不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数标识主题</span></span><br><span class="line"><span class="comment">// 第二个参数是从主题处push的数据，即传入notifyObservers()的数据对象</span></span><br><span class="line">update(Observable o, Object arg)</span><br></pre></td></tr></table></figure>
<h4 id="4-关于setChanged"><a href="#4-关于setChanged" class="headerlink" title="4. 关于setChanged"></a>4. 关于setChanged</h4><p>setChanged方法用来标记状态已经改变的事实。</p>
<p>如果调用notifyObserver()之前没有先调用setChanged()，观察者就不会被通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setChanged() &#123;</span><br><span class="line">    changed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">notifyObservers(Object arg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">        <span class="keyword">for</span> every observer on the list &#123;</span><br><span class="line">            call <span class="title function_">update</span><span class="params">(<span class="built_in">this</span>, arg)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        changed = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">notifyObservers() &#123;</span><br><span class="line">    notifyObservers(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-java-util-Observable"><a href="#2-java-util-Observable" class="headerlink" title="2. java.util.Observable"></a>2. java.util.Observable</h3><p>它的实现有许多问题，限制了它的使用和复用。</p>
<h4 id="Observable是一个类"><a href="#Observable是一个类" class="headerlink" title="Observable是一个类"></a>Observable是一个类</h4><ol>
<li>必须设计一个类继承它，由于Java不支持多重继承，这就使得不能同时继承Observable类和另一个超类，限制了Observable的复用潜力</li>
<li>因为没有Observable接口，无法建立自己的实现，和Java内置的Observable API搭配使用</li>
<li>将关键的方法保护起来，即setChanged方法被protected。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>有多个观察者时，不可以依赖特定的通知次序</p>
</li>
<li><p>使用此模式，可以由被观察者处推push或观察者拉pull数据</p>
</li>
<li><p>观察者和可观察者之间用松耦合方式结合( loosecoupling ) ，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/15/AQc8iSnM1263gOj.png" alt="image-20220315181625798"></p>
<h1 id="Chapter-3-装饰者模式"><a href="#Chapter-3-装饰者模式" class="headerlink" title="Chapter 3 装饰者模式"></a>Chapter 3 装饰者模式</h1><p>可以在不修改任何底层代码的情况下，给对象赋予新的职责。</p>
<p>引入星巴兹的故事。</p>
<p>通过动态地组合对象，可以写新的代码增加新功能，而无需修改现有代码，可以减少引进bug和产生副作用。</p>
<p>代码应该免于改变，能够拓展。</p>
<h2 id="1-第五个设计原则"><a href="#1-第五个设计原则" class="headerlink" title="1. 第五个设计原则"></a>1. 第五个设计原则</h2><p><strong>开放-关闭原则</strong></p>
<p><strong>类应该对拓展开放，对修改关闭。</strong></p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>这样，在不修改现有代码的基础上，就可搭配新的行为，设计具有弹性，可以接受新的功能来应对改变的需求。</p>
<p>将注意力集中在设计中最有可能改变的地方，然后应用开放-关闭原则。</p>
<h2 id="2-装饰者模式"><a href="#2-装饰者模式" class="headerlink" title="2. 装饰者模式"></a>2. 装饰者模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>装饰者模式动态地将责任附加到对象上。若要拓展功能，装饰提供了比继承更有弹性的替代方案。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>装饰者和被装饰对象有相同的超类型</li>
<li>可以用一个或多个装饰者包装一个对象</li>
<li>可以在任何需要原始对象(被包装对象)的场合，用装饰过的对象替代它</li>
<li>装饰者可以在所委托的被装饰者的行为之前或(/与)之后，加上自己的行为，以达到特定的目的</li>
<li>对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用装饰者来装饰对象</li>
</ul>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="https://s2.loli.net/2022/03/19/QIStJgXo5yMcG1s.png" alt="image-20220319182432157"></p>
<h2 id="3-回到星巴兹"><a href="#3-回到星巴兹" class="headerlink" title="3. 回到星巴兹"></a>3. 回到星巴兹</h2><h3 id="1-类图"><a href="#1-类图" class="headerlink" title="1. 类图"></a>1. 类图</h3><p><img src="https://s2.loli.net/2022/03/19/sWNk9LT27bcIOvF.png" alt="image-20220319182722745"></p>
<h3 id="2-装饰者模式下的cost"><a href="#2-装饰者模式下的cost" class="headerlink" title="2. 装饰者模式下的cost"></a>2. 装饰者模式下的cost</h3><p><img src="https://s2.loli.net/2022/03/19/U6iFmjsoKNSqGy5.png" alt="image-20220319182833028"></p>
<h3 id="3-继承？"><a href="#3-继承？" class="headerlink" title="3. 继承？"></a>3. 继承？</h3><p>装饰者和被装饰者必须是一样的类型，也就是拥有相同的超类。所以在这里，我们<strong>使用继承来达到”类型匹配”，而不是利用继承来获得”行为”</strong>。</p>
<p>也就是说，使用Beverage抽象类，是为了保证拥有正确的类型，而不是继承它的行为。行为来自装饰者和基础组件，或与其他装饰者之间的组合关系。</p>
<p>通常装饰者模式是采用抽象类，但是在Java中可以使用接口。</p>
<h3 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StarBuzzCoffee</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Beverage</span> <span class="variable">beverage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Espresso</span>();</span><br><span class="line">        System.out.println(beverage.getDescription() + <span class="string">&quot; $&quot;</span> + beverage.cost());</span><br><span class="line"></span><br><span class="line">        <span class="type">Beverage</span> <span class="variable">beverage2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DarkRoast</span>();</span><br><span class="line">        beverage2 = <span class="keyword">new</span> <span class="title class_">Mocha</span>(beverage2);</span><br><span class="line">        beverage2 = <span class="keyword">new</span> <span class="title class_">Mocha</span>(beverage2);</span><br><span class="line">        beverage2 = <span class="keyword">new</span> <span class="title class_">Whip</span>(beverage2);</span><br><span class="line">        System.out.println(beverage2.getDescription() + <span class="string">&quot; $&quot;</span> + beverage2.cost());</span><br><span class="line"></span><br><span class="line">        <span class="type">Beverage</span> <span class="variable">beverage3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseBlend</span>();</span><br><span class="line">        beverage3 = <span class="keyword">new</span> <span class="title class_">Soy</span>(beverage3);</span><br><span class="line">        beverage3 = <span class="keyword">new</span> <span class="title class_">Mocha</span>(beverage3);</span><br><span class="line">        beverage3 = <span class="keyword">new</span> <span class="title class_">Whip</span>(beverage3);</span><br><span class="line">        System.out.println(beverage3.getDescription() + <span class="string">&quot; $&quot;</span> + beverage3.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-others"><a href="#5-others" class="headerlink" title="5. others"></a>5. others</h3><p>如果把代码写成依赖于具体的组件类型，那么装饰者就会导致程序出问题。只有在针对抽象组件类型编程时，才不会因为装饰者而受到影响。</p>
<p>装饰者该做的事，就是增加行为到被包装对象上。当需要窥视装饰者链中的每一个装饰者，这就超出他们的天赋了，但并非做不到。</p>
<h2 id="4-Java-I-O"><a href="#4-Java-I-O" class="headerlink" title="4. Java I/O"></a>4. Java I/O</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://s2.loli.net/2022/03/19/MKG7YrlsJim6dFU.png" alt="image-20220319183837739"></p>
<h2 id="5-要点"><a href="#5-要点" class="headerlink" title="5. 要点"></a>5. 要点</h2><p>组合和委托可用于在运行时动态地加上新的行为。</p>
<p>装饰者模式反映出被装饰的组件的类型(事实上，它们用于相同的类型，都经过接口或继承实现)。</p>
<p>装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。</p>
<h1 id="Chapter-4-工厂模式"><a href="#Chapter-4-工厂模式" class="headerlink" title="Chapter 4 工厂模式"></a>Chapter 4 工厂模式</h1><h2 id="1-谈谈new"><a href="#1-谈谈new" class="headerlink" title="1. 谈谈new"></a>1. 谈谈new</h2><p>当使用new时，是在实例化一个具体的类，也就是说，此时用的是实现，而不是接口。</p>
<p>针对接口编程，可以隔离掉以后系统可能发生的一堆改变。因为，如果代码是针对接口而写，那么通过多态，可以与任何新类实现该接口。但是当代码使用大量的具体类时，等于是自找麻烦。因为一旦加入新的具体类，就必须改变代码。也就是说，代码并非”对修改关闭”。</p>
<p>那么，此时需要”找出会变化的部分，把他们从不变的部分分离出来”。</p>
<h2 id="2-对象村比萨店"><a href="#2-对象村比萨店" class="headerlink" title="2. 对象村比萨店"></a>2. 对象村比萨店</h2><h3 id="1-开张"><a href="#1-开张" class="headerlink" title="1. 开张"></a>1. 开张</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Pizza <span class="title function_">orderPizza</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    Pizza pizza;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据pizza的类型，实例化具体的类</span></span><br><span class="line">    <span class="keyword">if</span> (type.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;pepperoni&quot;</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> <span class="title class_">PepperoniPizza</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pizza.prepare();</span><br><span class="line">    pizza.bake();</span><br><span class="line">    pizza.cut();</span><br><span class="line">    pizza.box();</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去很不错，因为我们的鸭子就是按照这种方式。</p>
<h3 id="2-新增比萨类型"><a href="#2-新增比萨类型" class="headerlink" title="2. 新增比萨类型"></a>2. 新增比萨类型</h3><p>为了增加竞争力，需要新增或去掉比萨的种类。这就意味着，我们要打开orderPizza的代码进行修改。</p>
<p>但是，整个orderPizza代码中，除了具体类的new之外，其余的比萨准备、烘烤等部分都维持不变，所以这些代码是不变的部分，会发生改变的部分是发生这些动作的比萨。</p>
<p>很明显，如果实例化”某些”具体的类，将使orderPizza( )出问题，而且也无法让orderPizza( )对修改关闭，但所幸，已经知道哪些会改变，哪些不会改变，是时候使用封装了。</p>
<h3 id="3-封装创建对象的代码"><a href="#3-封装创建对象的代码" class="headerlink" title="3. 封装创建对象的代码"></a>3. 封装创建对象的代码</h3><p>将创建比萨的代码移到另一个对象中，由这个新对象专职创建比萨。</p>
<h4 id="1-工厂"><a href="#1-工厂" class="headerlink" title="1. 工厂"></a>1. 工厂</h4><p>工厂处理创建对象的细节。那么orderPizza( )只关心从工厂得到了一个比萨，而这个比萨实现了pizza接口。</p>
<h4 id="2-建立一个简单的比萨工厂"><a href="#2-建立一个简单的比萨工厂" class="headerlink" title="2. 建立一个简单的比萨工厂"></a>2. 建立一个简单的比萨工厂</h4><p>定义一个类SimplePizzaFactory，为所有的比萨封装创建对象的代码。</p>
<p>首先，在这个工厂中定义一个createPizza( )的方法，所有客户用这个方法来实例化新对象。</p>
<p>之后，实现改变时，只需要修改这个类即可。</p>
<h5 id="静态？"><a href="#静态？" class="headerlink" title="静态？"></a>静态？</h5><p>利用静态方法定义一个简单的工厂，是很常见的，被称为静态工厂。</p>
<p>为何使用静态方法?</p>
<p>因为不需要使用创建对象的方法来实例化对象，直接使用类名即可调用，但这样不能通过继承来改变创建方法的行为。</p>
<h4 id="3-此时的PizzaStore"><a href="#3-此时的PizzaStore" class="headerlink" title="3. 此时的PizzaStore"></a>3. 此时的PizzaStore</h4><p><img src="https://s2.loli.net/2022/03/22/MmxkJAh13vBcGl6.png" alt="image-20220322165649784"></p>
<h3 id="4-定义简单工厂"><a href="#4-定义简单工厂" class="headerlink" title="4. 定义简单工厂"></a>4. 定义简单工厂</h3><p><strong>简单工厂实际上并不是一个设计模式，反而像是一种编程习惯。</strong></p>
<h4 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h4><p><img src="https://s2.loli.net/2022/03/22/jSmAeftbg3hk8OL.png" alt="image-20220322170113022"></p>
<h3 id="重要提醒"><a href="#重要提醒" class="headerlink" title="重要提醒"></a>重要提醒</h3><p>所谓的”实现一个接口”，并不一定表示”下一个类，并利用implements关键字来实现某个Java接口”。</p>
<p>“实现一个接口”泛指，<strong>“实现某个超类型(可以似乎类或接口)的某个方法”</strong>。</p>
<h2 id="3-加盟比萨店"><a href="#3-加盟比萨店" class="headerlink" title="3. 加盟比萨店"></a>3. 加盟比萨店</h2><p>为了让比萨制作活动局限于PizzaStore类，同时又能让这些加盟店可以自由地制作该区域的风味，方法：</p>
<p><strong>把createPizza( )方法放回到PizzaStore中，把它设置为”抽象方法”</strong>，然后为每个区域创建一个PizzaStore的子类。</p>
<h3 id="1-允许子类做决定"><a href="#1-允许子类做决定" class="headerlink" title="1. 允许子类做决定"></a>1. 允许子类做决定</h3><p>做法是让PizzaStore的各个子类负责定义自己的createPizza( )方法。</p>
<p>所以我们会得到一些PizzaStore具体的子类，每个子类都有自己的比萨变体，而仍然适合PizzaStore框架，并使用调试好的orderPizza( )方法(可以将它声明为final，以防止被子类覆盖)。</p>
<h4 id="子类做决定？"><a href="#子类做决定？" class="headerlink" title="子类做决定？"></a>子类做决定？</h4><p>orderPizza( )方法对Pizza对象做了许多事情，但由于Pizza对象是抽象的，所以orderPizza( )并不知道那些实际的具体类参与进来了。换句话说，这就是”解耦(decouple)！”</p>
<p><img src="https://s2.loli.net/2022/03/22/UCuHqcWe8PoXYMA.png" alt="image-20220322173641308"></p>
<p>从orderPizza()的角度来看，如果选择在NYStylePizzaStore订购比萨，就是由这个子类(NYStylePizzaStore）决定。</p>
<p>严格来说，并非由这个子类实际做“决定”，而是由“顾客”决定到哪一家风味的比萨店才决定了比萨的风味。</p>
<h3 id="2-开家比萨店"><a href="#2-开家比萨店" class="headerlink" title="2. 开家比萨店"></a>2. 开家比萨店</h3><p>加盟店，只需要继承PizzaStore，然后提供createPizza( )方法实现自己的比萨风味即可。</p>
<h4 id="1-声明一个工厂方法"><a href="#1-声明一个工厂方法" class="headerlink" title="1. 声明一个工厂方法"></a>1. 声明一个工厂方法</h4><p>原本是由一个对象负责所有具体类的实例化，现在变成由一群子类来负责。</p>
<p>工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户程序中关于超类的代码(orderPizza( ))就和子类对象创建代码解耦了。</p>
<p><img src="https://s2.loli.net/2022/03/22/jQ6zEAmOpuaC1WV.png" alt="image-20220322191620477"></p>
<h4 id="2-订购工序"><a href="#2-订购工序" class="headerlink" title="2. 订购工序"></a>2. 订购工序</h4><p>首先建立一家纽约风味比萨的加盟店，之后调用orderPizza( )并传入cheese这一比萨类型进行点单，因为纽约风味的加盟店中没有重写orderPizza( )方法，那么会到PizzaStore类中调用父类的orderPizza( )方法，在该方法中，进一步调用createPizza( )制造纽约风味的芝士披萨，将其返回给客户。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaTestDrive</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PizzaStore</span> <span class="variable">nyStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NYPizzaStore</span>();</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> nyStore.orderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Ethan ordered a &quot;</span> + pizza.getName() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">orderPizza</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        Pizza pizza;</span><br><span class="line">        pizza = createPizza(type);</span><br><span class="line"></span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Pizza <span class="title function_">createPizza</span><span class="params">(String type)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NYPizzaStore</span> <span class="keyword">extends</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Pizza <span class="title function_">createPizza</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NYStyleCheesePizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>超类从来不管细节，通过实例化正确的比萨类，子类会自动照料一切。</p>
<h2 id="4-工厂模式"><a href="#4-工厂模式" class="headerlink" title="4. 工厂模式"></a>4. 工厂模式</h2><p>所有的工厂模式都用来封装对象的创建。</p>
<p>工厂方法模式通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</p>
<h3 id="1-类图-1"><a href="#1-类图-1" class="headerlink" title="1. 类图"></a>1. 类图</h3><h4 id="创建者类"><a href="#创建者类" class="headerlink" title="创建者类"></a>创建者类</h4><p><img src="https://s2.loli.net/2022/03/22/GIAtPdLrXRQveEs.png" alt="image-20220322195917649"></p>
<h4 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h4><p><img src="https://s2.loli.net/2022/03/22/F6cfgA2uVoJ3md5.png" alt="image-20220322200049860"></p>
<h3 id="2-平行的类层级"><a href="#2-平行的类层级" class="headerlink" title="2. 平行的类层级"></a>2. 平行的类层级</h3><p>将一个orderPizza方法和一个工厂方法联合起来，就可以成为一个框架。除此之外，工厂方法将生产知识封装进各个创建者，这样的做法，也可以被视为是一个框架。</p>
<h3 id="3-定义工厂方法模式"><a href="#3-定义工厂方法模式" class="headerlink" title="3. 定义工厂方法模式"></a>3. 定义工厂方法模式</h3><p>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的是哪一个。工厂方法让类把实例化推迟到子类。</p>
<p>工厂方法模式能够封装具体类型的实例化。抽象的Creator提供了一个创建对象的方法的接口，也称为工厂方法。在抽象的Creator中，任何其他实现的方法，都可能使用到这个工厂方法所制造出来的产品，但只有子类真正实现这个工厂方法并创建产品。</p>
<p>“工厂方法让子类决定要实例化的类是哪一个”，所谓的“决定”，并不是指模式允许子类本身在运行时做决定，而是指<strong>在编写创建者类时，不需要知道实际创建的产品是哪一个</strong>。选择了使用哪个子类，自然就决定了实际创建的产品是什么。</p>
<p><img src="https://s2.loli.net/2022/03/22/Z7EWQijVMTOg5dl.png" alt="image-20220322200841468"></p>
<h3 id="4-特点"><a href="#4-特点" class="headerlink" title="4. 特点"></a>4. 特点</h3><ol>
<li><p>工厂方法模式将产品的实现从使用中解耦，如果增加产品或改变产品的实现，Creator并不会受到影响。</p>
</li>
<li><p>注意工厂方法模式和简单工厂的区别</p>
<ol>
<li>简单工厂把所有的事情，在一个地方都处理完了，将对象创建封装起来，但是不能变更正在创建的产品。</li>
<li>但工厂方法却是创建一个框架，让子类决定要如何实现。</li>
</ol>
</li>
<li><p>将创建对象的代码集中在一个对象或方法中，可以避免代码中的重复，并且更方便以后的维护，这也意味着客户在实例化对象时，只会依赖于接口，而不是具体类。</p>
</li>
</ol>
<p><strong>对象的创建是现实的，如果不创建任何对象，就无法创建任何Java程序，可将这些创建对象的代码用栅栏围起来进行保护。</strong></p>
<h2 id="5-第六个设计原则"><a href="#5-第六个设计原则" class="headerlink" title="5. 第六个设计原则"></a>5. 第六个设计原则</h2><p><strong>依赖倒置原则(Dependency Inversion Principle)</strong></p>
<p>当直接实例化一个对象时，就是在依赖他的具体类，代码里减少对于具体类的依赖是件好事。</p>
<p><strong>要依赖抽象，不要依赖具体类。</strong></p>
<p>这个原则说明了，不能让高层组件依赖低层组件，而且，不管高层组件还是低层组件，都应该依赖于抽象。</p>
<p>所谓”高层组件”，是有其他低层组件定义其行为的类。</p>
<p>PizzaStore是”高层组件”，而比萨实现是”低层组件”，所以，应该：</p>
<p><img src="https://s2.loli.net/2022/03/22/l8eQyCBLhEWtZRf.png" alt="image-20220322202720059"></p>
<h3 id="1-何谓倒置"><a href="#1-何谓倒置" class="headerlink" title="1. 何谓倒置?"></a>1. 何谓倒置?</h3><p><img src="https://s2.loli.net/2022/03/22/d8XMwF1UVTqGsNg.png" alt="image-20220322202854226"></p>
<p><img src="https://s2.loli.net/2022/03/22/lUeTXdz5hSwpYMA.png" alt="image-20220322203058058"></p>
<h3 id="2-指导方针"><a href="#2-指导方针" class="headerlink" title="2. 指导方针"></a>2. 指导方针</h3><ul>
<li>变量不可以持有具体类的引用(如果使用new，就会持有具体类的医用，改用工厂)</li>
<li>不要让类派生自具体类(否则就会以来具体类，改用抽象)</li>
<li>不要覆盖基类中已实现的方法(应该由子类共享)</li>
</ul>
<p>应该尽量达到这个原则，而不是随时都要遵守这个原则。</p>
<p><img src="https://s2.loli.net/2022/03/22/NLwnU2jdhVOYrJ4.png" alt="image-20220322203424951"></p>
<h2 id="6-回到比萨店"><a href="#6-回到比萨店" class="headerlink" title="6. 回到比萨店"></a>6. 回到比萨店</h2><p>对于不同风味的比萨，显然会使用不同的原料。也就是说，所有的比萨都使用相同的组件制造而成，但是不同的区域对于这些组件却有不同的实现。</p>
<h3 id="1-建造原料工厂"><a href="#1-建造原料工厂" class="headerlink" title="1. 建造原料工厂"></a>1. 建造原料工厂</h3><p>为工厂定义一个接口，负责创建所有的原料：</p>
<p><img src="https://s2.loli.net/2022/03/22/SZgUOm9hGfFV6NQ.png" alt="image-20220322203758366"></p>
<h4 id="建造纽约工厂等"><a href="#建造纽约工厂等" class="headerlink" title="建造纽约工厂等"></a>建造纽约工厂等</h4><p>对于原料家族的每一种原料，提供不同区域的版本。</p>
<h3 id="2-重做比萨"><a href="#2-重做比萨" class="headerlink" title="2. 重做比萨"></a>2. 重做比萨</h3><p>此时，要将prepare( )方法声明为抽象。</p>
<p><img src="https://s2.loli.net/2022/03/22/iLPayqMVJAQ97dZ.png" alt="image-20220322210504651"></p>
<p><img src="https://s2.loli.net/2022/03/22/3MtYXAG5oWldhSJ.png" alt="image-20220322204156849"></p>
<h3 id="3-到底做了什么？"><a href="#3-到底做了什么？" class="headerlink" title="3. 到底做了什么？"></a>3. 到底做了什么？</h3><p>引入了新类型的工厂，也就是所谓的抽象工厂，来创建比萨原料家族。</p>
<p>通过抽象工厂所提供的接口，可以创建产品的家族，利用这个接口书写代码，将代码从实际工厂解耦，以便在不同上下文中实现各式各样的工厂，制造出各种不同的产品。</p>
<h4 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h4><p><img src="https://s2.loli.net/2022/03/22/LGrUKoq4OEIJ8cs.png" alt="image-20220322204454977"></p>
<p><img src="https://s2.loli.net/2022/03/22/uSjd7qnEBZPQmg1.png" alt="image-20220322204629684"></p>
<p>在createPizza( )中用到了抽象工厂。</p>
<h2 id="7-抽象工厂模式"><a href="#7-抽象工厂模式" class="headerlink" title="7. 抽象工厂模式"></a>7. 抽象工厂模式</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>抽象工作模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体的类。</strong></p>
<p>抽象工厂允许客户使用抽象的借口来创建一组相关的产品，而不需要知道实际产出的具体产品是什么。这样一来，客户就从具体的产品中被解耦。</p>
<h3 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h3><p><img src="https://s2.loli.net/2022/03/22/2yvcI3WiDeaGPEr.png" alt="image-20220322205149761"></p>
<h3 id="抽象方法和工厂方法"><a href="#抽象方法和工厂方法" class="headerlink" title="抽象方法和工厂方法"></a>抽象方法和工厂方法</h3><p>抽象工厂的方法经常以工厂方法的方式实现。</p>
<p>抽象工厂的任务是定义一个负责创建一组产品的接口，这个接口内的每个方法都负责创建一个具体的产品，同时我们利用实现抽象工厂的子类来提供这些具体的做法。</p>
<p><strong>工厂方法，使用继承。</strong>要利用它创建对象，需要拓展一个类，并覆盖它的工厂方法。整个工厂方法模式，只不过就是通过子类来创建对象。</p>
<p><strong>抽象工厂，使用对象组合。</strong>要利用它，必须先实例化它，然后将它传入一些针对抽象类型所写的代码中。</p>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><ul>
<li>所有的工厂都是用来封装对象的创建。</li>
<li>简单工厂，虽然不是个真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类中解耦。</li>
<li>工厂方法使用继承，把对象的创建委托给子类，子类实现工厂方法并创建对象。</li>
<li>抽象工厂使用对象组合，对象的创建被实现在工厂接口所暴露出来的方法中。</li>
<li>依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象。</li>
</ul>
<h1 id="Chapter-5-单件模式"><a href="#Chapter-5-单件模式" class="headerlink" title="Chapter 5 单件模式"></a>Chapter 5 单件模式</h1><p>用来创建独一无二的、只能有一个实例的对象。</p>
<h2 id="1-经典的单件模式"><a href="#1-经典的单件模式" class="headerlink" title="1. 经典的单件模式"></a>1. 经典的单件模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="comment">// 私有构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       	<span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="延迟实例化"><a href="#延迟实例化" class="headerlink" title="延迟实例化"></a>延迟实例化</h3><p>如果uniqueInstance是空的，表示还没有创建实例，则此时利用私有的构造器产生一个Singleton实例并把它赋值到uniqueInstance静态变量中。请注意，如果我们不需要这个实例，它就永远不会产生。这就是”延迟实例化(lazy instantiaze)”。</p>
<p>利用单件模式，可以保证程序中使用的全局资源只有一份。</p>
<p>没有公开的构造器，所以要取得实例，必须”请求”得到，而无法自行实例化。调用静态方法getInstance得到的实例，可能是这次调用被创建的，也可能很早就被创建出来了。</p>
<h2 id="2-巧克力工厂"><a href="#2-巧克力工厂" class="headerlink" title="2. 巧克力工厂"></a>2. 巧克力工厂</h2><h3 id="1-定义单件模式"><a href="#1-定义单件模式" class="headerlink" title="1. 定义单件模式"></a>1. 定义单件模式</h3><p>单件模式确保一个类只有一个实例，并提供一个全局访问点。</p>
<h3 id="2-类图"><a href="#2-类图" class="headerlink" title="2. 类图"></a>2. 类图</h3><p><img src="https://s2.loli.net/2022/03/28/8ZnMvr7zhoUQDwP.png" alt="image-20220328210822172"></p>
<h3 id="3-多线程时？"><a href="#3-多线程时？" class="headerlink" title="3. 多线程时？"></a>3. 多线程时？</h3><p>针对巧克力工厂，可能产生两个锅炉对象。</p>
<h3 id="4-处理多线程"><a href="#4-处理多线程" class="headerlink" title="4. 处理多线程"></a>4. 处理多线程</h3><p>把getInstance()变成同步(synchronized)方法，就可以解决多线程的灾难。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 迫使每个线程进入这个方法之前，要先等候别的线程离开，即不会有两个线程可以同时进入该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，只有第一次执行这个方法时，才真正需要同步。一旦设置好uniqueInstance变量，就不再需要同步这个方法了，否则，会影响性能。</p>
<h3 id="5-改善多线程"><a href="#5-改善多线程" class="headerlink" title="5. 改善多线程"></a>5. 改善多线程</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p><strong>如果getInstance( )的性能对应用程序不是很关键，就什么也别做</strong></p>
<p>如果应用程序可以接受造成的性能下降，就别管啦，因为这样同步简单又有效。</p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p><strong>使用”急切”创建实例，而不用延迟实例化的做法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 在静态初始化器中，创建单件，保证了线程安全。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">uniqueInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用这个做法，依赖JVM在加载这个类时马上创建此唯一的单件实例。</p>
<p><strong>JVM保证在任何线程访问uniqueInstance静态变量之前，一定先创建此实例。</strong></p>
<h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>用”双重检查加锁”，在getInstance( )中减少使用同步</p>
<p>利用双重检查加锁(double-checked locking)，首先检查是否实例已经创建了，如果尚未创建，才进行同步。这样一来，只有第一次会同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 检查实例，如果不存在，就进入同步区块，只有第一次才执行这些</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 进入后，再检查一次</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>volatile关键字确保，当uniqueInstance变量被初始化成Singleton实例时，多个线程正在正确地处理uniqueInstance变量。</p>
<h4 id="一些对比"><a href="#一些对比" class="headerlink" title="一些对比"></a>一些对比</h4><p><img src="https://s2.loli.net/2022/03/28/Zo1NaJWXHiqrksQ.png" alt="image-20220328213902078"></p>
<h3 id="6-全局变量和单件模式"><a href="#6-全局变量和单件模式" class="headerlink" title="6. 全局变量和单件模式"></a>6. 全局变量和单件模式</h3><p>在Java中，全局变量基本上就是对对象的静态引用。全局变量可以提供全局访问，但是不能确保只有一个实例。</p>
<p>单件模式的目的：确保类只有一个实例并提供全局访问。</p>
<h3 id="7-注意"><a href="#7-注意" class="headerlink" title="7. 注意"></a>7. 注意</h3><p>在Java中实现单件模式需要私有的构造器，一个静态方法和一个静态变量。</p>
<p>确定在性能和资源上的限制，然后小心地选择适当的方案来实现单件，以解决多线程的问题。</p>
<p>如果类使用多个类加载器，可能回到会导致单件失效而产生多个实例。</p>
<h1 id="Chapter-6-命令模式"><a href="#Chapter-6-命令模式" class="headerlink" title="Chapter 6 命令模式"></a>Chapter 6 命令模式</h1><p>把方法调用封装起来。</p>
<p>命令模式可将”动作的请求者”从”动作的执行者”对象中解耦。</p>
<h2 id="1-遥控器"><a href="#1-遥控器" class="headerlink" title="1. 遥控器"></a>1. 遥控器</h2><p>创建一组控制遥控器的API，让每个插槽都能够控制一个或一组装置。</p>
<p>利用命令对象，将请求封装成一个特定对象，让每个按钮都存储一个命令对象。遥控器不需要知道工作内容是什么，只要有个命令对象能和正确的对象沟通，把事情做好即可。</p>
<h3 id="1-对象村餐厅"><a href="#1-对象村餐厅" class="headerlink" title="1. 对象村餐厅"></a>1. 对象村餐厅</h3><p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220404171644535.png" alt="image-20220404171644535"></p>
<p>通过订单，可以实现女招待和厨师之间解耦。</p>
<p>同样地，也可以分隔开”发出请求的按钮代码”和”执行请求的厂商特定对象”。也就是说，遥控器不需要知道事情是怎么发生的，也不需要知道涉及哪些对象。</p>
<h3 id="2-从餐厅到命令模式"><a href="#2-从餐厅到命令模式" class="headerlink" title="2. 从餐厅到命令模式"></a>2. 从餐厅到命令模式</h3><h4 id="对应关系"><a href="#对应关系" class="headerlink" title="对应关系"></a>对应关系</h4><p><img src="https://s2.loli.net/2022/04/04/Wqmjgf9uP57BKwc.png" alt="image-20220404172017022"></p>
<h4 id="转化类图"><a href="#转化类图" class="headerlink" title="转化类图"></a>转化类图</h4><p><img src="https://s2.loli.net/2022/04/04/yZkxjElUdpo1hgG.png" alt="image-20220404171958001"></p>
<h3 id="3-第一个命令对象"><a href="#3-第一个命令对象" class="headerlink" title="3. 第一个命令对象"></a>3. 第一个命令对象</h3><h4 id="1-实现命令接口"><a href="#1-实现命令接口" class="headerlink" title="1. 实现命令接口"></a>1. 实现命令接口</h4><p>首先，让所有的命令对象实现相同的包含一个方法的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-打开电灯"><a href="#2-打开电灯" class="headerlink" title="2. 打开电灯"></a>2. 打开电灯</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightOnCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    Light light;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightOnCommand</span><span class="params">(Light light)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-使用命令对象"><a href="#3-使用命令对象" class="headerlink" title="3. 使用命令对象"></a>3. 使用命令对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRemoteControl</span> &#123;</span><br><span class="line">    Command slot;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRemoteControl</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buttonWasPressed</span><span class="params">()</span> &#123;</span><br><span class="line">        slot.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-遥控器的简单测试"><a href="#4-遥控器的简单测试" class="headerlink" title="4. 遥控器的简单测试"></a>4. 遥控器的简单测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteControlTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleRemoteControl</span> <span class="variable">remote</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRemoteControl</span>();</span><br><span class="line">        <span class="type">Light</span> <span class="variable">light</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">        <span class="comment">// 创建一个命令对象，将接收者传递给他</span></span><br><span class="line">        <span class="type">LightOnCommand</span> <span class="variable">lightOn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightOnCommand</span>(light);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将命令传递给调用者对象</span></span><br><span class="line">        remote.setCommand(lightOn);</span><br><span class="line">        remote.buttonWasPressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-命令模式"><a href="#2-命令模式" class="headerlink" title="2. 命令模式"></a>2. 命令模式</h2><h3 id="1-定义命令模式"><a href="#1-定义命令模式" class="headerlink" title="1. 定义命令模式"></a>1. 定义命令模式</h3><p>命令模式将”请求”封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。命令模式也支持可撤销的操作。</p>
<p>一个命令对象通过在特定接收者上绑定一组动作来封装一个请求。这个命令对象那个只暴露出一个execute()方法。当这个方法被调用时，接收者就会进行者一组动作。从外面来看，其他对象不知道究竟哪个接收者进行了哪些动作，只知道如果调用execute()方法，请求的目的就能达到。</p>
<h3 id="2-类图-1"><a href="#2-类图-1" class="headerlink" title="2. 类图"></a>2. 类图</h3><p><img src="https://s2.loli.net/2022/04/04/awspj8R5EzVnTIP.png" alt="image-20220404175347921"></p>
<h3 id="3-NoCommand"><a href="#3-NoCommand" class="headerlink" title="3. NoCommand"></a>3. NoCommand</h3><p>在遥控器中，为避免每次都检查是否某个插槽都加载了命令，可以实现一个不做事情的命令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么一来，在RemoteControl构造器中，将每个插槽都预先指定成NoCommand对象，以便确定每个插槽永远都有命令对象。</p>
<p>之后在测试中，没有被明确指定命令的插槽，其命令将是默认的NoCommand对象。</p>
<p><img src="https://s2.loli.net/2022/04/04/14kIgNFy9SDxU2M.png" alt="image-20220404175818437"></p>
<h3 id="4-撤销？"><a href="#4-撤销？" class="headerlink" title="4. 撤销？"></a>4. 撤销？</h3><p>当命令支持撤销时，该命令就必须提供和execute( )方法相反的undo( )方法。不管execute( )做什么，undo( )都会倒转回来。</p>
<h4 id="更新遥控器"><a href="#更新遥控器" class="headerlink" title="更新遥控器"></a>更新遥控器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteControlWithUndo</span> &#123;</span><br><span class="line">    Command[] onCommands;</span><br><span class="line">    Command[] offCommands;</span><br><span class="line">    <span class="comment">// 记录前一个命令</span></span><br><span class="line">    Command undoCommand;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteControlWithUndo</span><span class="params">()</span> &#123;</span><br><span class="line">        onCommands = <span class="keyword">new</span> <span class="title class_">Command</span>[<span class="number">7</span>];</span><br><span class="line">        offCommands = <span class="keyword">new</span> <span class="title class_">Command</span>[<span class="number">7</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="type">Command</span> <span class="variable">noCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NoCommand</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            onCommands[i] = noCommand;</span><br><span class="line">            offCommands[i] = noCommand;</span><br><span class="line">        &#125;</span><br><span class="line">        undoCommand = noCommand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(<span class="type">int</span> slot, Command onCommand, Command offCommand)</span> &#123;</span><br><span class="line">        onCommand[slot] = onCommand;</span><br><span class="line">        offCommand[slot] = offCommand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onButtonWasPushed</span><span class="params">(<span class="type">int</span> slot)</span> &#123;</span><br><span class="line">        onCommands[slot].execute();</span><br><span class="line">        undoCommand = onCommands[slot];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offButtonWasPushed</span><span class="params">(<span class="type">int</span> slot)</span> &#123;</span><br><span class="line">        offCommands[slot].execute();</span><br><span class="line">        undoCommand = offCommands[slot];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undoButtonWasPushed</span><span class="params">()</span> &#123;</span><br><span class="line">        undoCommand.undo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常，想要实现撤销的功能，需要记录一些状态。</p>
<h3 id="5-宏命令"><a href="#5-宏命令" class="headerlink" title="5. 宏命令"></a>5. 宏命令</h3><p>如果拥有了一个遥控器，却无法光凭按下一个按钮，就同时能打开灯、打开音响和电视、设置好DVD，并让热水器开始加温，那么要这个遥控器还有什么意义？</p>
<p><img src="https://s2.loli.net/2022/04/04/tYByPrkU3uh2DHn.png" alt="image-20220404181236293"></p>
<h3 id="6-Q-amp-A"><a href="#6-Q-amp-A" class="headerlink" title="6. Q&amp;A"></a>6. Q&amp;A</h3><h4 id="“聪明”命令对象"><a href="#“聪明”命令对象" class="headerlink" title="“聪明”命令对象?"></a>“聪明”命令对象?</h4><p>一般来说，尽量设置”傻瓜”命令对象，它只懂得调用一个接收者的一个行为。</p>
<p>然而，偶尔会有”聪明”命令对象会实现许多逻辑，直接完成一个请求。但是这样，调用者和接收者之间的解耦程度，是比不上”傻瓜”命令对象的。</p>
<h4 id="单独创建Party-Command？"><a href="#单独创建Party-Command？" class="headerlink" title="单独创建Party-Command？"></a>单独创建Party-Command？</h4><p>使用宏命令，可以动态决定PartyCommand是由哪些命令组成，所以使用更灵活，也不需要更多的新代码。</p>
<h3 id="7-拓展"><a href="#7-拓展" class="headerlink" title="7. 拓展"></a>7. 拓展</h3><h4 id="队列请求"><a href="#队列请求" class="headerlink" title="队列请求"></a>队列请求</h4><p><img src="https://s2.loli.net/2022/04/04/7h5e8Mndit2j9rN.png" alt="image-20220404182035550"></p>
<h4 id="日志请求"><a href="#日志请求" class="headerlink" title="日志请求"></a>日志请求</h4><p>新增store()和load()两个方法，命令被执行时，store()到磁盘中；系统死机后，重新load()</p>
<p><img src="https://s2.loli.net/2022/04/04/TUan9xObQZ6vSCf.png" alt="image-20220404182059425"></p>
<h1 id="Chapter-7-适配器模式与外观模式"><a href="#Chapter-7-适配器模式与外观模式" class="headerlink" title="Chapter 7 适配器模式与外观模式"></a>Chapter 7 适配器模式与外观模式</h1><p>适配器位于美式插头和欧式插头的中间，将欧式插座转换为美式插座，好让美式插头可以插进这个插座得到电力。</p>
<h2 id="1-面向对象适配器"><a href="#1-面向对象适配器" class="headerlink" title="1. 面向对象适配器"></a>1. 面向对象适配器</h2><p><img src="https://s2.loli.net/2022/04/08/DJrEgiXMTyH4S7C.png" alt="image-20220408165315066"></p>
<p> 引入适配器后：</p>
<p><img src="https://s2.loli.net/2022/04/08/UuqOtYbzhLIn4N8.png" alt="image-20220408165416051"></p>
<h2 id="2-火鸡冒充鸭子？"><a href="#2-火鸡冒充鸭子？" class="headerlink" title="2. 火鸡冒充鸭子？"></a>2. 火鸡冒充鸭子？</h2><h3 id="1-火鸡和鸭子接口"><a href="#1-火鸡和鸭子接口" class="headerlink" title="1. 火鸡和鸭子接口"></a>1. 火鸡和鸭子接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quark</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Turkey</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显而易见，因为火鸡和鸭子的接口不同，所以不能直接使用。</p>
<h3 id="2-火鸡转换器"><a href="#2-火鸡转换器" class="headerlink" title="2. 火鸡转换器"></a>2. 火鸡转换器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要实现目标接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="comment">// 接着要获得被适配者的实例</span></span><br><span class="line">    Turkey turkey;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TurkeyAdapter</span><span class="params">(Turkey turkey)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quark</span><span class="params">()</span> &#123;</span><br><span class="line">        turkey.gobble();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 火鸡飞行距离短，故而设置为火鸡飞5次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            turkey.fly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-适配器模式解析"><a href="#3-适配器模式解析" class="headerlink" title="3. 适配器模式解析"></a>3. 适配器模式解析</h3><p>适配器实现了目标接口，并持有被适配者的实例。</p>
<h4 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h4><ol>
<li>客户通过目标接口调用适配器的方法对适配器发出请求。</li>
<li>适配器使用被适配者接口把请求转换为被适配者的一个或多个调用接口。</li>
<li>客户接受到调用的结果，但并未察觉这一切是适配器在起转换作用。</li>
</ol>
<p>实现一个适配器所需要进行的工作，和一个目标接口的大小成正比。</p>
<h2 id="3-适配者模式"><a href="#3-适配者模式" class="headerlink" title="3. 适配者模式"></a>3. 适配者模式</h2><h3 id="1-定义适配者模式"><a href="#1-定义适配者模式" class="headerlink" title="1. 定义适配者模式"></a>1. 定义适配者模式</h3><p>适配者模式将一个类的接口，转换成客户期望的另一个接口，让原本接口不兼容的类可以合作无间。</p>
<p>这个模式可以通过创建适配器进行接口转换，让不兼容的接口变成兼容。这可以让客户从实现的接口解耦。</p>
<h3 id="2-类图-2"><a href="#2-类图-2" class="headerlink" title="2.类图"></a>2.类图</h3><p><img src="https://s2.loli.net/2022/04/08/WqynBrgfNE9VAp7.png" alt="image-20220408171641489"></p>
<p>把客户和接口绑定起来，而不是和实现绑定起来。</p>
<h3 id="3-对象和类的适配器"><a href="#3-对象和类的适配器" class="headerlink" title="3. 对象和类的适配器"></a>3. 对象和类的适配器</h3><p>上述类图是对象的适配器。</p>
<p>而关于类的适配器，需要多重继承，这对于Java而言，显然是无法实现的。</p>
<p><img src="https://s2.loli.net/2022/04/08/9gO2QpiMrWhk1Ry.png" alt="image-20220408171918792"></p>
<h4 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h4><p>对象适配器利用组合的方式将请求传送给被适配者。</p>
<p>类适配器不需要重新实现整个被适配者。</p>
<h3 id="4-真实世界的适配器"><a href="#4-真实世界的适配器" class="headerlink" title="4. 真实世界的适配器"></a>4. 真实世界的适配器</h3><h4 id="旧世界的枚举器"><a href="#旧世界的枚举器" class="headerlink" title="旧世界的枚举器"></a>旧世界的枚举器</h4><p>Java中早期的集合(collection)类型都实现了一个elements( )的方法。这个方法会返回一个Enumeration接口，它可以逐一走过此集合内的每个元素，而无需知道他们在集合内是如何被管理的。</p>
<p><img src="https://s2.loli.net/2022/04/08/QCzFu13GZU5vlkc.png" alt="image-20220408172828769"></p>
<h4 id="新世界的迭代器"><a href="#新世界的迭代器" class="headerlink" title="新世界的迭代器"></a>新世界的迭代器</h4><p>更新后的集合类，开始使用Iterator(迭代器)接口，与枚举接口不同的是，迭代器提供了删除元素的能力。</p>
<p><img src="https://s2.loli.net/2022/04/08/OzjBW3ivDxQmYSG.png" alt="image-20220408173009124"></p>
<h4 id="将枚举适配到迭代器"><a href="#将枚举适配到迭代器" class="headerlink" title="将枚举适配到迭代器"></a>将枚举适配到迭代器</h4><p><img src="https://s2.loli.net/2022/04/08/lEYOxtyJ8SPnZCd.png" alt="image-20220408173125362"></p>
<p>关于remove方法</p>
<p>枚举不支持删除，因为枚举是一个”只读”接口。</p>
<p>适配器无法实现一个有实际功能的remove()方法，最多只能抛出一个运行时异常。</p>
<p>而迭代器接口的设计者事先料到了这样的需求，所以将remove()方法定义成会抛出UnsupportedOperationException。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumerationIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    Enumeration enums;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EnumerationIterator</span><span class="params">(Enumeration enums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.enums = enums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> enums.hasMoreElements();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> enums.nextElement();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperatorException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-家庭影院"><a href="#4-家庭影院" class="headerlink" title="4. 家庭影院"></a>4. 家庭影院</h2><h3 id="1-播放电影"><a href="#1-播放电影" class="headerlink" title="1. 播放电影"></a>1. 播放电影</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>建造家庭影院后，想看电影，必须经过的步骤：</p>
<p><img src="https://s2.loli.net/2022/04/08/OH3nKzXefbNq9FJ.png" alt="image-20220408174025443"></p>
<h4 id="对应方法"><a href="#对应方法" class="headerlink" title="对应方法"></a>对应方法</h4><p><img src="https://s2.loli.net/2022/04/08/LomzuD6baBrcplZ.png" alt="image-20220408174155588"></p>
<h3 id="2-构建外观"><a href="#2-构建外观" class="headerlink" title="2. 构建外观"></a>2. 构建外观</h3><p>创建一个外观类，将家庭影院的诸多组件视为一个子系统，通过调用这个子系统，来实现watchMovie()方法。</p>
<p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220408174434535.png" alt="image-20220408174434535"></p>
<p>当然，外观只是提供更直接的操作，并未将原来的子系统阻隔起来。</p>
<h3 id="3-观赏电影"><a href="#3-观赏电影" class="headerlink" title="3. 观赏电影"></a>3. 观赏电影</h3><p><img src="https://s2.loli.net/2022/04/08/AOkrG6PjDxEobKy.png" alt="image-20220408174919643"></p>
<h2 id="5-外观模式"><a href="#5-外观模式" class="headerlink" title="5. 外观模式"></a>5. 外观模式</h2><h3 id="1-定义外观模式"><a href="#1-定义外观模式" class="headerlink" title="1. 定义外观模式"></a>1. 定义外观模式</h3><p>外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p>
<h3 id="2-类图-3"><a href="#2-类图-3" class="headerlink" title="2. 类图"></a>2. 类图</h3><p><img src="https://s2.loli.net/2022/04/08/EFrqxAj7HuDloc8.png" alt="image-20220408175117688"></p>
<h3 id="3-外观-amp-外观VS适配器"><a href="#3-外观-amp-外观VS适配器" class="headerlink" title="3. 外观 &amp; 外观VS适配器"></a>3. 外观 &amp; 外观VS适配器</h3><h4 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h4><p>外观没有”封装”子系统的类，外观只提供简化的接口。</p>
<p>这也是外观的特征之一：在提供简化的接口的同时，依然将系统完整的功能暴露出来，以供需要的人使用。</p>
<p>也就是说，外观不只是简化了接口，也将客户从组件的子系统中解耦。</p>
<p>一个子系统可以有多个外观。</p>
<h4 id="根本区别"><a href="#根本区别" class="headerlink" title="根本区别"></a>根本区别</h4><p>外观和适配器的根本区别在于，外观的意图是简化接口，而适配器的意图是转换接口。</p>
<h2 id="6-第七个设计原则"><a href="#6-第七个设计原则" class="headerlink" title="6. 第七个设计原则"></a>6. 第七个设计原则</h2><p>“最少知识”原则</p>
<p>最少知识原则：只和你的密友交谈。</p>
<h3 id="what？"><a href="#what？" class="headerlink" title="what？"></a>what？</h3><p>要减少对象之间的交互，只留下几个”密友”。</p>
<p>在设计中，不要让太多的类耦合在一起，免得修改系统中的一部分，会影响到其他部分。</p>
<h3 id="how？"><a href="#how？" class="headerlink" title="how？"></a>how？</h3><p>只允许调用下列对象的方法：</p>
<ul>
<li>该对象本身</li>
<li>被当作方法的参数而传递进来的对象</li>
<li>此方法创建或实例化的对象</li>
<li>对象的任何组件</li>
</ul>
<p>前三者说明了，如果某对象是调用其他的方法的返回结果，不要调用该对象的方法。</p>
<p><img src="https://s2.loli.net/2022/04/08/dThQFIgYLz9pev2.png" alt="image-20220408175555380"></p>
<h3 id="汽车类"><a href="#汽车类" class="headerlink" title="汽车类"></a>汽车类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="comment">// 是类的一个组件，可以调用它的方法</span></span><br><span class="line">    Engine engine;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Key key)</span> &#123;</span><br><span class="line">        <span class="comment">// 此处创建了一个对象，可以调用它的方法</span></span><br><span class="line">        <span class="type">Doors</span> <span class="variable">doors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Doors</span>();</span><br><span class="line">        <span class="comment">// key作为方法参数传进来的对象，可以调用方法</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">authorized</span> <span class="operator">=</span> key.turns();</span><br><span class="line">        <span class="keyword">if</span> (authorized) &#123;</span><br><span class="line">            <span class="comment">// 调用对象组件的方法</span></span><br><span class="line">            engine.start();</span><br><span class="line">            <span class="comment">// 调用同一个对象内的本地方法</span></span><br><span class="line">            updateDashboardDisplay();</span><br><span class="line">            <span class="comment">// 调用所创建或实例化的对象的方法</span></span><br><span class="line">            doors.lock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateDashboardDisplay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 更新展示</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然了，所有的原则，都应该在有帮助的时候才遵守。</p>
<p>采用最少知识原则，会导致更多的包装类被制造出来，以处理和其他组件的沟通，这会导致复杂度和开发时间的增加，降低性能。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行。</p>
<h3 id="一些对比-1"><a href="#一些对比-1" class="headerlink" title="一些对比"></a>一些对比</h3><p>适配器将一个对象包装起来，以改变其接口；</p>
<p>装饰者将一个对象包装起来，以增加新的行为和责任；</p>
<p>外观将一群对象”包装”起来，以简化其接口。</p>
<h1 id="Chapter-8-模板方法"><a href="#Chapter-8-模板方法" class="headerlink" title="Chapter 8 模板方法"></a>Chapter 8 模板方法</h1><h2 id="1-咖啡和茶"><a href="#1-咖啡和茶" class="headerlink" title="1. 咖啡和茶"></a>1. 咖啡和茶</h2><h3 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h3><p><img src="https://s2.loli.net/2022/04/12/X5dkPh89ey2KIs4.png" alt="image-20220412163629309"></p>
<h3 id="抽取共同点"><a href="#抽取共同点" class="headerlink" title="抽取共同点"></a>抽取共同点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CaffeineBeverage</span> &#123;</span><br><span class="line">    <span class="comment">// 此处final表明，不希望子类覆盖这个方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">prepareRecipe</span><span class="params">()</span> &#123;</span><br><span class="line">        boliWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">boilWater</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Boiling water&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pourInCup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Pouring into cup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则，咖啡和茶类各自实现即可。</p>
<h3 id="认识模板方法"><a href="#认识模板方法" class="headerlink" title="认识模板方法"></a>认识模板方法</h3><p><img src="https://s2.loli.net/2022/04/12/Abs4DzBupax7SHo.png" alt="image-20220412195823972"></p>
<h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><ol>
<li>它是一个方法</li>
<li>它用作一个算法(制作饮料)的模板</li>
</ol>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>在该模板中，算法内的每一个步骤都被一个方法代替了。</p>
<p>必须要由子类实现的步骤，要声明为abstract。</p>
<p>模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。</p>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><h3 id="定义模板方法模式"><a href="#定义模板方法模式" class="headerlink" title="定义模板方法模式"></a>定义模板方法模式</h3><p>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。</p>
<p>模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤(即提供具体实现)。</p>
<h3 id="类图-4"><a href="#类图-4" class="headerlink" title="类图"></a>类图</h3><p><img src="https://s2.loli.net/2022/04/12/7bt2yQdqrsANmxT.png" alt="image-20220412200553658"></p>
<h3 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h3><p>钩子是一种被声明在抽象类中的方法，但只有空的和默认的实现。子类可以选择是否实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CaffeineBeverage</span> &#123;</span><br><span class="line">    <span class="comment">// 此处final表明，不希望子类覆盖这个方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">prepareRecipe</span><span class="params">()</span> &#123;</span><br><span class="line">        boliWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="keyword">if</span> (customerWantsCondiments()) &#123;</span><br><span class="line">            addCondiments();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">boilWater</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Boiling water&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pourInCup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Pouring into cup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 钩子方法，通常是空的缺省实现。子类可以覆盖这个方法</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">customerWantsCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="when？"><a href="#when？" class="headerlink" title="when？"></a>when？</h4><p>当子类必须提供算法中某个方法或步骤的实现时，就是用抽象方法；</p>
<p>若算法的这个部分是可选的，就用钩子。子类可以选择实现或不实现。</p>
<h2 id="第八个设计原则"><a href="#第八个设计原则" class="headerlink" title="第八个设计原则"></a>第八个设计原则</h2><p>好莱坞原则</p>
<p>别调用我们，我们会调用你。</p>
<h3 id="why？"><a href="#why？" class="headerlink" title="why？"></a>why？</h3><p>可以防止”依赖腐败”，即高层组件依赖底层组件，低层组件又依赖高层组件。</p>
<p>允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些组件。也就是说，高层组件对低层组件的方式：”别调用我们，我们会调用你”。</p>
<h3 id="how？-1"><a href="#how？-1" class="headerlink" title="how？"></a>how？</h3><p><img src="https://s2.loli.net/2022/04/12/fFJ8ibZmQx95VwN.png" alt="image-20220412201824940"></p>
<h3 id="和模板方法"><a href="#和模板方法" class="headerlink" title="和模板方法"></a>和模板方法</h3><p>当设计模板方法模式时，就告诉子类，”别调用我们，我们会调用你”。</p>
<p><img src="https://s2.loli.net/2022/04/12/pjg7atbXJ5I1VFk.png" alt="image-20220412202111601"></p>
<h3 id="和依赖倒置原则"><a href="#和依赖倒置原则" class="headerlink" title="和依赖倒置原则"></a>和依赖倒置原则</h3><p>依赖倒置原则教我们尽量减少使用具体类，而多使用抽象，即注重在设计中避免依赖</p>
<p>好莱坞原则则是用在创建框架或组件的一种技巧，好让低层组件能被挂钩进计算中，而且又不会让高层组件依赖低层组件。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>允许底层操作能够互相操作，而又防止其他类太过依赖他们</p>
<p>根本目的是避免高层和底层之间明显的环状依赖。</p>
<h2 id="Java中的模板方法"><a href="#Java中的模板方法" class="headerlink" title="Java中的模板方法"></a>Java中的模板方法</h2><p><img src="https://s2.loli.net/2022/04/12/Ij13v4gPER7iZBJ.png" alt="image-20220412202921775"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>模板方法模式定义了一个算法的大纲，而由子类确定具体的实现某些步骤的内容。</p>
<p> 策略模式定义一个算法家族，并让这些算法可以互换。正因为每一个算法都被封装起来，所以客户可以轻易地使用不同的算法。</p>
</li>
<li><p>策略模式和模板方法模式都封装算法，一个使用组合，一个用继承。</p>
</li>
<li><p>工厂方法是模板方法的一个特殊版本。</p>
</li>
</ol>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">Chapter 1 设计模式入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.</span> <span class="toc-text">1. 第一个设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.2.</span> <span class="toc-text">2. 第二个设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%AE%BE%E5%AE%9A%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">动态设定行为</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AC%AC%E4%B8%89%E4%B8%AA%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.3.</span> <span class="toc-text">3. 第三个设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9C%E6%9C%89%E4%B8%80%E4%B8%AA%E2%80%9D%E5%8F%AF%E8%83%BD%E6%AF%94%E2%80%9D%E6%98%AF%E4%B8%80%E4%B8%AA%E2%80%9D%E6%9B%B4%E5%A5%BD"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">“有一个”可能比”是一个”更好</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">4. 策略模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-tips"><span class="toc-number">1.5.</span> <span class="toc-text">5. tips</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OO%E5%9F%BA%E7%A1%80"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">OO基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OO%E5%8E%9F%E5%88%99"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">OO原则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%80%BB%E7%BB%93%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">6. 总结过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%87%BA%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.1.</span> <span class="toc-text">提出问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA"><span class="toc-number">1.6.2.</span> <span class="toc-text">代码展示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2-%E8%A7%82%E5%AF%9F%E8%80%85-Observer-%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">Chapter 2 观察者(Observer)模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">1. 定义观察者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9D%BE%E8%80%A6%E5%90%88"><span class="toc-number">2.2.</span> <span class="toc-text">2. 松耦合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.2.1.</span> <span class="toc-text">原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AC%AC%E5%9B%9B%E4%B8%AA%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">2.3.</span> <span class="toc-text">3. 第四个设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%B0%94%E8%B1%A1%E7%AB%99"><span class="toc-number">2.4.</span> <span class="toc-text">4. 气象站</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9B%BE"><span class="toc-number">2.4.1.</span> <span class="toc-text">类图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA-1"><span class="toc-number">2.4.2.</span> <span class="toc-text">代码展示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Java%E5%86%85%E7%BD%AE%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.</span> <span class="toc-text">5. Java内置的观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E7%B1%BB%E5%9B%BE"><span class="toc-number">2.5.1.</span> <span class="toc-text">1. 修改后的类图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8A%8A%E5%AF%B9%E8%B1%A1%E5%8F%98%E4%B8%BA%E8%A7%82%E5%AF%9F%E8%80%85"><span class="toc-number">2.5.1.1.</span> <span class="toc-text">1. 把对象变为观察者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A7%82%E5%AF%9F%E8%80%85%E9%80%81%E5%87%BA%E9%80%9A%E7%9F%A5"><span class="toc-number">2.5.1.2.</span> <span class="toc-text">2. 观察者送出通知</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%A7%82%E5%AF%9F%E8%80%85%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">2.5.1.3.</span> <span class="toc-text">3. 观察者接收数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%85%B3%E4%BA%8EsetChanged"><span class="toc-number">2.5.1.4.</span> <span class="toc-text">4. 关于setChanged</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-java-util-Observable"><span class="toc-number">2.5.2.</span> <span class="toc-text">2. java.util.Observable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Observable%E6%98%AF%E4%B8%80%E4%B8%AA%E7%B1%BB"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">Observable是一个类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.5.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-3-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">Chapter 3 装饰者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AC%AC%E4%BA%94%E4%B8%AA%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">3.1.</span> <span class="toc-text">1. 第五个设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tips"><span class="toc-number">3.1.1.</span> <span class="toc-text">tips</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">2. 装饰者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">3.2.2.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%A4%BA"><span class="toc-number">3.2.3.</span> <span class="toc-text">图示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9B%9E%E5%88%B0%E6%98%9F%E5%B7%B4%E5%85%B9"><span class="toc-number">3.3.</span> <span class="toc-text">3. 回到星巴兹</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB%E5%9B%BE"><span class="toc-number">3.3.1.</span> <span class="toc-text">1. 类图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84cost"><span class="toc-number">3.3.2.</span> <span class="toc-text">2. 装饰者模式下的cost</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">3.3.3.</span> <span class="toc-text">3. 继承？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81"><span class="toc-number">3.3.4.</span> <span class="toc-text">4. 代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-others"><span class="toc-number">3.3.5.</span> <span class="toc-text">5. others</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Java-I-O"><span class="toc-number">3.4.</span> <span class="toc-text">4. Java I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9B%BE-1"><span class="toc-number">3.4.1.</span> <span class="toc-text">类图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%A6%81%E7%82%B9"><span class="toc-number">3.5.</span> <span class="toc-text">5. 要点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-4-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">Chapter 4 工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%B0%88%E8%B0%88new"><span class="toc-number">4.1.</span> <span class="toc-text">1. 谈谈new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E6%9D%91%E6%AF%94%E8%90%A8%E5%BA%97"><span class="toc-number">4.2.</span> <span class="toc-text">2. 对象村比萨店</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%80%E5%BC%A0"><span class="toc-number">4.2.1.</span> <span class="toc-text">1. 开张</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%96%B0%E5%A2%9E%E6%AF%94%E8%90%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.2.</span> <span class="toc-text">2. 新增比萨类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B0%81%E8%A3%85%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">4.2.3.</span> <span class="toc-text">3. 封装创建对象的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B7%A5%E5%8E%82"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">1. 工厂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%AF%94%E8%90%A8%E5%B7%A5%E5%8E%82"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">2. 建立一个简单的比萨工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%EF%BC%9F"><span class="toc-number">4.2.3.2.1.</span> <span class="toc-text">静态？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%AD%A4%E6%97%B6%E7%9A%84PizzaStore"><span class="toc-number">4.2.3.3.</span> <span class="toc-text">3. 此时的PizzaStore</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82"><span class="toc-number">4.2.4.</span> <span class="toc-text">4. 定义简单工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9B%BE-2"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">类图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%8F%90%E9%86%92"><span class="toc-number">4.2.5.</span> <span class="toc-text">重要提醒</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8A%A0%E7%9B%9F%E6%AF%94%E8%90%A8%E5%BA%97"><span class="toc-number">4.3.</span> <span class="toc-text">3. 加盟比萨店</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%81%E8%AE%B8%E5%AD%90%E7%B1%BB%E5%81%9A%E5%86%B3%E5%AE%9A"><span class="toc-number">4.3.1.</span> <span class="toc-text">1. 允许子类做决定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E5%81%9A%E5%86%B3%E5%AE%9A%EF%BC%9F"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">子类做决定？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%80%E5%AE%B6%E6%AF%94%E8%90%A8%E5%BA%97"><span class="toc-number">4.3.2.</span> <span class="toc-text">2. 开家比萨店</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">1. 声明一个工厂方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AE%A2%E8%B4%AD%E5%B7%A5%E5%BA%8F"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">2. 订购工序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text">4. 工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB%E5%9B%BE-1"><span class="toc-number">4.4.1.</span> <span class="toc-text">1. 类图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%80%85%E7%B1%BB"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">创建者类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A7%E5%93%81%E7%B1%BB"><span class="toc-number">4.4.1.2.</span> <span class="toc-text">产品类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B9%B3%E8%A1%8C%E7%9A%84%E7%B1%BB%E5%B1%82%E7%BA%A7"><span class="toc-number">4.4.2.</span> <span class="toc-text">2. 平行的类层级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.3.</span> <span class="toc-text">3. 定义工厂方法模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%89%B9%E7%82%B9"><span class="toc-number">4.4.4.</span> <span class="toc-text">4. 特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AC%AC%E5%85%AD%E4%B8%AA%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">4.5.</span> <span class="toc-text">5. 第六个设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%95%E8%B0%93%E5%80%92%E7%BD%AE"><span class="toc-number">4.5.1.</span> <span class="toc-text">1. 何谓倒置?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8C%87%E5%AF%BC%E6%96%B9%E9%92%88"><span class="toc-number">4.5.2.</span> <span class="toc-text">2. 指导方针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%9B%9E%E5%88%B0%E6%AF%94%E8%90%A8%E5%BA%97"><span class="toc-number">4.6.</span> <span class="toc-text">6. 回到比萨店</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BB%BA%E9%80%A0%E5%8E%9F%E6%96%99%E5%B7%A5%E5%8E%82"><span class="toc-number">4.6.1.</span> <span class="toc-text">1. 建造原料工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E7%BA%BD%E7%BA%A6%E5%B7%A5%E5%8E%82%E7%AD%89"><span class="toc-number">4.6.1.1.</span> <span class="toc-text">建造纽约工厂等</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%87%8D%E5%81%9A%E6%AF%94%E8%90%A8"><span class="toc-number">4.6.2.</span> <span class="toc-text">2. 重做比萨</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.6.3.</span> <span class="toc-text">3. 到底做了什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%A4%BA-1"><span class="toc-number">4.6.3.1.</span> <span class="toc-text">图示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.7.</span> <span class="toc-text">7. 抽象工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">4.7.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9B%BE-3"><span class="toc-number">4.7.2.</span> <span class="toc-text">类图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">4.7.3.</span> <span class="toc-text">抽象方法和工厂方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%80%BB%E7%BB%93"><span class="toc-number">4.8.</span> <span class="toc-text">8. 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-5-%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">Chapter 5 单件模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BB%8F%E5%85%B8%E7%9A%84%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">1. 经典的单件模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">5.1.1.</span> <span class="toc-text">延迟实例化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B7%A7%E5%85%8B%E5%8A%9B%E5%B7%A5%E5%8E%82"><span class="toc-number">5.2.</span> <span class="toc-text">2. 巧克力工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.1.</span> <span class="toc-text">1. 定义单件模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E5%9B%BE"><span class="toc-number">5.2.2.</span> <span class="toc-text">2. 类图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%97%B6%EF%BC%9F"><span class="toc-number">5.2.3.</span> <span class="toc-text">3. 多线程时？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%84%E7%90%86%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.2.4.</span> <span class="toc-text">4. 处理多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%94%B9%E5%96%84%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.2.5.</span> <span class="toc-text">5. 改善多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-number">5.2.5.1.</span> <span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-number">5.2.5.2.</span> <span class="toc-text">方法二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89"><span class="toc-number">5.2.5.3.</span> <span class="toc-text">方法三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%AF%B9%E6%AF%94"><span class="toc-number">5.2.5.4.</span> <span class="toc-text">一些对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.6.</span> <span class="toc-text">6. 全局变量和单件模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%B3%A8%E6%84%8F"><span class="toc-number">5.2.7.</span> <span class="toc-text">7. 注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-6-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">Chapter 6 命令模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%81%A5%E6%8E%A7%E5%99%A8"><span class="toc-number">6.1.</span> <span class="toc-text">1. 遥控器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%B9%E8%B1%A1%E6%9D%91%E9%A4%90%E5%8E%85"><span class="toc-number">6.1.1.</span> <span class="toc-text">1. 对象村餐厅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%8E%E9%A4%90%E5%8E%85%E5%88%B0%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.2.</span> <span class="toc-text">2. 从餐厅到命令模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">对应关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E5%8C%96%E7%B1%BB%E5%9B%BE"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">转化类图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.1.3.</span> <span class="toc-text">3. 第一个命令对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9E%E7%8E%B0%E5%91%BD%E4%BB%A4%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">1. 实现命令接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%89%93%E5%BC%80%E7%94%B5%E7%81%AF"><span class="toc-number">6.1.3.2.</span> <span class="toc-text">2. 打开电灯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.1.3.3.</span> <span class="toc-text">3. 使用命令对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%81%A5%E6%8E%A7%E5%99%A8%E7%9A%84%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">6.1.3.4.</span> <span class="toc-text">4. 遥控器的简单测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">2. 命令模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.1.</span> <span class="toc-text">1. 定义命令模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E5%9B%BE-1"><span class="toc-number">6.2.2.</span> <span class="toc-text">2. 类图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-NoCommand"><span class="toc-number">6.2.3.</span> <span class="toc-text">3. NoCommand</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%92%A4%E9%94%80%EF%BC%9F"><span class="toc-number">6.2.4.</span> <span class="toc-text">4. 撤销？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E9%81%A5%E6%8E%A7%E5%99%A8"><span class="toc-number">6.2.4.1.</span> <span class="toc-text">更新遥控器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AE%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">6.2.5.</span> <span class="toc-text">5. 宏命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Q-amp-A"><span class="toc-number">6.2.6.</span> <span class="toc-text">6. Q&amp;A</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9C%E8%81%AA%E6%98%8E%E2%80%9D%E5%91%BD%E4%BB%A4%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.2.6.1.</span> <span class="toc-text">“聪明”命令对象?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%8B%AC%E5%88%9B%E5%BB%BAParty-Command%EF%BC%9F"><span class="toc-number">6.2.6.2.</span> <span class="toc-text">单独创建Party-Command？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%8B%93%E5%B1%95"><span class="toc-number">6.2.7.</span> <span class="toc-text">7. 拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E8%AF%B7%E6%B1%82"><span class="toc-number">6.2.7.1.</span> <span class="toc-text">队列请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E8%AF%B7%E6%B1%82"><span class="toc-number">6.2.7.2.</span> <span class="toc-text">日志请求</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-7-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">Chapter 7 适配器模式与外观模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">7.1.</span> <span class="toc-text">1. 面向对象适配器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%81%AB%E9%B8%A1%E5%86%92%E5%85%85%E9%B8%AD%E5%AD%90%EF%BC%9F"><span class="toc-number">7.2.</span> <span class="toc-text">2. 火鸡冒充鸭子？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%81%AB%E9%B8%A1%E5%92%8C%E9%B8%AD%E5%AD%90%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.2.1.</span> <span class="toc-text">1. 火鸡和鸭子接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%81%AB%E9%B8%A1%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="toc-number">7.2.2.</span> <span class="toc-text">2. 火鸡转换器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90"><span class="toc-number">7.2.3.</span> <span class="toc-text">3. 适配器模式解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">7.2.3.1.</span> <span class="toc-text">调用过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%80%82%E9%85%8D%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.3.</span> <span class="toc-text">3. 适配者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E9%80%82%E9%85%8D%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.3.1.</span> <span class="toc-text">1. 定义适配者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E5%9B%BE-2"><span class="toc-number">7.3.2.</span> <span class="toc-text">2.类图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">7.3.3.</span> <span class="toc-text">3. 对象和类的适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E5%AF%B9%E6%AF%94"><span class="toc-number">7.3.3.1.</span> <span class="toc-text">二者对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">7.3.4.</span> <span class="toc-text">4. 真实世界的适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A7%E4%B8%96%E7%95%8C%E7%9A%84%E6%9E%9A%E4%B8%BE%E5%99%A8"><span class="toc-number">7.3.4.1.</span> <span class="toc-text">旧世界的枚举器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E4%B8%96%E7%95%8C%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">7.3.4.2.</span> <span class="toc-text">新世界的迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%9E%9A%E4%B8%BE%E9%80%82%E9%85%8D%E5%88%B0%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">7.3.4.3.</span> <span class="toc-text">将枚举适配到迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">7.3.4.4.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AE%B6%E5%BA%AD%E5%BD%B1%E9%99%A2"><span class="toc-number">7.4.</span> <span class="toc-text">4. 家庭影院</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%92%AD%E6%94%BE%E7%94%B5%E5%BD%B1"><span class="toc-number">7.4.1.</span> <span class="toc-text">1. 播放电影</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">7.4.1.1.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E5%BA%94%E6%96%B9%E6%B3%95"><span class="toc-number">7.4.1.2.</span> <span class="toc-text">对应方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9E%84%E5%BB%BA%E5%A4%96%E8%A7%82"><span class="toc-number">7.4.2.</span> <span class="toc-text">2. 构建外观</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A7%82%E8%B5%8F%E7%94%B5%E5%BD%B1"><span class="toc-number">7.4.3.</span> <span class="toc-text">3. 观赏电影</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.5.</span> <span class="toc-text">5. 外观模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.5.1.</span> <span class="toc-text">1. 定义外观模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E5%9B%BE-3"><span class="toc-number">7.5.2.</span> <span class="toc-text">2. 类图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%96%E8%A7%82-amp-%E5%A4%96%E8%A7%82VS%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">7.5.3.</span> <span class="toc-text">3. 外观 &amp; 外观VS适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E8%A7%82"><span class="toc-number">7.5.3.1.</span> <span class="toc-text">外观</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%9C%AC%E5%8C%BA%E5%88%AB"><span class="toc-number">7.5.3.2.</span> <span class="toc-text">根本区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%AC%AC%E4%B8%83%E4%B8%AA%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">7.6.</span> <span class="toc-text">6. 第七个设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#what%EF%BC%9F"><span class="toc-number">7.6.1.</span> <span class="toc-text">what？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#how%EF%BC%9F"><span class="toc-number">7.6.2.</span> <span class="toc-text">how？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%BD%E8%BD%A6%E7%B1%BB"><span class="toc-number">7.6.3.</span> <span class="toc-text">汽车类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93"><span class="toc-number">7.7.</span> <span class="toc-text">7. 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%AF%B9%E6%AF%94-1"><span class="toc-number">7.7.1.</span> <span class="toc-text">一些对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-8-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">Chapter 8 模板方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%92%96%E5%95%A1%E5%92%8C%E8%8C%B6"><span class="toc-number">8.1.</span> <span class="toc-text">1. 咖啡和茶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">8.1.1.</span> <span class="toc-text">制作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E5%8F%96%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">8.1.2.</span> <span class="toc-text">抽取共同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.3.</span> <span class="toc-text">认识模板方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0-1"><span class="toc-number">8.1.3.1.</span> <span class="toc-text">原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">8.1.3.2.</span> <span class="toc-text">特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">模板方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.2.1.</span> <span class="toc-text">定义模板方法模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9B%BE-4"><span class="toc-number">8.2.2.</span> <span class="toc-text">类图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hook"><span class="toc-number">8.2.3.</span> <span class="toc-text">hook</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#when%EF%BC%9F"><span class="toc-number">8.2.3.1.</span> <span class="toc-text">when？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E4%B8%AA%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">8.3.</span> <span class="toc-text">第八个设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#why%EF%BC%9F"><span class="toc-number">8.3.1.</span> <span class="toc-text">why？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#how%EF%BC%9F-1"><span class="toc-number">8.3.2.</span> <span class="toc-text">how？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.3.</span> <span class="toc-text">和模板方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99"><span class="toc-number">8.3.4.</span> <span class="toc-text">和依赖倒置原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-number">8.3.5.</span> <span class="toc-text">特征</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95"><span class="toc-number">8.4.</span> <span class="toc-text">Java中的模板方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">8.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
