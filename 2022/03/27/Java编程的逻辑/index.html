
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Java编程的逻辑 - Sunrise-shine的博客</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="Just do it!,Chapter 15 并发基础15.1 线程的基本概念15.1.1 创建线程线程表示一条单独的执行流，它有自己的程序执行计数器，有自己的栈。
创建线程两种方式
1. 继承ThreadJava中jav,"> 
    <meta name="author" content="Sunrise-shine"> 
    <link rel="alternative" href="atom.xml" title="Sunrise-shine的博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.4.1"></head>

<body class="loading">
    <span id="config-title" style="display:none">Sunrise-shine的博客</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://Sunrise-shine.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Java编程的逻辑</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Java编程的逻辑</h1>
        <div class="stuff">
            <span>三月 27, 2022</span>
            partial('_partial/livere', {post: page})
			
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Some/" rel="tag">Some</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="Chapter-15-并发基础"><a href="#Chapter-15-并发基础" class="headerlink" title="Chapter 15 并发基础"></a>Chapter 15 并发基础</h1><h2 id="15-1-线程的基本概念"><a href="#15-1-线程的基本概念" class="headerlink" title="15.1 线程的基本概念"></a>15.1 线程的基本概念</h2><h3 id="15-1-1-创建线程"><a href="#15-1-1-创建线程" class="headerlink" title="15.1.1 创建线程"></a>15.1.1 创建线程</h3><p>线程表示一条单独的执行流，它有自己的程序执行计数器，有自己的栈。</p>
<p>创建线程两种方式</p>
<h4 id="1-继承Thread"><a href="#1-继承Thread" class="headerlink" title="1. 继承Thread"></a>1. 继承Thread</h4><p>Java中java.lang.Thread这个类表示线程，一个类可以继承Thread并重写其run方法来实现一个线程。</p>
<p>调用start方法表示启动该线程，使其成为一条单独的执行流，操作系统会分配线程相关的资源，每个线程会有单独的程序计数器和栈，操作系统会把这个线程作为一个单独的个体进行调度，分配时间片让他执行，执行的起点就是run方法。</p>
<p>如果直接调用run方法，并不会启动一天单独的执行流，依旧是在main线程中执行的，run方法只是main方法调用的一个普通方法。</p>
<h5 id="currentThread"><a href="#currentThread" class="headerlink" title="currentThread"></a>currentThread</h5><p>每个Thread都有一个id和name：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Thread.currentThread().getName()，即可得当前线程的name</span></span><br><span class="line">System.out.println(<span class="string">&quot;thread name: &quot;</span> + Thread.currentThread().getName());</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/27/1z8W6NImvY53ouF.png" alt="image-20220327145526760"></p>
<p>调用start之后，就有了两个执行流，新的一条执行run方法，旧的一条继续执行main方法，两条执行流并发执行，操作系统负责调度。</p>
<h4 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2. 实现Runnable接口"></a>2. 实现Runnable接口</h4><p>仅仅实现Runnable是不够的，要启动线程，还是要创建一个Thread对象，但传递一个Runnable对象。</p>
<p><img src="https://s2.loli.net/2022/03/27/nNM9S2XmPwr3VYp.png" alt="image-20220327145814126"></p>
<p>无论是通过继承Thread还是实现Runnable接口来创建线程，启动线程都是调用start方法。</p>
<h3 id="15-1-2-线程的基本属性和方法"><a href="#15-1-2-线程的基本属性和方法" class="headerlink" title="15.1.2 线程的基本属性和方法"></a>15.1.2 线程的基本属性和方法</h3><h4 id="1-id和name"><a href="#1-id和name" class="headerlink" title="1. id和name"></a>1. id和name</h4><p>每个线程都有一个id和name。id是一个递增的整数，每创建一个线程，就加一。</p>
<p>name的默认值是Thread-后跟一个编号，可以setName</p>
<h4 id="2-优先级"><a href="#2-优先级" class="headerlink" title="2. 优先级"></a>2. 优先级</h4><p>在Java中，优先级从1到10，默认为5。可以setPriority和getPriority。</p>
<p>这个优先级会被映射到操作系统中线程的优先级。不过，操作系统不一定都有10个优先级，所以Java中不同的优先级，到了操作系统中可能被映射到相同的优先级。</p>
<p>优先级对于操作系统而言，主要是一种提示和建议，而非强制。</p>
<h4 id="3-状态"><a href="#3-状态" class="headerlink" title="3. 状态"></a>3. 状态</h4><p>getState()，返回值类型为Thread.State，是一个枚举类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    NEW, <span class="comment">// 没有调用过start的线程</span></span><br><span class="line">    RUNNABLE, <span class="comment">// 运行结束后的线程</span></span><br><span class="line">    BLOCKED, <span class="comment">// 在执行run方法且没有阻塞时，不一定正在执行该线程，只是该线程没有在等待其他条件</span></span><br><span class="line">    WAITING, <span class="comment">// 此三者表示线程被阻塞</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-是否daemon线程"><a href="#4-是否daemon线程" class="headerlink" title="4. 是否daemon线程"></a>4. 是否daemon线程</h4><p>Thread有一个是否daemon线程的属性，其相关方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setDaemon</span><span class="params">(<span class="type">boolean</span> on)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isDaemon</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>daemon线程，一般是其他线程的辅助线程，在它辅助的主线程退出的时候，它就没有存在的意义了。</p>
<p>在运行一个”Hello World”类型的程序时，Java也会创建多个线程，除了main线程之外，至少还有一个复杂垃圾回收的线程，这个线程就是daemon线程，在main线程结束时，垃圾回收线程也会退出。</p>
<h4 id="5-sleep方法"><a href="#5-sleep方法" class="headerlink" title="5. sleep方法"></a>5. sleep方法</h4><p><code>public static native void sleep(long millis) throws InterruptedException</code></p>
<p>调用该方法会让当前线程睡眠指定的时间，以毫秒为单位。</p>
<p>睡眠期间，该线程会让出CPU，如果此时线程被中断，sleep会抛出InterruptedException。</p>
<h4 id="6-yield方法"><a href="#6-yield方法" class="headerlink" title="6. yield方法"></a>6. yield方法</h4><p>让出CPU的方法</p>
<p><code>public static native void yield();</code></p>
<p>调用该方法，是告诉操作系统的调度器：可以让其他线程先运行</p>
<p>不过这仅仅是建议</p>
<h4 id="7-join方法"><a href="#7-join方法" class="headerlink" title="7. join方法"></a>7. join方法</h4><p>可以调用join的线程等待该线程结束。</p>
<p>调用join的线程，可以让等待该线程结束。</p>
<p><code>public final void join() throws InterruptedException</code></p>
<p>在等待线程结束时，这个等待可能被中断，如果被中断，会抛出InterruptedException异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">	<span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-1-3-共享内存及可能存在的问题"><a href="#15-1-3-共享内存及可能存在的问题" class="headerlink" title="15.1.3 共享内存及可能存在的问题"></a>15.1.3 共享内存及可能存在的问题</h3><p>线程之间可以共享内存，它们可以访问和操作相同的对象。</p>
<p>执行流、内存和程序代码</p>
<ol>
<li><p>该例有三条执行流，一条执行main方法，另外两条执行两个ChildThread的run方法。</p>
</li>
<li><p>不同的执行流可以访问和操作相同的变量</p>
</li>
<li><p>不同执行流可以执行相同的程序代码。在分析代码执行的过程时，理解代码在被哪个线程执行是很重要的。</p>
</li>
<li>当多条执行流执行相同的程序代码时，每条执行流都有单独的栈，方法中的参数和局部变量都有自己的一份。</li>
</ol>
<p>共享内存的意料之外：</p>
<ol>
<li>竞态条件</li>
</ol>
<p>所谓竞态条件是指，当多个线程访问和操作同一个对象时，最终的执行结果和执行时序有关。</p>
<p>这是因为，执行的操作可能不是原子操作。一条语句可能分为几个步骤执行，如果不能保证原子性，多个线程同时操作一个数据时，可能让步骤之间发生重叠，从而无法得到正确的修改结果。</p>
<p><img src="https://s2.loli.net/2022/03/27/QkDeYtGEojMZfs4.png" alt="image-20220327162727873"></p>
<ol>
<li>内存可见性</li>
</ol>
<p>多个线程可以共享访问和操作相同的变量，但一个线程对一个共享变量的修改，另一个线程不一定马上就能看到。</p>
<p>在计算机系统中，除了内存，数据还会被缓存在CPU的寄存器以及各级缓存中，当访问一个变量时，可能直接从寄存器或CPU缓存中获取，而不一定到内存中获取。当修改一个变量时，也可能是先写到缓存中，稍后才会同步更新到内存中。</p>
<p>一个线程对内存的修改，另一个线程看不到，一是修改没有及时同步到内存，二是另一个线程根本就没从内存读。</p>
<p><img src="https://s2.loli.net/2022/03/27/PwYQ6shCxX2MzyU.png" alt="image-20220327162741710"></p>
<h2 id="15-2-synchronized"><a href="#15-2-synchronized" class="headerlink" title="15.2 synchronized"></a>15.2 synchronized</h2><h3 id="15-2-1-用法和基本原理"><a href="#15-2-1-用法和基本原理" class="headerlink" title="15.2.1 用法和基本原理"></a>15.2.1 用法和基本原理</h3><p>synchronized可以用于修饰类的实例方法、静态方法和代码块。</p>
<h4 id="1-实例方法"><a href="#1-实例方法" class="headerlink" title="1. 实例方法"></a>1. 实例方法</h4><p>方法内的代码就变成了原子操作。</p>
<p>允许多个线程同时执行同一个synchronized实例方法，只要它们访问的对象不同。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Counter</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line"><span class="type">Counter</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CouterThread</span>(c1);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterThread</span>(c2);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>
<p>这里的t1和t2可以同时执行被synchronized修饰的Counter类中的incr()方法，因为访问的对象不同呀。</p>
<p><strong>synchronized修饰实例方法，实际保护的是同一个对象的方法调用，确保只有一个线程执行。也就是说，他保护的是当前实例对象，即this。</strong></p>
<p><strong>this对象有只能被一个线程持有的锁，以及等待获得该锁的等待队列(其中的线程被阻塞且等待唤醒，即BLOCKED状态)。</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li><p><strong>synchronized保护的是对象而非代码。</strong></p>
</li>
<li><p>只要是访问同一个对象的synchronized方法，即使是不同的代码，也会被同步顺序访问。</p>
</li>
<li><p>一般在保护变量时，会给所有访问该变量的方法加上synchronized修饰符。</p>
</li>
</ol>
<h4 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2. 静态方法"></a>2. 静态方法</h4><p>对于实例方法而言，保护的是当前实例对象this；</p>
<p><strong>对于静态方法而言，保护的是类对象，即StaticCounter.class。</strong></p>
<p>实际上，每个对象都有一个锁和一个等待队列，连类对象也不例外。</p>
<p>由于静态方法和实例方法保护的对象不同，所有可以两个线程，一个访问synchronized静态方法，一个访问synchronized实例方法。</p>
<h4 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3. 代码块"></a>3. 代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123; <span class="comment">// 括号里是保护的对象，即实例对象，或synchronized(StaticCounter.class)</span></span><br><span class="line">        count++; <span class="comment">// 此处是同步执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-2-2-进一步理解"><a href="#15-2-2-进一步理解" class="headerlink" title="15.2.2 进一步理解"></a>15.2.2 进一步理解</h3><h4 id="1-可重用性"><a href="#1-可重用性" class="headerlink" title="1.可重用性"></a>1.可重用性</h4><p>对于同一个执行的线程，它在获得锁之后，在调用其他同样需要锁的代码时，可以直接调用。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>可重用性是通过记录锁的持有线程和持有数量(应该是指，调用的 需要同样锁的 方法的 数量)来实现的。</p>
<p>调用被synchronized保护的代码时</p>
<p><img src="https://i.niupic.com/images/2022/04/09/9YEL.png" alt="image-20220402195944393"></p>
<p>当想要释放锁时，需要减少持有数量。</p>
<p>只有当数量变为0时，才释放整个锁。</p>
<h4 id="2-内存可见性"><a href="#2-内存可见性" class="headerlink" title="2. 内存可见性"></a>2. 内存可见性</h4><p>synchronized可以保证内存可见性。</p>
<p>在释放锁时，所有的写入都会被写回内存，而获得锁后，都会从内存中读取最新数据。</p>
<h5 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h5><p>不过若是单纯想要保证内存可见性，使用synchronized未免开销大了点，可以使用更加轻量级的volatile。</p>
<h4 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3. 死锁"></a>3. 死锁</h4><p>A持有对象lockA的锁，等待加锁lockB；而B持有对象lockB的锁，申请加锁lockA，即二者相互等待。</p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><ol>
<li>避免在持有一个锁的时候，去申请另外一个锁</li>
<li>如果实在需要多个锁，那么约定按照相同的顺序去申请锁。(如先去加锁lockA，再去加锁lockB)</li>
</ol>
<h3 id="15-2-3-同步容器及其注意事项"><a href="#15-2-3-同步容器及其注意事项" class="headerlink" title="15.2.3 同步容器及其注意事项"></a>15.2.3 同步容器及其注意事项</h3><p>所谓同步容器，是通过给所有的容器方法都加上synchronized来实现安全的。</p>
<p>类似于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(length) &#123;</span><br><span class="line">        <span class="keyword">return</span> c.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处的线程安全，指的是容器对象。</p>
<p>这种方式可以减少多个线程并发访问时，再加synchronized的麻烦。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><h5 id="1-复合操作"><a href="#1-复合操作" class="headerlink" title="1. 复合操作"></a>1. 复合操作</h5><p>即先检查再更新。</p>
<p>如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnhancedMap</span>&lt;K,V&gt; &#123;</span><br><span class="line">    Map&lt;K, V&gt; map;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EnhancedMap</span><span class="params">(Map&lt;K, V&gt; map)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = Collections.synchronizedMap(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EnhancedMap是一个装饰类，接受一个Map对象，调用synchronizedMap转换为了同步容器对象map，增加了一个方法putIfAbsent，该方法只有在原Map中没有对应键的时候才添加。</p>
<p>map的每个方法都是安全的，但这个复合方法并不安全。</p>
<p>在多线程的情况下，可能有多个线程都执行完了检查这一步，都发现Map中没有对应的键，然后就会调用put。</p>
<h5 id="2-伪同步"><a href="#2-伪同步" class="headerlink" title="2. 伪同步"></a>2. 伪同步</h5><p>即，同步错了对象。</p>
<p>由于上边分析，方法putIfAbsent并不安全，但是直接对putIfAbsent加锁，因为该方法是实例方法，所以同步的是EnhancedMap对象，但是其他方法使用的却Collections.synchronizedMap返回的map对象，两者，是不同的对象。</p>
<p>则，所有的方法必须使用相同的对象锁(此处可以对map加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(map) &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-迭代"><a href="#3-迭代" class="headerlink" title="3. 迭代"></a>3. 迭代</h5><p>举个栗子，此时创建一个同步List对象，一个线程修改List，另一个遍历List，结果，抛出了并发修改异常。</p>
<p>这很显然，因为<strong>在遍历的同时，容器发生了结构性的变化，就会抛出ConcurrentModificationException异常</strong>。</p>
<p>所以，在遍历时，应该给整个容器对象加锁。</p>
<p><img src="https://s2.loli.net/2022/04/02/3eZgS1AkpBFWVoM.png" alt="image-20220402210616592"></p>
<h5 id="4-并发容器"><a href="#4-并发容器" class="headerlink" title="4. 并发容器"></a>4. 并发容器</h5><p>同步容器的性能较低。</p>
<p>Java中还有很多转为并发设计的容器类，如：</p>
<ul>
<li>CopyOnWriteArrayList</li>
<li>ConcurrentHashMap</li>
<li>ConcurrentLinkedQueue</li>
<li>ConcurrentSkipListSet</li>
</ul>
<h2 id="15-3-线程的基本协作机制"><a href="#15-3-线程的基本协作机制" class="headerlink" title="15.3 线程的基本协作机制"></a>15.3 线程的基本协作机制</h2><p>多线程协作的基本机制wait/notify。</p>
<h3 id="15-3-1-协作的场景"><a href="#15-3-1-协作的场景" class="headerlink" title="15.3.1 协作的场景"></a>15.3.1 协作的场景</h3><h4 id="1-生产者-消费者协作模式"><a href="#1-生产者-消费者协作模式" class="headerlink" title="1. 生产者/消费者协作模式"></a>1. 生产者/消费者协作模式</h4><p>这是一种常见的协作模式，生产者线程和消费者线程通过共享队列进行协作。</p>
<p>生产者将数据或任务放到队列上，而消费者从队列上取数据或任务，如果队列长度有限，在队列满的时候，生产者需要等待，而在队列为空的时候，消费者需要等待。</p>
<h4 id="2-同时开始"><a href="#2-同时开始" class="headerlink" title="2. 同时开始"></a>2. 同时开始</h4><p>类似运动员比赛，在某些程序中，要求多个线程能够同时开始。</p>
<h4 id="3-等待结束"><a href="#3-等待结束" class="headerlink" title="3. 等待结束"></a>3. 等待结束</h4><p>主从协作模式也是一种常见的协作模式，主线程将任务分解为若干子任务，为每个子任务创建一个线程，主线程在继续执行其他任务之前，需要等待每个子任务执行完毕。</p>
<h4 id="4-异步结果"><a href="#4-异步结果" class="headerlink" title="4. 异步结果"></a>4. 异步结果</h4><p>在主从协作模式中，主线程手动创建子线程的写法比较麻烦，一种常见的模式是将子线程的管理封装为异步调用，异步调用马上返回，但返回的不是最终结果，而是一个一般称为Future的对象，通过它可以在随后获得最终的结果。</p>
<h4 id="5-集合点"><a href="#5-集合点" class="headerlink" title="5. 集合点"></a>5. 集合点</h4><p>每个线程负责一部分计算，然后在集合点等待其他线程完成，所有线程到齐之后，交换数据和计算结果，再进行下一次迭代。</p>
<h3 id="15-3-2-wait-notify"><a href="#15-3-2-wait-notify" class="headerlink" title="15.3.2 wait/notify"></a>15.3.2 wait/notify</h3><p>Java在Object类而非Thread类中定义了一些线程协作的基本方法，使得每个对象都可以调用这些方法。</p>
<p>这些方法有两类，一类是wait，另一类是notify。</p>
<h4 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a>wait方法</h4><p>主要有两个：</p>
<p><img src="https://s2.loli.net/2022/04/02/125XceL4K8OImGH.png" alt="image-20220402211608428"></p>
<p>一个带时间参数，单位是毫秒，表示最多等待这么长时间，参数0表示无限期等待；</p>
<p>一个不带时间参数，表示无限期等待，实际就是调用wait(0)。</p>
<p>除了用于锁的等待队列，每个对象还有另一个等待队列，表示<strong>条件队列</strong>，该队列用于线程间的协作。</p>
<p>调用wait就会把当前线程放到条件队列上并阻塞，表示当前线程执行不下去了，它需要等待一个条件，这个条件它自己改变不了，需要其他线程改变。</p>
<h4 id="notify方法"><a href="#notify方法" class="headerlink" title="notify方法"></a>notify方法</h4><p>当其他线程改变了条件后，应该调用Object的notify方法：</p>
<p><img src="https://s2.loli.net/2022/04/02/GraJTLlHjRg3Cdt.png" alt="image-20220402211811317"></p>
<p>notify做的事情就是从条件队列中选一个线程，将其从队列中移除并唤醒，notifyAll和notify的区别是，它会移除条件队列中所有的线程并全部唤醒。</p>
<h4 id="需要对象锁"><a href="#需要对象锁" class="headerlink" title="需要对象锁"></a>需要对象锁</h4><p>实际上，wait和notify方法只能在synchronized代码块内被调用，如果调用wait/notify方法时，当前线程没有持有对象锁，会抛出异常java.lang.IllegalMonitor-StateException。</p>
<p>但是</p>
<p>如果wait必须被synchronized保护，那一个线程在wait时，另一线程怎么可能调用同样被synchronized保护的notify方法呢？</p>
<h5 id="详解wait"><a href="#详解wait" class="headerlink" title="详解wait"></a>详解wait</h5><p>它虽然在synchronized方法内，但调用wait时，线程会释放对象锁。</p>
<p>wait的具体过程是：</p>
<ol>
<li>将当前线程放入条件等待队列，释放对象锁，阻塞等待，线程状态变为WAITING或TIMED_WAITING。</li>
<li>等待时间到或被其他线程调用notify/notifyAll从条件队列中移除，这时要重新竞争对象锁。<ol>
<li>如果能够获得对象锁，线程状态变为RUNNABLE，并从wait调用中返回</li>
<li>否则，该线程加入对象锁等待队列，线程状态变为BLOCKED，只有在获得锁后才会从wait调用中返回。</li>
</ol>
</li>
</ol>
<p>线程从wait中返回后，不代表其等待的条件就一定成立了，它需要重新检查其等待的条件。<img src="https://s2.loli.net/2022/04/02/GnJFYVa5IksCBbW.png" alt="image-20220402212936889"></p>
<p>调用notify会把在条件队列中等待的线程唤醒并从队列中移除，但它不会释放对象锁，也就是说，只有在包含notify的synchronized代码块执行完后，等待的线程才会从wait调用中返回。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-15-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Chapter 15 并发基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">15.1 线程的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">15.1.1 创建线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BFThread"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1. 继承Thread</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#currentThread"><span class="toc-number">1.1.1.1.1.</span> <span class="toc-text">currentThread</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">2. 实现Runnable接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">15.1.2 线程的基本属性和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-id%E5%92%8Cname"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1. id和name</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">2. 优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">3. 状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%98%AF%E5%90%A6daemon%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">4. 是否daemon线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-sleep%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">5. sleep方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-yield%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">6. yield方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-join%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">7. join方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-3-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%8F%8A%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.3.</span> <span class="toc-text">15.1.3 共享内存及可能存在的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-synchronized"><span class="toc-number">1.2.</span> <span class="toc-text">15.2 synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-1-%E7%94%A8%E6%B3%95%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">15.2.1 用法和基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1. 实例方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">2. 静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">3. 代码块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-2-%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3"><span class="toc-number">1.2.2.</span> <span class="toc-text">15.2.2 进一步理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%AF%E9%87%8D%E7%94%A8%E6%80%A7"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1.可重用性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2. 内存可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#tips"><span class="toc-number">1.2.2.2.1.</span> <span class="toc-text">tips</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%AD%BB%E9%94%81"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3. 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.3.1.</span> <span class="toc-text">解决方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-3-%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.2.3.</span> <span class="toc-text">15.2.3 同步容器及其注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A4%8D%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">1. 复合操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BC%AA%E5%90%8C%E6%AD%A5"><span class="toc-number">1.2.3.1.2.</span> <span class="toc-text">2. 伪同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.2.3.1.3.</span> <span class="toc-text">3. 迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.3.1.4.</span> <span class="toc-text">4. 并发容器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%8F%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.</span> <span class="toc-text">15.3 线程的基本协作机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-1-%E5%8D%8F%E4%BD%9C%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.1.</span> <span class="toc-text">15.3.1 协作的场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">1. 生产者&#x2F;消费者协作模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%90%8C%E6%97%B6%E5%BC%80%E5%A7%8B"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">2. 同时开始</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%AD%89%E5%BE%85%E7%BB%93%E6%9D%9F"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">3. 等待结束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%BC%82%E6%AD%A5%E7%BB%93%E6%9E%9C"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">4. 异步结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%9B%86%E5%90%88%E7%82%B9"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">5. 集合点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-2-wait-notify"><span class="toc-number">1.3.2.</span> <span class="toc-text">15.3.2 wait&#x2F;notify</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wait%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">wait方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#notify%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">notify方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E5%AF%B9%E8%B1%A1%E9%94%81"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">需要对象锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%A6%E8%A7%A3wait"><span class="toc-number">1.3.2.3.1.</span> <span class="toc-text">详解wait</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
