
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>程序是怎么跑起来的 - Sunrise-shine的博客</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="Just do it!,Chapter 1 对程序员来说CPU是什么CPU是英文Central Processing Unit(中央处理器)的缩写，相当于计算机的大脑，它的内部有数百万至数亿个晶体管构成。
1.1 CPU的,"> 
    <meta name="author" content="Sunrise-shine"> 
    <link rel="alternative" href="atom.xml" title="Sunrise-shine的博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.4.1"></head>

<body class="loading">
    <span id="config-title" style="display:none">Sunrise-shine的博客</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://Sunrise-shine.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">程序是怎么跑起来的</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">程序是怎么跑起来的</h1>
        <div class="stuff">
            <span>三月 17, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E8%AE%B0%E5%BD%95/" rel="tag">记录</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="Chapter-1-对程序员来说CPU是什么"><a href="#Chapter-1-对程序员来说CPU是什么" class="headerlink" title="Chapter 1 对程序员来说CPU是什么"></a>Chapter 1 对程序员来说CPU是什么</h1><p>CPU是英文Central Processing Unit(中央处理器)的缩写，相当于计算机的大脑，它的内部有数百万至数亿个晶体管构成。</p>
<h2 id="1-1-CPU的内部结构解析"><a href="#1-1-CPU的内部结构解析" class="headerlink" title="1.1 CPU的内部结构解析"></a>1.1 CPU的内部结构解析</h2><p>CPU和内存是由许多晶体管组成的电子部件，通常称为IC （Integrated Circuit，集成电路）。</p>
<h3 id="程序运行流程示例"><a href="#程序运行流程示例" class="headerlink" title="程序运行流程示例"></a>程序运行流程示例</h3><ol>
<li>程序员用高级语言编写程序 -&gt; 2. 将程序编译后转换为机器语言的EXE文件 -&gt; 3. 程序运行时，在内存中生成EXE文件的副本 -&gt; 4. CPU解释并执行程序内容</li>
</ol>
<p>在这一流程中，<strong>CPU所负责的就是解释和运行最终转换为机器语言的程序内容。</strong></p>
<h3 id="CPU的结构"><a href="#CPU的结构" class="headerlink" title="CPU的结构"></a>CPU的结构</h3><ul>
<li><p>寄存器：暂存指令、数据等处理对象</p>
</li>
<li><p>控制器：负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机</p>
</li>
<li><p>运算器：负责运算从内存中读入寄存器的数据</p>
</li>
<li><p>时钟：发出CPU开始计时的时钟信号。(也有些时钟位于CPU的外部。)</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/18/5xKCZlJ89djuimP.png" alt="image-20220318110922481"></p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存指的是计算机的主存储器，通过控制芯片等与CPU相连，主要负责存储指令和数据。</p>
<p>主存由可读写的元素构成，每个字节都带有一个地址编号。CPU可以通过该地址读取主存中的指令和数据，当然也可以写入数据。</p>
<p><strong>但主存中存储的指令和数据会随着计算机的关机而自动清除。</strong></p>
<h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p>程序启动后，根据时钟信号，控制器会从主存中读取指令和数据。通过对这些指令加以解释和运行，运算器就会对数据进行运算，控制器根据该运算结果来控制计算机。</p>
<h2 id="1-2-CPU是寄存器的集合体"><a href="#1-2-CPU是寄存器的集合体" class="headerlink" title="1.2 CPU是寄存器的集合体"></a>1.2 CPU是寄存器的集合体</h2><p>CPU的四个构成部分中，程序员只需要了解寄存器即可，其余三个都不用太过关注。</p>
<p>程序是把寄存器作为对象来描述的。</p>
<h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p>汇编语言(assembly)采用助记符(memonic)来编写程序，每一个原本是电气信号的机器语言指令都会有一个与其相应的助记符。</p>
<p>助记符通常为指令功能的英语单词的简写。例如，mov和add分别是数据的存储（move）和相加（addition）的简写。汇编语言和机器语言基本上是一一对应的。</p>
<p>汇编语言是80386以上的CPU所使用的语言。</p>
<p>通常将汇编语言编写的程序转换成机器语言的过程称为汇编；</p>
<p>反之，机器语言程序转化为汇编语言程序的过程则称为反汇编。</p>
<p><img src="https://s2.loli.net/2022/03/18/9cbyBfMWgrKm2AZ.png" alt="image-20220318115348860"></p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>代码中，eax和ebp表示的都是寄存器。</p>
<p><strong>内存的存储场所通过地址编号来区分，而寄存器的种类则通过名字来区分。</strong></p>
<p>不同类型的CPU，其内部寄存器的数量、种类以及寄存器存储的数值范围都是不同的。</p>
<p>不过，根据功能的不同，我们可以将寄存器大致划分为八类。</p>
<p><img src="https://s2.loli.net/2022/03/18/lnz7YXjiymSpgqB.png" alt="image-20220318115709060"></p>
<h4 id="寄存器存储内容"><a href="#寄存器存储内容" class="headerlink" title="寄存器存储内容"></a>寄存器存储内容</h4><p>寄存器中存储的内容可以是指令也可以是数据。</p>
<p>数据又可以分为”用于运算的数值”和”表示内存地址的数值”两种。</p>
<p>数据种类不同，存储该数值的寄存器也不同。用于运算的数值放在累加寄存器中存储，表示内存底子好的数值则放在基址寄存器和变址寄存器中存储。</p>
<p>eax：累加寄存器；ebp：基址寄存器。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>CPU是具有各种功能的寄存器的集合体。其中，程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其他的寄存器一般有多个。</p>
<p><img src="https://s2.loli.net/2022/03/18/SePdzoWYvMEXqxf.png" alt="image-20220318120303663"></p>
<h2 id="1-3-程序计数器"><a href="#1-3-程序计数器" class="headerlink" title="1.3 程序计数器"></a>1.3 程序计数器</h2><p>用户发出启动程序的指示后，Windows等操作系统会把硬盘中保存的程序复制到内存中。</p>
<p>存储指令和数据的内存，是通过地址来划分的。</p>
<p>CPU的控制器会参照程序计数器的数值，从内存中读取命令并执行。</p>
<p>也就是说，程序计数器决定着程序的流程。</p>
<h2 id="1-4-条件分支和循环机制"><a href="#1-4-条件分支和循环机制" class="headerlink" title="1.4 条件分支和循环机制"></a>1.4 条件分支和循环机制</h2><p>程序的流程分为顺序执行、条件分支和循环三种。</p>
<p>顺序执行是指按照地址内容的顺序执行指令。</p>
<p>条件分支是指根据条件执行任意地址的指令。</p>
<p>循环是指重复执行同一地址的指令。</p>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p>“跳转到0104地址”这个指令，间接执行了“将程序计数器设定成0104地址”这个操作。</p>
<p>条件分支和循环中使用的跳转指令，会参照当前执行的运算结果来判断是否跳转。</p>
<h4 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h4><p>无论当前累加寄存器的运算结果是负数、零还是正数，标记寄存器都会将其保存(也负责存放溢出和奇偶校验的结果)。</p>
<p>CPU在进行运算时，标志寄存器的数值会根据运算结果自动设定。</p>
<p>条件分支在跳转指令前会进行比较运算。而是否跳转，由CPU在参考标志寄存器的数值后进行判断，运算结果的正、零、负三种状态由标志寄存器的三个位表示。</p>
<p><img src="https://s2.loli.net/2022/03/18/KAti4WQE8Xdzapu.png" alt="image-20220318121336116"></p>
<h4 id="CPU中的比较-减法"><a href="#CPU中的比较-减法" class="headerlink" title="CPU中的比较=减法"></a>CPU中的比较=减法</h4><p>假设要比较累加寄存器中存储的XXX值和通用寄存器中存储的YYY值，执行比较的指令后，CPU的运算装置就会在内部（暗中）进行XXX-YYY的减法运算。</p>
<p>而无论减法运算的结果是正数、零还是负数，都会保存到标志寄存器中。结果为正表示XXX比YYY大，零表示XXX和YYY相等，负表示XXX比YYY小。</p>
<p><strong>程序中的比较指令，就是在CPU内部做减法运算。</strong> </p>
<h2 id="1-5-函数的调用机制"><a href="#1-5-函数的调用机制" class="headerlink" title="1.5 函数的调用机制"></a>1.5 函数的调用机制</h2><p>函数调用处理也是通过<strong>把程序计数器的值设定为函数的存储地址</strong>来实现的。</p>
<p>函数的调用需要在完成函数内部的处理后，处理流程再返回到函数调用点(函数调用指令的下一条指令)。</p>
<p><img src="https://s2.loli.net/2022/03/18/hkx9enzWYfSTXVm.png" alt="image-20220318121836115"></p>
<p><strong>由于一行C语言程序在编译后通常会变成多行的机器语言，所以图中的地址是离散的。</strong></p>
<p>函数的调用原点（0132地址）和被调用函数（0260地址）之间的数据传递，可以通过内存或寄存器来实现。</p>
<h3 id="call指令和return命令"><a href="#call指令和return命令" class="headerlink" title="call指令和return命令"></a>call指令和return命令</h3><p>函数调用使用的是call指令，而不是跳转指令。</p>
<p>在函数的入口地址设定到程序计数器之前，call指令会把调用函数后要执行的指令地址存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行return命令。return命令的功能是把保存在栈中的地址设定到程序计数器中。</p>
<h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><h5 id="执行call指令"><a href="#执行call指令" class="headerlink" title="执行call指令"></a>执行call指令</h5><p><img src="https://s2.loli.net/2022/03/18/gtCnirZWEwaxB97.png" alt="image-20220318122514204"></p>
<h5 id="执行return指令"><a href="#执行return指令" class="headerlink" title="执行return指令"></a>执行return指令</h5><p><img src="https://s2.loli.net/2022/03/18/AEJYl9jKUVab4kO.png" alt="image-20220318122717400"></p>
<p>函数调用的处理会转换成call指令，函数结束的处理则会转换成return指令。</p>
<h2 id="1-6-通过地址和索引实现数组"><a href="#1-6-通过地址和索引实现数组" class="headerlink" title="1.6 通过地址和索引实现数组"></a>1.6 通过地址和索引实现数组</h2><p>例如，查看10000000地址～1000FFFF地址时，如图所示，可以将10000000存入基址寄存器，并使变址寄存器的值在00000000～0000FFFF变化。</p>
<p>CPU则会把基址寄存器+变址寄存器的值解释为实际查看的内存地址。</p>
<p><strong>变址寄存器的值就相当于高级编程语言程序中数组的索引功能。</strong></p>
<p><img src="https://s2.loli.net/2022/03/18/KVeUZ95HLSD2dig.png" alt="image-20220318123038828"></p>
<h2 id="1-7-CPU的处理其实很简单"><a href="#1-7-CPU的处理其实很简单" class="headerlink" title="1.7 CPU的处理其实很简单"></a>1.7 CPU的处理其实很简单</h2><p><img src="https://s2.loli.net/2022/03/18/NXjMqKV8JmBlHI9.png" alt="image-20220318123305339"></p>
<h1 id="Chapter-2-数据是用二进制数表示的"><a href="#Chapter-2-数据是用二进制数表示的" class="headerlink" title="Chapter 2 数据是用二进制数表示的"></a>Chapter 2 数据是用二进制数表示的</h1><p>要想对程序的运行机制形成一个大致印象，就要了解信息（数据）在计算机内部是以怎样的形式来表现的，又是以怎样的方法进行运算的。</p>
<h2 id="2-1-二进制表示信息"><a href="#2-1-二进制表示信息" class="headerlink" title="2.1 二进制表示信息"></a>2.1 二进制表示信息</h2><p>8位二进制数被称为一个字节。</p>
<p>字节是最基本的信息计量单位。位是最小单位，字节是基本单位。</p>
<p>内存和磁盘都使用字节单位来存储和读写数据，使用位单位则无法读写数据。因此，字节是信息的基本单位。</p>
<p><img src="https://s2.loli.net/2022/03/18/ptjEIbRe7lmv5sY.png" alt="image-20220318124340185"></p>
<p><img src="https://s2.loli.net/2022/03/18/Yw9udDHa284kXqy.png" alt="image-20220318124453697"></p>
<h1 id="Chapter-3-小数运算出错的原因"><a href="#Chapter-3-小数运算出错的原因" class="headerlink" title="Chapter 3 小数运算出错的原因"></a>Chapter 3 小数运算出错的原因</h1><h2 id="3-1-用二进制表示小数"><a href="#3-1-用二进制表示小数" class="headerlink" title="3.1 用二进制表示小数"></a>3.1 用二进制表示小数</h2><p><img src="https://s2.loli.net/2022/03/18/GmBI3Rnloi28Qwf.png" alt="image-20220318151900327"></p>
<h2 id="3-4-什么是浮点数"><a href="#3-4-什么是浮点数" class="headerlink" title="3.4 什么是浮点数"></a>3.4 什么是浮点数</h2><p>浮点数是指用符号、尾数、基数和指数这四部分来表示的小数。</p>
<p>由于基数必然是2，所以实际数据中往往不考虑基数，只用符号、尾数、指数这三部分来表示浮点数。</p>
<h3 id="IEEE标准"><a href="#IEEE标准" class="headerlink" title="IEEE标准"></a>IEEE标准</h3><p>IEEE标准中，尾数部分将”将小数点前面的值固定为1的正则表达式”。</p>
<p>指数部分用的是”EXCESS系统表现”。</p>
<h4 id="EXCESS系统表现"><a href="#EXCESS系统表现" class="headerlink" title="EXCESS系统表现"></a>EXCESS系统表现</h4><p>通过将指数部分表示范围的中间值设为0，使得负数不需要用符号来表示。</p>
<p>也就是说，</p>
<p>当指数部分是8位单精度浮点数时，最大值11111111=255的1/2，即01111111=127(小数部分舍弃)表示的是0</p>
<p>指数部分是11位双精度浮点数时，11111111111=2047的1/2，即01111111111=1023(小数部分舍弃)表示的是0</p>
<h2 id="3-7-如何避免计算机计算出错"><a href="#3-7-如何避免计算机计算出错" class="headerlink" title="3.7 如何避免计算机计算出错"></a>3.7 如何避免计算机计算出错</h2><ol>
<li>回避策略，即无视这些错误</li>
<li>把小数转换成整数来计算，例如0.1相加100次这一计算，就可以转换为将0.1扩大10倍后再将1相加100次的计算，最后把结果除以10就可以了</li>
</ol>
<h1 id="Chapter-4-熟练使用有棱有角的内存"><a href="#Chapter-4-熟练使用有棱有角的内存" class="headerlink" title="Chapter 4 熟练使用有棱有角的内存"></a>Chapter 4 熟练使用有棱有角的内存</h1><p>物理内存是以字节为单位进行数据存储的。</p>
<p>内存IC中有电源、地址信号、数据信号、控制信号等用于输入输出的大量引脚(IC的引脚)，通过为其指定地址，来进行数据的读写。</p>
<p><img src="https://s2.loli.net/2022/03/18/nEowaSU8vutsQjG.png" alt="image-20220318230029334"></p>
<p>WR：write；RD：read，这样可以让IC运行的信号，称为控制信号。当WR和RD同时为0时，写入和读出的操作都无法进行。</p>
<h2 id="4-2-内存的逻辑模型是楼房"><a href="#4-2-内存的逻辑模型是楼房" class="headerlink" title="4.2 内存的逻辑模型是楼房"></a>4.2 内存的逻辑模型是楼房</h2><p>编程语言中的数据类型表示存储的是何种类型的数据。从内存来看，就是占用的内存大小（占有的楼层数）的意思。</p>
<p>通过使用变量，即便不指定物理地址，也可以在程序中对内存进行读写，这是因为，在程序运行时，Windows等操作系统会自动决定变量的物理地址。</p>
<h2 id="4-4-数组是高效使用内存的基础"><a href="#4-4-数组是高效使用内存的基础" class="headerlink" title="4.4 数组是高效使用内存的基础"></a>4.4 数组是高效使用内存的基础</h2><p>数组是指多个同样数据类型的数据在内存中连续排列的形式。</p>
<p>作为数组元素的各个数据会通过连续的编号被区分开来，这个编号称为索引。</p>
<p>指定索引后，就可以对该索引所对应地址的内存进行读写操作。<strong>而索引和内存地址的变换工作则是由编译器自动实现的。</strong></p>
<p>数组的定义中所指定的数据类型，也表示一次能够读写的内存大小。</p>
<p>之所以说，数组是内存的使用方法的基础，<strong>是因为数组和内存的物理构造是一样的。</strong>特别是1字节类型的数组，它和内存的物理构造完全一致。</p>
<p><img src="https://s2.loli.net/2022/03/18/N69LykWPUFgGhwQ.png" alt="image-20220318232440056"></p>
<h2 id="4-5-栈、队列以及环形缓冲区"><a href="#4-5-栈、队列以及环形缓冲区" class="headerlink" title="4.5 栈、队列以及环形缓冲区"></a>4.5 栈、队列以及环形缓冲区</h2><p>栈[插图]和队列，都可以不通过指定地址和索引来对数组的元素进行读写。</p>
<p>需要临时保存计算过程中的数据、连接在计算机上的设备或者输入输出的数据时，都可以通过这些方法来使用内存。</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>为了实现临时保存数据的目的，使用这种类似于干草堆的机制是非常方便的。而这种机制体现在内存上，就是栈。当我们需要暂时舍弃当前的数据，随后再原貌还原时，会使用栈。</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列一般是以环形缓冲区(ring buffer)的方式来实现，也就是本章标题中所说的”熟练使用有棱有角的内存”。</p>
<h3 id="环形缓冲区模型"><a href="#环形缓冲区模型" class="headerlink" title="环形缓冲区模型"></a>环形缓冲区模型</h3><p><img src="https://s2.loli.net/2022/03/18/zbK4sIcDvrtjl1e.png" alt="image-20220318234128245"></p>
<h2 id="4-6-链表"><a href="#4-6-链表" class="headerlink" title="4.6 链表"></a>4.6 链表</h2><p>在数组的各个元素中，除了数据的值以外，通过为其附带上下一个元素的索引，即可实现链表。数据的值和下一个元素的索引组合在一起，就构成了数组的一个元素。</p>
<p><img src="https://s2.loli.net/2022/03/18/zQaPuIGqt9Oi6e1.png" alt="image-20220318234504095"></p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>当第2个元素的下一个元素变成第4个元素后，第3个元素就被删除了。虽然第3个元素在物理内存上还残留着，但在逻辑上确实被删除了。</p>
<p><img src="https://s2.loli.net/2022/03/18/2EjNsywBTI5fmxc.png" alt="image-20220318234736654"></p>
<h3 id="追加操作"><a href="#追加操作" class="headerlink" title="追加操作"></a>追加操作</h3><p><img src="https://s2.loli.net/2022/03/19/juDk9Yn2voKTgWq.png" alt="image-20220319003420940"></p>
<h2 id="4-7-二叉查找树"><a href="#4-7-二叉查找树" class="headerlink" title="4.7 二叉查找树"></a>4.7 二叉查找树</h2><p><strong>二叉查找树</strong>是指在链表的基础上往数组中追加元素时，考虑到数据的大小关系，将其分成左右两个方向的表现形式。</p>
<p><img src="https://s2.loli.net/2022/03/19/YodkWDlQU6cijx9.png" alt="image-20220319003533853"></p>
<p><img src="https://s2.loli.net/2022/03/19/tGMzZCbY6fhwnWl.png" alt="image-20220319003627199"></p>
<p><img src="https://s2.loli.net/2022/03/19/KkdbxOmCesJZatH.png" alt="image-20220319003652423"></p>
<p>而使用二叉查找树时，当目标数据比现在读出来的数据小时就可以转到左侧，反之目标数据较大时即可转到链表的右侧，这样就加快了找到目标数据的速度。</p>
<p><strong>数组是进行这些处理的基础。</strong></p>
<h1 id="Chapter-5-内存和磁盘的亲密关系"><a href="#Chapter-5-内存和磁盘的亲密关系" class="headerlink" title="Chapter 5 内存和磁盘的亲密关系"></a>Chapter 5 内存和磁盘的亲密关系</h1><p>磁盘缓存是指，把从磁盘中读出的数据存储在内存中，当该数据再次被读取时，不是从磁盘而是直接从内存中高速读出。</p>
<p>从都具有存储程序命令和数据这点来看，内存和磁盘的功能是相同的。在计算机的5大部件(即，输入装置、输出装置、存储器、运算器和控制器)中，内存和磁盘也都被归类为存储部件。</p>
<p>不过，利用电流来实现存储的内存，同利用磁效应来实现存储的磁盘，还是有差异的。而从存储容量来看，内存是高速高价，而磁盘则是低速廉价。</p>
<h2 id="5-1-不读入内存就无法运行"><a href="#5-1-不读入内存就无法运行" class="headerlink" title="5.1 不读入内存就无法运行"></a>5.1 不读入内存就无法运行</h2><p>如今，程序保存在存储设备中，通过有序地被读出来实现运行，这一机制称为存储程序方式(程序内置方式)。</p>
<p>计算机中主要的存储部件是内存和磁盘。</p>
<p>磁盘中存储的程序，必须要加载到内存后才能运行。在磁盘中保存的原始程序是无法直接运行的。这是因为，负责解析和运行程序内容的CPU，需要通过内部程序计数器来指定内存地址，然后才能读出程序。</p>
<h3 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h3><p><img src="https://s2.loli.net/2022/03/20/zNZeMdm5kFXwURA.png" alt="image-20220320000805561"></p>
<h2 id="5-2-磁盘缓存加快访问速度"><a href="#5-2-磁盘缓存加快访问速度" class="headerlink" title="5.2 磁盘缓存加快访问速度"></a>5.2 磁盘缓存加快访问速度</h2><p>磁盘缓存是指把从磁盘中读出的数据存储到内存空间中的方式。</p>
<p>当接下来需要读取同一数据时，就不需要通过实际的磁盘，而是从磁盘缓存中把内存读出，改善访问速度。</p>
<p><strong>把低速设备的数据保存在高速设备中，需要时可以直接将其从高速设备中读出。</strong></p>
<h3 id="小栗子"><a href="#小栗子" class="headerlink" title="小栗子"></a>小栗子</h3><p>由于Web浏览器是通过网络来获取远程Web服务器的数据并将其显示出来的，因此，在显示较大的图片等文件时，会花费不少时间。于是，Web浏览器就可以把获取的数据暂时保存在磁盘中，然后在需要时再显示磁盘中的数据。</p>
<p>也就是说，把低速的网络数据保存到相对高速的磁盘中。</p>
<h2 id="5-3-虚拟内存把磁盘作为部分内存来使用"><a href="#5-3-虚拟内存把磁盘作为部分内存来使用" class="headerlink" title="5.3 虚拟内存把磁盘作为部分内存来使用"></a>5.3 虚拟内存把磁盘作为部分内存来使用</h2><p>虚拟内存是指把磁盘的一部分作为假想内存来使用，这与磁盘缓存是假象的磁盘(实际上是内存)相对，虚拟内存是假想的内存(实际上是磁盘)。</p>
<h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p>虚拟内存虽说是把磁盘作为内存的一部分来使用，但实际上<strong>正在运行的程序部分，在这个时间点上是必须存在在内存中的</strong>。</p>
<p>也就是说，为了实现虚拟内存，就必须<strong>把实际内存的内容，和磁盘上的虚拟内存的内容进行部分置换</strong>，并同时运行程序。</p>
<h3 id="Windows下的分页式"><a href="#Windows下的分页式" class="headerlink" title="Windows下的分页式"></a>Windows下的分页式</h3><p>虚拟内存的方法有<strong>分页式</strong>和<strong>分段式</strong>两种。</p>
<p>Windows采用的是分页式。</p>
<p>该方式是指，在不考虑程序构造的情况下，把运行的程序按照一定大小的页进行分割，并以页为单位在内存和磁盘间进行置换。</p>
<p>在分页式中，我们把磁盘的内容读出到内存称为Page In，把内存的内容写入磁盘称为Page Out。一般情况下，Windows计算机的页的大小是4KB。也就是说，把大程序用4KB的页来进行切分，并以页为单位放入磁盘（虚拟内存）或内存中。</p>
<p><img src="https://s2.loli.net/2022/03/20/TlwoKpLfUdX1Nms.png" alt="image-20220320010617832"></p>
<p>为了实现虚拟内存功能，Windows在磁盘上提供了虚拟内存用的文件（pagefile，页文件）。该文件由Windows自动做成和管理。</p>
<p>文件的大小也就是虚拟内存的大小，通常是实际内存的相同程度至两倍程度。</p>
<h2 id="5-4-节约内存的编程方法"><a href="#5-4-节约内存的编程方法" class="headerlink" title="5.4 节约内存的编程方法"></a>5.4 节约内存的编程方法</h2><p>虚拟内存可以避免因内存不足导致的应用无法启动。不过，由于使用虚拟内存时发生的Page In和Page Out往往伴随着低速的磁盘访问，因此会导致应用的运行变得迟钝起来。</p>
<p>所以，虚拟内存无法彻底解决内存不足的问题！</p>
<p><strong>为了从根本上解决内存不足的问题，需要增加内存的容量，或者尽量把运行的应用文件变小。</strong></p>
<h3 id="通过DLL文件实现函数共有"><a href="#通过DLL文件实现函数共有" class="headerlink" title="通过DLL文件实现函数共有"></a>通过DLL文件实现函数共有</h3><p>动态链接</p>
<p>DLL(Dynamic Link Library)文件，是在程序运行时可以动态加载Library（函数和数据的集合）的文件。</p>
<p>另外，多个应用可以共有同一个DLL文件。而通过共有同一个DLL文件则可以达到节约内存的效果。</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>例如，假设我们编写了一个具有某些处理功能的函数MyFunc()。应用A和应用B都会使用这个函数。<strong>在各个应用的运行文件中内置函数MyFunc()（这个称为StaticLink，静态链接）后同时运行这两个应用</strong>，内存中就存在了具有同一函数的两个程序。但这会导致内存的利用效率降低。所以，有两个同样的函数，还是有点浪费。</p>
<p><img src="https://s2.loli.net/2022/03/20/lwFIq6ykK9S58Cd.png" alt="image-20220320012110001"></p>
<p>那么，如果函数MyFunc()是独立的DLL文件，由于同一个DLL文件的内容在运行时可以被多个应用共有，因此内存中存在的函数MyFunc()的程序就只有1个。这样一来，内存的利用效率也就提高了。</p>
<p><img src="https://s2.loli.net/2022/03/20/etGFhK5ZQJdDWcm.png" alt="image-20220320012157243"></p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>Windows的操作系统本身也是多个DL文件的集合体。</p>
<p>有时在安装新应用时，DLL文件也会被追加。应用则会通过利用这些DLL文件的功能来运行。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>像这样，之所以要利用多个DLL文件，其中一个原因就是可以节约内存。</p>
<p>而且DLL文件还有一个优点就是，在不变更EXE文件的情况下，只通过升级DLL文件就可以更新。</p>
<h3 id="通过调用-stdcall来减小程序文件的大小"><a href="#通过调用-stdcall来减小程序文件的大小" class="headerlink" title="通过调用_stdcall来减小程序文件的大小"></a>通过调用_stdcall来减小程序文件的大小</h3><p>C语言中，在调用函数后，需要执行栈清理处理指令。</p>
<h4 id="栈清理处理指令"><a href="#栈清理处理指令" class="headerlink" title="栈清理处理指令"></a>栈清理处理指令</h4><p>栈清理处理是指，把不需要的数据从接收和传递函数的参数时使用的内存上的栈区域中清理出去。该命令不是程序记述的，而是在程序编译时由编译器自动附加到程序中的。编译器默认将该处理附加在函数调用方。</p>
<p>在同一个程序中，同样的函数可能会被多次反复调用。而如果是同样的函数，栈清理处理的内容也是一样的。由于该处理是在调用函数一方，因此就会导致同一处理被反复进行。这就造成了内存的浪费。</p>
<h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p><img src="https://s2.loli.net/2022/03/20/MuU1tQR5Ii9orYE.png" alt="image-20220320012924316"></p>
<p>栈清理处理，比起在函数调用方进行，在反复被调用的函数一方进行时，程序整体要小一些。</p>
<p>这时所使用的就是_stdcall。在函数前加上 _stdcall，就可以把栈清理处理变为在被调用函数一方进行。</p>
<p>把代码清单5-1中的int MyFunc(int a, int b)部分转成int _stdcall MyFunc(int a, int b)进行再编译后，和代码清单5-2中add esp, 8同样的处理就会在函数MyFunc()一方执行。</p>
<p><strong>栈清理处理指令执行的次数是一样的，但是所占的内存数目减小了。</strong></p>
<p><img src="https://s2.loli.net/2022/03/20/1UkOxdqpnric2tM.png" alt="image-20220320013148120"></p>
<h2 id="5-5-磁盘的物理结构"><a href="#5-5-磁盘的物理结构" class="headerlink" title="5.5 磁盘的物理结构"></a>5.5 磁盘的物理结构</h2><p>磁盘是通过把其物理表面划分成多个空间来使用的。</p>
<p>划分的方式</p>
<p>有扇区方式和可变长方式两种，前者是指将磁盘划分为固定长度的空间，后者则是指把磁盘划分为长度可变的空间。</p>
<h3 id="Windows中的磁盘"><a href="#Windows中的磁盘" class="headerlink" title="Windows中的磁盘"></a>Windows中的磁盘</h3><p>一般的Windows计算机所使用的硬盘和软盘，采用的都是扇区方式。扇区方式中，把磁盘表面分成若干个同心圆的空间就是磁道，把磁道按照固定大小（能存储的数据长度相同）划分而成的空间就是扇区。</p>
<p>扇区是对磁盘进行物理读写的最小单位。Windows中使用的磁盘，一般1个扇区是512字节。</p>
<p>Windows在逻辑方面（软件方面）对磁盘进行读写的单位是<strong>扇区整数倍——簇</strong>。</p>
<p>根据磁盘容量的不同，1簇可以是512字节（1簇=1扇区）、1KB（1簇=2扇区）、2KB、4KB、8KB、16KB、32KB（1簇=64扇区）。磁盘的容量越大，簇的容量也越大。</p>
<p>不过，在软盘中，<strong>1簇=512字节=1扇区，簇和扇区的大小是相等的</strong>。</p>
<p>不管是硬盘还是软盘，不同的文件是不能存储在同一簇中的，否则就会导致存在一方的文件不能被删除。</p>
<p>因此，不管是多小的文件，都会占用一簇的空间。这样一来，所有的文件都会占用一簇的整数倍的磁盘空间。</p>
<h3 id="一簇为单位"><a href="#一簇为单位" class="headerlink" title="一簇为单位"></a>一簇为单位</h3><p><img src="https://s2.loli.net/2022/03/20/YizIZRHfkq8J94m.png" alt="image-20220320014053998"></p>
<p>虽然文件的大小只有1字节，但使用空间却变成了512字节。</p>
<p><strong>以簇为单位进行读写时，1簇中没有填满的区域会保持不被使用的状态。虽然这看起来是有点浪费，不过该机制就是如此规定的。</strong></p>
<p>另外，如果减少簇的容量，磁盘访问次数就会增加，就会导致读写文件的时间变长。</p>
<p>由于在磁盘表面上，表示扇区区分的领域是必要的，因此，如果簇的容量过小，磁盘的整体容量也会减少。</p>
<p><strong>扇区和簇的大小，是由处理速度和存储容量的平衡来决定的。</strong></p>
<h1 id="Chapter-6-尝试压缩数据"><a href="#Chapter-6-尝试压缩数据" class="headerlink" title="Chapter 6 尝试压缩数据"></a>Chapter 6 尝试压缩数据</h1><p>文件存储的基本单位是字节。</p>
<h2 id="6-1-文件以字节为单位保存"><a href="#6-1-文件以字节为单位保存" class="headerlink" title="6.1 文件以字节为单位保存"></a>6.1 文件以字节为单位保存</h2><p>文件就是字节数据的集合。</p>
<p>在任何情况下，文件中的字节数据都是连续存储的。</p>
<p><img src="https://s2.loli.net/2022/03/23/lHTg9zSs2wDAWLX.png" alt="image-20220323104144532"></p>
<h2 id="6-2-RLE算法的机制"><a href="#6-2-RLE算法的机制" class="headerlink" title="6.2 RLE算法的机制"></a>6.2 RLE算法的机制</h2><p>数据×重复次数：RLE(Run Length Encoding，行程长度编码)</p>
<p><img src="https://s2.loli.net/2022/03/23/XhIiBwMevtEAq13.png" alt="image-20220323104437547"> </p>
<h2 id="6-4-哈夫曼算法"><a href="#6-4-哈夫曼算法" class="headerlink" title="6.4 哈夫曼算法"></a>6.4 哈夫曼算法</h2><p>哈夫曼算法的关键就在于，”多次出现的数据用小于8位的字节数来表示，不常用的数据则可以用超过8位的字节数来表示”。</p>
<p>注意，不管是不满8位的数据，还是超过8位的数据，最终都以8位为单位保存到文件中。</p>
<p>用哈夫曼算法压缩过的文件中，存储着哈夫曼编码信息和压缩过的数据。</p>
<p><img src="https://s2.loli.net/2022/03/23/34OxLYWDKMBHAPu.png" alt="image-20220323110407423"></p>
<p>AAAAAABBCDDEEEEEF，结果为0000000000001001001101011010101010101111,40位=5字节</p>
<p>压缩比率：5/17</p>
<h2 id="6-7-可逆压缩和非可逆压缩"><a href="#6-7-可逆压缩和非可逆压缩" class="headerlink" title="6.7 可逆压缩和非可逆压缩"></a>6.7 可逆压缩和非可逆压缩</h2><p>Windows的标准图像数据形式是BMP，是完全未压缩的。由于显示器及打印机输出的bit是可以直接映射(mapp-ing)的，所以便有了BMP=bitmap这一名称。</p>
<p>把能还原到压缩前状态的压缩称为可逆压缩，无法还原到压缩前状态的压缩称为非可逆压缩.</p>
<p>JPEG格式的文件是非可逆压缩，因此还原后的图像信息有一部分是模糊的。</p>
<p>而GIF格式的文件虽然是可逆压缩，但因为有色数不能超过256色的限制，所以还原后颜色信息会有一些缺失，进而导致了图像模糊。</p>
<h1 id="Chapter-7-程序是在何种环境中运行的"><a href="#Chapter-7-程序是在何种环境中运行的" class="headerlink" title="Chapter 7 程序是在何种环境中运行的"></a>Chapter 7 程序是在何种环境中运行的</h1><p>应用的运行环境，指的是操作系统和计算机本身(硬件)的种类。</p>
<h2 id="7-1-运行环境-操作系统-硬件"><a href="#7-1-运行环境-操作系统-硬件" class="headerlink" title="7.1 运行环境=操作系统+硬件"></a>7.1 运行环境=操作系统+硬件</h2><h2 id="7-2-Windows克服了CPU以外的硬件差异"><a href="#7-2-Windows克服了CPU以外的硬件差异" class="headerlink" title="7.2 Windows克服了CPU以外的硬件差异"></a>7.2 Windows克服了CPU以外的硬件差异</h2><p>在Windows的应用软件中，键盘输入、显示器输出等并不是直接向硬件发送指令，而是通过向Windows发送指令来间接实现的。</p>
<p><img src="https://s2.loli.net/2022/03/23/YizVoUaGcBeprjI.png" alt="image-20220323112404880"></p>
<p>但Windows应用软件，都是用特定的CPU的本地代码来完成的。</p>
<h2 id="7-3-不同操作系统的API不同"><a href="#7-3-不同操作系统的API不同" class="headerlink" title="7.3 不同操作系统的API不同"></a>7.3 不同操作系统的API不同</h2><p>CPU的类型不同，所对应的机器语言也不同，同样的道理，操作系统的类型不同，应用程序向操作系统传递指令的途径也不同。</p>
<p>应用程序向操作系统传递指令的途径，称为API(Application Programming Interface)(也称系统调用，是应用调用操作系统功能的手段)，Windows及Unix系列操作系统的API，提供了任何应用程序都可以利用的函数组合。</p>
<h2 id="7-4-FreeBSD-Port"><a href="#7-4-FreeBSD-Port" class="headerlink" title="7.4 FreeBSD Port"></a>7.4 FreeBSD Port</h2><p>Unix系列操作系统FreeBSD中，存在一种名为Ports的机制。该机制能够结合当前运行的硬件环境来编译应用的源代码，进而得到可以运行的本地代码系统。如果目标应用的源代码没有在硬件上的话，Ports会自动使用FTP连接到相关站点来下载代码。</p>
<h2 id="7-6-Java虚拟机"><a href="#7-6-Java虚拟机" class="headerlink" title="7.6 Java虚拟机"></a>7.6 Java虚拟机</h2><p>Java的两个层面的意思，一个是作为编程语言的Java，另一个是作为程序运行环境的Java。</p>
<p>从操作系统方面来看，Java虚拟机是一个应用，而从Java应用方面来看，Java虚拟机就是运行环境。</p>
<h2 id="7-7-BIOS和引导"><a href="#7-7-BIOS和引导" class="headerlink" title="7.7 BIOS和引导"></a>7.7 BIOS和引导</h2><p>BIOS存储在ROM中，是预先内置在计算机主机内部的程序。BIOS除了键盘、磁盘、显卡等基本控制程序外，还有启动”引导程序”的功能。</p>
<h3 id="引导程序"><a href="#引导程序" class="headerlink" title="引导程序"></a>引导程序</h3><p>引导程序是存储在启动驱动器起始区域的小程序。</p>
<p>操作系统的启动驱动器一般是硬盘，不过有时也可以是CD-ROM或软盘。</p>
<h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>开机后，BIOS会确认硬件是否正常运行，没有问题的话就会启动引导程序。</p>
<p>引导程序的功能是把在硬盘等记录的OS加载到内存中运行。</p>
<p>虽然启动应用是OS的功能，但OS并不能自己启动自己，而是通过引导程序来启动。</p>
<p>（Bootstrap的原意是指靴子上部的“拔靴带”。BIOS这样小的程序（拔靴带），可以带动（启动）操作系统这样的大程序（靴子），所以由此得名。虽然操作系统运行以后，程序员就不用再关注BIOS及引导程序了，但需要知道它们的存在。）</p>
<h1 id="Chapter-8-从源文件到可执行文件"><a href="#Chapter-8-从源文件到可执行文件" class="headerlink" title="Chapter 8 从源文件到可执行文件"></a>Chapter 8 从源文件到可执行文件</h1><p>链接器会从库文件中抽取出必要的目标文件并将其结合到EXE文件中。</p>
<h2 id="8-1-计算机只能运行本地代码"><a href="#8-1-计算机只能运行本地代码" class="headerlink" title="8.1 计算机只能运行本地代码"></a>8.1 计算机只能运行本地代码</h2><p>本地（native）这个术语有“母语的”意思。</p>
<p>对CPU来说，母语就是机器语言，而转换成机器语言的程序就是本地代码。用任何编程语言编写的源代码，最后都要翻译成本地代码（图8-2），否则CPU就不能理解。</p>
<h2 id="8-2-本地代码的内容"><a href="#8-2-本地代码的内容" class="headerlink" title="8.2 本地代码的内容"></a>8.2 本地代码的内容</h2><p>Windows中EXE文件的程序内容，使用的就是本地代码。</p>
<p>将EXE文件Dump后(Dump是指把文件的内容，每个字节用2位十六进制数来表示的方式)，可以发现本地代码就是各种数值的罗列。</p>
<h2 id="8-3-编译器负责转换源代码"><a href="#8-3-编译器负责转换源代码" class="headerlink" title="8.3 编译器负责转换源代码"></a>8.3 编译器负责转换源代码</h2><p>编译器首先读入代码的内容，然后再把源代码转换成本地代码。编译器中就好像有一个源代码同本地代码的对应表。但实际上，读入的源代码，还要经过语法解析、句法解析、语义解析等，才能生成本地代码。</p>
<p>根据CPU类型的不同，本地代码的类型也不同。因而，编译器不仅和编程语言的种类有关，和CPU的类型是也是相关的。</p>
<p><img src="https://s2.loli.net/2022/03/23/6JhA7YPEO2nbjvH.png" alt="image-20220323183804354"></p>
<p><img src="https://s2.loli.net/2022/03/23/ChVr2B69KcRDukP.png" alt="image-20220323183924787"></p>
<h2 id="8-4-仅靠编译无法得到可执行文件的"><a href="#8-4-仅靠编译无法得到可执行文件的" class="headerlink" title="8.4 仅靠编译无法得到可执行文件的"></a>8.4 仅靠编译无法得到可执行文件的</h2><p>编译器转换源代码之后，就会生成本地文件。不过，本地文件是无法直接运行的。为了得到可运行的EXE文件，编译之后还需要进行”链接”处理。</p>
<h3 id="未完成"><a href="#未完成" class="headerlink" title="未完成"></a>未完成</h3><p>在Windows的命令提示符中，运行下列命令后，由C语言编写的代码Sample1.c就会被编译。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcc32 -W -c Sample1.c</span><br></pre></td></tr></table></figure>
<p>“-W-c”是用来指定编译Windows用的程序的选项。选项是对编译器的指示。有时也称为”开关”。</p>
<p>编译后生成的不是EXE文件，而是扩展名为“.obj”的目标文件。Sample1.c编译后，就生成了Sample1.obj目标文件。虽然目标文件的内容是本地代码，但却无法直接运行。那么这是为什么呢？原因就是当前程序还处于未完成状态。</p>
<p><img src="https://s2.loli.net/2022/03/23/Q7SwKs4MqazWmGo.png" alt="image-20220323184915391"></p>
<p>如该代码所示：</p>
<p>sprintf和MessageBox在源代码中，都没有记述这些函数的处理内容。因此，就必须将存储着sprintf()和MessageBox( )的处理内容的目标文件同Sample1.obj结合，否则处理不完整,EXE文件也无法完成。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>把多个目标文件结合，生成1个EXE文件的处理就是链接，运行链接的程序就成为链接器。</p>
<p>Windows下，运行以下命令，程序所需的目标文件就会被全部链接生成Sample1.exe这个EXE文件。</p>
<p><img src="https://s2.loli.net/2022/03/23/KvLJexZhjpVbToC.png" alt="image-20220323185423760"></p>
<h2 id="8-5-启动及库文件"><a href="#8-5-启动及库文件" class="headerlink" title="8.5 启动及库文件"></a>8.5 启动及库文件</h2><p>链接选项“-Tpe-c-x-aa”是指定生成Windows用的EXE文件的选项。</p>
<p>在这些选项之后，会指定结合的目标文件。而该命令行中就指定了c0w32.obj、Sample1.obj这两个目标文件。</p>
<h3 id="1-c0w32-obj"><a href="#1-c0w32-obj" class="headerlink" title="1. c0w32.obj"></a>1. c0w32.obj</h3><p>c0w32.obj这个目标文件记述的是同所有程序起始位置相结合的处理内容，称为程序的启动。因而，即使程序不调用其他目标文件的函数，也必须要进行链接，并和启动结合起来。</p>
<p>在链接的命令行末尾，存在着拓展名为”.lib”的import32.lib和cw32.lib这两个文件。这是因为sprintf()的目标文件在cw32.lib中，MessageBox()的目标文件在import32.lib中（实际上，MessageBox()的目标文件在user32. dll这个DLL文件中。）</p>
<h3 id="2-库文件"><a href="#2-库文件" class="headerlink" title="2. 库文件"></a>2. 库文件</h3><p>像import32.lib及cw32.lib这样的文件称为库文件。</p>
<p>库文件指的是把多个目标文件集成保存到一个文件中的形式。链接器指定库文件后，就会从中把需要的目标文件抽取出来，并同其他目标文件结合生成EXE文件。</p>
<h3 id="3-如果不指定呢？"><a href="#3-如果不指定呢？" class="headerlink" title="3. 如果不指定呢？"></a>3. 如果不指定呢？</h3><p>Sample1.obj是尚未完成的本地代码，其中包含有“链接时请结合sprintf()及MessageBox()”这样的信息。意思是如果不存在其他函数的话，程序就无法运行。</p>
<p>下面，我们就来做一个尝试，看看在不指定这两个库文件的情况下进行链接会发生什么。</p>
<p><img src="https://s2.loli.net/2022/03/24/qZnrhKfJtaPTVER.png" alt="image-20220324011320494"></p>
<p>外部符号指的是，其他目标文件中的变量或函数。错误消息“无法解析的外部符号”表示的是无法找到记述着目的变量及函数的目标文件，因而无法进行链接的意思。</p>
<h4 id="标准函数"><a href="#标准函数" class="headerlink" title="标准函数"></a>标准函数</h4><p>sprintf()等函数，不是通过源代码形式而是通过库文件形式和编译器一起提供的。这样的函数称为标准函数。</p>
<p>之所以使用库文件，是为了简化为链接器的参数指定多个目标文件这个过程，因为使用存储着多个目标文件的库文件的话，只需在链接器的命令行中指定几个库文件就可以。</p>
<p>通过以目标文件的形式或集合多个目标文件的库文件形式来提供函数，就可以不用公开标准函数的源代码内容。</p>
<h2 id="8-6-DLL文件及导入库"><a href="#8-6-DLL文件及导入库" class="headerlink" title="8.6 DLL文件及导入库"></a>8.6 DLL文件及导入库</h2><p>Windows以函数的形式为应用提供了各种功能。这些形式的函数称为API(Application Programming Interface)。MessageBox()，他并不是C语言的标准函数，而是Windows提供的API的一种。MessageBox( )提供了显示消息框的功能。</p>
<h3 id="1-导入库"><a href="#1-导入库" class="headerlink" title="1. 导入库"></a>1. 导入库</h3><p>Windows中，API的目标文件，并不是存储在通常的库文件中，而是存储在名为DLL(Dynamic Link Library) 文件的特殊库文件中。DLL是程序运行时动态结合的文件。</p>
<h4 id="import32-lib"><a href="#import32-lib" class="headerlink" title="import32.lib"></a>import32.lib</h4><p>实际上，import32.lib中仅仅存储着两个信息，<strong>一是MessageBox( )在user32.dll这个DLL文件中，另一个是存储着DLL文件的文件夹信息，MessageBox( )的目标文件的实体实际上并不存在。把类似于import32.lib这样的库文件称为导入库。</strong></p>
<h3 id="2-静态链接库"><a href="#2-静态链接库" class="headerlink" title="2. 静态链接库"></a>2. 静态链接库</h3><p>与此相反，存储着目标文件的实体，并直接和EXE文件结合的库文件形式称为<strong>静态链接库</strong>。</p>
<p>存储着sprintf()的目标文件的cw32lib就是静态链接库。</p>
<h3 id="3-形成EXE过程"><a href="#3-形成EXE过程" class="headerlink" title="3. 形成EXE过程"></a>3. 形成EXE过程</h3><p>通过结合导入库文件，执行时从DLL文件中调出的MessageBox( )函数这一信息就会与EXE文件进行结合。这样链接器链接时，就不会再出现错误消息，从而就可以顺利编写EXE文件。</p>
<p><img src="https://s2.loli.net/2022/03/24/iw9uTjJgSMtabEk.png" alt="image-20220324205047519"></p>
<p><img src="https://s2.loli.net/2022/03/24/cYzTlwUoGE2Lb5k.png" alt="image-20220324205124089"></p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ol>
<li><p>编译是将.c变成.obj，再结合启动信息，链接所需目标文件，才能得到最终可执行的的EXE文件。</p>
</li>
<li><p>也就是说，导入库中存的是目标文件所在的DLL文件名，以及DLL文件的位置，需要将目标文件调出DLL再结合；而静态链接库存的是目标文件的实体，直接可以与EXE结合。</p>
</li>
</ol>
<h2 id="8-7-可执行文件运行机制"><a href="#8-7-可执行文件运行机制" class="headerlink" title="8.7 可执行文件运行机制"></a>8.7 可执行文件运行机制</h2><p>EXE文件是作为单独的文件存储在硬盘里的。</p>
<p>通过资源管理器找到并双击EXE文件，就会把EXE文件中的内容加载到内存中运行。</p>
<p>本地代码在对程序记述的变量进行读写时，是参照数据存储的内存地址来运行命令的。</p>
<p>在调用函数时，程序的处理流程就会跳转到存储着函数处理内容的内存地址上。<strong>EXE文件作为本地代码的程序，并没有指定变量及函数的实际内存地址。</strong>每次运行时，程序内的变量及函数被分配到的内存地址都是不同的。如何表示实际内存地址？</p>
<h3 id="再配置信息"><a href="#再配置信息" class="headerlink" title="再配置信息"></a>再配置信息</h3><p>EXE文件中给变量及函数分配了虚拟的内存地址。在程序运行时，虚拟的内存地址会转换成实际的内存地址。</p>
<p><strong>链接器会在EXE文件的开头，追加转换内存地址所需的必要信息。这个信息称为再配置信息</strong>。</p>
<h4 id="相对地址"><a href="#相对地址" class="headerlink" title="相对地址"></a>相对地址</h4><p><strong>EXE文件的再配置信息，就成为了变量和函数的相对地址。</strong></p>
<p>相对地址表示的是相对于基点地址的偏移量，也就是相对距离。实现相对地址，也是需要花费一番心思的。</p>
<p>在源代码中，虽然变量及函数是在不同位置分散记述的，<strong>但在链接后的EXE文件中，变量及函数就会变成一个连续排列的组。</strong></p>
<p>这样一来，各变量的内存地址就可以用相对于变量组起始位置这一基点的偏移量来表示，同样，各函数的内存地址也可以用相对于函数组起始位置这一基点的偏移量来表示。而各组基点的内存地址则是在程序运行时被分配的。</p>
<h4 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h4><p><img src="https://s2.loli.net/2022/03/24/NlSFoiLGPDvtTmQ.png" alt="image-20220324210321653"></p>
<p>函数之类的信息，已经放在了EXE文件中，而且EXE文件只保存各信息相对基点的偏移量，即相对地址。</p>
<p>也就是说，在程序运行时，会分配基点地址，之后根据再配置信息中的偏移量，确定实际的数据和函数地址，从而进行调用。</p>
<h2 id="8-8-程序加载时会生成栈和堆"><a href="#8-8-程序加载时会生成栈和堆" class="headerlink" title="8.8 程序加载时会生成栈和堆"></a>8.8 程序加载时会生成栈和堆</h2><p>EXE文件的内容分为再配置信息、变量组和函数组。</p>
<h3 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h3><p>不过，当程序加载到内存后，除此之外还会额外生成两个组，那就是栈和堆。</p>
<p>栈是用来存储函数内部临时使用的变量(局部变量)，以及函数调用时所用的参数的内存区域。</p>
<p>堆是用来存储程序运行时的任意数据及对象的内存领域。</p>
<p><img src="https://s2.loli.net/2022/03/24/XTrBjWiwxou1H4n.png" alt="image-20220324211037907"></p>
<h3 id="内存中的程序"><a href="#内存中的程序" class="headerlink" title="内存中的程序"></a>内存中的程序</h3><p>EXE文件中并不存在栈及堆的组。</p>
<p>栈和堆需要的内存空间是在EXE文件加载到内存后开始运行时得到分配的。</p>
<p>因而，内存中的程序，就是<strong>由用于变量的内存空间、用于函数的内存空间、用于栈的内存空间、用于堆的内存空间这4部分构成的。</strong></p>
<h3 id="堆和栈的释放"><a href="#堆和栈的释放" class="headerlink" title="堆和栈的释放"></a>堆和栈的释放</h3><p>栈中对数据进行存储和舍弃的代码，是由编译器自动生成的，不需要程序员参与。每次函数被调用时，会得到申请分配，函数处理完毕会自动释放。</p>
<p>堆的内存空间，要根据程序员编写的程序，来明确进行申请分配(malloc、new)或释放(free、delete)。</p>
<h2 id="8-9-一些Q-amp-A"><a href="#8-9-一些Q-amp-A" class="headerlink" title="8.9 一些Q&amp;A"></a>8.9 一些Q&amp;A</h2><p>Q：编译器和解释器有什么不同？</p>
<p>A：编译器是在运行前对所有源代码进行解释处理的。而解释器则是在运行时对源代码的内容一行一行地进行解释处理的。</p>
<p>Q：“分割编译”指的是什么？</p>
<p>A：将整个程序分为多个源代码来编写，然后分别进行编译，最后链接成一个EXE文件。这样每个源代码都相对变短，便于程序管理。</p>
<p>Q：使用DLL文件的好处是什么？</p>
<p>A:DLL文件中的函数可以被多个程序共用。因此，借助该功能可以节约内存和磁盘。此外，在对函数的内容进行修正时，还不需要重新链接（静态链接）使用这个函数的程序[插图]。</p>
<h1 id="Chapter-9-操作系统和应用的关系"><a href="#Chapter-9-操作系统和应用的关系" class="headerlink" title="Chapter 9 操作系统和应用的关系"></a>Chapter 9 操作系统和应用的关系</h1><h2 id="9-1-操作系统功能的历史"><a href="#9-1-操作系统功能的历史" class="headerlink" title="9.1 操作系统功能的历史"></a>9.1 操作系统功能的历史</h2><p>用机器语言编写程序，然后再使用开关将程序输入，这一过程非常麻烦。</p>
<h3 id="1-监控程序"><a href="#1-监控程序" class="headerlink" title="1. 监控程序"></a>1. 监控程序</h3><p>于是，开发出了仅具有加载和运行功能的监控程序，这就是操作系统的原型。通过事先启动监控程序，程序员就可以根据需要将各种程序加载到内存中运行。</p>
<p><img src="https://s2.loli.net/2022/03/24/IlqjdzLpksGYJgR.png" alt="image-20220324212332747"></p>
<h3 id="2-添加基本输入输出"><a href="#2-添加基本输入输出" class="headerlink" title="2. 添加基本输入输出"></a>2. 添加基本输入输出</h3><p>由于很多程序都有共通的部分，如果没编写一个新的程序都要记述相同的处理的话，很浪费时间，所以就把基本的输入输出部分的程序追加到了监控程序中。</p>
<p><img src="https://s2.loli.net/2022/03/24/eO3tTkC426cAzLj.png" alt="image-20220324212727454"></p>
<h3 id="3-现代操作系统"><a href="#3-现代操作系统" class="headerlink" title="3. 现代操作系统"></a>3. 现代操作系统</h3><p>操作系统本身并不是单独的程序，而是多个程序的集合体。</p>
<p><img src="https://s2.loli.net/2022/03/24/WojkBhzTEriQNnl.png" alt="image-20220324212803056"></p>
<h2 id="9-2-操作系统的存在"><a href="#9-2-操作系统的存在" class="headerlink" title="9.2 操作系统的存在"></a>9.2 操作系统的存在</h2><p>在操作系统诞生以后，就没有必要再编写直接控制硬件的程序了。这样一来，制作应用的程序员就逐渐同硬件隔离开来了。</p>
<p>但，掌握基本的硬件知识，并借助操作系统进行抽象化，可以大大提高编程效率。</p>
<h3 id="如何控制硬件？"><a href="#如何控制硬件？" class="headerlink" title="如何控制硬件？"></a>如何控制硬件？</h3><p>应用的可执行文件指的是，计算机的CPU可以直接解释并运行的本地代码。不过这些代码是无法直接控制计算机中配置的时钟IC及显示器用的I/O等硬件的。那么，为什么代码清单9-1的应用能够控制硬件呢？</p>
<p>在操作系统这个运行环境下，应用并不是直接控制硬件，而是通过操作系统来间接控制硬件的。</p>
<p>变量定义中涉及的内存的申请分配，以及time()和printf()这些函数的运行结果，都不是面向硬件而是面向操作系统的。操作系统收到应用发出的指令后，首先会对该指令进行解释，然后会对时钟IC（实时时钟[插图]）和显示器用的I/O进行控制。</p>
<p><img src="https://s2.loli.net/2022/03/24/RicNoX28njIQMbf.png" alt="image-20220324213032802"></p>
<h2 id="9-3-系统调用和高级编程语言的移植性"><a href="#9-3-系统调用和高级编程语言的移植性" class="headerlink" title="9.3 系统调用和高级编程语言的移植性"></a>9.3 系统调用和高级编程语言的移植性</h2><h3 id="1-系统调用"><a href="#1-系统调用" class="headerlink" title="1. 系统调用"></a>1. 系统调用</h3><p>操作系统的硬件控制功能，通常是通过一些小的函数集合体的形式来提供的。</p>
<p>这些函数及调用函数的行为统称为系统调用（system call），也就是应用对操作系统（system）的功能进行调用（call）的意思。</p>
<p>在Windows操作系统中，提供返回当前日期和时刻，以及在显示器中显示字符串等功能的系统调用的函数名，并不是time()和printf()。系统调用是在time()和printf()函数的内部执行的。</p>
<h3 id="2-为什么可移植？"><a href="#2-为什么可移植？" class="headerlink" title="2. 为什么可移植？"></a>2. 为什么可移植？</h3><p>高级编程语言的机制就是，使用独自的函数名，然后再在编译时将其转换成相应操作系统的系统调用（也有可能是多个系统调用的组合）。</p>
<p>也就是说，用高级编程语言编写的应用在编译后，就转换成了利用系统调用的本地代码。</p>
<h2 id="9-4-硬件抽象化"><a href="#9-4-硬件抽象化" class="headerlink" title="9.4 硬件抽象化"></a>9.4 硬件抽象化</h2><p>通过使用操作系统提供的系统调用，程序员就没必要编写直接控制硬件的程序了。而且，通过使用高级编程语言，有时甚至也无需考虑系统调用的存在。这是因为操作系统和高级编程语言能够使硬件抽象化。</p>
<h3 id="文件？"><a href="#文件？" class="headerlink" title="文件？"></a>文件？</h3><p>文件是操作系统对磁盘媒介空间的抽象化。</p>
<p>（作为硬件的磁盘媒介，就如同树木的年轮一样，被划分为了多个扇区，并以扇区为单位对磁盘进行读写。如果直接对硬件进行操作的话，那就变成了通过向磁盘用的I/O指定扇区位置来对数据进行读写了。）</p>
<p>磁盘媒介的读写采用了文件这个概念，将整个流程抽象化成了打开文件用的fopen()、写入文件用的fputs()、关闭文件用的fclose()。</p>
<p><img src="https://s2.loli.net/2022/03/24/P8ExlM6eCAyUuNs.png" alt="image-20220324213629602"></p>
<h2 id="9-5-Windows操作系统的特征"><a href="#9-5-Windows操作系统的特征" class="headerlink" title="9.5 Windows操作系统的特征"></a>9.5 Windows操作系统的特征</h2><p>所谓32位操作系统，32位指的是处理效率最高的数据大小。</p>
<h3 id="1-API"><a href="#1-API" class="headerlink" title="1. API"></a>1. API</h3><p>Windows是通过名为API的函数集来提供系统调用的。API是联系应用程序和操作系统之间的接口。所以称为API（Application Programming Interface，应用程序接口）。API通过多个DLL文件来提供。各API的实体都是用C语言编写的函数。</p>
<h3 id="2-多任务"><a href="#2-多任务" class="headerlink" title="2. 多任务"></a>2. 多任务</h3><p>多任务指的是同时运行多个程序的功能。Windows是通过时钟分割技术来实现多任务功能的。时钟分割指的是在短时间间隔内，多个程序切换运行的方式。</p>
<p><img src="https://s2.loli.net/2022/03/24/RE7LGkU6TmNnwxB.png" alt="image-20220324213845895"></p>
<h3 id="3-中间件"><a href="#3-中间件" class="headerlink" title="3. 中间件"></a>3. 中间件</h3><p>网络功能和数据库功能，虽并不是操作系统本身不可欠缺的功能，但因为它们和操作系统很接近，所以被统称为中间件而不是应用。</p>
<p>意思是处于操作系统和应用的中间（middle）。操作系统和中间件合在一起，也称为系统软件。</p>
<p><img src="https://s2.loli.net/2022/03/24/i1TOZtfs8kMEQ9e.png" alt="image-20220324213943480"></p>
<h3 id="4-即插即用"><a href="#4-即插即用" class="headerlink" title="4. 即插即用"></a>4. 即插即用</h3><p>即插即用（Plug-and-Play）指的是新的设备连接（Plug）后立刻就可以使用（Play）的机制。新的设备连接到计算机后，系统就会自动安装和设定用来控制该设备的设备驱动程序。</p>
<p>程序是操作系统、中间件、应用等所有软件的统称。因此，通常程序员制作的应该都是应用，而不是操作系统。不过，既然是应用，那么就肯定会通过某种形式来利用操作系统的功能。</p>
<h1 id="Chapter-10-汇编语言"><a href="#Chapter-10-汇编语言" class="headerlink" title="Chapter 10 汇编语言"></a>Chapter 10 汇编语言</h1><p>助记符：本地代码指令的功能缩写。</p>
<h2 id="10-1-汇编语言和本地代码一一对应"><a href="#10-1-汇编语言和本地代码一一对应" class="headerlink" title="10.1 汇编语言和本地代码一一对应"></a>10.1 汇编语言和本地代码一一对应</h2><p>如果直接打开本地代码看的话，只能看到数值的罗列。如果直接使用这些数值来编写程序的话，不易理解。所以，就在各本地代码中，附带上表示其功能的英语单词的缩写，即助记符，使用助记符的编程语言称为汇编语言。</p>
<p>即使使用汇编语言编写的代码，最终也必须要转换成本地代码才能运行。负责转换工作的程序称为汇编器，转换这一处理本身称为汇编。在将源代码转换成本地代码这个功能方面，汇编器和编译器是同样的。</p>
<h2 id="10-3-伪指令"><a href="#10-3-伪指令" class="headerlink" title="10.3 伪指令"></a>10.3 伪指令</h2><p>汇编语言的源代码，是由转换成本地代码的指令（后面讲述的操作码）和针对汇编器的伪指令构成的。</p>
<p>伪指令负责把程序的构造及汇编的方法指示给汇编器（转换程序）。不过伪指令本身是无法汇编转换成本地代码的。</p>
<p><img src="https://s2.loli.net/2022/03/24/zOEVMsRFBmC6KyA.png" alt="image-20220324221023218"></p>
<h3 id="1-段定义"><a href="#1-段定义" class="headerlink" title="1. 段定义"></a>1. 段定义</h3><p>由伪指令segment和ends围起来的部分，是给构成程序的命令和数据的集合体加上一个名字得到的，称为段定义。</p>
<p>段定义的英文表达segment具有“区域”的意思。在程序中，段定义指的是命令和数据等程序的集合体的意思。一个程序由多个段定义构成。</p>
<h3 id="2-TEXT等"><a href="#2-TEXT等" class="headerlink" title="2. _TEXT等"></a>2. _TEXT等</h3><p>源代码的开始位置，定义了3个名称分别为<code>_TEXT、_DATA、_BSS</code>的段定义。</p>
<p><code>_TEXT</code>是指令的段定义，<code>_DATA</code>是被初始化（有初始值）的数据的段定义，<code>_BSS</code>是尚未初始化的数据的段定义。</p>
<p>类似于这种段定义的名称及划分方法是Borland C++的规定，是由Borland C++的编译器自动分配的。<strong>因而程序段定义的配置顺序就成了<code>_TEXT、_DATA、_BSS</code>，这样也确保了内存的连续性。</strong></p>
<p><strong>group这一伪指令，表示的是把<code>_BSS和_DATA</code>这两个段定义汇总为名为DGROUP的组。</strong></p>
<p>此外，栈和堆的内存空间会在程序运行时生成，</p>
<h3 id="3-整齐的本地代码"><a href="#3-整齐的本地代码" class="headerlink" title="3. 整齐的本地代码"></a>3. 整齐的本地代码</h3><p>围起<code>_AddNum和_MyFun的_TEXT segment和_TEXT ends</code>，表示<code>_AddNum和_MyFunc</code>是属于_TEXT这一段定义的。因此，即使在源代码中指令和数据是混杂编写的，经过编译或者汇编后，也会转换成段定义划分整齐的本地代码。</p>
<p><code>_AddNum proc和_AddNum endp</code>围起来的部分，以及<code>_MyFunc proc和_MyFunc endp</code>围起来的部分，分别表示AddNum函数和MyFunc函数的范围。</p>
<h3 id="4-过程"><a href="#4-过程" class="headerlink" title="4. 过程"></a>4. 过程</h3><p>伪指令proc和endp围起来的部分，表示的是过程（procedure）的范围。在汇编语言中，这种相当于C语言的函数的形式称为过程。末尾的end伪指令，表示的是源代码的结束。</p>
<h2 id="10-2-操作码-操作数"><a href="#10-2-操作码-操作数" class="headerlink" title="10.2 操作码+操作数"></a>10.2 操作码+操作数</h2><p>在汇编语言中，1行表示对CPU的一个指令。</p>
<p>汇编语言指令的语法结构是操作码+操作数（也存在只有操作码没有操作数的指令）。操作码表示的是指令动作，操作数表示的是指令对象。</p>
<h3 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h3><p>CPU内的寄存器是用eax及ebx这些名称来区分的。</p>
<p><img src="https://s2.loli.net/2022/03/24/SsXo7zyPnDTEdMa.png" alt="image-20220324222353929"></p>
<h2 id="10-5-mov指令"><a href="#10-5-mov指令" class="headerlink" title="10.5 mov指令"></a>10.5 mov指令</h2><h3 id="mov-a，b"><a href="#mov-a，b" class="headerlink" title="mov a，b"></a>mov a，b</h3><p><strong>mov指令的两个操作数，分别用来指定数据的存储地和读出源。</strong></p>
<p>操作数中可以指定寄存器、常数、标签（附加在地址前），以及用方括号（[]）围起来的这些内容。</p>
<p><strong>如果指定了没有用方括号围起来的内容，就表示对该值进行处理；如果指定了用方括号围起来的内容，方括号中的值则会被解释为内存地址，然后就会对该内存地址对应的值进行读写操作。</strong></p>
<p><img src="https://s2.loli.net/2022/03/24/MRa1UiNLu6SOzn2.png" alt="image-20220324222506242"></p>
<p>mov ebp, esp中，esp寄存器中的值被直接存储在了ebp寄存器中。esp寄存器的值是100时ebp寄存器的值也是100。</p>
<p>而在mov eax, dword ptr [ebp+8]的情况下，ebp寄存器的值加8后得到的值会被解释为内存地址。</p>
<p>如果ebp寄存器的值是100的话，那么eax寄存器中存储的就是100 + 8=108地址的数据。</p>
<h3 id="dword-ptr"><a href="#dword-ptr" class="headerlink" title="dword ptr"></a>dword ptr</h3><p>dword ptr（double word pointer）表示的是从指定内存地址读出4字节的数据。像这样，有时也会在汇编语言的操作数前附带dword ptr这样的修饰语。</p>
<h2 id="10-6-栈的push和pop"><a href="#10-6-栈的push和pop" class="headerlink" title="10. 6 栈的push和pop"></a>10. 6 栈的push和pop</h2><h3 id="栈的模型"><a href="#栈的模型" class="headerlink" title="栈的模型"></a>栈的模型</h3><p>数据在存储时是从内存的<strong>下层（大的地址编号）逐渐往上层（小的地址编号）累积</strong>，读出时则是按照从上往下的顺利进行。<img src="https://s2.loli.net/2022/03/24/U8rpBat2qVYue6c.png" alt="image-20220324222823432"></p>
<h3 id="push和pop"><a href="#push和pop" class="headerlink" title="push和pop"></a>push和pop</h3><p>push指令和pop指令中只有一个操作数。</p>
<p>该操作数表示的是“push的是什么及pop的是什么”，而不需要指定“对哪一个地址编号的内存进行push或pop”。</p>
<p>这是因为，对栈进行读写的内存地址是由esp寄存器（栈指针）进行管理的。</p>
<p><strong>push指令和pop指令运行后，esp寄存器的值会自动进行更新（push指令是-4, pop命令是+4）。</strong></p>
<h2 id="10-7-函数调用机制"><a href="#10-7-函数调用机制" class="headerlink" title="10.7 函数调用机制"></a>10.7 函数调用机制</h2><p><img src="https://s2.loli.net/2022/03/24/Vbmd6jgt8RuIO4C.png" alt="image-20220324223044548"></p>
<h3 id="3-6"><a href="#3-6" class="headerlink" title="3~6"></a>3~6</h3><p>在C语言的源代码中，虽然记述为函数AddNum(123, 456)，但入栈时则会按照456、123这样的顺序，也就是位于后面的数值先入栈。这是C语言的规定。</p>
<p>(5)的call指令，把程序流程跳转到了操作数中指定的AddNum函数所在的内存地址处。</p>
<p>在汇编语言中，函数名表示的是函数所在的内存地址。</p>
<p>AddNum函数处理完毕后，程序流程必须要返回到编号(6)这一行。</p>
<h4 id="栈清理处理"><a href="#栈清理处理" class="headerlink" title="栈清理处理"></a>栈清理处理</h4><p>(6)部分会把栈中存储的两个参数(456和123)进行销毁处理，也就是栈清理处理。</p>
<p>虽然通过使用两次pop指令也可以实现，不过采用esp寄存器加8的方式会更有效率(处理1次即可)。对栈进行数值的输入输出时，数值的单位是4字节。因此，通过在负责栈地址管理的esp寄存器中加上4的2倍8，就可以达到运行两次pop命令同样的效果。</p>
<p>和运行两次pop命令同样的效果。虽然内存中的数据实际上还残留着，但只要把esp寄存器的值更新为数据存储地址前面的数据位置，该数据也就相当于被销毁了。</p>
<p><img src="https://s2.loli.net/2022/03/24/rU7uWGPznvb3BVq.png" alt="image-20220324232932014"></p>
<h3 id="最优化功能"><a href="#最优化功能" class="headerlink" title="最优化功能"></a>最优化功能</h3><p>最优化功能是编译器在本地代码上费尽功夫实现的，其目的是让编译后的程序运行速度更快、文件更小。</p>
<p>在代码清单10-1中，由于存储着AddNum函数返回值的变量c在后面没有被用到，因此编译器就会认为“该处理没有意义”，进而也就没有生成与之对应的汇编语言代码。</p>
<h2 id="10-8-函数内部的处理"><a href="#10-8-函数内部的处理" class="headerlink" title="10.8 函数内部的处理"></a>10.8 函数内部的处理</h2><p><img src="https://s2.loli.net/2022/03/24/gnIv1SjJ2dpWBXE.png" alt="image-20220324233336246"></p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>ebp寄存器的值在（1）中入栈，在（5）中出栈。</p>
<p>这主要是为了把函数中用到的ebp寄存器的内容，恢复到函数调用前的状态。在进入函数处理之前，无法确定ebp寄存器用到了什么地方，但由于函数内部也会用到ebp寄存器，所以就暂时将该值保存了起来。</p>
<p>CPU拥有的寄存器是有数量限制的。</p>
<p>在函数调用前，调用源有可能已经在使用ebp寄存器了。因而，在函数内部利用的寄存器，要尽量返回到函数调用前的状态。</p>
<p>为此，我们就需要将其暂时保存在栈中，然后再在函数处理完毕之前出栈，使其返回到原来的状态。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>(2)中把负责管理栈地址的esp寄存器的值赋值到了ebp寄存器中。这是因为，在mov指令中方括号内的参数，是不允许指定esp寄存器的。</p>
<p>因此，这里就采用了不直接通过esp，而是用ebp寄存器来读写栈内容的方法。</p>
<h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>(3)是用[ebp+8]指定栈中存储的第1个参数123，并将其读出到eax寄存器中。像这样，不使用pop指令，也可以查看栈的内容。</p>
<p>而之所以从多个寄存器中选择了eax寄存器，是因为eax寄存器是负责运算的累加寄存器。</p>
<h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>通过(4)的add指令，把当前eax寄存器的值同第2个参数相加后的结果存储在eax寄存器中。[ebp+12]是用来指定第2个参数456的。</p>
<p>在C语言中，函数的返回值必须通过eax寄存器返回，这也是规定。不过，和ebp寄存器不同的是，eax寄存器的值不用还原到原始状态。</p>
<p>至此，我们进行了很多细节的说明，其实就是希望大家了解“<strong>函数的参数是通过栈来传递，返回值是通过寄存器来返回的</strong>”这一点。</p>
<h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><p>(6)中ret指令运行后，函数返回目的地的内存地址会自动出栈，据此，程序流程就会跳转返回到代码清单10-4的（6）（Call _AddNum的下一行）。</p>
<h3 id="栈状态变化"><a href="#栈状态变化" class="headerlink" title="栈状态变化"></a>栈状态变化</h3><p>由于（a）状态时处理跳转到AddNum函数，因此（a）和（b）是同样的。同理，在（d）状态时，处理跳转到了调用源，因此（d）和（e）是同样的。在（f）状态时则进行了清理处理。栈的最高位的数据地址，是一直存储在esp寄存器中的。</p>
<p><img src="https://s2.loli.net/2022/03/24/2CfyJbQYeW3ivcq.png" alt="image-20220324233510024"></p>
<h2 id="10-9-始终确保全局变量用的内存空间"><a href="#10-9-始终确保全局变量用的内存空间" class="headerlink" title="10.9 始终确保全局变量用的内存空间"></a>10.9 始终确保全局变量用的内存空间</h2><p>C语言中，在函数外部定义的变量称为全局变量，在函数内部定义的变量称为局部变量。</p>
<p><img src="https://s2.loli.net/2022/03/24/WFJrw3Nbu12Re6D.png" alt="image-20220324234352980"></p>
<p><img src="https://s2.loli.net/2022/03/24/eCMH7byilYdfLct.png" alt="image-20220324234510447"></p>
<p><img src="https://s2.loli.net/2022/03/24/FhQZCzgR4y7VPid.png" alt="image-20220324234601096"></p>
<p>编译后的程序，会被归类到名为段定义的组。初始化的全局变量，会像(2)那样被汇总到名为_BSS的段定义中。</p>
<p>指令则会像(3)那样被汇总到名为_TEXT的段定义中。</p>
<p><code>_DATA segment和_DATA ends、_BSS segment和_BSS ends、_TEXT segment和_TEXT ends</code>，这些都是表示各段定义范围的伪指令。</p>
<h3 id="DATA"><a href="#DATA" class="headerlink" title="_DATA"></a>_DATA</h3><h4 id="4-1"><a href="#4-1" class="headerlink" title="4"></a>4</h4><p>(4)中定义了_a1这个标签。标签表示的是相对于段定义起始位置的位置。由于它在开头位置，所以相对位置是0.</p>
<p>_a1就相当于全局变量a1。编译后的函数名和变量名前会附加一个下划线，这也是Borland C++的规定。</p>
<h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p>(5)中的dd 1指的是，申请分配了4字节的内存空间，存储着1这个初始值。dd(define double word)表示的是顶一个双字(double word)，而每个字的长度是2个字节，也就是申请了一个4字节的内存空间。由于int类型的长度是4字节，因此汇编器就把int a1 = 1；变换成了_a1 label dword和dd 1.</p>
<p>同样，这里定义了全部变量a2~a5的标签，各自的初始值也被存储在了4字节的领域中。</p>
<h3 id="BSS"><a href="#BSS" class="headerlink" title="_BSS"></a>_BSS</h3><p>这里定义了相当于全局变量b1～b5的标签<code>_b1～_b5</code>。</p>
<h4 id="6-1"><a href="#6-1" class="headerlink" title="6"></a>6</h4><p>(6)的db 4 dup(?)表示的是申请分配了4字节的领域，但值尚未确定(这里用？来表示)的意思。db(define byte)表示有1个长度是1字节的内存空间。因而，db 4 dup(? )的情况下，就是4字节的内存空间。</p>
<p>要注意不要和dd 4混淆了。db 4 dup(? )表示的是4个长度是1字节的内存空间。而dd 4表示的则是双字（4 byte）的内存空间中存储的值是4。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在<code>_DATA和_BSS</code>的段定义中，全局变量的内存空间都得到了确保，程序运行时没有初始化的全局变量的领域（_BSS段定义）都会被设定为0进行初始化。</p>
<p>可见，通过汇总，初始化很容易实现，只要把内存的特定范围全部设定为0就可以了。</p>
<h2 id="10-10-临时确保局部变量的内存空间"><a href="#10-10-临时确保局部变量的内存空间" class="headerlink" title="10.10 临时确保局部变量的内存空间"></a>10.10 临时确保局部变量的内存空间</h2><p>局部变量是保存在寄存器和栈中的。</p>
<p>函数内部利用栈，在函数处理完毕后会恢复到初始状态，因此局部变量的值也就被销毁了，而寄存器也可能会被用于其他目的。</p>
<p>因此，局部变量只是在函数处理运行期间临时存储在寄存器和栈上。</p>
<p>在代码清单10-6中定义了10个局部变量。这是为了表示存储局部变量的不仅仅是栈，还有寄存器。为确保c1～c10所需的领域，寄存器空闲时就使用寄存器，寄存器空间不足的话就使用栈。</p>
<h3 id="TEXT"><a href="#TEXT" class="headerlink" title="_TEXT"></a>_TEXT</h3><h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><p>(7)表示的是MyFunc函数的范围。</p>
<p>在MyFunc函数中定义的局部变量所需要的内存领域，会被尽可能地分配在寄存器中。</p>
<p>大家可能会认为用高性能的寄存器来代替普通的内存是很奢侈的事情，不过编译器不会这么认为，只要寄存器有空间，编译器就会使用它。因为与内存相比，使用寄存器时访问速度会高很多，这样就可以更快速地进行处理。</p>
<p>局部变量利用寄存器，是Borland C++编译器最优化的运行结果。旧的编译器没有类似的最优化功能，局部变量就可能会仅仅使用栈。</p>
<h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><p>(8)表示的是往寄存器中分配局部变量的部分。仅仅对局部变量进行定义是不够的，只有在给局部变量赋值时，才会被分配到寄存器的内存区域。（8）就相当于给5个局部变量c1～c5分别赋予数值1～5这一处理。</p>
<p>在这种情况下，寄存器只是被单纯地用于存储变量的值，和其本身的角色没有任何关系。</p>
<p>其中空闲的，最多也只有几个。因而，局部变量数目很多的时候，可分配的寄存器就不够了。这种情况下，局部变量就会申请分配栈的内存空间。</p>
<h4 id="11"><a href="#11" class="headerlink" title="11"></a>11</h4><p>（11）中的mov ebp,esp这一处理，指的是把当前esp寄存器的值复制到ebp寄存器中。之所以需要（11）这一处理，是为了通过在函数出口处的（12）这一move esp, ebp的处理，把esp寄存器的值还原到原始状态，从而对申请分配的栈空间进行释放，这时栈中用到的局部变量就消失了。这也是栈的清理处理。在使用寄存器的情况下，局部变量则会在寄存器被用于其他用途时自动消失</p>
<p><img src="https://s2.loli.net/2022/03/25/NHk9i8DIpCP17Gu.png" alt="image-20220325225716319"></p>
<h4 id="9"><a href="#9" class="headerlink" title="9"></a>9</h4><p>（9）中的mov dword ptr [ebp - 4], 6表示的就是，从申请分配的内存空间的下端（ebp寄存器指示的位置）开始往前4字节的地址（[ebp -4]）中，存储着6这一4字节的数据。</p>
<p><img src="https://s2.loli.net/2022/03/25/XfAdjbv7IWrHShC.png" alt="image-20220325225803158"></p>
<h2 id="10-11-循环处理的实现方法"><a href="#10-11-循环处理的实现方法" class="headerlink" title="10.11 循环处理的实现方法"></a>10.11 循环处理的实现方法</h2><p><img src="https://s2.loli.net/2022/03/25/LFOE9sJIVd1yiqa.png" alt="image-20220325225949853"></p>
<p>在汇编的源代码中，循环是通过比较指令(cmp)和跳转指令(jl)来实现的。</p>
<h3 id="汇编代码解析"><a href="#汇编代码解析" class="headerlink" title="汇编代码解析"></a>汇编代码解析</h3><h4 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h4><p>MyFunc函数中用到的局部变量只有i，变量i申请分配了ebx寄存器的内存空间。for语句的括号中的i=0；被转换成了xor ebx, ebx这一处理。xor指令会对左起第一个操作数和右起第二个操作数进行XOR运算，然后把结果存储在第一个操作数中。(xor这个异或要快于使用mov置零)</p>
<h4 id="jl"><a href="#jl" class="headerlink" title="jl"></a>jl</h4><p>汇编语言中有多个跳转指令，这些跳转指令会根据标志寄存器的值来判定是否需要跳转。</p>
<p>最后一行的jl，是jump on less than（小于的话就跳转）的意思。也就是说，jl short @4的意思就是，前面运行的比较指令的结果若“小”的话就跳转到@4这个标签。</p>
<h2 id="10-12-条件分支的实现方法"><a href="#10-12-条件分支的实现方法" class="headerlink" title="10.12 条件分支的实现方法"></a>10.12 条件分支的实现方法</h2><p><img src="https://s2.loli.net/2022/03/25/35sadGzSF1WuCxN.png" alt="image-20220325230254465"></p>
<h3 id="代码简析"><a href="#代码简析" class="headerlink" title="代码简析"></a>代码简析</h3><p>三种跳转指令，分别是比较结果小或相等时跳转的jle（jump on less or equal）、大或相等时跳转的jge（jump on greater orequal）、不管结果怎样都无条件跳转的jmp。</p>
<h2 id="10-13-程序运行方式"><a href="#10-13-程序运行方式" class="headerlink" title="10.13 程序运行方式"></a>10.13 程序运行方式</h2><p><img src="https://s2.loli.net/2022/03/25/rFd6aVWwhCnvB95.png" alt="image-20220325230503744"></p>
<p>counter <em>=2；这一个指令的部分，在汇编语言源代码，也就是实际运行的程序中，分成了3个指令。如果只是看counter </em>=2；的话，就会以为counter的数值被直接扩大为了原来的2倍。然而，实际上执行的却是“把counter的数值读入eax寄存器”“将eax寄存器的数值变成原来的2倍”“把eax寄存器的数值写入counter”这3个处理。</p>
<h3 id="多线程下的bug"><a href="#多线程下的bug" class="headerlink" title="多线程下的bug"></a>多线程下的bug</h3><p><img src="https://s2.loli.net/2022/03/25/3IpyrhkW9YZJBqc.png" alt="image-20220325230609855"></p>
<h1 id="Chapter-11-硬件控制方法"><a href="#Chapter-11-硬件控制方法" class="headerlink" title="Chapter 11 硬件控制方法"></a>Chapter 11 硬件控制方法</h1><p>所有连接到计算机的外围设备都会分配一个I/O地址编号。</p>
<h2 id="11-2-IN指令和OUT指令"><a href="#11-2-IN指令和OUT指令" class="headerlink" title="11.2 IN指令和OUT指令"></a>11.2 IN指令和OUT指令</h2><p>IN指令通过指定端口号的端口输入数据，并将其存储在CPU内部的寄存器中。OUT指令则是把CPU寄存器中存储的数据，输出到指定端口号的端口。</p>
<p><img src="https://s2.loli.net/2022/03/25/rZUCXkT27Kwb38a.png" alt="image-20220325230816504"></p>
<h3 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I/O控制器"></a>I/O控制器</h3><p>计算机主机中，附带了用来连接显示器及键盘等外围设备的连接器。而各连接器的内部，都连接有用来交换计算机主机同外围设备之间电流特性的IC。这些IC，统称为I/O 控制器。</p>
<p>由于电压不同，数字信号及模拟信号的电流特性也不同，计算机主机和外围设备是无法直接连接的。为了解决这个问题，I/O控制器就很有必要了。</p>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>I/O控制器中有用于临时保存输入输出数据的内存，这个内存就是端口。</p>
<p>I/O寄存器内部的内存，也成为寄存器，用来临时存储数据。</p>
<p>一个I/O控制器既可以控制一个外围设备，也可以控制多个外围设备。各端口之间通过端口号进行区分。端口号也称为I/O地址。</p>
<p>IN指令和OUT指令在端口号指定的端口和CPU之间进行数据的输入输出。这和通过内存地址来进行主内存的读写是一样的道理。</p>
<p><img src="https://s2.loli.net/2022/03/25/pxlUNtISDPGXZje.png" alt="image-20220325231134226"></p>
<p>端口是内存。</p>
<h2 id="11-4-中断请求"><a href="#11-4-中断请求" class="headerlink" title="11.4 中断请求"></a>11.4 中断请求</h2><p>IRQ是用来暂停当前正在执行的程序，并跳转到其他程序运行的必要机制。该机制称为中断处理。</p>
<h3 id="中断编号"><a href="#中断编号" class="headerlink" title="中断编号"></a>中断编号</h3><p>实施中断请求的是连接外围设备的I/O控制器，负责实施中断处理程序的是CPU。</p>
<p>为了进行区分，外围设备的中断请求会使用不同于I/O端口的其他编号，该编号称为中断编号。</p>
<h3 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h3><p>在I/O控制器和CPU中间加入名为中断控制器的IC来进行缓冲。中断控制器会把从多个外围设备发出的中断请求有序地传递给CPU。</p>
<p><img src="https://s2.loli.net/2022/03/25/DWMmlNCHuEQbqFG.png" alt="image-20220325231614331"></p>
<h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><p>中断处理程序的第一步处理，就是把CPU所有寄存器的数值保存到内存的栈中。在中断处理程序中完成外围设备的输入输出后，把栈中保存的数值还原到CPU寄存器中，然后再继续进行对主程序的处理。</p>
<p><img src="https://s2.loli.net/2022/03/25/Ci1rszRGx2cnhIm.png" alt="image-20220325231704128"></p>
<h2 id="11-5-用中断来实现实时处理"><a href="#11-5-用中断来实现实时处理" class="headerlink" title="11.5 用中断来实现实时处理"></a>11.5 用中断来实现实时处理</h2><h2 id="11-6-DMA"><a href="#11-6-DMA" class="headerlink" title="11.6 DMA"></a>11.6 DMA</h2><p>DMA（Direct Memory Access），DMA是指在不通过CPU的情况下，外围设备直接和主内存进行数据传送。</p>
<p>磁盘等都用到了这个DMA机制。通过利用DMA，无需经过CPU，大量数据就可以在短时间内转送到主内存。之所以这么快速，是因为CPU作为中介的时间被节省了。</p>
<p>在资源标签中有DMA设定，可以看出此处该设定为02。</p>
<p>02这个编号称为DMA通道。CPU借助DMA通道，来识别是哪一个外围设备使用了DMA。</p>
<p><img src="https://s2.loli.net/2022/03/25/FyGRcALuqYtD9Nn.png" alt="image-20220325231859355"></p>
<h3 id="识别外围设备"><a href="#识别外围设备" class="headerlink" title="识别外围设备"></a>识别外围设备</h3><p>I/O端口号、IRQ、DMA通道可以说是识别外围设备的3点组合。(不过，IRQ和DMA通道并不是所有的外围设备都必须具备的。)</p>
<p><strong>计算机主机通过软件控制硬件时所需要的信息的最低限，是外围设备的I/O端口号。</strong></p>
<p>IRQ只对需要中断处理的外围设备来说是必需的，DMA通道则只对需要DMA机制的外围设备来说是必需的。</p>
<h2 id="11-7-显示机制"><a href="#11-7-显示机制" class="headerlink" title="11.7 显示机制"></a>11.7 显示机制</h2><p>显示器显示文字及图形的机制</p>
<p>如果用一句话来简单地概括该机制，那就是显示器中显示的信息一直存储在某内存中。</p>
<p>该内存称为VRAM（Video RAM）。在程序中，只要往VRAM中写入数据，该数据就会在显示器中显示出来。</p>
<p>实现该功能的程序，是由操作系统或BIOS提供，并借助中断来进行处理的。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1-%E5%AF%B9%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9D%A5%E8%AF%B4CPU%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.</span> <span class="toc-text">Chapter 1 对程序员来说CPU是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-CPU%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 CPU的内部结构解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">程序运行流程示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">CPU的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">1.1.3.</span> <span class="toc-text">内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.4.</span> <span class="toc-text">运行机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-CPU%E6%98%AF%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E9%9B%86%E5%90%88%E4%BD%93"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 CPU是寄存器的集合体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="toc-number">1.2.1.</span> <span class="toc-text">汇编语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%AD%98%E5%82%A8%E5%86%85%E5%AE%B9"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">寄存器存储内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 程序计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 条件分支和循环机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">1.4.1.</span> <span class="toc-text">跳转指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">标志寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E4%B8%AD%E7%9A%84%E6%AF%94%E8%BE%83-%E5%87%8F%E6%B3%95"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">CPU中的比较&#x3D;减法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 函数的调用机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#call%E6%8C%87%E4%BB%A4%E5%92%8Creturn%E5%91%BD%E4%BB%A4"><span class="toc-number">1.5.1.</span> <span class="toc-text">call指令和return命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%A4%BA"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">图示</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8Ccall%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.1.1.1.</span> <span class="toc-text">执行call指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8Creturn%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.1.1.2.</span> <span class="toc-text">执行return指令</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E9%80%9A%E8%BF%87%E5%9C%B0%E5%9D%80%E5%92%8C%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 通过地址和索引实现数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-CPU%E7%9A%84%E5%A4%84%E7%90%86%E5%85%B6%E5%AE%9E%E5%BE%88%E7%AE%80%E5%8D%95"><span class="toc-number">1.7.</span> <span class="toc-text">1.7 CPU的处理其实很简单</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2-%E6%95%B0%E6%8D%AE%E6%98%AF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E8%A1%A8%E7%A4%BA%E7%9A%84"><span class="toc-number">2.</span> <span class="toc-text">Chapter 2 数据是用二进制数表示的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 二进制表示信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-3-%E5%B0%8F%E6%95%B0%E8%BF%90%E7%AE%97%E5%87%BA%E9%94%99%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.</span> <span class="toc-text">Chapter 3 小数运算出错的原因</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%B0%8F%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 用二进制表示小数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">3.4 什么是浮点数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IEEE%E6%A0%87%E5%87%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">IEEE标准</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EXCESS%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%8E%B0"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">EXCESS系统表现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AE%A1%E7%AE%97%E5%87%BA%E9%94%99"><span class="toc-number">3.3.</span> <span class="toc-text">3.7 如何避免计算机计算出错</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-4-%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8%E6%9C%89%E6%A3%B1%E6%9C%89%E8%A7%92%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">4.</span> <span class="toc-text">Chapter 4 熟练使用有棱有角的内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%86%85%E5%AD%98%E7%9A%84%E9%80%BB%E8%BE%91%E6%A8%A1%E5%9E%8B%E6%98%AF%E6%A5%BC%E6%88%BF"><span class="toc-number">4.1.</span> <span class="toc-text">4.2 内存的逻辑模型是楼房</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%95%B0%E7%BB%84%E6%98%AF%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="toc-number">4.2.</span> <span class="toc-text">4.4 数组是高效使用内存的基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.3.</span> <span class="toc-text">4.5 栈、队列以及环形缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">4.3.1.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">4.3.2.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.3.3.</span> <span class="toc-text">环形缓冲区模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E9%93%BE%E8%A1%A8"><span class="toc-number">4.4.</span> <span class="toc-text">4.6 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">4.4.1.</span> <span class="toc-text">删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E5%8A%A0%E6%93%8D%E4%BD%9C"><span class="toc-number">4.4.2.</span> <span class="toc-text">追加操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">4.5.</span> <span class="toc-text">4.7 二叉查找树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-5-%E5%86%85%E5%AD%98%E5%92%8C%E7%A3%81%E7%9B%98%E7%9A%84%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB"><span class="toc-number">5.</span> <span class="toc-text">Chapter 5 内存和磁盘的亲密关系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E4%B8%8D%E8%AF%BB%E5%85%A5%E5%86%85%E5%AD%98%E5%B0%B1%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 不读入内存就无法运行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%A4%BA-1"><span class="toc-number">5.1.1.</span> <span class="toc-text">图示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98%E5%8A%A0%E5%BF%AB%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 磁盘缓存加快访问速度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%A0%97%E5%AD%90"><span class="toc-number">5.2.1.</span> <span class="toc-text">小栗子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%8A%E7%A3%81%E7%9B%98%E4%BD%9C%E4%B8%BA%E9%83%A8%E5%88%86%E5%86%85%E5%AD%98%E6%9D%A5%E4%BD%BF%E7%94%A8"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 虚拟内存把磁盘作为部分内存来使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#swap"><span class="toc-number">5.3.1.</span> <span class="toc-text">swap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows%E4%B8%8B%E7%9A%84%E5%88%86%E9%A1%B5%E5%BC%8F"><span class="toc-number">5.3.2.</span> <span class="toc-text">Windows下的分页式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98%E7%9A%84%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 节约内存的编程方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87DLL%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E5%85%B1%E6%9C%89"><span class="toc-number">5.4.1.</span> <span class="toc-text">通过DLL文件实现函数共有</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">5.4.1.2.1.</span> <span class="toc-text">优点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%B0%83%E7%94%A8-stdcall%E6%9D%A5%E5%87%8F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">5.4.2.</span> <span class="toc-text">通过调用_stdcall来减小程序文件的大小</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E6%B8%85%E7%90%86%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">栈清理处理指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B-1"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">举例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E7%A3%81%E7%9B%98%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 磁盘的物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows%E4%B8%AD%E7%9A%84%E7%A3%81%E7%9B%98"><span class="toc-number">5.5.1.</span> <span class="toc-text">Windows中的磁盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%B0%87%E4%B8%BA%E5%8D%95%E4%BD%8D"><span class="toc-number">5.5.2.</span> <span class="toc-text">一簇为单位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-6-%E5%B0%9D%E8%AF%95%E5%8E%8B%E7%BC%A9%E6%95%B0%E6%8D%AE"><span class="toc-number">6.</span> <span class="toc-text">Chapter 6 尝试压缩数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%96%87%E4%BB%B6%E4%BB%A5%E5%AD%97%E8%8A%82%E4%B8%BA%E5%8D%95%E4%BD%8D%E4%BF%9D%E5%AD%98"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 文件以字节为单位保存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-RLE%E7%AE%97%E6%B3%95%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 RLE算法的机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%AE%97%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">6.4 哈夫曼算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-%E5%8F%AF%E9%80%86%E5%8E%8B%E7%BC%A9%E5%92%8C%E9%9D%9E%E5%8F%AF%E9%80%86%E5%8E%8B%E7%BC%A9"><span class="toc-number">6.4.</span> <span class="toc-text">6.7 可逆压缩和非可逆压缩</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-7-%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%9C%A8%E4%BD%95%E7%A7%8D%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%BF%90%E8%A1%8C%E7%9A%84"><span class="toc-number">7.</span> <span class="toc-text">Chapter 7 程序是在何种环境中运行的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%A1%AC%E4%BB%B6"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 运行环境&#x3D;操作系统+硬件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-Windows%E5%85%8B%E6%9C%8D%E4%BA%86CPU%E4%BB%A5%E5%A4%96%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%B7%AE%E5%BC%82"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 Windows克服了CPU以外的硬件差异</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E4%B8%8D%E5%90%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84API%E4%B8%8D%E5%90%8C"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 不同操作系统的API不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-FreeBSD-Port"><span class="toc-number">7.4.</span> <span class="toc-text">7.4 FreeBSD Port</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-Java%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">7.5.</span> <span class="toc-text">7.6 Java虚拟机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-BIOS%E5%92%8C%E5%BC%95%E5%AF%BC"><span class="toc-number">7.6.</span> <span class="toc-text">7.7 BIOS和引导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F"><span class="toc-number">7.6.1.</span> <span class="toc-text">引导程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">7.6.2.</span> <span class="toc-text">启动过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-8-%E4%BB%8E%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">8.</span> <span class="toc-text">Chapter 8 从源文件到可执行文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%AA%E8%83%BD%E8%BF%90%E8%A1%8C%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 计算机只能运行本地代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 本地代码的内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E7%BC%96%E8%AF%91%E5%99%A8%E8%B4%9F%E8%B4%A3%E8%BD%AC%E6%8D%A2%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">8.3.</span> <span class="toc-text">8.3 编译器负责转换源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E4%BB%85%E9%9D%A0%E7%BC%96%E8%AF%91%E6%97%A0%E6%B3%95%E5%BE%97%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84"><span class="toc-number">8.4.</span> <span class="toc-text">8.4 仅靠编译无法得到可执行文件的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E5%AE%8C%E6%88%90"><span class="toc-number">8.4.1.</span> <span class="toc-text">未完成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">8.4.2.</span> <span class="toc-text">链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-%E5%90%AF%E5%8A%A8%E5%8F%8A%E5%BA%93%E6%96%87%E4%BB%B6"><span class="toc-number">8.5.</span> <span class="toc-text">8.5 启动及库文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-c0w32-obj"><span class="toc-number">8.5.1.</span> <span class="toc-text">1. c0w32.obj</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BA%93%E6%96%87%E4%BB%B6"><span class="toc-number">8.5.2.</span> <span class="toc-text">2. 库文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%8C%87%E5%AE%9A%E5%91%A2%EF%BC%9F"><span class="toc-number">8.5.3.</span> <span class="toc-text">3. 如果不指定呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0"><span class="toc-number">8.5.3.1.</span> <span class="toc-text">标准函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-DLL%E6%96%87%E4%BB%B6%E5%8F%8A%E5%AF%BC%E5%85%A5%E5%BA%93"><span class="toc-number">8.6.</span> <span class="toc-text">8.6 DLL文件及导入库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%BC%E5%85%A5%E5%BA%93"><span class="toc-number">8.6.1.</span> <span class="toc-text">1. 导入库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#import32-lib"><span class="toc-number">8.6.1.1.</span> <span class="toc-text">import32.lib</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="toc-number">8.6.2.</span> <span class="toc-text">2. 静态链接库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BD%A2%E6%88%90EXE%E8%BF%87%E7%A8%8B"><span class="toc-number">8.6.3.</span> <span class="toc-text">3. 形成EXE过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-number">8.6.4.</span> <span class="toc-text">4. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">8.7.</span> <span class="toc-text">8.7 可执行文件运行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="toc-number">8.7.1.</span> <span class="toc-text">再配置信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E5%9C%B0%E5%9D%80"><span class="toc-number">8.7.1.1.</span> <span class="toc-text">相对地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%A4%BA-2"><span class="toc-number">8.7.1.2.</span> <span class="toc-text">图示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8-%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E6%97%B6%E4%BC%9A%E7%94%9F%E6%88%90%E6%A0%88%E5%92%8C%E5%A0%86"><span class="toc-number">8.8.</span> <span class="toc-text">8.8 程序加载时会生成栈和堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E5%A0%86"><span class="toc-number">8.8.1.</span> <span class="toc-text">栈和堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">8.8.2.</span> <span class="toc-text">内存中的程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E9%87%8A%E6%94%BE"><span class="toc-number">8.8.3.</span> <span class="toc-text">堆和栈的释放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-9-%E4%B8%80%E4%BA%9BQ-amp-A"><span class="toc-number">8.9.</span> <span class="toc-text">8.9 一些Q&amp;A</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-9-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%BA%94%E7%94%A8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">9.</span> <span class="toc-text">Chapter 9 操作系统和应用的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 操作系统功能的历史</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%9B%91%E6%8E%A7%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.1.1.</span> <span class="toc-text">1. 监控程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B7%BB%E5%8A%A0%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">9.1.2.</span> <span class="toc-text">2. 添加基本输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">9.1.3.</span> <span class="toc-text">3. 现代操作系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%98%E5%9C%A8"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 操作系统的存在</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E7%A1%AC%E4%BB%B6%EF%BC%9F"><span class="toc-number">9.2.1.</span> <span class="toc-text">如何控制硬件？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A7%BB%E6%A4%8D%E6%80%A7"><span class="toc-number">9.3.</span> <span class="toc-text">9.3 系统调用和高级编程语言的移植性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">9.3.1.</span> <span class="toc-text">1. 系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E7%A7%BB%E6%A4%8D%EF%BC%9F"><span class="toc-number">9.3.2.</span> <span class="toc-text">2. 为什么可移植？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E7%A1%AC%E4%BB%B6%E6%8A%BD%E8%B1%A1%E5%8C%96"><span class="toc-number">9.4.</span> <span class="toc-text">9.4 硬件抽象化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%EF%BC%9F"><span class="toc-number">9.4.1.</span> <span class="toc-text">文件？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">9.5.</span> <span class="toc-text">9.5 Windows操作系统的特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-API"><span class="toc-number">9.5.1.</span> <span class="toc-text">1. API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%9A%E4%BB%BB%E5%8A%A1"><span class="toc-number">9.5.2.</span> <span class="toc-text">2. 多任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">9.5.3.</span> <span class="toc-text">3. 中间件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8D%B3%E6%8F%92%E5%8D%B3%E7%94%A8"><span class="toc-number">9.5.4.</span> <span class="toc-text">4. 即插即用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-10-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="toc-number">10.</span> <span class="toc-text">Chapter 10 汇编语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%92%8C%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E4%B8%80%E4%B8%80%E5%AF%B9%E5%BA%94"><span class="toc-number">10.1.</span> <span class="toc-text">10.1 汇编语言和本地代码一一对应</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">10.2.</span> <span class="toc-text">10.3 伪指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%AE%B5%E5%AE%9A%E4%B9%89"><span class="toc-number">10.2.1.</span> <span class="toc-text">1. 段定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-TEXT%E7%AD%89"><span class="toc-number">10.2.2.</span> <span class="toc-text">2. _TEXT等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B4%E9%BD%90%E7%9A%84%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">10.2.3.</span> <span class="toc-text">3. 整齐的本地代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BF%87%E7%A8%8B"><span class="toc-number">10.2.4.</span> <span class="toc-text">4. 过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E6%93%8D%E4%BD%9C%E7%A0%81-%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="toc-number">10.3.</span> <span class="toc-text">10.2 操作码+操作数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8-1"><span class="toc-number">10.3.1.</span> <span class="toc-text">寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-mov%E6%8C%87%E4%BB%A4"><span class="toc-number">10.4.</span> <span class="toc-text">10.5 mov指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mov-a%EF%BC%8Cb"><span class="toc-number">10.4.1.</span> <span class="toc-text">mov a，b</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dword-ptr"><span class="toc-number">10.4.2.</span> <span class="toc-text">dword ptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6-%E6%A0%88%E7%9A%84push%E5%92%8Cpop"><span class="toc-number">10.5.</span> <span class="toc-text">10. 6 栈的push和pop</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.5.1.</span> <span class="toc-text">栈的模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push%E5%92%8Cpop"><span class="toc-number">10.5.2.</span> <span class="toc-text">push和pop</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-7-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">10.6.</span> <span class="toc-text">10.7 函数调用机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6"><span class="toc-number">10.6.1.</span> <span class="toc-text">3~6</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E6%B8%85%E7%90%86%E5%A4%84%E7%90%86"><span class="toc-number">10.6.1.1.</span> <span class="toc-text">栈清理处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E5%8C%96%E5%8A%9F%E8%83%BD"><span class="toc-number">10.6.2.</span> <span class="toc-text">最优化功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-8-%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">10.7.</span> <span class="toc-text">10.8 函数内部的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">10.7.1.</span> <span class="toc-text">过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1"><span class="toc-number">10.7.1.1.</span> <span class="toc-text">1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2"><span class="toc-number">10.7.1.2.</span> <span class="toc-text">2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3"><span class="toc-number">10.7.1.3.</span> <span class="toc-text">3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4"><span class="toc-number">10.7.1.4.</span> <span class="toc-text">4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6"><span class="toc-number">10.7.1.5.</span> <span class="toc-text">6</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96"><span class="toc-number">10.7.2.</span> <span class="toc-text">栈状态变化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-9-%E5%A7%8B%E7%BB%88%E7%A1%AE%E4%BF%9D%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">10.8.</span> <span class="toc-text">10.9 始终确保全局变量用的内存空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DATA"><span class="toc-number">10.8.1.</span> <span class="toc-text">_DATA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1"><span class="toc-number">10.8.1.1.</span> <span class="toc-text">4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5"><span class="toc-number">10.8.1.2.</span> <span class="toc-text">5</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BSS"><span class="toc-number">10.8.2.</span> <span class="toc-text">_BSS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1"><span class="toc-number">10.8.2.1.</span> <span class="toc-text">6</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">10.8.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-10-%E4%B8%B4%E6%97%B6%E7%A1%AE%E4%BF%9D%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">10.9.</span> <span class="toc-text">10.10 临时确保局部变量的内存空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TEXT"><span class="toc-number">10.9.1.</span> <span class="toc-text">_TEXT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7"><span class="toc-number">10.9.1.1.</span> <span class="toc-text">7</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8"><span class="toc-number">10.9.1.2.</span> <span class="toc-text">8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11"><span class="toc-number">10.9.1.3.</span> <span class="toc-text">11</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9"><span class="toc-number">10.9.1.4.</span> <span class="toc-text">9</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-11-%E5%BE%AA%E7%8E%AF%E5%A4%84%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">10.10.</span> <span class="toc-text">10.11 循环处理的实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">10.10.1.</span> <span class="toc-text">汇编代码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#xor"><span class="toc-number">10.10.1.1.</span> <span class="toc-text">xor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jl"><span class="toc-number">10.10.1.2.</span> <span class="toc-text">jl</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-12-%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">10.11.</span> <span class="toc-text">10.12 条件分支的实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%AE%80%E6%9E%90"><span class="toc-number">10.11.1.</span> <span class="toc-text">代码简析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-13-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">10.12.</span> <span class="toc-text">10.13 程序运行方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84bug"><span class="toc-number">10.12.1.</span> <span class="toc-text">多线程下的bug</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-11-%E7%A1%AC%E4%BB%B6%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">Chapter 11 硬件控制方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-IN%E6%8C%87%E4%BB%A4%E5%92%8COUT%E6%8C%87%E4%BB%A4"><span class="toc-number">11.1.</span> <span class="toc-text">11.2 IN指令和OUT指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">11.1.1.</span> <span class="toc-text">I&#x2F;O控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3"><span class="toc-number">11.1.2.</span> <span class="toc-text">端口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82"><span class="toc-number">11.2.</span> <span class="toc-text">11.4 中断请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%BC%96%E5%8F%B7"><span class="toc-number">11.2.1.</span> <span class="toc-text">中断编号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">11.2.2.</span> <span class="toc-text">中断控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="toc-number">11.2.3.</span> <span class="toc-text">中断处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-%E7%94%A8%E4%B8%AD%E6%96%AD%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E5%A4%84%E7%90%86"><span class="toc-number">11.3.</span> <span class="toc-text">11.5 用中断来实现实时处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-6-DMA"><span class="toc-number">11.4.</span> <span class="toc-text">11.6 DMA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%86%E5%88%AB%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87"><span class="toc-number">11.4.1.</span> <span class="toc-text">识别外围设备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-7-%E6%98%BE%E7%A4%BA%E6%9C%BA%E5%88%B6"><span class="toc-number">11.5.</span> <span class="toc-text">11.7 显示机制</span></a></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
