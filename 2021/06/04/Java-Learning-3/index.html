
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Java Learning 3 - Sunrise-shine的博客</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="Just do it!,集合常见集合ArrayList是最常用的API，但不是唯一的。
TreeSet 以有序的状态保持并可防止重复。
但是如果没有需要让清单保持有序的状态，TreeSet的成本会比想付出的还要多—-每当插,"> 
    <meta name="author" content="Sunrise-shine"> 
    <link rel="alternative" href="atom.xml" title="Sunrise-shine的博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.4.1"></head>

<body class="loading">
    <span id="config-title" style="display:none">Sunrise-shine的博客</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://Sunrise-shine.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Java Learning 3</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Java Learning 3</h1>
        <div class="stuff">
            <span>六月 04, 2021</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Java-Learning-3/" rel="tag">Java Learning 3</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="常见集合"><a href="#常见集合" class="headerlink" title="常见集合"></a>常见集合</h2><p>ArrayList是最常用的API，但不是唯一的。</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p> 以有序的状态保持并可防止重复。</p>
<p>但是如果没有需要让清单保持有序的状态，TreeSet的成本会比想付出的还要多—-每当插入新项目，都要花时间找到合适的位置，而ArrayList只要把项目放在最后面就好。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>可用成对的name/value来保存与取出</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>针对经常插入或删除中间元素所涉及的高效率集合。（实际上ArrayList还是比较实用）</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>防止重复的集合，可快速地找寻相符的元素。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>类似HashMap，但可记住元素插入的顺序，也可以设定成按照元素上次存取的先后来排序。</p>
<p><img src="https://s2.loli.net/2021/12/26/RjgciyJoDFGkQIN.png" alt="image-20211226110456330"></p>
<h2 id="Perface"><a href="#Perface" class="headerlink" title="Perface"></a>Perface</h2><h3 id="Collections-sort"><a href="#Collections-sort" class="headerlink" title="Collections.sort( )"></a>Collections.sort( )</h3><p>鉴于ArrayList是最常用的集合，而且实现了List接口。恰巧，Collections这个类中存在sort( )方法，要用到List。所以多亏了多态机制，可以把ArrayList传给用到了List的方法。也就是说，可以使用Collections.sort( )方法来实现排序。</p>
<p>当歌曲的类型，由String变为Song时，可以明显发现编译器报错。也就是，ArrayList<String> 和 ArrayList<Song>之间的差异导致。</p>
<p><img src="https://s2.loli.net/2021/12/26/XJNW7FbSmytRw39.png" alt="image-20211226115014403"></p>
<h2 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h2><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><h4 id="泛型意味着更好的类型安全性。"><a href="#泛型意味着更好的类型安全性。" class="headerlink" title="泛型意味着更好的类型安全性。"></a>泛型意味着更好的类型安全性。</h4><p>几乎所有会以泛型写的程序都与处理集合有关。虽然泛型也可以用在其他地方，但它的<strong>主要目的还是让你能够写出有安全类型的集合</strong>。也就是，<strong>让编译器能够帮助防止把Dog加到一群Cat中。</strong></p>
<p>在泛型功能出现之前，编译器无法注意到加入集合中的东西是什么，因为所有的集合都写成处理Object类型，可以把任何东西放进ArrayList中，就类似于ArrayList<Object>。<strong>运用泛型，可以创建类型安全更好的集合</strong>，让问题尽可能在编译器就能抓到。</p>
<p><img src="https://s2.loli.net/2021/12/26/9Ph7AzNUo4eEMCm.png" alt="image-20211226120001237"></p>
<p><img src="https://s2.loli.net/2021/12/26/n6eZXf32TVu5sRK.png" alt="image-20211226120459538"></p>
<h4 id="泛型的本质为参数化类型，即程序中的数据类型被指定为一个参数E-Element-。"><a href="#泛型的本质为参数化类型，即程序中的数据类型被指定为一个参数E-Element-。" class="headerlink" title="泛型的本质为参数化类型，即程序中的数据类型被指定为一个参数E(Element)。"></a>泛型的本质为参数化类型，即程序中的数据类型被指定为一个参数E(Element)。</h4><p><strong>E代表用来创建与初始ArrayList的类型。</strong>在编译时，E会被指定的真正类型所取代(又称为类型参数)。这也是为何add( )这个方法无法加入与E所指定类型不兼容的引用的原因。若创建出ArrayList<Dog>, 则add( )会变成add(Dog o)。</p>
<p>其在定义时，不指明参数类型，在用时确定。</p>
<h3 id="运用泛型的方法"><a href="#运用泛型的方法" class="headerlink" title="运用泛型的方法"></a>运用泛型的方法</h3><p>泛型的类代表类的声明用到类型参数，泛型的方法代表方法的声明特征用到类型参数。</p>
<p>在方法中的类型参数有两种不同的运用方式。</p>
<h4 id="使用定义在类声明的类型参数"><a href="#使用定义在类声明的类型参数" class="headerlink" title="使用定义在类声明的类型参数"></a>使用定义在类声明的类型参数</h4><p><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;...&#123;</code></p>
<p><code>public boolean add(E o)</code> //只能在此使用E，因为已经被定义为类的一部分</p>
<p><code>&#125;</code></p>
<p><strong>当声明类的类型参数时，就可以把该类或接口类型用在任何地方。参数的类型声明基本上会以用来初始化类的类型来取代。</strong></p>
<h4 id="使用未定义在类声明的类型参数"><a href="#使用未定义在类声明的类型参数" class="headerlink" title="使用未定义在类声明的类型参数"></a>使用未定义在类声明的类型参数</h4><p><code>public &lt;T extends Animal&gt; void takeThing(ArrayList&lt;T&gt; list)</code></p>
<p><strong>如果类本身没有使用类型参数，可通过在一个不寻常但可行的位置上指定给方法—-在返回类型之前。这意味着T可以是”任何一种Animal”。</strong></p>
<p>附：</p>
<p><img src="https://s2.loli.net/2021/12/26/l7UROxS1a5siVTu.png" alt="image-20211226122852024"></p>
<h3 id="回到引出的那个问题："><a href="#回到引出的那个问题：" class="headerlink" title="回到引出的那个问题："></a>回到引出的那个问题：</h3><p><img src="https://s2.loli.net/2021/12/26/VPBtOAGQiLpyNm6.png" alt="image-20211226123237186"></p>
<p>也就是说，sort( )方法只能接受Comparable对象的list。而Song不是Comparable的子型，所以不能。</p>
<p>但是，根据String的说明：</p>
<p><code>public final class String extends Object implements Serializable, Comparable&lt;String&gt;, CharSequence...</code></p>
<p>也就是说，<strong>String没有继承过Comparable，只有实现，因为Comparable是个接口</strong>，那为什么会是extends？</p>
<h4 id="以泛型的观点来说，extend代表extend或implement。"><a href="#以泛型的观点来说，extend代表extend或implement。" class="headerlink" title="以泛型的观点来说，extend代表extend或implement。"></a>以泛型的观点来说，extend代表extend或implement。</h4><p><strong>对一个泛型而言，extends这个关键词代表“是一个……”，且不管接口或类都能使用。也就是说，适用于extends和implements。</strong></p>
<h4 id="SO"><a href="#SO" class="headerlink" title="SO"></a>SO</h4><p><strong>Song类必须实现Comparable！</strong></p>
<p>只有在这种情况下，才能把ArrayList<Song>传给sort( )方法，因为这个方法就是如此声明的。况且，也需要确定两个Song如何比较的大小。</p>
<p><img src="https://s2.loli.net/2021/12/26/sMv1TYhmF2oknrd.png" alt="image-20211226124605060"></p>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20211226124953490.png" alt="image-20211226124953490"></p>
<p>但是，如果想用多几种进行排序呢?</p>
<p>可以引出另一种sort( )方法—-取用Comparator参数。</p>
<h4 id="Another"><a href="#Another" class="headerlink" title="Another"></a>Another</h4><p>使用自制的Comparator，这是独立于所比较元素类型之外的——它是独立的类！因此，可以有各种不同的比较方法~~</p>
<p>取用Comparator版的sort( )方法会用Comparator而不是元素内置的CompareTo( )方法来比较顺序。也就是说，如果sort( )方法带有Comparator，就不会调用元素的CompareTo( )，而会去调用Comparator的Compare( )方法。</p>
<p><img src="https://s2.loli.net/2021/12/26/NHnioReGCWIEVJj.png" alt="image-20211226171420009"></p>
<h4 id="处理重复"><a href="#处理重复" class="headerlink" title="处理重复"></a>处理重复</h4><h5 id="LIST：对付顺序的好帮手"><a href="#LIST：对付顺序的好帮手" class="headerlink" title="LIST：对付顺序的好帮手"></a>LIST：对付顺序的好帮手</h5><p>一种知道索引位置的集合。</p>
<p>List直到某物在系列集合中的位置。可以有多个元素引用相同的对象。</p>
<h5 id="SET：注重独一无二的性质"><a href="#SET：注重独一无二的性质" class="headerlink" title="SET：注重独一无二的性质"></a>SET：注重独一无二的性质</h5><p>不允许重复的集合。</p>
<p>知道某物是否已经存在于集合中。不会有多个元素引用相同的对象。</p>
<h5 id="MAP：-用key来搜索的专家。"><a href="#MAP：-用key来搜索的专家。" class="headerlink" title="MAP： 用key来搜索的专家。"></a>MAP： 用key来搜索的专家。</h5><p>使用成对的键值和数据值。</p>
<p>Map会维护与key有关联的值。<strong>两个key可以引用相同的对象，但key不能重复</strong>，典型的key是String，但也可以是其他任何对象。</p>
<blockquote>
<p>泛型规则和限制：</p>
<ul>
<li>泛型的类型参数只能是类类型，不能是简单类型</li>
<li>泛型的参数类型可以有多个，如Map<K, V></li>
<li>泛型的参数类型可以使用extends语句，如<T extends M>，但此处的extends并非继承，而是类型限制，即在M范围内的T。</li>
<li>也可以使用通配符类型，即类似于&lt;? Extends M&gt;，是指在M范围内的某个类型，此处的?代表不定型。</li>
</ul>
</blockquote>
<h3 id="Collection-API"><a href="#Collection-API" class="headerlink" title="Collection API"></a>Collection API</h3><p><strong>接口Collection位于Collection API的最高层，定义了所有底层接口或类的公共方法。</strong></p>
<p><img src="https://s2.loli.net/2021/12/26/34MHN52sn7tSmUO.png" alt="image-20211226175620388"></p>
<p><img src="https://s2.loli.net/2021/12/26/4gLxYnumoHhwtPd.png" alt="image-20211226175744747"></p>
<p>所以，此处<strong>使用HashSet取代ArrayList</strong>。</p>
<h3 id="对象的相等"><a href="#对象的相等" class="headerlink" title="对象的相等"></a>对象的相等</h3><h4 id="引用相等性"><a href="#引用相等性" class="headerlink" title="引用相等性"></a>引用相等性</h4><p>堆上同一个对象的两个引用。</p>
<p>引用到堆上同一个对象的两个引用是相等的。如果对两个引用调用hashCode( )，会得到相同的结果。</p>
<blockquote>
<p>如果没有被覆盖的话，hashCode( )默认的行为会返回每个对象特有的序号(大部分Java版本是依据内存位置计算此序号，所以不会有相同的hashcode。)</p>
</blockquote>
<p><strong>要知道两个引用是否相等，可以使用==来比较变量上的字节组合</strong>。如果是相同的对象，字节组合也一样。</p>
<h4 id="对象相等性"><a href="#对象相等性" class="headerlink" title="对象相等性"></a>对象相等性</h4><p>堆上的不同两个对象在意义上是相同的。</p>
<p>如果你想要把两个不同的Song对象视为相等的,就必须覆盖过从Object继承下来的hashCode( )方法与equals()方法。就因为上面所说的内存计算问题, 所以你必须覆盖过hashCode( )才能确保两个对象有相同的hashcode, 也要确保以另一个对象为参数的equals( )调用会返回true。</p>
<p><img src="https://s2.loli.net/2021/12/26/rNl1MoT3asIdGPA.png" alt="image-20211226181219247"></p>
<p><img src="https://s2.loli.net/2021/12/26/ylYvh4RZu2q6CMI.png" alt="image-20211226181200357"></p>
<p><img src="https://s2.loli.net/2021/12/26/MFyzxri8KOEkcDW.png" alt="image-20211226181806418"></p>
<p><img src="https://s2.loli.net/2021/12/26/vMrlW1eN4mhXkwn.png" alt="image-20211226182244389"></p>
<p>API文件有对对象的状态制定出必须遵守的规则:</p>
<p>(1）如果两个对象相等,则hashcode必须也是相等的。</p>
<p>(2）如果两个对象相等, 对其中一个对象调用equals()必须返回true。也就是说,若a.equals(b).则b.equals(a).</p>
<p>(3）如果两个对象有相同的hashcode值, 它们也不一定是相等的。但若两个对象相等, 则hashcode值一定是相等的。</p>
<p>(4）若equals()被覆盖过，则hashCode()也必须被覆盖。</p>
<p>(5) hashCode()的默认行为是对在heap上的对象产生独特的值。如果你没有override过hashCode(),则该class的两个对象怎样都不会被认为是相同的。</p>
<p>(6)equals()的默认行为是执行==的比较。也就是说会去测试两个引用是否对上heap上同一个对象。如果equals()没有被覆盖过,两个对象永远都不会被视为相同的,因为不同的对象有不同的字节组合。</p>
<p><img src="https://s2.loli.net/2021/12/26/BSQdlC9kRIVxru1.png" alt="image-20211226182512343"></p>
<h4 id="Something-About-TreeSet"><a href="#Something-About-TreeSet" class="headerlink" title="Something About TreeSet"></a>Something About TreeSet</h4><p><img src="https://s2.loli.net/2021/12/26/gIQXAxSnyqZz5v2.png" alt="image-20211226182608504"></p>
<p><img src="https://s2.loli.net/2021/12/26/PkmZnsKwjTtXGaQ.png" alt="image-20211226185927531"></p>
<h4 id="1-Collection-接口"><a href="#1-Collection-接口" class="headerlink" title="1. Collection 接口"></a>1. Collection 接口</h4><h5 id="常用的方法："><a href="#常用的方法：" class="headerlink" title="常用的方法："></a>常用的方法：</h5><p>​    boolean add(E obj)</p>
<p>​    boolean isEmpty()</p>
<p>​    Iterator<E> iterator() : 获取手机的Iterator接口实例</p>
<p>​    Object[] toArray() : 将收集变为对象数组</p>
<h5 id="关于Iterator接口"><a href="#关于Iterator接口" class="headerlink" title="关于Iterator接口:"></a>关于Iterator接口:</h5><ol>
<li><p>boolean hasNext(): 是否存在下一个元素</p>
</li>
<li><p>Object next(): 返回要访问的下一个元素，若无，引发异常</p>
</li>
</ol>
<h4 id="2-Set-接口"><a href="#2-Set-接口" class="headerlink" title="2. Set 接口"></a>2. Set 接口</h4><p>特点：不含重复元素，且无序，其中的SortedSet接口用于描述按“自然顺序”组织元素的收集，即其中对象有序。</p>
<p>其判断集合中重复元素的标准为按对象值比较，即使用equals()方法。</p>
<p>迭代器：Iterator it = Set.iterator();</p>
<h4 id="3-List-接口"><a href="#3-List-接口" class="headerlink" title="3. List 接口"></a>3. List 接口</h4><p>特点：其中可含重复元素，且有序。包括ArrayList与LinkedList两个类。</p>
<p>常用方法：</p>
<p>​    void add(E e) : 在尾部添加元素</p>
<p>​    void add(int pos, E e) : 在指定位置添加元素</p>
<p>​    E get(int pos) : 返回指定位置的元素</p>
<p>​    E set(int pos, E e) : 更改指定位置的元素</p>
<p>​    E remove(int pos) : 删除指定位置的元素</p>
<p>ArrayList 与 LinkedList区别：</p>
<p>​    前者使用数组存储元素，可以实现快速访问元素；后者使用双向链表，可以实现快速插入，删除元素。</p>
<h4 id="4-Map-接口"><a href="#4-Map-接口" class="headerlink" title="4. Map 接口"></a>4. Map 接口</h4><h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><p>public Set<K> keySet(): 关键字的集合</p>
<p>public Collection<V> values() : 值的集合</p>
<p>public Set<Map.Entry<K, V> &gt;entrySet : 关键字和值的映射关系的集合</p>
<p>public V get(K key) : 获取关键字对应的值</p>
<p>public V put(K key, V val) : 加入新的映射；若已经存在，修改映射的值，返回原映射的值，否则，返回null</p>
<p>public V remove(Object key) : 删除关键字多对应的映射，返回值同上。</p>
<p>public boolean equals(Object obj) : 判断Map对象与参数对象是否等价，两个相同的Map，其映射关系集合应当一致</p>
<p>public boolean containsKey(Object key): 是否存在于关键值匹配的映射关系</p>
<p>public boolean containsValues(Object value) : 是否存在与键值匹配的映射关系</p>
<h6 id="另："><a href="#另：" class="headerlink" title="另："></a>另：</h6><p>​    <code>通过与Set接口的结合，可以实现由值取关键字。即首先将关键字通过keySet()提取出来进入Set s中，而后通过迭代器for(Iterator it = s.iterator();it.hasNext();),  匹配m.get(it.next()).equals(V value)或 for(T s : s) 遍历(T为Set中元素的数据类型），m.get(s).equals(V value)来查找值对应的关键字</code></p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在普通数组的情况下，Dogs[ ]可以调用Animals[ ]的方法，即可以将其作为参数传入以Animal为参数的方法中。</p>
<p>但在泛型中，这是不允许的。</p>
<p>吃个栗子：<img src="https://s2.loli.net/2021/12/26/MVXCheT5z6G8LQ3.png" alt="image-20211226192723304"></p>
<p>很显然的是，就普通数组而言，不可调用add方法，也就是说，不会出现这种添加情况，编译不会通过。但泛型中存在这种情况，如果允许Dogs[ ]传入，会导致在dog中混入一只cat，这显然不合理。</p>
<p>其实，数组也能进行相应的操作的哦。</p>
<p><strong>数组的类型是在运行期间检查的，但集合的类型检查只会发生在编译期间。</strong></p>
<p>这也就是为何数组这样操作，可以逃过编译(但运行的时候会出错)，而集合却不能。</p>
<p>如果把方法的参数设定为ArrayList<Animal>，那么Array<Cat>和Array<Dog>都不可用。</p>
<h3 id="万用字符"><a href="#万用字符" class="headerlink" title="万用字符"></a>万用字符</h3><p>这样设定方法的参数为ArrayList<Animal>时，就可以接收Animal子型参数了。</p>
<p><img src="https://s2.loli.net/2021/12/26/nwfPWjNJMEtukZ9.png" alt="image-20211226194114402"></p>
<p>但是，注意：</p>
<p><strong>在这种情况下，只能使用list中任何元素的方法，不能在list中新增元素!!!</strong></p>
<p>也就是说，可以操作集合元素，但不能新增集合元素。如此才能保障执行期间的安全性，因为编译器会阻止执行期的恐怖行动。</p>
<p><code>for(Animal a:animals) &#123;</code></p>
<p><code>a.eat();&#125; //可以的</code></p>
<p><code>for (Animal a:animals) &#123;</code> </p>
<p><code>a.add(new Cat());&#125;// 不可以！</code></p>
<p><img src="https://s2.loli.net/2021/12/26/HYxVAqajiUOR1cl.png" alt="image-20211226194715004"></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">1.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88"><span class="toc-number">1.1.</span> <span class="toc-text">常见集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet"><span class="toc-number">1.1.1.</span> <span class="toc-text">TreeSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">1.1.2.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList"><span class="toc-number">1.1.3.</span> <span class="toc-text">LinkedList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet"><span class="toc-number">1.1.4.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap"><span class="toc-number">1.1.5.</span> <span class="toc-text">LinkedHashMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Perface"><span class="toc-number">1.2.</span> <span class="toc-text">Perface</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collections-sort"><span class="toc-number">1.2.1.</span> <span class="toc-text">Collections.sort( )</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">Java泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E4%B9%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">意义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%84%8F%E5%91%B3%E7%9D%80%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E6%80%A7%E3%80%82"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">泛型意味着更好的类型安全性。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%8D%B3%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A2%AB%E6%8C%87%E5%AE%9A%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0E-Element-%E3%80%82"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">泛型的本质为参数化类型，即程序中的数据类型被指定为一个参数E(Element)。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">运用泛型的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9A%E4%B9%89%E5%9C%A8%E7%B1%BB%E5%A3%B0%E6%98%8E%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">使用定义在类声明的类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%AA%E5%AE%9A%E4%B9%89%E5%9C%A8%E7%B1%BB%E5%A3%B0%E6%98%8E%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">使用未定义在类声明的类型参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%88%B0%E5%BC%95%E5%87%BA%E7%9A%84%E9%82%A3%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">1.3.3.</span> <span class="toc-text">回到引出的那个问题：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%A7%82%E7%82%B9%E6%9D%A5%E8%AF%B4%EF%BC%8Cextend%E4%BB%A3%E8%A1%A8extend%E6%88%96implement%E3%80%82"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">以泛型的观点来说，extend代表extend或implement。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SO"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">SO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Another"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">Another</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E9%87%8D%E5%A4%8D"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">处理重复</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LIST%EF%BC%9A%E5%AF%B9%E4%BB%98%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%A5%BD%E5%B8%AE%E6%89%8B"><span class="toc-number">1.3.3.4.1.</span> <span class="toc-text">LIST：对付顺序的好帮手</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SET%EF%BC%9A%E6%B3%A8%E9%87%8D%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.3.3.4.2.</span> <span class="toc-text">SET：注重独一无二的性质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MAP%EF%BC%9A-%E7%94%A8key%E6%9D%A5%E6%90%9C%E7%B4%A2%E7%9A%84%E4%B8%93%E5%AE%B6%E3%80%82"><span class="toc-number">1.3.3.4.3.</span> <span class="toc-text">MAP： 用key来搜索的专家。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection-API"><span class="toc-number">1.3.4.</span> <span class="toc-text">Collection API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E7%AD%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">对象的相等</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89%E6%80%A7"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">引用相等性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89%E6%80%A7"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">对象相等性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Something-About-TreeSet"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">Something About TreeSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Collection-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">1. Collection 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.3.5.4.1.</span> <span class="toc-text">常用的方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EIterator%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.5.4.2.</span> <span class="toc-text">关于Iterator接口:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Set-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.5.5.</span> <span class="toc-text">2. Set 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-List-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.5.6.</span> <span class="toc-text">3. List 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Map-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.5.7.</span> <span class="toc-text">4. Map 接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.3.6.</span> <span class="toc-text">常用方法：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%A6%EF%BC%9A"><span class="toc-number">1.3.6.0.0.1.</span> <span class="toc-text">另：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.3.7.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%87%E7%94%A8%E5%AD%97%E7%AC%A6"><span class="toc-number">1.3.8.</span> <span class="toc-text">万用字符</span></a></li></ol></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
