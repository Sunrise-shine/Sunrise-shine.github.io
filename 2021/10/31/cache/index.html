
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>cache - Sunrise-shine的博客</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="Just do it!,cache存储器一  背景在计算机系统中，CPU的工作速度远超主存储器的工作速度。一方面，因为高速的静态存储器芯片因为容量小且价格高，并不适合组成大容量的主存储器，故而主存储器一般采用动态存储器实现,"> 
    <meta name="author" content="Sunrise-shine"> 
    <link rel="alternative" href="atom.xml" title="Sunrise-shine的博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.4.1"></head>

<body class="loading">
    <span id="config-title" style="display:none">Sunrise-shine的博客</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://Sunrise-shine.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">cache</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">cache</h1>
        <div class="stuff">
            <span>十月 31, 2021</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag">计算机组成原理</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="cache存储器"><a href="#cache存储器" class="headerlink" title="cache存储器"></a>cache存储器</h1><h2 id="一-背景"><a href="#一-背景" class="headerlink" title="一  背景"></a>一  背景</h2><p>在计算机系统中，CPU的工作速度远超主存储器的工作速度。一方面，因为高速的静态存储器芯片因为容量小且价格高，并不适合组成大容量的主存储器，故而主存储器一般采用动态存储器实现。但由于其读取速度慢，一定程度上限制了CPU的工作速度。另一方面，通过大量统计发现，程序对存储空间的90%的访问局限于存储空间10%的区域，另外10%的访问则分布在存储空间的90%的区域中。</p>
<p>所谓，时势造英雄。为了中和CPU和主存之间速度的不匹配，诞生了cache这一重要的技术。</p>
<h2 id="二-简介"><a href="#二-简介" class="headerlink" title="二  简介"></a>二  简介</h2><h3 id="1-功能"><a href="#1-功能" class="headerlink" title="1  功能"></a>1  功能</h3><p>cache是介于CPU和主存之间的小容量存储器，存取速度比主存块。它能高速地向CPU提供指令和数据，加快程序的执行速度。它的内容为主存一部分内容的副本。当储存器收到读取指令时，先在cache中查找此信息是否存在，若有，则不经主存，直接从cache中取出，否则直接从主存中取出，同时写出cache，以备再次使用。</p>
<h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2  原理"></a>2  原理</h3><p>CPU与cache之间的数据交换是==以字为单位==，而cache与主存之间的数据交换是==以块为单位==。一个块由若干定长字组成。当CPU读取主存中的一个字时，便发出<strong>此字的地址到cache和主存</strong>。此时cache控制逻辑，依据地址判断此字是否在cache中，若是，此字立即传送给CPU；若非，则用主存读周期把此字从主存读出送到CPU，与此同时，把含有这个字的<strong>整个数据块</strong>从主存读出送到cache中。</p>
<h3 id="3-工作过程"><a href="#3-工作过程" class="headerlink" title="3  工作过程"></a>3  工作过程</h3><p>1.当CPU执行访问指令时，将所要访问的字的地址送到相联存储器(cam)中和主存。</p>
<p>2.在相联存储器中进行地址查找，若相联存储器指出，所要访问的字W在cache中(命中)，则把W直接由cache送入CPU；反之(不命中)，则从主存中读取W，送入CPU，顺便把包含W在内的4个字(一个块)送入cache。(分配给cache的地址，保存在相联存储器(cam)中，它是按照内容寻址的。)</p>
<h3 id="4-cache的命中率"><a href="#4-cache的命中率" class="headerlink" title="4  cache的命中率"></a>4  cache的命中率</h3><p>增加cache的目的，就是在性能上使主存的平均读出时间尽可能接近cache的读出时间。因此，cache的命中率应接近于1。在一个程序执行期间，设Nc表示cache完成存取的次数，Nm表示主存完成存取的总次数，H定义为命中率，则有：</p>
<script type="math/tex; mode=display">
H=Nc/(Nc+Nm)</script><p>若tc表示命中时cache访问时间，tm表示未命中时的主存访问时间，则cache/贮存系统的平均访问时间ta为：</p>
<script type="math/tex; mode=display">
ta=tc*H+(1-H)*tm</script><script type="math/tex; mode=display">
r=tm/tc表示主存慢于cache的倍率，e=tc/ta表示访问效率</script><p>为提高访问效率，命中率H越接近于1越好，r值以5-10为宜，不宜过大。</p>
<p>注：</p>
<ul>
<li>命中率与程序的行为、cache的容量、组织方式、块的大小有关。</li>
<li>程序的行为：程序顺序执行最佳。</li>
<li>cache的容量：容量越大，可存放的部分复本越多，调进调出的动作少。</li>
<li>组织方式：cache与主存的相连方式影响调进调出的次数。</li>
<li>块的大小：块太小，块太大都影响调进调出的次数。</li>
</ul>
<h3 id="5-主存与cache的地址映射"><a href="#5-主存与cache的地址映射" class="headerlink" title="5  主存与cache的地址映射"></a>5  主存与cache的地址映射</h3><p>cache的容量很小，它保存的内容只是主存内容的一个子集，且cache与主存的数据交换是以块为单位。</p>
<p>地址映射即是应用某种方法把主存地址定位到cache中。地址映射的方式有<strong>全相联方式、直接映射方式和组相联方式三种。</strong></p>
<h4 id="1-全相联方式"><a href="#1-全相联方式" class="headerlink" title="1. 全相联方式"></a>1. 全相联方式</h4><p>主存中的一个<strong>块的地址与块的内容</strong>一起存于cache的行中，其中<strong>块地址存于cache行的标记部分</strong>中，是由于此种方式，内存中的块可以映射到cache任意一行中。块的大小 = 行的大小。但注意，若以内存一块256字为例，则cache一行长度不仅保存了内存的地址，还有该地址对应的内容，即其实保存了521字的内容，但其可用大小应为256×行数。因为地址固定时，内容就固定了，没有可变性，故而不能是521×块数，没有那么多可用的。由于其电路设计复杂，更多用于小容量cache。<img src="https://s2.loli.net/2021/12/22/dmGe41p2RknPCAt.png" alt="image-20211031151344855"></p>
<h4 id="2-直接映射方式"><a href="#2-直接映射方式" class="headerlink" title="2. 直接映射方式"></a>2. 直接映射方式</h4><p>这也是一种多对一的映射关系，但一个主存块只能拷贝到cache的一个特定行位置上去。cache的行号i和主存的块号j有如下函数关系：</p>
<script type="math/tex; mode=display">
i=j (mod) m(m为cache的行数)</script><p><img src="https://s2.loli.net/2021/12/22/2AgZ6BmErHPQC1M.png" alt="image-20211031151518192"></p>
<p>注意比较的顺序，另外由于几个内存块对应同一行，容易发生空间冲突。适合于大容量cache。</p>
<h4 id="3-组相联映射"><a href="#3-组相联映射" class="headerlink" title="3.组相联映射"></a>3.组相联映射</h4><p>将cache分为u组，每组v行，主存块存放到哪个组是固定的(直接映射方式)，至于存放到该组哪一行，是灵活的(全相联映射方式)。</p>
<p><img src="https://s2.loli.net/2021/12/22/btAswxjhvFGR92y.png" alt="image-20211031152253327"></p>
<p>注意比较的顺序。</p>
<h3 id="6-替换策略"><a href="#6-替换策略" class="headerlink" title="6  替换策略"></a>6  替换策略</h3><p>cache的工作原理要求其尽可能保存最新的数据，则必然存在将有用的信息从主存调入cache，这样就产生替换。</p>
<blockquote>
<p><strong><em>针对直接映射的cache来说，因为其在cache中的位置是固定的，故而只需把特定位置上的原主存块换出cache即可，将新增信息调进即可。</em></strong></p>
</blockquote>
<p>对<strong>全相联和组相联的cache而言</strong>，就要从允许存放新主存块的若干特定行中选取一行换出，这就涉及到常用的替换算法了。</p>
<h4 id="1-最不长使用法-类似队列先进先出-："><a href="#1-最不长使用法-类似队列先进先出-：" class="headerlink" title="1.最不长使用法(类似队列先进先出)："></a>1.最不长使用法(类似队列先进先出)：</h4><p>将一段时间内，访问次数最少的那行数据换出。即每行设置一计数器，每访问一次，就增加一次计数，最后替换计数最小的一行。</p>
<h4 id="2-近期最少使用法-LRU"><a href="#2-近期最少使用法-LRU" class="headerlink" title="2.近期最少使用法(LRU):"></a>2.近期最少使用法(LRU):</h4><p>将近期长久未被访问过的那行数据换出。即每行设置一计数器，每访问一次，就将所访问者计数器清零，其他计数值加1，最后替换计数最大的一行(可用<em>标记许久未使用的行，<em>*常用</em></em>)。</p>
<h3 id="7-cache的写操作策略"><a href="#7-cache的写操作策略" class="headerlink" title="7  cache的写操作策略"></a>7  cache的写操作策略</h3><p>CPU对cache的写入，更改了cache的内容。为保持主存与cache中信息的一致性，避免CPU在读写过程中，将cache中的新数据遗失，造成错误的读数据，确保cache中数据不会因覆盖而消失，必须将cache中的数据更新及时反映到主存中。</p>
<p>可选用三种写操作策略，以使cache内容和主存内容保持一致。</p>
<h4 id="1-写回法-回写式"><a href="#1-写回法-回写式" class="headerlink" title="1.写回法(回写式)"></a>1.写回法(回写式)</h4><p>​    当CPU写cache命中时，只修改cache内容，而不立即写入内存，只有当此行(块)被换出时，才写回内存。</p>
<p>这种方法减少了CPU访问内存的次数，但存在内存不一致的隐患。</p>
<p>实现这种方法时，每一个cache须设置一个修改位，以反映此行是否被CPU修改过。(常用)</p>
<h4 id="2-全写法-直写式"><a href="#2-全写法-直写式" class="headerlink" title="2.全写法(直写式)"></a>2.全写法(直写式)</h4><p>​    当写cache命中时，cache与主存同时发生写修改，因而较好维护了cache与主存内容的一致性。</p>
<p>当写cache未命中时，直接向主存中写入。cache每行无需设置修改位以及相应的判断逻辑。此时可将修改内容调进cache中，也可不调进。</p>
<p>减弱了cache的效果。</p>
<h4 id="3-写一次法-缓冲直写式"><a href="#3-写一次法-缓冲直写式" class="headerlink" title="3.写一次法(缓冲直写式)"></a>3.写一次法(缓冲直写式)</h4><p>两种方法的结合。写命中与写未命中与写回法相同。只是第一次写命中时，会启动一个存储写周期，即同时写入主存，而其他cache块监听到此周期时，也顺便更新自身该数据块数据。便于维护系统中所有cache的一致性。(奔腾CPU采用)</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#cache%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">cache存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E8%83%8C%E6%99%AF"><span class="toc-number">1.1.</span> <span class="toc-text">一  背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.</span> <span class="toc-text">二  简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.1.</span> <span class="toc-text">1  功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.2.</span> <span class="toc-text">2  原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">3  工作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-cache%E7%9A%84%E5%91%BD%E4%B8%AD%E7%8E%87"><span class="toc-number">1.2.4.</span> <span class="toc-text">4  cache的命中率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BB%E5%AD%98%E4%B8%8Ecache%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-number">1.2.5.</span> <span class="toc-text">5  主存与cache的地址映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%A8%E7%9B%B8%E8%81%94%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">1. 全相联方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2. 直接映射方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">3.组相联映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.6.</span> <span class="toc-text">6  替换策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%80%E4%B8%8D%E9%95%BF%E4%BD%BF%E7%94%A8%E6%B3%95-%E7%B1%BB%E4%BC%BC%E9%98%9F%E5%88%97%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA-%EF%BC%9A"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">1.最不长使用法(类似队列先进先出)：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%91%E6%9C%9F%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E6%B3%95-LRU"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">2.近期最少使用法(LRU):</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-cache%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.7.</span> <span class="toc-text">7  cache的写操作策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%99%E5%9B%9E%E6%B3%95-%E5%9B%9E%E5%86%99%E5%BC%8F"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">1.写回法(回写式)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%A8%E5%86%99%E6%B3%95-%E7%9B%B4%E5%86%99%E5%BC%8F"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">2.全写法(直写式)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%86%99%E4%B8%80%E6%AC%A1%E6%B3%95-%E7%BC%93%E5%86%B2%E7%9B%B4%E5%86%99%E5%BC%8F"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">3.写一次法(缓冲直写式)</span></a></li></ol></li></ol></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
