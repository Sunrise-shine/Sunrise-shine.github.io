<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>After-reading</title>
    <url>/2021/12/12/After-reading/</url>
    <content><![CDATA[<h1 id="认知觉醒"><a href="#认知觉醒" class="headerlink" title="认知觉醒"></a>认知觉醒</h1><h2 id="上篇"><a href="#上篇" class="headerlink" title="上篇"></a>上篇</h2><h3 id="第一章-大脑：一切问题的根源"><a href="#第一章-大脑：一切问题的根源" class="headerlink" title="第一章 大脑：一切问题的根源"></a>第一章 大脑：一切问题的根源</h3><h4 id="第一节-大脑：重新认识你自己"><a href="#第一节-大脑：重新认识你自己" class="headerlink" title="第一节 大脑：重新认识你自己"></a>第一节 大脑：重新认识你自己</h4><p>大脑主要包括本能脑(约3.6亿年)、情绪脑(约2亿年)和理智脑(约250万年)。</p>
<p>由于理智脑出现时间最短，对大脑的掌控能力很弱，所以，<strong>我们在生活中做的大部分决策，往往源于本能和情绪，而非理智</strong>。</p>
<p>情绪脑和本能脑，是为了适应远古时期的生活，而具有目光短浅和及时满足的特性。</p>
<h5 id="突出的"><a href="#突出的" class="headerlink" title="突出的"></a>突出的</h5><ul>
<li><strong>趋易避难</strong>——只做简单和舒适的事，喜欢在核心区域周边打转，待在舒适区内逃避真正的困难。</li>
<li><strong>急于求成</strong>——凡事希望立即看到结果，对不能马上看到结果的事往往缺乏耐心，非常容易放弃。</li>
</ul>
<p>这就导致，<strong>大多数时候，我们以为自己在思考，其实都是在对自身的行为和欲望合理化。</strong></p>
<p>习惯之所以难以改变，就是因为他是自我巩固的——越用越强，越强越用。要想从既有的习惯中跳出俩，最好的方法不是依靠自制力，而是依靠知识。</p>
<h4 id="第二节-焦虑：焦虑的根源"><a href="#第二节-焦虑：焦虑的根源" class="headerlink" title="第二节 焦虑：焦虑的根源"></a>第二节 焦虑：焦虑的根源</h4><p>事实上，我们应该跟过去的自己比，哪怕好那么一点点，也是值得的。而不是要去跟所谓的成功人士比。</p>
<h5 id="焦虑的几种形式"><a href="#焦虑的几种形式" class="headerlink" title="焦虑的几种形式"></a>焦虑的几种形式</h5><ul>
<li>完成焦虑。日程安排太慢，每天都活在deadline前。</li>
<li>定位焦虑。在零基础阶段就知识该领域的能人们现在的所作所为。</li>
<li>选择焦虑。想做的事情太多，选择太多。</li>
<li>环境焦虑。有些事不想做，却必须花大量的时间去做。有些事想做却做不了。</li>
<li>难度焦虑。有些东西就是很难学。真正能让你变强的东西，其核心困难是无法回避的。</li>
</ul>
<h5 id="焦虑的根源"><a href="#焦虑的根源" class="headerlink" title="焦虑的根源"></a>焦虑的根源</h5><p>焦虑的原因，就两条：<strong>想同时做很多事，又想立即看到效果</strong>。自己的欲望大于能力，又极度缺乏耐心。</p>
<ul>
<li>急于求成：想同时做很多事</li>
<li>避难趋易：想不怎么努力就看到结果</li>
</ul>
<h5 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h5><ul>
<li>克制欲望，不要让自己同时做很多事</li>
<li>面对现实，看清自己真实的能力水平</li>
<li>要事优先，想办法只做最重要的事</li>
<li>接受环境，在局限中做力所能及的事</li>
<li>直面核心，狠狠逼自己一把去突破它</li>
</ul>
<h4 id="第三节-耐心：得耐心者得天下"><a href="#第三节-耐心：得耐心者得天下" class="headerlink" title="第三节 耐心：得耐心者得天下"></a>第三节 耐心：得耐心者得天下</h4><p><strong>要想有所成就，必须保持耐心，延迟满足。</strong>要想保持出色，就必须经受长时间的磨练。</p>
<h5 id="原因和规律"><a href="#原因和规律" class="headerlink" title="原因和规律"></a>原因和规律</h5><p>很多时候，我们对困难事物缺乏耐心是因为看不到全局、不知道自己身在何处，所以总拿着天性这把短视之尺去到处衡量。牢记复利曲线。<img src="https://s2.loli.net/2021/12/22/36EnLCdeK9V2suZ.png" alt="image-20211212153853571"></p>
<p>无论个体还是群体，其能力都以”舒适区—拉伸区—困难区“的形式分布。要想让自己高效成长，必须让自己始终处于舒适区的边缘。</p>
<p><img src="https://s2.loli.net/2021/12/22/OHVMN58ufSXTktL.png" alt="image-2127"></p>
<p>首先要认识到，成长权重对比。</p>
<p>对于学习而言，学习之后的思考，思考之后的行动，行动之后的改变更重要，如果不叮嘱内层的改变量，那么在表层投入再多的学习量也会事倍功半，因此，从权重上看，改变量&gt;行动量&gt;思考量&gt;学习量.</p>
<p>很多人之所以痛苦焦虑，就是因为只盯着表层的学习量。它们读了很多书，报了很多课，天天打卡，日日坚持，但就是没有深入关注过自己的思考、行动和改变。原因仍然是我们的天性在作祟，因为单纯保持学习输入事件单的。</p>
<p>停在表层，我们就会陷入欲望漩涡，什么都想学，什么都想要，忙忙碌碌却收效甚微；若是能深入底层，盯住实际改变，就能跳出盲目、焦虑、浮躁的怪圈。</p>
<p>另一个值得关注的规律就是，学习的平台期。</p>
<p>学习进展和时间的关系并不是想象中的线性关系(学多少是多少)，而是波浪式上升曲线。</p>
<p>当我们清楚了上述规律之后，就能在面对长期的冷寂或挫折失败时做出与他人不同的选择。各自所处的阶段不同，只要持续创造价值，别人的今天就是自己的明天。</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ul>
<li><p><strong>首先，面对天性，放下心理包袱，坦然接纳自己。</strong></p>
<p>从现在开始，对于自己表现出的任何急躁、焦虑和不耐烦，都不要感到自责和内疚，一旦感觉到失去耐心了，就温和地对自己说：”你看，身体里的那个原始人又出来了，让他离开丛林到城市生活，确实挺不容易的，要理解他。“不要指望一下子就能变得很有耐心，如果对自己不能立即变好这件事感到焦虑，着本身就是缺乏耐心的表现。</p>
</li>
<li><p><strong>其次，面对诱惑，学会延迟满足，变对抗为沟通</strong></p>
<p>和自己对话“该有的享受一点都不会少，只是不是现在享受，而是完成重要的事情之后。”  “暂时忍耐一下，先做重要的事情，之后会有专门的半个小时到一个小时的时间，专门玩手机，想怎么玩都行。”</p>
<p><strong>将享乐的快感建立在完成重要任务之后的成就感</strong>上，很放松，很踏实，就像一种奖赏。</p>
</li>
<li><p><strong>最后，面对困难，主动改变视角，赋予行动意义</strong></p>
<p>别人能持之以恒，一个重要原因是，他们更擅长探索原理，会主动改变认知视角，来找到行动的意义和好处。比如当我们知道阅读的本质和意义，我们就更有可能放下手机，主动拿起书本。想办法去看清那些想做之事的意义和好处。</p>
</li>
</ul>
<p>想办法让本能脑和情绪脑感受到困难事物的乐趣并上瘾，这才是理智脑最高级的策略。</p>
<h3 id="第二章-潜意识：生命留给我们的彩蛋"><a href="#第二章-潜意识：生命留给我们的彩蛋" class="headerlink" title="第二章 潜意识：生命留给我们的彩蛋"></a>第二章 潜意识：生命留给我们的彩蛋</h3><h4 id="第一节-模糊：人生是一场消除模糊的比赛"><a href="#第一节-模糊：人生是一场消除模糊的比赛" class="headerlink" title="第一节 模糊：人生是一场消除模糊的比赛"></a>第一节 模糊：人生是一场消除模糊的比赛</h4><h5 id="引证"><a href="#引证" class="headerlink" title="引证"></a>引证</h5><p>领域内的精英无不是比其他人了解的知识更多，他们的盲区更小，认知更清晰，因而也更具影响力。</p>
<p>学习知识的目的是“消除模糊”，而获取知识的方法也是“消除模糊”。</p>
<p>思考力的本质就是：丢弃所有已经消化的信息，让问题的核心浮出水面。</p>
<p>《刻意练习》中的核心方法论是：不要重复练习已经会的，要不断需找那些稍有难度的部分。</p>
<p>《超越感觉》一书，要想拥有清晰的逻辑，就坚持一点：凡事不要凭模糊的感觉判断，而是要寻找清晰的证据。</p>
<p>提升思考能力的方法正是不断明确核心困难和心得感悟，并专注于此。</p>
<p>“学霸”的错题本：他们更愿意花时间明确错误，并集中精力攻克；即谁愿意做高耗能的事——消除模糊，制造清晰。</p>
<h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>人不喜欢主动耗能，所以，多数人为了逃避真正的思考，愿意做任何事。</p>
<p>然而回避痛苦并不会使痛苦消失，反而会使其转入潜意识，变成模糊的感觉。<strong>而具体事件一旦变模糊，其边界就会无限扩大，原本并不困难的小事，也会在模糊的潜意识里变得难以解决。</strong></p>
<p><strong>真正的困难总比想象中的要小很多</strong>。人们拖延、纠结、位居的根本原因往往不是事情本身有多难，而是内心的想法变得模糊。记住，任何痛苦事件都不会自动消失，哪怕再小的事情也是如此。</p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>要想不受其困扰，唯一的办法就是主动正视它、拆解它、看清它，不给它进入潜意识的机会，不给它变模糊的机会；即使已经进入潜意识，也要想办法将它挖出来。所以，当你感到心里有说不清、道不明的难受时，赶紧坐下来，向自己提问。</p>
<ul>
<li>到底是什么让自己烦躁不安？是上台演讲、会见某人，还是思绪纷乱？</li>
<li>具体是什么让自己恐惧担忧？是能力不足，准备不够，还是害怕某事发生？</li>
<li>面对困境，我能做什么？不能做什么？如果做不到或搞砸了，最坏的结果是什么？</li>
</ul>
<h5 id="里清外明，消除行为模糊"><a href="#里清外明，消除行为模糊" class="headerlink" title="里清外明，消除行为模糊"></a>里清外明，消除行为模糊</h5><p>行动力不足的真正原因是选择模糊。</p>
<p>当我们没有清晰的指令或者目标时，就很容易选择享乐，放弃那些本该坚持但比较烧脑的选项。</p>
<p><strong>要想让自己更胜一筹，就必须学会花费更多的脑力和心力去思考如何拥有足够清晰的目标。我们要把目标和过程细化、具体化，在诸多可能性中建立一条单行通道，让自己始终处于“没得选”的状态。</strong></p>
<p>消除认知、情绪和行动上的模糊，主动反本能。</p>
<h4 id="第二节-感性"><a href="#第二节-感性" class="headerlink" title="第二节 感性"></a>第二节 感性</h4><p>潜意识没有思维，只关心眼前的事物，喜欢即刻、确定、简单、舒适，这是属于天性的部分。但他处理信息的速度又极快，<strong>至少可达11,000,000次每秒</strong>，能极其敏锐地感知很多不易察觉的信息。</p>
<p>而意识，即我们的理性思考，处理信息的速度<strong>只有40次每秒</strong>。</p>
<p>二者具有天壤之别！</p>
<h5 id="凭感觉学习"><a href="#凭感觉学习" class="headerlink" title="凭感觉学习"></a>凭感觉学习</h5><p><strong>所谓“熔断不读书法”，意思就是在读书时一旦看到有启发的内容，就触发熔断点，立刻停止阅读，对自己进行提问。</strong></p>
<ul>
<li>为什么刚才这个点让我有启发？</li>
<li>我能够把这个启发点用在3个不同的事情上吗？</li>
<li>这个启发点有没有其他类似的知识？</li>
</ul>
<p>不管是生活中还是学习上，凡是被某件事击中，“动了感情”，就要有意识地追问原因：</p>
<ul>
<li>为什么这个电影桥段让我感动？发生了什么？</li>
<li>为什么这个产品让我这么喜欢？是什么让它这么与众不同？</li>
<li>为什么我不由自主沉溺于这段剧情了？</li>
</ul>
<p>这就是方法：<strong>先用感性能力帮自己选择，再用理性能力帮助自己思考。</strong>这背后的原理就是通过捕捉潜意识发出的信号进行感知。</p>
<p>”只有那种大致能看出点思路，但又要动点脑筋的题目，一定要多做。这个就是中间地带，是你能够进步最快的地方。”</p>
<p>看出端倪没？“凭感觉”之所以被称为顶级的方法，是因为它能帮我们感知真正适合自己并需要的东西，让自己处于学习的“拉伸区”。</p>
<h5 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h5><p>更好的读书方法，或许就是你在读完整本书后，过几天再问自己：<strong>现在你印象最深的触动点是什么？牢牢抓住这个触动点，去关联、去实践，就会获得最大的收获</strong>，而其他的内容则可以先放到一边。这也是我自己的读书方法——<strong>只取一个全书最触动自己的点，然后尽可能去实践、改变</strong>。这样读书不仅收获更大，而且也不会焦虑。</p>
<h5 id="确立人生目标"><a href="#确立人生目标" class="headerlink" title="确立人生目标"></a>确立人生目标</h5><ul>
<li><p>这个世界有很多事情可以做，你最想帮助哪些人？</p>
</li>
<li><p>什么事让你废寝忘食？</p>
</li>
<li><p>你在做什么事情的时候最让自己感动？</p>
</li>
<li><p>你最让人感动的时刻是什么？</p>
</li>
<li><p>如果没有任何经济压力，你会如何度过余生？</p>
</li>
<li><p>闲暇的时候，你关注最多的是哪方面的信息？</p>
<p><strong>我们需要用心去感受什么事情让自己最触动，而不是用脑去思考什么事情最有利</strong>。</p>
</li>
<li><p>设想你即将离开世界，回首一生会为什么事情而后悔？</p>
</li>
<li><p>想一想你最喜欢的人物是谁？</p>
</li>
<li><p>你年轻的时候是怎么度过闲暇时光的？</p>
<p>回答这3个问题同样需要我们动用感知力而不是思考力</p>
</li>
</ul>
<h5 id="捕捉感知"><a href="#捕捉感知" class="headerlink" title="捕捉感知"></a>捕捉感知</h5><ol>
<li><strong>“最”字法</strong>。关注那些最触动自己的点：让你眼前一亮、心中泛起波澜的人和事，脑中灵光乍现的想法，遭遇的痛苦，等等。学会捕捉它们，并深入分析挖掘，往往会有丰厚的收获。</li>
<li><strong>“总”字法</strong>。平时脑子里总是不自觉地跳出来的某些重复念头，或是心里总是挥之不去的事，这些通常都是我们心中最放不下的事，是情绪波动的源头。当我们有意识地去审视并消除它时，自己会变得更加平和。</li>
<li><strong>无意识的第一反应</strong>。关注自己第一次见到某个人、第一次走进某个房间、第一次做某件事时，心中出现的瞬间反应或第一个念头。</li>
<li><strong>梦境</strong>。梦境是潜意识传递信息的一种方式，它可能是内心真实想法的展示，也可能是灵感的启发。</li>
<li><strong>直觉</strong>。丘吉尔。</li>
</ol>
<h3 id="第三章-元认知—人类的终极能力"><a href="#第三章-元认知—人类的终极能力" class="headerlink" title="第三章 元认知—人类的终极能力"></a>第三章 元认知—人类的终极能力</h3><h4 id="第一节-元认知"><a href="#第一节-元认知" class="headerlink" title="第一节 元认知"></a>第一节 元认知</h4><p><img src="https://s2.loli.net/2022/02/05/vzZM9AcLdiUuKGy.png" alt="image-20220205131103870"></p>
<h5 id="反观，是元认知的起点。"><a href="#反观，是元认知的起点。" class="headerlink" title="反观，是元认知的起点。"></a>反观，是元认知的起点。</h5><p>你能意识到自己在想什么，进而意识到这些想法是否明智，再进一步纠正那些不明智的想法，最终做出更好的选择。</p>
<p>缺乏自我意识的人，只能无意识地顺着感觉和喜好行事，无论是生理上还是精神上，都会不自觉地追求眼前的舒适和简单，觉察不到自己当前的思维和行为有什么不妥，直到碰壁。</p>
<p>高级的元认知—时刻帮你从高处、深处、远处看待现在的自己，让自己保持清醒、不迷失，保持动力、不懈怠，保持平和、不冲动。</p>
<p><img src="https://s2.loli.net/2022/02/05/V9dTtGp3mFAosZu.png" alt="image-20220205132904267"></p>
<h5 id="如何获取"><a href="#如何获取" class="headerlink" title="如何获取"></a>如何获取</h5><p>第一，提升元认知能力的工具，需要从“过去”端获取，包括学习前人的智慧和反思自己的经历。</p>
<p>前人的智慧有很多，大多可以从书籍中获取。学习前人的智慧，可以让我们拥有更广的全局视角(高度)、掌握更深的底层规律(深度)，帮我们从无知中跳出来，做出更加正确的选择。</p>
<p>尤其值得关注的是，脑科学和认知科学。</p>
<p>第二，自身的经历更是一种独特的财富。我们每天的生活像河水一样流过，如不做停留则很难攫取生活中的智慧，而反思复盘可以让我们有机会思考有什么经验可以获得、有什么教训可以汲取。</p>
<p>第三，主动运用元认知。</p>
<p>我们总是，一开始就想找一根绳子，最后却牵出一头大象。这都是元认知能力不足的表现—顺着自己的本性做喜欢和舒服的事，精力发散，缺乏觉知，任何偶发的干扰都会分散注意力。</p>
<p>如果有个“灵魂伴侣”一直在监控你，你就能审视自己的行为，从过程中跳出来，告诉自己：“这个事情可做可不做，还是先忍一下，等做完重要的事情再说；停下来，先想清楚什么事情是最重要的，不能盲目地做那些容易但是不重要的事情。”</p>
<p>第四、冥想。冥想就是那种只要静坐在某处，然后放松身体，把注意力完全集中到呼吸和感受上的活动。如果过程中觉察到自己走神了，我们只需柔和地将注意力拉回来。</p>
<p>现在再联系之前提到的“灵魂伴侣”，不难发现这些活动本质上都在做同一件事：监控自己的注意力，然后将其集中到自己需要关注的地方。</p>
<p>反馈是这个世界的进化机制。有反馈，并形成回路，就可能使任何系统开始自我进化，无论机械设计还是软件系统都是如此。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>想拥有和掌握元认知能力并不容易，这需要不断地练习、练习、再练习。</p>
<p>很多时候，你发现自己做得并不好，没关系，重新再来。用不了多久，你就会发现，自己慢慢变得和以前不一样了。</p>
<h4 id="第二节-自控力：我们生而为人就是为了称为思维舵手"><a href="#第二节-自控力：我们生而为人就是为了称为思维舵手" class="headerlink" title="第二节 自控力：我们生而为人就是为了称为思维舵手"></a>第二节 自控力：我们生而为人就是为了称为思维舵手</h4><p>元认知能力就是觉察力和自控力的组合。</p>
<p>从实用角度而言，元认知能力可以被重新定义为：自我审视、主动控制、防止被潜意识左右的能力。</p>
<h5 id="成长就是为了主动控制"><a href="#成长就是为了主动控制" class="headerlink" title="成长就是为了主动控制"></a>成长就是为了主动控制</h5><p>教育的意义就是，教你在遇到一件事的时候如何看待它。当你对这件事进行反应的时候，总是有你自己的天性在里面，比如说有人骂你，你就想骂回去，<strong>但是你在这个反应当中会有一个哪怕是零点几秒的间隔去思考或者审视，这个间隔就是你获得的教育或者经历的意义。</strong></p>
<p>如果你希望自己能从娱乐中抽身，<strong>只需提前告诉自己：“这个视频结束后暂停几秒。”</strong>一旦理智脑拥有了审视和反思的时间，我们通常都能控制住自己。</p>
<p><strong>每当遇到需要选择的情况时，我们要是能先停留几秒思考一下，就有可能激活自己的理智脑，启用元认知来审视当前的思维，然后做出不一样的选择。</strong></p>
<h5 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h5><p>有的人能看到事物更多的意义，赋予目标强烈的价值，因此他们比其他人的专注力、执行力和意志力更强；</p>
<p>有的人能觉察他人的想法，克制自己的言行，从而显得情商更高。</p>
<p>他们真正的竞争力不在于学习能力，而在于强大的元认知能力。</p>
<h5 id="所以"><a href="#所以" class="headerlink" title="所以"></a>所以</h5><p>一定要在选择节点上多花“元时间”。</p>
<h5 id="成为自己人生的思维舵手"><a href="#成为自己人生的思维舵手" class="headerlink" title="成为自己人生的思维舵手"></a>成为自己人生的思维舵手</h5><p>所有面临选择的时间节点，都可以被称作“元时间”。</p>
<p>在元时间要做的只有一件事：想清楚。</p>
<p>应对策略：在选择节点审视自己的第一反应，并产生清晰明确的主张。</p>
<h5 id="一些例子-1"><a href="#一些例子-1" class="headerlink" title="一些例子"></a>一些例子</h5><p>脱口而出的话往往出自本能，如果我们能在那句话说出口前先停一两秒，用理智脑再审视一遍，或许马上就会改变主意、换一种说法，甚至选择保持沉默，毕竟有时候最好的回答就是不回答。</p>
<p>同样，早上醒来的那一瞬间、拿起手机的那一瞬间、回到家的那一瞬间……我们都要面临新的选择，要主动消耗脑力去审视它们。</p>
<p>要想清楚，不仅要有审视第一反应，同时还要有清晰明确的主张。</p>
<p>原能力强的一个突出表现是：对模糊零容忍。也就是，想尽一切办法，让自己找出那个最重要的、唯一的选项，让自己在某一个时间段里，只有一条路可走。</p>
<p>犹豫不决，什么都想做又什么都做不好，才是最大的损失。</p>
<p>自己行动力弱的时候，脑子里对未来的具体行动肯定是模糊不清的。在这个时候，最好的自救方法就是把所有想做的事情都列出来，进行排序，找出最重要的那件事，让脑子清醒。</p>
<p>焦虑的人很少有“元时间”的意识，他们习惯不动脑子、直接行动，喜欢用饱和的行动来感动自己，想与做的时间配比差距悬殊，他们甚至连一丁点儿深入思考的时间都不愿意花，任由本能欲望让自己迷失在自我满足的行动里。</p>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ul>
<li>针对当下的时间，保持觉知，审视第一反应，产生明确的主张；</li>
<li>针对全天的日程，保持清醒，时刻明确下一步要做的事情；</li>
<li>针对长远的目标，保持思考，想清楚长远意义和内在动机。</li>
</ul>
<p>元认知能力强的人就是这样：无论是当下的注意力、当天的日程安排，还是长期的人生目标，他们都力求想清楚意义、进行自我审视和主动控制，而不是随波逐流。</p>
<p>每一次克制自己，就意味着比以前更强大。</p>
<h2 id="下篇-外观世界，借力而行"><a href="#下篇-外观世界，借力而行" class="headerlink" title="下篇 外观世界，借力而行"></a>下篇 外观世界，借力而行</h2><h3 id="第四章-专注力：情绪和智慧的交叉地带"><a href="#第四章-专注力：情绪和智慧的交叉地带" class="headerlink" title="第四章 专注力：情绪和智慧的交叉地带"></a>第四章 专注力：情绪和智慧的交叉地带</h3><h4 id="第一节-情绪专注"><a href="#第一节-情绪专注" class="headerlink" title="第一节 情绪专注"></a>第一节 情绪专注</h4><p>我们的注意力其实都可以分为<strong>“集中在行动上的”</strong>和“<strong>集中在感受上的</strong>”两部分。</p>
<p>起初，行动和感受二者是统一的。我们会在做一件事时，全身心地感受这件事，将注意力全部放在和当前事务相关的事情上，所以跑就是跑，吃就是吃，睡就是睡……</p>
<p>随着行动越来越熟练，我们在行动上集中的注意力越来越少，分散在其他地方的注意力越来越多，于是我们不再去耐心感受行动。</p>
<h5 id="分神的原因"><a href="#分神的原因" class="headerlink" title="分神的原因"></a>分神的原因</h5><ul>
<li>当下太无聊，所以追求更有意思的事情</li>
<li>当下太痛苦，于是追求更舒适的事情</li>
</ul>
<p>换句话说，就是分心走神的成本太低，而人的天性又是急于求成和趋易避难的，所以在默认情况下，我们都会不自觉地待在精神舒适区内。</p>
<h5 id="分神的后果"><a href="#分神的后果" class="headerlink" title="分神的后果"></a>分神的后果</h5><p>走神可以让我们活在任何时候，唯独不能让我们活在当下。</p>
<p>而生命是由当下的一个个片段组成的，身心合一的片段组成的就是幸福专注的高质量人生，身心分离的片段组成的就是分心走神的低质量人生。</p>
<p>分心走神的本质是逃避。</p>
<p>面对困难时，身心分离的人总会不自觉地退回舒适区，而身心合一的人则更容易跳出舒适区，直面困难。</p>
<h5 id="收回感受，回归当下"><a href="#收回感受，回归当下" class="headerlink" title="收回感受，回归当下"></a>收回感受，回归当下</h5><p>跑步时，把感受收回来，悉心体会抬腿摆臂、呼吸吐纳和迎面的微风；睡觉时，把感受收回来，悉心感受身体的紧张与松弛；吃饭时，把感受收回来，感受每一口饭菜的香甜，体会味觉从有到无的整个过程</p>
<p><strong>身体感受永远是进入当下状态最好的媒介，而感受事物消失的过程更是一种很好的专注力训练。它提示我们，身心合一的要领，不仅是专注于当下，更是享受当下。</strong></p>
<p><strong>慢慢练习收回感受，让注意力回到当下，我们的烦恼就会慢慢减少。</strong></p>
<p>得道前，砍柴时惦记着挑水，挑水时惦记着做饭；得道后，砍柴即砍柴，担水即担水，做饭即做饭。</p>
<h4 id="第二节-学习专注"><a href="#第二节-学习专注" class="headerlink" title="第二节 学习专注"></a>第二节 学习专注</h4><p>人类情绪和能力的优劣差异来自于对自身注意力关注方式的差异。</p>
<p>能力弱者极易分心，他们必须在一个理想的环境中才能学习，任何风吹草动都会让他们心神不宁；他们总是忍不住想做点更有趣的事情，一条热点新闻、一段有趣的闲聊都能把他们的注意力从重要的事情上移开。</p>
<p>能力强者则正好相反，他们的优势就在于能够主动屏蔽干扰，选择需要的信息并沉浸其中，为此他们甚至会主动练习，比如有人会故意在声音嘈杂的地方锻炼专注力</p>
<p>因沉浸能力的不同，人最终停留在了不同的层次。</p>
<h5 id="有定义明确的目标"><a href="#有定义明确的目标" class="headerlink" title="有定义明确的目标"></a>有定义明确的目标</h5><p>“连续三次不犯任何错误、以适当的速度弹奏完曲子。”而不是“我要练琴半小时”这样宽泛的目标。</p>
<p>目标定义越明确，注意力的感知精度就会越高，精力越集中，技能越精进。</p>
<p>如果目标太大，那就将它分解成小目标，这样做也是为了使目标更具体、精细。</p>
<h5 id="练习时极度专注"><a href="#练习时极度专注" class="headerlink" title="练习时极度专注"></a>练习时极度专注</h5><p>在短时间内投入100%的精力比长时间投入70%的精力好。</p>
<p>因为专注真正的动力不是毅力和耐心，而是不断发现技巧上的微妙差异和持续存在的关注点，精力越集中，则感知越细微。</p>
<h6 id="变聪明的秘诀就是："><a href="#变聪明的秘诀就是：" class="headerlink" title="变聪明的秘诀就是："></a>变聪明的秘诀就是：</h6><p>先保持极度专注，想不出答案时再将注意力转换到另一件与此毫不相干的事情上。即事前聚精会神，让意识极度投入；事后完全忘记，让意识彻底撒手。这样，灵感和答案就会大概率地出现。</p>
<h6 id="好的学习模式："><a href="#好的学习模式：" class="headerlink" title="好的学习模式："></a>好的学习模式：</h6><p>在做A的时候彻底关注A，在做B的时候，彻底关注B，A和B之间有非常清晰的界限。</p>
<h5 id="能获得有效的反馈"><a href="#能获得有效的反馈" class="headerlink" title="能获得有效的反馈"></a>能获得有效的反馈</h5><p>想方设法得到及时、有效的指导和反馈是不断精进的重要条件。</p>
<p>如果条件有限，反馈也可以通过书籍影像、与他人交流或者自我反思来获取。</p>
<h5 id="始终在拉伸区练习"><a href="#始终在拉伸区练习" class="headerlink" title="始终在拉伸区练习"></a>始终在拉伸区练习</h5><p><img src="https://s2.loli.net/2022/02/12/pSvlT6gBkEuYr8Z.png" alt="image-20220212115955425"></p>
<p>我们每天都要做那些让自己感到有困难但又可以通过努力来完成的事情。</p>
<p><img src="https://s2.loli.net/2022/02/12/FfHEvmaVCGhdSYw.png" alt="image-20220212120112977"></p>
<p><strong>要大量练习！</strong></p>
<ul>
<li>审视自己的注意力——是被动吸引还是主动选择？</li>
<li>审视自己的沉浸度——是分心走神还是极度专注？</li>
<li>审视自己的练习量——是浅尝辄止还是大量投入？</li>
</ul>
<h3 id="第五章-学习力——学习不是一味地努力"><a href="#第五章-学习力——学习不是一味地努力" class="headerlink" title="第五章 学习力——学习不是一味地努力"></a>第五章 学习力——学习不是一味地努力</h3><h4 id="第一节-匹配"><a href="#第一节-匹配" class="headerlink" title="第一节 匹配"></a>第一节 匹配</h4><p>刻意练习的真正核心在于，难易匹配上。</p>
<p>好的成长是始终游走在“舒适区边缘”。</p>
<h5 id="经验1"><a href="#经验1" class="headerlink" title="经验1"></a>经验1</h5><p>找一个自己能坚持做下去的方式，比单纯按照标准化的时间和方式做更重要。</p>
<p>以前一直以为多花时间才能学好、才能达到效果，其实那是因为自己急于求成，想要快速见效，这样反而不容易坚持。</p>
<p>现在降低了难度和标准，自己的行动力反而能持续增强，虽然达到目标所需的时间可能会变长，但是我相信这样的坚持最终可以产生复利效应。</p>
<p>事实上，它就是难易匹配的意思：既不要太难，也不要太容易，难易适中的地带才是学习的心流通道。</p>
<h5 id="经验2"><a href="#经验2" class="headerlink" title="经验2"></a>经验2</h5><p>我们就应该花大量的时间去梳理哪些内容处在自己的拉伸区，即梳理那些“会做但特别容易错或不会做但稍微努力就能懂”的内容.</p>
<p>千万不要认为没有管束的生活很美好，一旦进入完全自由的时间，虽然开始会很舒服，但很快，我们就会迷失在众多选项中——做这个也行，做那个也行。</p>
<p>做选择是一件极为耗能的事情，如果没有与之匹配的清醒和定力，绝大多数人最终都会被强大的天性支配，去选择娱乐消遣。</p>
<p>在有约束的环境下我们反而效率更高，生活更充实。</p>
<h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h5><p>它能帮我们解决行动力中的大问题。</p>
<p>比如，我们每次行动遇阻时都会一筹莫展，但只要细想就能发现，不管你遇到的是什么问题，其根源都是一样的，那就是：这个问题太大、太模糊。</p>
<p>所以，你只要拆解目标——把大目标拆分为小目标，任务就会立即从困难区转移到拉伸区，这样你就愿意行动了。</p>
<p>不信的话，你可以细心观察一下，几乎所有的行动达人都是拆解任务的高手。</p>
<p>掌握了这个原理，我们就能推导出从舒适区到拉伸区的策略：<strong>提炼目标</strong>。</p>
<h5 id="专注"><a href="#专注" class="headerlink" title="专注"></a>专注</h5><p>在拉伸区练习的一大特点就是要有关注点。</p>
<p>关注点越多、越细致，我们的注意力就越集中，提升的效果就越明显。</p>
<p>因此，跳出舒适区的最好办法就是去发现和收集那些要点，也就是每次行动的小目标。</p>
<p>比如练习弹钢琴的时候，不是一遍一遍地重复，而是只练出错最多的地方……</p>
<h5 id="反馈和拉伸"><a href="#反馈和拉伸" class="headerlink" title="反馈和拉伸"></a>反馈和拉伸</h5><p>目标清晰了之后，“极度专注”也自然能做到了，然后通过自我测试、反思、错题本这些方式获得反馈，这样做能不断优化自己关注的要点和小目标。</p>
<h4 id="第二节-深度学习"><a href="#第二节-深度学习" class="headerlink" title="第二节 深度学习"></a>第二节 深度学习</h4><h5 id="什么是深度学习"><a href="#什么是深度学习" class="headerlink" title="什么是深度学习"></a>什么是深度学习</h5><p><img src="https://s2.loli.net/2022/02/12/thl6wSjJV5g4Bbz.png" alt="image-20220212121356159"></p>
<p>以阅读为例，从浅到深依次为：</p>
<p>听书、自己读书、自己读书+摘抄金句、自己读书+思维导图/读书笔记、自己读书+践行操练、自己读书+践行操练+输出教授。</p>
<h5 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h5><p>明明心里想得挺明白，讲的时候就开始语无伦次了，如果再让你把知道的东西写下来呢？你可能会觉得根本无从下笔。</p>
<p>请注意，遇到这种困难才是深度学习真正的开始！</p>
<p>因为你必须动用已有的知识去解释新知识，当你能够把新学的知识解释清楚时，就意味着把它纳入了自己的知识体系，同时达到了可以教授他人的水平，并可能创造新的知识。</p>
<p>所以，逼迫自己获取高质量的知识以及深度缝接新知识，再用自己的语言或文字教授他人，是为深度学习之道。</p>
<h5 id="如何深度学习"><a href="#如何深度学习" class="headerlink" title="如何深度学习"></a>如何深度学习</h5><ul>
<li>获取高质量的知识</li>
<li>深度缝接新知识</li>
<li>输出成果去教授</li>
</ul>
<h5 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h5><p>正确的行动往往是反天性的，让你觉得舒服和容易的事往往得不到好结果，而一开始你认为难受和困难的事才能让你真正产生收获，所以我们可以通过以下几个方法逐步改进。</p>
<h6 id="一、尽可能获取并亲自钻研一手知识。"><a href="#一、尽可能获取并亲自钻研一手知识。" class="headerlink" title="一、尽可能获取并亲自钻研一手知识。"></a>一、尽可能获取并亲自钻研一手知识。</h6><p>比如，我们可以读经典、读原著，甚至读学术论文。放弃那些“几分钟读完……”</p>
<p>读书这件事还是不要请人代劳，从长远看，终归是要自己获得挖矿的能力的。</p>
<h6 id="二、尽可能用自己的话把所学的知识写出来"><a href="#二、尽可能用自己的话把所学的知识写出来" class="headerlink" title="二、尽可能用自己的话把所学的知识写出来"></a>二、尽可能用自己的话把所学的知识写出来</h6><p>每读完一本有价值的好书，就用写作的方式把作者的思想用自己的语言重构出来，尽力结合自身经历、学识、立场，去解释、延伸，而不是简单把书本的要点进行罗列。</p>
<p>只有做到知识转换才能用旧知识体系对新知识进行深度缝接。</p>
<h6 id="三、反思生活"><a href="#三、反思生活" class="headerlink" title="三、反思生活"></a>三、反思生活</h6><p>人与人之间的差距不是来自年龄，甚至不是来自经验，而是来自经验总结、反思和升华的能力。</p>
<p>如果让我推荐一个不可或缺的习惯，我必推每日反思。</p>
<h5 id="深度学习的好处"><a href="#深度学习的好处" class="headerlink" title="深度学习的好处"></a>深度学习的好处</h5><p>人的能力分为知识、技能和才干三个层次：</p>
<p>知识是最不具迁移能力的。你成为医学博士，也照样有可能不会做麻婆豆腐；</p>
<p>技能通常由70%的通用技能和30%的专业技能组成，迁移性要好一些；</p>
<p>而到了才干层面，职业之间的界限就完全被打破了。</p>
<h5 id="为浅学习正名"><a href="#为浅学习正名" class="headerlink" title="为浅学习正名"></a>为浅学习正名</h5><p>娱乐热点并非没有价值，浅层知识也同样具有意义，但前提是你需要具备一定的认知深度——深度之下的广度才是有效的。</p>
<p>专注于深度学习，同时对浅学习保持开放。</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>选择一些值得关注的人，和他们保持联结。他们释放的一些有价值的信息会引领我们走向更广阔的世界，但无论如何，最终要自己去读、自己去想、自己去做。</p>
<p>就像这本书，如果它触动了你，也仅仅是为你开启了一个新的视角，最终能否获取深度学习的能力，只能靠你自己行动，没有人能够代替。</p>
<h4 id="第三节-关联"><a href="#第三节-关联" class="headerlink" title="第三节 关联"></a>第三节 关联</h4><h5 id="无关联，不学习"><a href="#无关联，不学习" class="headerlink" title="无关联，不学习"></a>无关联，不学习</h5><ul>
<li>用自己的语言重述信息，即找到触动自己的信息点；</li>
<li>描述自己的相关经验，即关联生活中的其他知识；</li>
<li>我的应用，即转化为行动，让自己切实改变。</li>
</ul>
<p>这既是有效阅读的三个步骤，也是深度学习的三个层次：</p>
<ul>
<li>知道信息点</li>
<li>关联信息点</li>
<li>行动和改变</li>
</ul>
<p><img src="https://s2.loli.net/2022/02/12/Yu1xRK6sabfkHpv.png" alt="image-20220212123623802"></p>
<p>绝大多数人习惯以孤立的思维看待事物，喜欢花大量时间收集和占有信息；</p>
<p>而另一批先行者则更喜欢拨弄信息之间的关联，从而在不知不觉间变得聪明了起来。</p>
<h5 id="事不关己，不关联"><a href="#事不关己，不关联" class="headerlink" title="事不关己，不关联"></a>事不关己，不关联</h5><p>因为只有真正和自己有关的内容才对自己有用，在这个注意力非常匮乏的时代，没有必要把所有的书或是书中所有的内容都读完。</p>
<p>知识的获取不在于多少，而在于是否与自己有关联，以及这种关联有多充分。</p>
<p>对别人有用的东西可能与自己并没有关系，那就果断将其放弃，把握“与自己有关”的筛选原则，会让关联效能大大提升。</p>
<p>当然，还有一个更重要的隐蔽条件不能忽视：<strong>你需要明确的目标或强烈的需求</strong>。</p>
<h5 id="如何获取关联能力"><a href="#如何获取关联能力" class="headerlink" title="如何获取关联能力"></a>如何获取关联能力</h5><h6 id="首先，手中有锤子。"><a href="#首先，手中有锤子。" class="headerlink" title="首先，手中有锤子。"></a>首先，手中有锤子。</h6><p>如果你对某件事情没有足够的热爱和投入，没有极致的专注和思考，恐怕任何事物对你都没有意义。</p>
<h6 id="其次，输入足够多。"><a href="#其次，输入足够多。" class="headerlink" title="其次，输入足够多。"></a>其次，输入足够多。</h6><p>不管是阅读获取，还是现实经历，知识和阅历越丰富，成功关联的概率就越大。</p>
<p>很难想象空白的头脑和苍白的人生如何建立精彩的关联。所谓巧妇难为无米之炊。</p>
<h6 id="再次，保持好奇心"><a href="#再次，保持好奇心" class="headerlink" title="再次，保持好奇心"></a>再次，保持好奇心</h6><h6 id="最后，常说一句话。"><a href="#最后，常说一句话。" class="headerlink" title="最后，常说一句话。"></a>最后，常说一句话。</h6><p>总有一些话让人听过一次就难以忘记，比如李笑来的这句话我就一直记在脑中：“这个道理还能用在什么地方？”</p>
<p>但凡收获一个感悟、了解一个观点或是学到一个知识，只要触动了自己，就要想办法让它效率最大化，而效率最大化的办法就是主动关联到别处，并让自己的行动发生改变。</p>
<p>所以你不妨也把这句话当作口头禅，时常问自己：<strong>这个道理还能用在什么地方？</strong></p>
<h5 id="一切在于主动"><a href="#一切在于主动" class="headerlink" title="一切在于主动"></a>一切在于主动</h5><h4 id="第四节-体系"><a href="#第四节-体系" class="headerlink" title="第四节 体系"></a>第四节 体系</h4><p>只有当知识能够帮助你做实际决策的时候，它才是你的知识。</p>
<p>在个人成长领域，没有最优、最确定、最权威的认知体系，只有最适合我们当前状态的认知体系。</p>
<h5 id="只学让自己触动的"><a href="#只学让自己触动的" class="headerlink" title="只学让自己触动的"></a>只学让自己触动的</h5><p>在阅读时，唯一要做的是：<strong>寻找触动点</strong></p>
<p>我会在触动自己的地方做标记，在空白处写下大量能联想到的思考，书读完之后，我会放上几天，然后问自己：“这本书最触动自己的是哪个点？”</p>
<p>只要它真正触动我，并能让我发生真实的改变，我就认为这本书超值了，至于其他，忘记就忘记了，我一点也不觉得可惜。而作者的知识体系和框架，又与我何干呢？</p>
<p><img src="https://s2.loli.net/2022/02/12/ATSbCgw4J83vtIe.png" alt="image-20220212124517057"></p>
<p><img src="https://s2.loli.net/2022/02/12/to5DGyesiKJab7S.png" alt="image-20220212124606229"></p>
<h5 id="搭建个人认知体系"><a href="#搭建个人认知体系" class="headerlink" title="搭建个人认知体系"></a>搭建个人认知体系</h5><p>体系的本质就是用独特的视角将一些零散的、独立的知识、概念或观点整合为应对这个世界的方法和技巧。</p>
<p>打碎各家的认知体系，只取其中最触动自己的点或块，然后将其拼接成自己的认知网络。</p>
<h5 id="触动是最好的筛选器"><a href="#触动是最好的筛选器" class="headerlink" title="触动是最好的筛选器"></a>触动是最好的筛选器</h5><p>每日反思不是记流水账，而是留意每天最触动自己的那件事，不管是好的启发还是坏的体验，都写下来复盘，写得越细越好。</p>
<p><img src="https://s2.loli.net/2022/02/12/3qAuPWl96XkLgQH.png" alt="image-20220212124819780"></p>
<h5 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h5><p>一、是用自己的语言重新解释新知识，这会促使自己原有的知识体系对新知识做出反应。</p>
<p>二、是在需要的时候能够顺利提取知识，提取不出来的知识就是伪触动。</p>
<p>但我在写作时，能从那些60秒语音分享中提取出来的观点只占少数，大多数观点都被我忘了。</p>
<p>如果你在读书、写作、交谈的时候想到了一个观点，哪怕你记不清具体的内容，只有一条微弱的线索，你也要极端重视这些内容，因为那些能在需要的时候被提取的知识，是与你真正产生触动的知识，你们之间宝贵的连接还在，所以要想办法主动关联和强化。</p>
<p>三、是在生活中能够经常练习或使用这些知识，因为实践是产生强关联的终极方法。</p>
<p>学习不是为了知道，而是为了发生真实的改变。</p>
<p>当你运用那些知识践行那些道理时，相关细节就会源源不断地显现在你的视野里。</p>
<p>到那时，你不仅能成为认知上的强者，也会成为行动上的巨人。</p>
<p>最终，你会明白，所谓的学习成长，诸如阅读、写作、反思、培养习惯、练习技能、建立认知体系，等等，本质上都是一回事：<strong>在舒适区边缘，一点一点向外扩展。</strong></p>
<h4 id="第五节-打卡"><a href="#第五节-打卡" class="headerlink" title="第五节 打卡"></a>第五节 打卡</h4><p>这就是打卡心态的特性：学不到，假装一下；学到了，立即停止。</p>
<p>只要一个小方法就能立即改变，那就是用记录代替打卡。</p>
<p>每次学习后只做行动记录，不做打卡展示。</p>
<p>把学习过程记录下来，既可以看到自己的学习轨迹，也便于每周复盘</p>
<p>只要专注于学习成长活动本身，体会其中的乐趣，就能保持强烈的学习动机，化被动学习为主动学习。</p>
<p>打卡与记录，看似只是叫法上的不同，但其中的差别非常微妙，需要悉心体会。</p>
<h5 id="设下限，不设上限。"><a href="#设下限，不设上限。" class="headerlink" title="设下限，不设上限。"></a><strong>设下限，不设上限。</strong></h5><p>把任务调整为背5个单词——一个很容易完成的下限。</p>
<p>这样做的好处是：你完成目标毫无负担，且此时刚好进入学习状态，精力旺盛，就愿意顺着惯性继续学下去，毕竟此后多学一个单词都是额外的收获，心态完全不同，身心容易沉浸，不会顾虑什么时候才能完成任务。</p>
<h4 id="第六节-反馈"><a href="#第六节-反馈" class="headerlink" title="第六节 反馈"></a>第六节 反馈</h4><p>是否有及时、持续的正向反馈，正是产生学习效果差异的关键。</p>
<h5 id="正向反馈"><a href="#正向反馈" class="headerlink" title="正向反馈"></a>正向反馈</h5><p>持续的正向反馈才能真正激发本能脑和情绪脑的强大行动力。</p>
<p>因为人类强大的本能脑和情绪脑虽然没有思维、短视愚笨，时常沉溺于游戏、手机、美食、懒觉……</p>
<p>但它们超强的欲望和情绪力量却是非常宝贵的行动力资源，如果能让它们感受到学习的乐趣，它们同样会展现强大的行动力，让自己像沉迷娱乐一样沉迷于学习。</p>
<p>所以科学的学习策略是产出作品、获取反馈，驱动本能脑和情绪脑去“玩玩玩”，而不是一味地努力坚持，让理智脑苦苦地去“学学学”。</p>
<h5 id="有作品意识才会有未来"><a href="#有作品意识才会有未来" class="headerlink" title="有作品意识才会有未来"></a>有作品意识才会有未来</h5><p>有了这种认知，人是会迅速改变的——会拥有清晰而强烈的作品意识，会更加重视输出和运用，会倾心打磨作品，主动换取外界的反馈。</p>
<p>比如以前你学习英语可能会选择每日打卡的方式，但现在你可能会选择直接用：直接翻译一段美文、查询英文文档、阅读英文原版书，或者把手机语言设置成英文……这么做当然会造成一些困难，但为了解决问题，你必定会想办法补全相关知识，所以你的学习行为都能得到即时反馈：要么帮自己或他人解决了一个问题，要么产出了一个有价值的作品，这些反馈带给自己的必然是强烈的成就感和继续行动的欲望。</p>
<h5 id="经验-1"><a href="#经验-1" class="headerlink" title="经验"></a>经验</h5><ul>
<li><p>教是最好的学；</p>
</li>
<li><p>用是最好的学；</p>
</li>
<li><p>输出倒逼输入；</p>
</li>
<li><p>请用作品说话……</p>
<p>那些先行者确实都有相同的品质，他们在学习的时候经常不按常理出牌，不管是不是新知识、技能，他们都直接用、直接做。</p>
<p>当然，一开始常常用不好、做不好，但他们肯定要“鼓捣”出一个东西，然后抛出去获取反馈，不断打磨迭代。</p>
</li>
</ul>
<p>不管是不是新知识、技能，他们都直接用、直接做。当然，一开始常常用不好、做不好，但他们肯定要“鼓捣”出一个东西，然后抛出去获取反馈，不断打磨迭代。</p>
<p>找到自己的高价值区——让自己成为某个领域的头部——再借助头部效应的系统推力，从一个小头部不断地向大头部移动，实现跃迁。</p>
<p><strong>而抢占头部最好的途径莫过于持续打磨高价值的作品，凭借作品换取反馈。</strong></p>
<h5 id="痛苦也是反馈"><a href="#痛苦也是反馈" class="headerlink" title="痛苦也是反馈"></a>痛苦也是反馈</h5><p>首先，分享不是随意分享半成品，而是尽最大力气将作品打磨成自己当前能力范围内可完成的最好的样子。</p>
<p>其次，制定分享策略，展示给那些能力不及你的人。</p>
<p>最后，冷静客观地对待打击。</p>
<p>所有痛苦都是上天给我们的成长提示。</p>
<h5 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h5><p>主动的回想测试是最好的学习方法之一，比坐在那儿被动地重读材料要好得多。</p>
<p><strong>真正的学习成长不是“努力，努力再努力”，而是“反馈，反馈再反馈”。</strong></p>
<p>跳过原理，直接实操的方式仅适用于学习的初级阶段。也就是说，采用这一方式，你快速达到60分的水平是可以的，但到了中级或高级阶段，仍然需要系统学习原理，否则走不远。</p>
<p>不过，反馈的规律是贯穿始终的，无论什么时候，只要能通过产出换取反馈，你就会不自觉地去钻研探索。</p>
<h4 id="第七节-休息"><a href="#第七节-休息" class="headerlink" title="第七节 休息"></a>第七节 休息</h4><p>你肯定记得“刻意练习四要素”：定义明确的目标、极度的专注、有效的反馈、在拉伸区练习。</p>
<p>有效学习的关键是保持极度专注，而非一味比拼毅力和耐心。</p>
<p>不过，保持专注需要花费精力，而我们的精力是有限的，就像一桶水，有的人总量多些，有的人少些，但只要在困难的事情上消耗精力，精力桶的水位就会慢慢下降。</p>
<h5 id="主动休息"><a href="#主动休息" class="headerlink" title="主动休息"></a>主动休息</h5><p><img src="https://s2.loli.net/2022/02/12/luc3gRKXZOdBD6I.png" alt="image-20220212130109139"></p>
<p>学习时从不过度消耗自己，只要感到精力不足，就停下来主动休息，这反而使他们精力桶的水位得到快速回升</p>
<p><img src="https://s2.loli.net/2022/02/12/pKRrhi2WmgvUQFs.png" alt="image-20220212130220452"></p>
<p><img src="https://s2.loli.net/2022/02/12/7TgYsOwSnpV1RyE.png" alt="image-20220212130243972"></p>
<h5 id="保持专注的危机"><a href="#保持专注的危机" class="headerlink" title="保持专注的危机"></a>保持专注的危机</h5><p>高效学习的关键在于保持极度专注。</p>
<p>科学的模式：<strong>极度专注+主动休息，如此反复。</strong></p>
<p>在生活中，最要不得的就是那种明明已经分心走神了，却还要强撑内耗，倒不如遵循“极度专注+主动休息”的模式，让自己先尽力保持短时间的极度专注，到有些累的时候就主动停下来，这是更加明智的生活和学习策略。</p>
<p><img src="https://s2.loli.net/2022/02/12/hLRq9Hf1IKA4SoD.png" alt="image-20220212130425253"></p>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>一个真正的自控高手，不是一个只知道冲刺的人，而是一个善于主动休息、保持平衡的人。</p>
<p>这些人无论面对精力的消耗与恢复，还是面对情绪的波动与还原，都会刻意保持高位富足的状态，避免进入低位稀缺的境地。</p>
<p>一个简单又通用的方法正是前文说的主动培养“极度专注+主动休息”的行为模式。</p>
<p>具体的做法就是：只要开始学习或工作，就尽量保持极度专注的状态，哪怕保持专注的时间很短也是有意义的；一旦发现自己开始因为精力不足而分心走神，就主动停下来调整片刻。</p>
<p>很多人在学习和工作中都不具备不受打扰的理想条件，但只要坚持“极度专注+主动休息”的模式，效果也会让你满意。</p>
<p>不管你能工作几分钟，只要开始了，就尽力保持专注，把无关的事情都放在一边。</p>
]]></content>
      <tags>
        <tag>一篇读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer_Composition_Principle</title>
    <url>/2022/02/14/Computer-Composition-Principle/</url>
    <content><![CDATA[<h1 id="Chapter-1-计算机系统概述-≤5分"><a href="#Chapter-1-计算机系统概述-≤5分" class="headerlink" title="Chapter 1 计算机系统概述(≤5分)"></a>Chapter 1 计算机系统概述(≤5分)</h1><h2 id="1-计算机的分类"><a href="#1-计算机的分类" class="headerlink" title="1. 计算机的分类"></a>1. 计算机的分类</h2><ol>
<li>电子计算机从总体上来说，分为两大类：电子模拟计算机和电子数字计算机。</li>
<li>电子数字计算机进一步又分为专用计算机和通用计算机。</li>
<li>通用计算机可分为：超级计算机、大型机、服务器、PC机、单片机和多核机六类，他们的区别在于体积、简易性、功率损耗、性能指标、数据存储容量、指令系统规模和机器价格。</li>
</ol>
<p><img src="https://s2.loli.net/2022/02/14/szBqT86LX3twZhF.png" alt="image-20220214143435926"></p>
<h2 id="2-计算机的发展"><a href="#2-计算机的发展" class="headerlink" title="2. 计算机的发展"></a>2. 计算机的发展</h2><h3 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h3><p>主要是CPU性能指标、存储器性能指标和I/O吞吐率。</p>
<h4 id="1-吞吐量"><a href="#1-吞吐量" class="headerlink" title="1. 吞吐量"></a>1. 吞吐量</h4><p>表征一台计算机在某一时间间隔内能够处理的信息量。</p>
<h4 id="2-响应时间"><a href="#2-响应时间" class="headerlink" title="2. 响应时间"></a>2. 响应时间</h4><p>表征从输入有效到系统产生响应之间的时间度量，用时间单位来度量。</p>
<h4 id="3-总线宽度"><a href="#3-总线宽度" class="headerlink" title="3. 总线宽度"></a>3. 总线宽度</h4><p>一般指CPU中运算器与存储器之间进行互连的内部总线<strong>二进制位数</strong>。</p>
<h4 id="4-存储器容量"><a href="#4-存储器容量" class="headerlink" title="4. 存储器容量"></a>4. 存储器容量</h4><p>存储器中所有存储单元的总数目，通常用KB、MB、GB、TB来表示。</p>
<h4 id="5-主频-时钟周期"><a href="#5-主频-时钟周期" class="headerlink" title="5. 主频/时钟周期"></a>5. 主频/时钟周期</h4><p>CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，主时钟的频率(f)叫CPU的主频。</p>
<p>主频的倒数称为CPU时钟周期(T)，$T=\frac{1}{f}$。</p>
<h4 id="6-CPU执行时间"><a href="#6-CPU执行时间" class="headerlink" title="6. CPU执行时间"></a>6. CPU执行时间</h4><p>表示CPU执行一般程序所占的CPU时间，计算公式：</p>
<script type="math/tex; mode=display">
CPU执行时间=CPU时钟周期数×CPU时钟周期</script><h4 id="7-CPI"><a href="#7-CPI" class="headerlink" title="7. CPI"></a>7. CPI</h4><p>表示每条指令周期数，即执行一条指令所需的平局时钟周期数。计算公式：</p>
<script type="math/tex; mode=display">
CPI=执行某段程序所需的CPU周期数÷程序所包含的指令条数</script><h4 id="8-存储器带宽"><a href="#8-存储器带宽" class="headerlink" title="8. 存储器带宽"></a>8. 存储器带宽</h4><p>单位时间内从存储器读出的二进制信息量，一般用字节数/秒来表示。</p>
<h4 id="9-处理器字长"><a href="#9-处理器字长" class="headerlink" title="9. 处理器字长"></a>9. 处理器字长</h4><p>指处理机运算器中一次能够完成二进制数运算的位数，如32位、64位。</p>
<h2 id="3-计算机的硬件"><a href="#3-计算机的硬件" class="headerlink" title="3. 计算机的硬件"></a>3. 计算机的硬件</h2><h2 id="4-计算机的软件"><a href="#4-计算机的软件" class="headerlink" title="4. 计算机的软件"></a>4. 计算机的软件</h2><h2 id="5-计算机系统的层次结构"><a href="#5-计算机系统的层次结构" class="headerlink" title="5. 计算机系统的层次结构"></a>5. 计算机系统的层次结构</h2><ol>
<li>计算机系统的层次结构从下至上可分为五级：<strong>微程序级、一般机器级、操作系统级、汇编语言级、高级语言级</strong>组成，每一级上都能进行程序设计，且得到下面各级的支持。</li>
</ol>
<p><img src="https://s2.loli.net/2022/02/14/ojHdKUNcV4ifqng.png" alt="image-20220214150037411"></p>
<h1 id="Chapter-2-运算方法和运算器-20分左右"><a href="#Chapter-2-运算方法和运算器-20分左右" class="headerlink" title="Chapter 2 运算方法和运算器(20分左右)"></a>Chapter 2 运算方法和运算器(20分左右)</h1><p>肯定有个计算题</p>
<h2 id="1-数据与文字的表示方法"><a href="#1-数据与文字的表示方法" class="headerlink" title="1. 数据与文字的表示方法"></a>1. 数据与文字的表示方法</h2><p>计算机中常用的数据表示格式有两种：一是定点格式，二是浮点格式。</p>
<h3 id="1-定点数的表示方法"><a href="#1-定点数的表示方法" class="headerlink" title="1. 定点数的表示方法"></a>1. 定点数的表示方法</h3><p>所谓定点格式，即约定机器中所有数据的小数点位置是固定不变的。</p>
<h4 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h4><p>假设用一个n+1位字来表示一个定点数x，其中一位$x_n$用来表示数的符号，其余位数表示它的量值。则</p>
<p><img src="https://s2.loli.net/2022/02/15/kMfs3KqAv8u19Yt.png" alt="image-20220215211440074"></p>
<h5 id="纯小数"><a href="#纯小数" class="headerlink" title="纯小数"></a>纯小数</h5><p>如果数x表示的是纯小数，那么小数点位于$x_n$和$x_{n-1}$之间。当各位均为0时，数x的绝对值最小，即$|x|_{min}=0$；当各位均为1时，数x的绝对值最大，即$|x|_{max}=1-2^{-n}$。</p>
<h5 id="纯整数"><a href="#纯整数" class="headerlink" title="纯整数"></a>纯整数</h5><p>如果数x表示的时纯整数，那么小数点位于最低位$x_0$的右边，此时数x的表示范围为$0≤|x|≤2^n-1$</p>
<h3 id="2-浮点数的表示方法"><a href="#2-浮点数的表示方法" class="headerlink" title="2. 浮点数的表示方法"></a>2. 浮点数的表示方法</h3><h4 id="浮点表示法"><a href="#浮点表示法" class="headerlink" title="浮点表示法"></a>浮点表示法</h4><p>把一个数的有效数字和数的范围在计算机的一个存储单元中分别予以表示。</p>
<p>这种把数的范围和精度分别表示的方法，相当于数的小数点位置随比例因子的不同而在一定范围内可以自由浮动，所以称作浮点表示法。</p>
<p>任意一个二进制数N可以写成：$N=2^e*M$</p>
<p>其中，<strong>M称为浮点数的尾数，是一个纯小数。</strong></p>
<p><strong>e是比例因子的指数，称为浮点数的指数，是一个整数。</strong></p>
<h4 id="在机器中"><a href="#在机器中" class="headerlink" title="在机器中"></a>在机器中</h4><p>表示一个浮点数时，</p>
<p>一是要给出尾数，用定点小数形式表示。位数部分给出有效数字的位数，因为决定了浮点数的表示精度。</p>
<p>二是要给出指数，用整数形式表示，常称为阶码，阶码指明小数点在数据中的位置，因而决定了浮点数的表示范围。</p>
<p>计算机中，一个浮点数由阶码、尾数及其符号位组成。</p>
<p><img src="https://s2.loli.net/2022/02/15/lQ9uog5xkcSvr42.png" alt="image-20220215220234364"></p>
<h3 id="3-数的机器码表示"><a href="#3-数的机器码表示" class="headerlink" title="3. 数的机器码表示"></a>3. 数的机器码表示</h3><h4 id="1-原码表示法"><a href="#1-原码表示法" class="headerlink" title="1. 原码表示法"></a>1. 原码表示法</h4><p>若定点整数的源码形式为$x_n x_{n-1}…x_1 x_0 (x_n为符号位)$，则原码表示的定义是</p>
<script type="math/tex; mode=display">
[x]_原 = \begin{cases}
x & 2^n＞x≥0 \\ 
2^n - x = 2^n + |x| & 0≥x≥-2^n
\end{cases} \\
式中，[x]_原 是机器数，x是真值。</script><p>增加符号位作为最高位，其后加原数据绝对值。</p>
<p>最大的缺点是加法运算复杂。</p>
<p><img src="https://s2.loli.net/2022/02/16/Lxf5qSJim4Gc1TC.png" alt="image-20220216145144763"></p>
<p><img src="https://s2.loli.net/2022/02/15/gEftjZVW2FniR8o.png" alt="image-20220215222231486"></p>
<h5 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h5><p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220216145301928.png" alt="image-20220216145301928"></p>
<p>其表示范围与原码一致，且0有两种表示方法。</p>
<h4 id="2-补码表示法"><a href="#2-补码表示法" class="headerlink" title="2. 补码表示法"></a>2. 补码表示法</h4><p>正数补码等于原码</p>
<p>负数补码在原码的基础上，符号位不变，其余位数取反加一。</p>
<p>补码的拓展即为符号位的拓展，正数前补0，负数前补1.</p>
<p>补码的取值范围-128-127。</p>
<p><img src="https://s2.loli.net/2022/02/16/7mkTa4O25PA9xdv.png" alt="image-20220216145854118"></p>
<h5 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h5><p><img src="https://s2.loli.net/2022/02/16/yv8A5dPc4N1nthX.png" alt="image-20220216150338907"></p>
<h4 id="3-移码表示法"><a href="#3-移码表示法" class="headerlink" title="3. 移码表示法"></a>3. 移码表示法</h4><p>移码通常用来表示浮点数的阶码。</p>
<p><img src="https://s2.loli.net/2022/02/26/fMboR2hywnZcvdl.png" alt="image-20220215223357232"></p>
<h4 id="4-浮点数的机器表示"><a href="#4-浮点数的机器表示" class="headerlink" title="4. 浮点数的机器表示"></a>4. 浮点数的机器表示</h4><p>当前的计算机都采用统一的IEEE754标准中的格式表示浮点数。如下：</p>
<h5 id="32位短浮点数："><a href="#32位短浮点数：" class="headerlink" title="32位短浮点数："></a>32位短浮点数：</h5><p><img src="https://s2.loli.net/2022/02/15/7TBCrlsdJjVxeyU.png" alt="image-20220215224328269"></p>
<p>64位长浮点数</p>
<p><img src="https://s2.loli.net/2022/02/15/al9TZi3uD6RWStI.png" alt="image-20220215224403466"></p>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>S是浮点数的符号位，占1位，安排在最高位，S=0表示正数，S=1表示负数；</p>
<p>M是尾数，放在低位部分，占用23位/52位，小数点位置放在尾数域最左(最高)有效位的右边；</p>
<p>E是阶码，占用8位/11位，阶符采用隐含的方式，即采用移码的方法来表示正负指数。此时，将浮点数的指数真值e变成阶码E时，应将指数e加上一个固定的偏置常数127，即E=e+127。</p>
<h5 id="规格化表示"><a href="#规格化表示" class="headerlink" title="规格化表示"></a>规格化表示</h5><p>当尾数的值不为0时，尾数域的最高有效位应为1，这称为浮点数的规格化表示。</p>
<p>在IEEE754标准中，一个规格化的32位浮点数x的真值表示为：</p>
<script type="math/tex; mode=display">
x = (-1)^S × (1.M)×2^{E-127} \quad e=E-127</script><p>其中，尾数域所表示的值是1.M。由于尾数域最左边(最高有效位)总是1，故这一位无需存储，而认为隐藏在小数点的左边。于是用23位的字段可以存储24位有效数。</p>
<p><img src="https://s2.loli.net/2022/02/16/tdcgX5bT2U6eIZP.png" alt="image-20220216144706157"></p>
<p><img src="https://s2.loli.net/2022/02/15/KHYbaiTJy5Aw62B.png" alt="image-20220215231236313"></p>
<p><img src="https://s2.loli.net/2022/02/15/HayV5z3XrB7evwU.png" alt="image-20220215231312541"></p>
<p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220215231414891.png" alt="image-20220215231414891"></p>
<h3 id="5-校验码"><a href="#5-校验码" class="headerlink" title="5. 校验码"></a>5. 校验码</h3><p>在每个字上添加一些校验位，用来确定字中出现错误的位置。</p>
<p>最简单且广泛应用的检错码是，采用<strong>一位校验码</strong>的奇校验或偶校验。</p>
<h4 id="1-奇校验"><a href="#1-奇校验" class="headerlink" title="1. 奇校验"></a>1. 奇校验</h4><p>设$X=(x_0 x_1 … x_{n-1})$是一个n位字，则奇校验位$\overline C$定义为</p>
<script type="math/tex; mode=display">
\overline C = x_0 \bigoplus x_1 \bigoplus ... \bigoplus x_{n-1}</script><p>式中，$\bigoplus$表示按位加，表明只有当X中包含奇数个1时，才能使$\overline C = 1，即C=0$。</p>
<h4 id="2-偶校验"><a href="#2-偶校验" class="headerlink" title="2. 偶校验"></a>2. 偶校验</h4><p>偶校验位C定义为</p>
<script type="math/tex; mode=display">
C = x_0 \bigoplus x_1 \bigoplus ... \bigoplus x_{n-1}</script><p>即X中包含偶数个1时，才使C=0。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>若A=41H，即0010 0001增加偶校验位后，为0010 0001 0。</p>
<p><img src="https://s2.loli.net/2022/02/16/zXmiDflgtS4u1T6.png" alt="image-20220216140020946"></p>
<h2 id="2-定点加法、减法运算"><a href="#2-定点加法、减法运算" class="headerlink" title="2. 定点加法、减法运算"></a>2. 定点加法、减法运算</h2><h3 id="常用公式："><a href="#常用公式：" class="headerlink" title="常用公式："></a>常用公式：</h3><p>补码加法：$[x]_补 + [y]_补 = [x+y]_补 \quad (mod \, 2^{n+1})$</p>
<p>补码减法：$[x-y]_补 = [x]_补 - [y]_补 = [x]_补+[-y]_补$</p>
<p>​                   $[-y]_补 = -[y]_补 \quad (mod \, 2_{n+1})$</p>
<p>从$[y]_补求[-y]_补的方法是：对[y]_补连同符号位取反加1$。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="https://s2.loli.net/2022/02/16/NSrs7CmWVylAojt.png" alt="image-20220216142608474"></p>
<h3 id="溢出与检测方法"><a href="#溢出与检测方法" class="headerlink" title="溢出与检测方法"></a>溢出与检测方法</h3><h4 id="溢出概念"><a href="#溢出概念" class="headerlink" title="溢出概念"></a>溢出概念</h4><p>当两个正数相加，其值<strong>大于机器字长所能表示的最大正数</strong>，称为正溢；</p>
<p>当两个负数相加，其值<strong>小于机器字长所能表示的最小负数</strong>，称为负溢。</p>
<h4 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h4><h5 id="双符号位"><a href="#双符号位" class="headerlink" title="双符号位"></a>双符号位</h5><p>这称为“变形补码”。</p>
<p>为了得到两数变形补码之和等于两数和的变形补码，必须：</p>
<ol>
<li>两个符号位都看作数码一样参加运算</li>
<li>两数进行模$2_{n+2}$的加法，即最高位上产生进位要丢掉。</li>
</ol>
<p>采用变形补码后，任何正数，两个符号位都是”0”；任何负数，两个符号为都是”1”。</p>
<p>若两数相加，其结果符号位出现”01”，表示正溢出(结果大于$2^n$)；出现”10”，表示负溢出(结果小于$-2^n$)。</p>
<p>最高符号位永远表示结果的正确符号。</p>
<p><img src="https://s2.loli.net/2022/02/16/DcKbAWxeBkmiS6h.png" alt="image-20220216143907684"></p>
<h3 id="4-基本的二进制加法-减法器"><a href="#4-基本的二进制加法-减法器" class="headerlink" title="4. 基本的二进制加法/减法器"></a>4. 基本的二进制加法/减法器</h3><h4 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h4><p><img src="https://s2.loli.net/2022/02/16/Jm3B5DFwHl8WCpR.png" alt="image-20220216150729104"></p>
<h2 id="3-定点乘法运算"><a href="#3-定点乘法运算" class="headerlink" title="3. 定点乘法运算"></a>3. 定点乘法运算</h2><h3 id="1-不带符号的阵列乘法器"><a href="#1-不带符号的阵列乘法器" class="headerlink" title="1. 不带符号的阵列乘法器"></a>1. 不带符号的阵列乘法器</h3><p>采用与门和全加器(fa)构成阵列乘法。</p>
<h4 id="时间估算"><a href="#时间估算" class="headerlink" title="时间估算"></a>时间估算</h4><p><img src="https://s2.loli.net/2022/02/16/6FlX1poDRkTSu9j.png" alt="image-20220216152154058"></p>
<h3 id="2-带符号的阵列乘法器"><a href="#2-带符号的阵列乘法器" class="headerlink" title="2. 带符号的阵列乘法器"></a>2. 带符号的阵列乘法器</h3><h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><p><img src="https://s2.loli.net/2022/02/16/6naZS5Dkqjcb8zu.png" alt="image-20220216151100556"></p>
<p><img src="https://s2.loli.net/2022/02/16/ldHwSpa9nbWYx1D.png" alt="image-20220216153345959"></p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>在这种逻辑结构中，共使用了三个求补器。</p>
<h5 id="两个算前求补器的作用"><a href="#两个算前求补器的作用" class="headerlink" title="两个算前求补器的作用"></a>两个算前求补器的作用</h5><p>将两个操作数A和B在被不带符号的乘法阵列(核心部件)相乘之前，先变成正整数。</p>
<h5 id="算后求补器的作用"><a href="#算后求补器的作用" class="headerlink" title="算后求补器的作用"></a>算后求补器的作用</h5><p>当两个输入操作数的符号不一致时，把运算结果变换成带符号的数。</p>
<h5 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h5><p>为了完成必需的求补和乘法运算，时间大约比原码阵列乘法增加1倍。</p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><img src="https://s2.loli.net/2022/02/16/ob1DpAYUqvLigJl.png" alt="image-20220216152236154"></p>
<ol>
<li>符号位要单独运算</li>
<li>补码要转换为原码，再进行乘法，不方便</li>
<li><img src="https://s2.loli.net/2022/02/16/hd2vBO1muQXaoV6.png" alt="image-20220216153257787"></li>
</ol>
<h3 id="3-直接补码阵列乘法器"><a href="#3-直接补码阵列乘法器" class="headerlink" title="3. 直接补码阵列乘法器"></a>3. 直接补码阵列乘法器</h3><p><img src="https://s2.loli.net/2022/02/16/Wol642bgEqwZtLG.png" alt="image-20220216152609536"></p>
<h2 id="4-定点除法运算"><a href="#4-定点除法运算" class="headerlink" title="4. 定点除法运算"></a>4. 定点除法运算</h2><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p>机器不会心算，必须先作减法。</p>
<p>若余数为正，才知道够减(商1)；若余数为负, 不够减(商0)。不够减时必须恢复原来的余数，以便再继续往下运算。这种方法称为<strong>恢复余数法。</strong>要恢复原来的余数，只要当前的余数加上除数即可。</p>
<p>实际中常用<strong>加减交替法</strong>。其特点是运算过程中如出现不够减，则不必恢复余数，根据余数符号,可以继续往下运算，因此步数固定，控制简单。</p>
<h3 id="加减交替法"><a href="#加减交替法" class="headerlink" title="加减交替法"></a>加减交替法</h3><p><strong>不用恢复余数。</strong></p>
<p><strong>当余数为正时，商1，余数左移一位，减除数做2ri-|y|运算</strong></p>
<p><strong>当余数为负时，商0，余数左移一位，加除数做2ri+|y| 运算</strong></p>
<p>因为：$-y+y-\frac{1}{2}y = -y + \frac{1}{2}y$</p>
<p><img src="https://s2.loli.net/2022/02/16/WSRwnZdvV4s8K5T.png" alt="image-20220216153321434"></p>
<h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p><img src="https://s2.loli.net/2022/02/24/G3Kbyhnm6A4xd9W.png" alt="image-20220224193547423"></p>
<p><img src="https://s2.loli.net/2022/02/24/IoYjiUPKXaWnmDT.png" alt="image-20220224193915015"></p>
<p>一般都是当商变为1时，根据商的长度，考虑是否到此为止(确定保留几位小数)。</p>
<p>除法运算不加符号，等计算完毕后，再把符号补上。</p>
<h2 id="5-定点运算器的组成"><a href="#5-定点运算器的组成" class="headerlink" title="5. 定点运算器的组成"></a>5. 定点运算器的组成</h2><p>计算机中的逻辑运算，主要是指逻辑非、逻辑加(逻辑或)、逻辑乘(逻辑与)、逻辑异(逻辑异或)四种基本操作。</p>
<h3 id="多功能算数、逻辑运算单元-ALU"><a href="#多功能算数、逻辑运算单元-ALU" class="headerlink" title="多功能算数、逻辑运算单元(ALU)"></a>多功能算数、逻辑运算单元(ALU)</h3><p>多功能算术/逻辑运算单元(ALU)，它不仅具有多种算术运算和逻辑运算的功能，而且具有先行进位逻辑，从而能实现高速运算。</p>
<p><img src="https://s2.loli.net/2022/02/24/oJrZO7l4BPUmxSh.png" alt="image-20220224201931968"></p>
<p><img src="https://s2.loli.net/2022/02/24/f7v51F2IuhwDPoX.png" alt="image-20220224202048320"></p>
<h5 id="组内先行，组间串行"><a href="#组内先行，组间串行" class="headerlink" title="组内先行，组间串行(*)"></a>组内先行，组间串行(*)</h5><h2 id="6-浮点运算方法"><a href="#6-浮点运算方法" class="headerlink" title="6. 浮点运算方法"></a>6. 浮点运算方法</h2><p>设有两个浮点数，分别为：</p>
<p>$ x = 2^{E_x} \cdot M_x$</p>
<p>$ y = 2^{E_y} \cdot M_y$</p>
<p>其中，$E_x 和 E_y分别为数x和y的阶码，M_y和M_x分别是y和x的尾数。$</p>
<p>则，两浮点数进行加法和减法的运算规则是</p>
<script type="math/tex; mode=display">
z=x \pm y = (M_x 2^{E_x-E_y} \pm M_y)2^{E_y}</script><h3 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1. 步骤"></a>1. 步骤</h3><h4 id="0操作数检查"><a href="#0操作数检查" class="headerlink" title="0操作数检查"></a>0操作数检查</h4><p>检查是否有一个操作数为0。</p>
<h4 id="比较阶码大小并完成对阶"><a href="#比较阶码大小并完成对阶" class="headerlink" title="比较阶码大小并完成对阶"></a>比较阶码大小并完成对阶</h4><p>对阶时，小阶向大阶看齐，即小阶的尾数向右移位(相当于小数点左移)</p>
<h4 id="尾数进行加或减运算"><a href="#尾数进行加或减运算" class="headerlink" title="尾数进行加或减运算"></a>尾数进行加或减运算</h4><h4 id="操作数规格化并进行舍入处理"><a href="#操作数规格化并进行舍入处理" class="headerlink" title="操作数规格化并进行舍入处理"></a>操作数规格化并进行舍入处理</h4><h4 id="尾数处理"><a href="#尾数处理" class="headerlink" title="尾数处理"></a>尾数处理</h4><p><img src="https://s2.loli.net/2022/02/24/CrmpNQ7GkxoDiMd.png" alt="image-20220224202407215"></p>
<h5 id="舍入处理法"><a href="#舍入处理法" class="headerlink" title="舍入处理法"></a>舍入处理法</h5><ul>
<li>舍去的数中，有1，那保留的最低位就是1</li>
<li>舍去的数中，最高位是1，那么保留的最低位就是1</li>
</ul>
<h4 id="另外-1"><a href="#另外-1" class="headerlink" title="另外"></a>另外</h4><p><strong>浮点数的溢出，在于阶码溢出。</strong></p>
<h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h3><p>设数的阶码3位，尾数6位，用浮点运算方法：</p>
<p><img src="https://s2.loli.net/2022/02/24/r6odCAghiRlGnmy.png" alt="image-20220224200340588"> </p>
<p>设数的阶码3位，尾数6位，用浮点运算方法：</p>
<p><img src="https://s2.loli.net/2022/02/24/GVZ1X3uiyS2DL8A.png" alt="image-20220224200813157"></p>
<h3 id="3-流水线运算器"><a href="#3-流水线运算器" class="headerlink" title="3. 流水线运算器"></a>3. 流水线运算器</h3><p>加速比 = 串行/并行(一定大于1)。</p>
<p><img src="https://s2.loli.net/2022/02/24/kRBsQeVaEP6K2hq.png" alt="image-20220224202713285"></p>
<h1 id="Chapter-3-存储系统-两个大题"><a href="#Chapter-3-存储系统-两个大题" class="headerlink" title="Chapter 3 存储系统(两个大题)"></a>Chapter 3 存储系统(两个大题)</h1><h2 id="1-存储器概述"><a href="#1-存储器概述" class="headerlink" title="1. 存储器概述"></a>1. 存储器概述</h2><h3 id="三级存储系统"><a href="#三级存储系统" class="headerlink" title="三级存储系统"></a>三级存储系统</h3><p>cache、主存、外存储器。</p>
<p>前两个合起来即为二级存储系统：内存、外存。</p>
<h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><h4 id="读写功能"><a href="#读写功能" class="headerlink" title="读写功能"></a>读写功能</h4><p>只能读出不能写入：ROM(只读存储器)</p>
<p>既能读出也能写入：RAM(随机存取存储器)</p>
<h4 id="信息易失性"><a href="#信息易失性" class="headerlink" title="信息易失性"></a>信息易失性</h4><p>断电后信息消失的存储器：易失性存储器(RAM)</p>
<p>断电后仍能保存信息的存储器：非易失性存储器(ROM)</p>
<p>磁性材料做成的存储器是非易失性存储器。</p>
<h3 id="存储器的技术指标"><a href="#存储器的技术指标" class="headerlink" title="存储器的技术指标"></a>存储器的技术指标</h3><h4 id="1-存储容量"><a href="#1-存储容量" class="headerlink" title="1. 存储容量"></a>1. 存储容量</h4><p>存储容量指一个存储器中可存储的信息比特数。</p>
<p>可表示为：存储字数(存储单元数)×存储字长(每单元的比特数)。</p>
<h4 id="2-存取时间"><a href="#2-存取时间" class="headerlink" title="2. 存取时间"></a>2. 存取时间</h4><p>又称存储器访问时间，是从存储器接收到读/写命令开始，到信息被读出或写入完成所需的时间。</p>
<h4 id="3-存储周期"><a href="#3-存储周期" class="headerlink" title="3. 存储周期"></a>3. 存储周期</h4><p>是在存储器连续读写过程中，一次完整的存取操作所需的时间，即CPU连续两次访问存储器的最小间隔时间。</p>
<p>存储周期略大于存取时间。</p>
<h2 id="2-静态随机存取存储器-必考"><a href="#2-静态随机存取存储器-必考" class="headerlink" title="2. 静态随机存取存储器(必考)"></a>2. 静态随机存取存储器(必考)</h2><p>SRAM的优点是存取速度快，但存储密度和容量不如DRAM大。</p>
<h3 id="1-基本的SRAM逻辑结构"><a href="#1-基本的SRAM逻辑结构" class="headerlink" title="1. 基本的SRAM逻辑结构"></a>1. 基本的SRAM逻辑结构</h3><p><img src="https://s2.loli.net/2022/02/24/xwq5lBe3aCPdykR.png" alt="image-20220224204804844"></p>
<h3 id="2-SRAM的读-写时序"><a href="#2-SRAM的读-写时序" class="headerlink" title="2. SRAM的读/写时序"></a>2. SRAM的读/写时序</h3><h4 id="读周期"><a href="#读周期" class="headerlink" title="读周期"></a>读周期</h4><p>地址线先有效，以便进行地址译码，选中存储单元。$\overline {CS}和\overline{OE}$有效。</p>
<p>这是$t_{RC}$</p>
<p><img src="https://s2.loli.net/2022/02/24/oeg7NKVEyFxZjPw.png" alt="image-20220224205711890"></p>
<h4 id="写周期"><a href="#写周期" class="headerlink" title="写周期"></a>写周期</h4><p>地址线先有效，接着片选信号$\overline{CS}$有效，写命令$\overline{WE}$有效。此时数据总线上必须置 待写入数据。</p>
<p>写入时，地址线不能总变。</p>
<p><img src="https://s2.loli.net/2022/02/24/Fsw3kKND2yifraj.png" alt="image-20220224205809217"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>为了控制方便，常取$t_{RC} = t_{WC}$,通常称为存取周期。</p>
<h3 id="3-存储器容量的扩充"><a href="#3-存储器容量的扩充" class="headerlink" title="3. 存储器容量的扩充"></a>3. 存储器容量的扩充</h3><h4 id="1-位拓展"><a href="#1-位拓展" class="headerlink" title="1. 位拓展"></a>1. 位拓展</h4><p>拓展数据线。</p>
<h4 id="2-字拓展"><a href="#2-字拓展" class="headerlink" title="2. 字拓展"></a>2. 字拓展</h4><p>拓展地址线。</p>
<h4 id="3-字位拓展"><a href="#3-字位拓展" class="headerlink" title="3. 字位拓展"></a>3. 字位拓展</h4><p>二者都拓展。</p>
<h2 id="4-DRAM"><a href="#4-DRAM" class="headerlink" title="4. DRAM"></a>4. DRAM</h2><p>DRAM的存储元所需元件更少，所以存储密度更高。</p>
<h3 id="DRAM的刷新策略"><a href="#DRAM的刷新策略" class="headerlink" title="DRAM的刷新策略"></a>DRAM的刷新策略</h3><p>DRAM存储位元是基于电容器上的电荷量存储信息的，DRAM的读操作是破坏性的，会使电容器上的电荷流失，因为读出后必须刷新(读被读出的数据，将其重新写入)。</p>
<p>而未读写的存储元也要定期刷新，因为电荷量会逐渐泄露而减少。</p>
<h2 id="5-cache"><a href="#5-cache" class="headerlink" title="5. cache"></a>5. cache</h2><h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><h4 id="题型1"><a href="#题型1" class="headerlink" title="题型1"></a>题型1</h4><p><img src="https://s2.loli.net/2022/02/25/ubRFgBvWiTq39ec.png" alt="image-20220225231927296"></p>
<h4 id="题型2"><a href="#题型2" class="headerlink" title="题型2"></a>题型2</h4><p><img src="https://s2.loli.net/2022/02/25/mQ5ygktUGXr2Yow.png" alt="image-20220225231708983"></p>
<p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220225231840941.png" alt="image-20220225231840941"></p>
<h2 id="6-虚拟存储器"><a href="#6-虚拟存储器" class="headerlink" title="6. 虚拟存储器"></a>6. 虚拟存储器</h2><p>用户在编制程序时，使用的地址为虚地址或逻辑地址，其对应的存储空间称为虚存空间，是程序员所看到的地址范围。</p>
<p>而计算机物理内存的访问地址则称为实地址或物理地址，对应的存储空间称为物理存储空间或主存空间。程序进行虚地址到实地址转换的过程称为程序的再定位。</p>
<h3 id="1-功能"><a href="#1-功能" class="headerlink" title="1. 功能"></a>1. 功能</h3><p><strong>虚拟存储器的一个重要用途是解决计算机中主存储器的容量问题，在不明显降低平均访问速度的前提下增加程序的访问空间。</strong></p>
<h3 id="2-两种存储系统的区别"><a href="#2-两种存储系统的区别" class="headerlink" title="2. 两种存储系统的区别"></a>2. 两种存储系统的区别</h3><p>在虚拟存储器中未命中的性能损失要远大于cache系统中未命中的损失（因为磁盘的存取时间是主存存取时间的上千倍）。主存存取时间是cache的存取时间的5～10倍。</p>
<p>cache是通过硬件实现的，虚拟存储器是通过软件(操作系统)实现的。</p>
<h3 id="3-页式虚拟存储器"><a href="#3-页式虚拟存储器" class="headerlink" title="3. 页式虚拟存储器"></a>3. 页式虚拟存储器</h3><p><img src="https://s2.loli.net/2022/02/26/XPucjEiNYwpSd1B.png" alt="image-20220226221911029"></p>
<p><img src="https://s2.loli.net/2022/02/26/kqFEH9eUWbDwdM5.png" alt="image-20220226222027358"></p>
<p><img src="https://s2.loli.net/2022/02/26/hurljqTQZi3sPLK.png" alt="image-20220226222252150"></p>
<h3 id="4-段式虚拟存储器"><a href="#4-段式虚拟存储器" class="headerlink" title="4. 段式虚拟存储器"></a>4. 段式虚拟存储器</h3><p><strong>在段式虚拟存储系统中，段是按照程序的逻辑结构划分的，各个段的长度因程序而异。</strong></p>
<p><img src="https://s2.loli.net/2022/02/26/C6pScNbjUX2aAlr.png" alt="image-20220226222825964"></p>
<p><img src="https://s2.loli.net/2022/02/26/kKQj8P2sOXrtRYh.png" alt="image-20220226222855961"></p>
<p>实存地址=段起地址 + 段内地址。</p>
<h3 id="5-段页式虚拟存储器"><a href="#5-段页式虚拟存储器" class="headerlink" title="5. 段页式虚拟存储器"></a>5. 段页式虚拟存储器</h3><p><img src="https://s2.loli.net/2022/02/26/quk52C7th1wTvXg.png" alt="image-20220226223319885"></p>
<p><img src="https://s2.loli.net/2022/02/26/km6AvEIRjygpHY1.png" alt="image-20220226223341265"></p>
<p>表示的是：通过基号C，到基址寄存器获取程序C段的起始地址，找到其中序号为1的段，再去寻段中的第2页。</p>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p>①根据基号C执行SC加1（段号）操作，得到段表相应行地址，其内容为页表的起始地址ｂ。</p>
<p>②执行b+2（页号），得到物理页号的地址，其内容即为物理页10。</p>
<p>③物理页号与页内地址拼接即得物理地址。</p>
<p><strong>如果，计算机只有一个基址寄存器，基号可不要，多道程序切换时，操作系统修改基址寄存器内容。</strong></p>
<p><strong>可以看出，段页式虚拟存储系统由虚拟地址向主存地址的变换至少需要查两次表。</strong> </p>
<h5 id="页面替换是由操作系统实现的。"><a href="#页面替换是由操作系统实现的。" class="headerlink" title="页面替换是由操作系统实现的。"></a>页面替换是由操作系统实现的。</h5><h1 id="Chapter-4-指令系统"><a href="#Chapter-4-指令系统" class="headerlink" title="Chapter 4 指令系统"></a>Chapter 4 指令系统</h1><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><h3 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h3><p>指令中包含着操作数的地址，操作数在累加寄存器中</p>
<h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><p>地址字段放的是操作数的值</p>
<h4 id="操作数-A"><a href="#操作数-A" class="headerlink" title="操作数=A"></a>操作数=A</h4><h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>地址字段放的是操作数在内存中的地址</p>
<h4 id="EA-A"><a href="#EA-A" class="headerlink" title="EA=A"></a>EA=A</h4><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>地址字段放的是存放 操作数在内存中的地址 的内存地址</p>
<h4 id="EA-A-1"><a href="#EA-A-1" class="headerlink" title="EA=(A)"></a>EA=(A)</h4><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>操作数放在寄存器中，地址字段放的是寄存器的编号</p>
<h4 id="EA-R"><a href="#EA-R" class="headerlink" title="EA=R"></a>EA=R</h4><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p>操作数地址放在寄存器中，地址字段放的是寄存器的编号</p>
<h4 id="EA-R-1"><a href="#EA-R-1" class="headerlink" title="EA=(R)"></a>EA=(R)</h4><h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><p>偏移量即为PC</p>
<h4 id="EA-A-PC"><a href="#EA-A-PC" class="headerlink" title="EA=A+(PC)"></a>EA=A+(PC)</h4><h3 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h3><p>被引用的基址寄存器中放的是操作数在内存中的起始地址，另一个地址字段放的是偏移量</p>
<h4 id="EA-A-R"><a href="#EA-A-R" class="headerlink" title="EA=A+(R)"></a>EA=A+(R)</h4><h3 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h3><p>被引用的寄存器中放的是偏移量，另一个地址字段放的是操作数在内存中的起始地址。</p>
<h4 id="EA-A-R-1"><a href="#EA-A-R-1" class="headerlink" title="EA=A+(R)"></a>EA=A+(R)</h4><h2 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h2><h3 id="1-定长设计出多少条指令"><a href="#1-定长设计出多少条指令" class="headerlink" title="1. 定长设计出多少条指令"></a>1. 定长设计出多少条指令</h3><p><img src="https://s2.loli.net/2022/02/26/CU6a24uVJKAdxnR.png" alt="image-20220226011505296"></p>
<h3 id="2-变长设计出指令数目"><a href="#2-变长设计出指令数目" class="headerlink" title="2. 变长设计出指令数目"></a>2. 变长设计出指令数目</h3><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><p>由于操作码的长度不固定，那么2地址指令给操作码分配的地址长度n，不可能在设计2地址指令时用完。也就是说，不可能会是$2^n$条2地址指令，因为还要留出一部分的二级制数字组合，存放1地址指令的前四位和0地址指令的前4位。此时，使用$2^n-m$，其中m为2地址指令的数目，可得当前剩余的n位的2进制组合的数目。</p>
<p><img src="https://s2.loli.net/2022/02/26/5sCmxlB4R8DkHjX.png" alt="image-20220226011553541"></p>
<h3 id="3-综合题"><a href="#3-综合题" class="headerlink" title="3. 综合题"></a>3. 综合题</h3><p><img src="https://s2.loli.net/2022/02/26/X2iRSm4VuqyaQK8.png" alt="image-20220226011705292"></p>
<p><img src="https://s2.loli.net/2022/02/26/lqNuFiafBOXtb5k.png" alt="image-20220226011752472"></p>
]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>DataBase-System</title>
    <url>/2022/01/06/DataBase-System/</url>
    <content><![CDATA[<h1 id="第一章-数据库系统世界"><a href="#第一章-数据库系统世界" class="headerlink" title="第一章 数据库系统世界"></a>第一章 数据库系统世界</h1><p>数据库的能力来自于已发展了数十年的知识和技术，这些知识和技术蕴藏在名为<strong>数据库管理系统(Database Management System)</strong> 的软件中。该软件也叫DBMS，或更通俗地称为“数据库系统”。</p>
<h2 id="第二节-数据库管理系统概述"><a href="#第二节-数据库管理系统概述" class="headerlink" title="第二节 数据库管理系统概述"></a>第二节 数据库管理系统概述</h2><p>如图所示，是一个完整的DBMS结构，其中单线框表示系统构成，双线框表示内存中的数据结构，实线表示控制和数据流，虚线只表示数据流。</p>
<p>首先，在顶部有两个命令源将命令发给DBMS：</p>
<ol>
<li>通常的用户和应用程序，发出查询数据或修改数据命令。</li>
<li>数据库管理员(Administrator)，一个人或一批人，负责数据库结构或模式。</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/06/drTh2xNimCMFBlg.png" alt="image-20220106211555051"></p>
<h3 id="数据定义语言命令"><a href="#数据定义语言命令" class="headerlink" title="数据定义语言命令"></a>数据定义语言命令</h3><p><img src="https://s2.loli.net/2022/01/07/gQmTNBluVt7sIpr.png" alt="image-20220107003044094"></p>
<h3 id="查询处理概述"><a href="#查询处理概述" class="headerlink" title="查询处理概述"></a>查询处理概述</h3><p>与DBMS交互最重要的工作使沿着图所示左边的路径。</p>
<p>用户或应用程序使用数据库操作语言(DML)启动一些不影响数据库模式的操作，但是这些操作可能会影响数据库的内容，或者是从数据库中抽取数据。DML语言由两个独立的子系统处理。</p>
<h4 id="查询处理"><a href="#查询处理" class="headerlink" title="查询处理"></a>查询处理</h4><p>查询通过查询编译器(query compiler)完成语法分析和优化。</p>
<p>编译的结果使查询计划(query plan)或是由DBMS执行并获得查询结果的操作序列，它们将被送给执行引擎(execution engine)。执行引擎向资源管理器发出一系列获取小块数据的请求，典型的小块数据关系是记录或元组。</p>
<p><strong>资源管理器知道数据文件(data file, 存放关系的条件)、数据文件的格式和记录大小以及索引文件(index file)等。</strong>这些信息对于快速从数据文件中找到响应数据元素是有用的。</p>
<p>数据请求又被传送给缓冲区管理器(buffer manager)。缓冲区管理器的任务是从二级存取器(通常是磁盘，永久地保存数据)中获取数据送入主存缓冲区中。</p>
<p>一般情况下，页或“磁盘块”是缓冲区和磁盘间的传送单位。</p>
<p>为了从磁盘中得到数据，缓冲区管理器与存储器管理器进行通信。存储器管理器可能包含操作系统命令，但是最典型的是DBMS直接向磁盘控制器发命令。</p>
<h4 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h4><p>查询或其他DML操作被组织成事务(transaction)。事务是必须原子性执行的单位，执行中的事务之间还必须相互隔离。任何一个查询或修改操作本身，就可以是一个事务。另外，事务的执行必须持久(durable)，也就是说任何已完成事务的作用必须被保持，即使是事务刚刚完成系统就失败时也应如此。是五处理器被分成两个主要部分：</p>
<ol>
<li>并发控制管理器(concurrency-control manager)或调度器(scheduler)，保证事务的原子性和独立性。</li>
<li>日志(logging)和恢复管理器(recovery manager)，负责事务的持久性。</li>
</ol>
<h3 id="存储器和缓冲区管理器"><a href="#存储器和缓冲区管理器" class="headerlink" title="存储器和缓冲区管理器"></a>存储器和缓冲区管理器</h3><p>数据库数据平常存储在二级存储器中。计算机系统中的“二级存储器”一般指磁盘。可是，对数据的操作只能在主存中执行。存储器管理器( storage manager）的任务就是控制数据在磁盘上的位置存放和在磁盘与主存间的移动。</p>
<p>在一个简单数据库系统中，存储器管理器可以就是操作系统下的文件系统。可是，为了提高效率，DBMS常常直接控制磁盘上的存储，至少是在某些环境下如此。存储器管理器保持跟踪磁盘上的文件位置，根据请求从缓冲区管理器中获取含有请求文件的一个或多个磁盘块。</p>
<p><strong>缓冲区管理器负责把可用主存分割成缓冲区(buffer)</strong>，缓冲区是包含若干个页面的区域，其中可以传输磁盘块。于是，所有需要从磁盘中获取信息的DBMS组件，都或是直接或是通过执行引擎的方式，与缓冲区和缓冲区管理器交互。</p>
<h4 id="各个组件可能需要的信息种类有"><a href="#各个组件可能需要的信息种类有" class="headerlink" title="各个组件可能需要的信息种类有:"></a>各个组件可能需要的信息种类有:</h4><ol>
<li>数据：数据库本身的内容</li>
<li>元数据：描述数据库结构及其约束的数据库模式</li>
<li>日志记录：对数据库新近修改的信息，该信息支持数据库的持久性</li>
<li>统计数据：由DBMS手机和存储的关于数据特征的数据。例如，数据库大小、数据库中的值、数据库中的各种关系和其他成分。</li>
<li>索引：支持对数据库中数据有效存取的数据结构。</li>
</ol>
<h3 id="事务处理-1"><a href="#事务处理-1" class="headerlink" title="事务处理"></a>事务处理</h3><p>通常将一个或一组数据库操作组成一个事务。</p>
<p>事务的执行满足原子性，并且与其他事务的执行互相隔离。另外，DBMS还要保证事务的持久性:已完成事务的工作永不丢失。</p>
<p>事务管理器（(transaction manager）接收来自应用的事务命令( transaction command)，这些命令告诉事务管理器事务何时开始，何时结束，以及应用期望的信息（例如，某些应用可能不需要原子性)。</p>
<p>事务处理器执行如下一些任务:</p>
<ol>
<li><p><strong>记日志(logging): </strong>为了保证持久性，数据库的每一个变化都单独地记录在磁盘上。</p>
<p>日志管理器( tog manager）遵循一种设计原则，无论何时系统失败或“崩溃”，恢复管理器都能够通过检查日志中的修改记录，把数据库恢复到某个一致状态。</p>
<p>日志管理器先把日志写人缓冲区，然后与缓冲区管理器协商以确保缓冲区在合适的时间被写入磁盘（磁盘数据可以在系统崩溃后幸存下来)。</p>
</li>
<li><p><strong>并发控制(concurrency control):事务必须独立执行。</strong></p>
<p>但是在大多数系统中，很多事务都是同时在执行。因此，调度器（并发控制管理器）必须保证多个事务的单个动作是按某个次序在执行，按该次序执行的效果应该与系统一次只执行一个事务一样。</p>
<p>典型的调度器是通过在数据库的某些片断上加锁（lock)的方式工作。锁将防止两个事务用不正确的交互方式对同一数据片段存取。如图1-1所示，锁通常保存在主存的锁表(lock table)中，调度器通过阻止执行引擎对已加锁的数据库内容的存取来影响查询和其他数据库操作。</p>
</li>
<li><p><strong>消除死锁（deadlock resolution): </strong>当事务通过调度器获取锁以竞争其所需的资源时，系统可能会陷人一种状态。</p>
<p><strong>在该状态中，因为每个事务需要的资源都被另一个事务占有，所以没有一个事务能够继续执行。</strong></p>
<p>此时，事务管理器有责任调解，并删除（“回滚”或“终止”)一个或多个事务，以便其他事物可以继续执行。<br><img src="https://s2.loli.net/2022/01/07/jZcvXrLtJOzDWFI.png" alt="image-20220107012544181"></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库系统基础教程</tag>
      </tags>
  </entry>
  <entry>
    <title>DataBase</title>
    <url>/2021/12/22/DataBase/</url>
    <content><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="1-1-数据库系统概论"><a href="#1-1-数据库系统概论" class="headerlink" title="1.1 数据库系统概论"></a>1.1 数据库系统概论</h2><h3 id="1-4个基本概念"><a href="#1-4个基本概念" class="headerlink" title="1. 4个基本概念"></a>1. 4个基本概念</h3><h4 id="1-数据"><a href="#1-数据" class="headerlink" title="1. 数据"></a>1. 数据</h4><p><strong>描述事物的符号记录称为数据</strong>。数据的种类有数字、文字、图形、图像、声音、正文等。</p>
<p>数据的含义称为数据的语义，数据与其语义是不可分的。</p>
<h4 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2. 数据库"></a>2. 数据库</h4><p>数据库是<strong>长期储存</strong>在计算机内、<strong>有组织的</strong>、<strong>可共享的</strong>大量数据的集合。</p>
<h5 id="数据库的基本特征："><a href="#数据库的基本特征：" class="headerlink" title="数据库的基本特征："></a>数据库的基本特征：</h5><ul>
<li>数据按一定的数据规模组织、描述和储存</li>
<li>可为各种用户共享</li>
<li>冗余度较小</li>
<li>数据独立性较高</li>
<li>易拓展</li>
</ul>
<h4 id="3-数据库管理系统-DBMS"><a href="#3-数据库管理系统-DBMS" class="headerlink" title="3. 数据库管理系统(DBMS)"></a>3. 数据库管理系统(DBMS)</h4><ul>
<li>位于用户与操作系统之间的一层数据管理软件</li>
<li><p>是基础软件，是一个大型复杂的软件系统</p>
</li>
<li><p>可以科学地组织和存储数据、高效地获取和维护数据</p>
</li>
</ul>
<h5 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h5><ul>
<li>数据定义功能</li>
<li>数据组织、存储和管理功能</li>
<li>数据操纵功能</li>
<li>数据库的事务管理和运行管理</li>
<li>数据库的建立和维护功能</li>
<li>其他功能，如不同数据库之间的互访和互操作功能等。</li>
</ul>
<h4 id="4-数据库系统"><a href="#4-数据库系统" class="headerlink" title="4. 数据库系统"></a>4. 数据库系统</h4><p>由数据库、数据库管理系统(及其应用开发工具)、应用程序、数据库管理员四部分构成。</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>数据结构化</li>
<li>数据的共享性高，冗余度低，易扩充</li>
<li>数据独立性高</li>
<li>数据由DBMS统一管理和控制</li>
</ol>
<h3 id="2-数据模型"><a href="#2-数据模型" class="headerlink" title="2. 数据模型"></a>2. 数据模型</h3><p>数据模型通常是由数据结构、数据操作和完整性约束三部分组成。</p>
<p>数据模型是数据库系统的基础。</p>
<h4 id="三种数据模型"><a href="#三种数据模型" class="headerlink" title="三种数据模型"></a>三种数据模型</h4><p>数据库管理系统常见的数据模型有层次模型、网状模型和关系模型。</p>
<h5 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h5><p>满足下面两个条件的基本层次联系的集合：</p>
<ul>
<li>有且只有一个结点没有双亲结点，这个结点称为根节点；</li>
<li>根以外的其他结点有且只有一个双亲结点。</li>
</ul>
<h5 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h5><p>满足下面两个条件的基本层次联系的集合：</p>
<ul>
<li>允许一个以上的结点无双亲；</li>
<li>一个结点可以有多于一个的双亲。 </li>
</ul>
<h3 id="3-三级模式结构"><a href="#3-三级模式结构" class="headerlink" title="3. 三级模式结构"></a>3. 三级模式结构</h3><p>数据库系统的三级模式结构由外模式、模式和内模式组成。</p>
<h4 id="外模式"><a href="#外模式" class="headerlink" title="外模式"></a>外模式</h4><p>亦称子模式或用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图。</p>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p>亦称逻辑模式，是数据库全体数据的逻辑结构和特性的描述，是所有用户的公共数据视图。模式描述的是数据的全局逻辑结构。外模式通常是模式的子集。</p>
<h4 id="内模式"><a href="#内模式" class="headerlink" title="内模式"></a>内模式</h4><p>亦称存储模式，是数据在数据库系统内部的表示，即对数据的物理结构和存储方式的描述。</p>
<p>(内模式是数据库在物理存储方面的描述，定义所有的内部记录类型、 <strong>索引</strong> 和 <strong>文件</strong> 的组织方式，以及数据控制方面的细节。)</p>
<h4 id="两级映像"><a href="#两级映像" class="headerlink" title="两级映像"></a>两级映像</h4><p>为了能够在内部实现这三个抽象层次的联系和转换，数据库系统在这三级模式之间提供了两级映像：外模式/模式映像和模式/内模式映像，保证了数据库系统中数据较高的逻辑独立性和物理独立性。</p>
<h3 id="4-数据独立性"><a href="#4-数据独立性" class="headerlink" title="4. 数据独立性"></a>4. 数据独立性</h3><h4 id="数据的物理独立性"><a href="#数据的物理独立性" class="headerlink" title="数据的物理独立性"></a>数据的物理独立性</h4><p>当数据库的存储结构发生改变时，由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变，这就是数据与程序的物理独立性。</p>
<h4 id="数据的逻辑独立性"><a href="#数据的逻辑独立性" class="headerlink" title="数据的逻辑独立性"></a>数据的逻辑独立性</h4><p>当数据的逻辑结构即模式改变时，由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变，从而应用程序不必修改，这就是数据与程序的逻辑独立性。</p>
<h4 id="而"><a href="#而" class="headerlink" title="而"></a>而</h4><p>DBMS在三级模式之间提供的两级映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。</p>
<h3 id="5-术语"><a href="#5-术语" class="headerlink" title="5. 术语"></a>5. 术语</h3><h4 id="实体中"><a href="#实体中" class="headerlink" title="实体中"></a>实体中</h4><p>实体：客观存在并可以相互区分的事物。</p>
<p>实体型：用实体名及其属性名集合来抽象和刻画同类实体。</p>
<p> 实体集：同型实体的集合。</p>
<p> 实体之间的联系：包括实体(型)内部的联系(各属性之间的联系)和实体(型)之间的联系(不同实体集之间的联系)。有一对一、一对多、多对多。</p>
<h4 id="关系模型中"><a href="#关系模型中" class="headerlink" title="关系模型中"></a>关系模型中</h4><p>关系模型是由关系数据结构、关系操作集合和关系完整性约束三部分组成。在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。</p>
<p>关系：一个关系对应通常说的是一张表。</p>
<p>属性(关系模型中)：表中的一列即为一个属性。</p>
<p>域：属性的取值范围。</p>
<p>元组：表中的一行即为一个元组。</p>
<p>码(关系模型中)：表中的某个属性组，可以唯一确定一个元组。</p>
<p>分量：元组中的一个属性值。</p>
<p>关系模式：对关系的描述，一般表示为关系名（属性1，属性2，··· ，属性n）</p>
<h4 id="语言及其他"><a href="#语言及其他" class="headerlink" title="语言及其他"></a>语言及其他</h4><p>DDL：数据定义语言，用来定义数据库模式、外模式、内模式的语言。</p>
<p>DML：数据操纵语言，用来对数据库中的数据进行查询、插入、删除和修改的语句。</p>
<p>E-R模型是数据库的 <strong>概念模型</strong> 设计阶段的一个有力工具。</p>
<p>E-R图中包括 <strong>实体</strong> 、<strong>属性</strong> 和联系三种基本图素。</p>
<p>数据库中的文件组织方式是：顺序文件、索引文件、散列文件、倒排文件。</p>
]]></content>
      <tags>
        <tag>数据库...</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer_Network</title>
    <url>/2021/12/22/Computer-Network/</url>
    <content><![CDATA[<h1 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h1><h5 id="计算机网络涉及通信与计算机两个领域，它的发展过程是计算机与通信融合的过程。"><a href="#计算机网络涉及通信与计算机两个领域，它的发展过程是计算机与通信融合的过程。" class="headerlink" title="计算机网络涉及通信与计算机两个领域，它的发展过程是计算机与通信融合的过程。"></a>计算机网络涉及通信与计算机两个领域，它的发展过程是计算机与通信融合的过程。</h5><h2 id="1-四个阶段"><a href="#1-四个阶段" class="headerlink" title="1. 四个阶段"></a>1. 四个阶段</h2><p>计算机网络的发展经历了四个阶段：</p>
<ol>
<li>第一阶段：<strong>面向终端</strong>的计算机网络(以<strong>单个计算机为中心</strong>的<strong>远程联机系统</strong>)，特点为连接。</li>
<li>第二阶段：<strong>互不兼容</strong>的计算机网络(多台计算机通过通信线路互联的计算机网络，完成了网络体系结构与协议的研究)(协议是计算机之间沟通的基本规则)(通过网关实现SNA和DNA之间的通信，适合异种网络规模较小的场合)</li>
<li>第三阶段：<strong>标准的开放的</strong>计算机网络(具有统一的网络体系结构，遵循国际通信标准化协议的计算机网络，提出了开放系统互联参考模型与协议)</li>
<li>第四阶段：Internet发展和普及阶段(计算机网络向互联、高速、智能化方向发展，获得广泛应用)</li>
</ol>
<blockquote>
<p>在计算网络的发展过程中，最具代表性的是20世纪70年代美国国防部高级研究计划局的<strong>ARPANET(ARPA网)</strong>，采用了<strong>“存储转发-分组交换”</strong>原理，标志着计算机网络的兴起。</p>
</blockquote>
<h2 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h2><p>国外经典：计算机网络是自主计算机的互联集合。(就这个吧)</p>
<p>谢希仁：一些相互连接的、自治的计算机集合。</p>
<p>书上：计算机网络是通过通信设施(通信网络)，将地理上分散的<strong>具有自治功能的多个计算机系统(主体)互连起来(形式)</strong>，进行信息交换，实现资源共享、互操作和协同工作的系统。</p>
<h2 id="3-模型"><a href="#3-模型" class="headerlink" title="3. 模型"></a>3. 模型</h2><h3 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h3><p><strong>1984年，ISO正式颁布了一个称为“开放系统互联基本参考模型”的国际标准ISO7498，简称OSI/RM。该模型分为7个层次，有时也称OSI 7层模型</strong>。<img src="https://s2.loli.net/2021/12/22/tsJdIEiZFnVfwu7.png" alt="image-20211222154318373"></p>
<h4 id="分层及介绍"><a href="#分层及介绍" class="headerlink" title="分层及介绍"></a>分层及介绍</h4><h5 id="第一层：物理层"><a href="#第一层：物理层" class="headerlink" title="第一层：物理层"></a>第一层：<strong>物理层</strong></h5><ul>
<li>是整个OSI参考模型的最低层，提供物理连接。</li>
<li>其功能是在物理媒体上<strong>透明地传输原始比特流(进行二进制传输)</strong></li>
<li>接口标准：EIA-232、EIA/TIA RS-449等</li>
</ul>
<h5 id="第二层：数据链路层"><a href="#第二层：数据链路层" class="headerlink" title="第二层：数据链路层"></a>第二层：<strong>数据链路层</strong></h5><ul>
<li>建立在物理传输能力的基础上，以<strong>帧为单位</strong>传输数据</li>
<li>主要功能包括：成帧、差错控制、流量控制和传输管理等。主要考虑相邻节点之间的数据交换</li>
<li>可用的协议：PPP，X.25，帧中继。</li>
<li>工作在数据链路层上的交换机俗称“第二层交换机”。</li>
</ul>
<h5 id="第三层：网络层"><a href="#第三层：网络层" class="headerlink" title="第三层：网络层"></a>第三层：<strong>网络层</strong></h5><ul>
<li>通过网络连接交换运输层实体发出的数据，以<strong>分组</strong>为传送单位。</li>
<li>主要功能：选择合适的路由，使发送站的传输层传下来的分组能够正确无误地按照地址找到目的站，并交付目的站的运输层，以及实现拥塞控制、网络互连等功能。</li>
<li>协议有：IP、ARP、RARP等。</li>
</ul>
<h5 id="第四层：运输层-传输层"><a href="#第四层：运输层-传输层" class="headerlink" title="第四层：运输层(传输层)"></a>第四层：<strong>运输层(传输层)</strong></h5><ul>
<li>在底层服务的基础上，提供一种通用的传输服务。</li>
<li>运输层向上一层提供一个可靠的端到端的服务，使会话层不知道运输层以下的数据通信的细节。运输层只存在于端系统(主机)种，运输层以上的层不再考虑信息传输的问题。</li>
<li>主要功能：传输地址到网络地址的映射、多路复用与分用、传输连接的建立与释放、分段与重新组装、组块与分块。</li>
</ul>
<h5 id="第五层：会话层"><a href="#第五层：会话层" class="headerlink" title="第五层：会话层"></a>第五层：<strong>会话层</strong></h5><ul>
<li><p>不参与具体的数据传输，但管理数据，为相互合作的表示层进程之间提供一套会话设施。会话的意思是，两个应用进程之间为交换面向进程的信息而按一定规则建立起来的一个暂时联系</p>
</li>
<li><p>主要功能：会话连接到传输连接的映射、数据传送、会话连接的恢复和释放、会话管理、令牌管理和活动管理。</p>
</li>
</ul>
<h5 id="第六层：表示层"><a href="#第六层：表示层" class="headerlink" title="第六层：表示层"></a>第六层：<strong>表示层</strong></h5><ul>
<li>表示层为异种计算机通信提供了一种公共语言，完成应用层数据所需的任何转换，以便能进行互操作。</li>
<li>主要功能：数据语法转换、语法表示、表示层连接管理、数据加密和数据压缩。</li>
</ul>
<h5 id="第七层：应用层"><a href="#第七层：应用层" class="headerlink" title="第七层：应用层"></a>第七层：<strong>应用层</strong></h5><ul>
<li>应用层是OSI体系结构的最高层。这一层的协议直接为端用户服务，提供分布式处理环境。</li>
<li>应用层不仅要提供应用进程所需要的信息变换和远程操作，而且还要作为相互作用的应用进程的用户代理，来完成一些进行语义上有意义的信息的交换所必需的功能。</li>
</ul>
<h4 id="数据的封装与实际传送过程"><a href="#数据的封装与实际传送过程" class="headerlink" title="数据的封装与实际传送过程"></a>数据的封装与实际传送过程</h4><p><img src="https://s2.loli.net/2021/12/22/EzOWNewC9PLvM18.png" alt="image-20211222165453663"></p>
<blockquote>
<p>下层是通信服务的提供者，上层是通信服务的使用者。</p>
<p>N-1层使用N-2层提供的服务以及本层的功能。</p>
</blockquote>
<h3 id="TCP-IP-参考模型"><a href="#TCP-IP-参考模型" class="headerlink" title="TCP/IP 参考模型"></a>TCP/IP 参考模型</h3><p><strong>1977~1979年，ARPANET推出TCP/IP体系结构和协议(传输控制协议/网际协议为代表的协议栈)</strong>。</p>
<p><img src="https://s2.loli.net/2021/12/22/s1fY2Eqt8jU7p5x.png" alt="image-20211222170621802"></p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>协议：远程登录协议(TELNET)、文件传送协议(FTP)、简单邮件传送协议(SMTP)、域名服务器(DNS)、超文本传输协议(HTTP)等。</p>
<h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><p>协议：TCP(面向连接的可靠的协议)、UDP(无连接的、不可靠的协议)</p>
<h4 id="网际层"><a href="#网际层" class="headerlink" title="网际层"></a>网际层</h4><p>定义了正式的分组交换格式和协议，即IP协议。</p>
<h4 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h4><p>功能就类似于OSI的物理层和数据链路层，但实际上TCP/IP协议并没有真正描述这一部分。</p>
<h3 id="二者的对比"><a href="#二者的对比" class="headerlink" title="二者的对比"></a>二者的对比</h3><p><img src="https://s2.loli.net/2022/02/15/BOmxQ5HEI4ApYdJ.png" alt="image-20220215105935188"></p>
<p>事实上，OSI参考模型和TCP/IP参考模型的原理和概念都是一样的，只是在定义上和细节处理上不同而已。</p>
<p>第一、OSI参考模型精确地定义了三个主要概念：服务、协议和接口，与现代的面向对象程序设计思想非常吻合。而TCP/IP模型在这三个概念上却没有明确区分(不符合软件工程的思想)。</p>
<p>第二、OSI参考模型产生在协议发明之前，没有偏向于任何特定的协议，通用性良好。TCP/IP模型实际上是对已有协议的描述，因此不会出现协议不能匹配模型的情况(不适合非TCP/IP模型的协议栈)。</p>
<p>第三、OSI参考模型在网络层支持无连接和面向连接的通信，但在运输层仅有面向连接的通信，而TCP/IP模型认为可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式，但在运输层支持无连接和面向连接两种模式。</p>
<p>OSI参考模型缺乏市场与商业动力，结构复杂，实现周期长，运行效率低。</p>
<p><img src="https://s2.loli.net/2022/02/15/NXTg2uRIZ8W3qac.png" alt="image-20220215111501221"></p>
<h2 id="4-计算机网络的分类"><a href="#4-计算机网络的分类" class="headerlink" title="4. 计算机网络的分类"></a>4. 计算机网络的分类</h2><p>记得大致分了几类。</p>
<h3 id="按地理位置分"><a href="#按地理位置分" class="headerlink" title="按地理位置分"></a>按地理位置分</h3><ul>
<li>广域网(覆盖范围通常是几十到几千公里(一公里=一千米)的区域。)</li>
<li>城域网(覆盖范围通常是10~100km。)</li>
<li>局域网(覆盖范围通常是几十米到几千米)(最常用的是以太网)</li>
<li>个人区域网(10米左右)</li>
</ul>
<h3 id="按网络拓扑结构分"><a href="#按网络拓扑结构分" class="headerlink" title="按网络拓扑结构分"></a>按网络拓扑结构分</h3><ul>
<li>星型</li>
<li>环型</li>
<li>总线型</li>
</ul>
<h3 id="按传输介质分"><a href="#按传输介质分" class="headerlink" title="按传输介质分"></a>按传输介质分</h3><ul>
<li>有线网络</li>
<li>无线网络</li>
</ul>
<h3 id="按交换技术分"><a href="#按交换技术分" class="headerlink" title="按交换技术分"></a>按交换技术分</h3><ul>
<li><p>电路交换网络(适用于持续通信，不适于具有突发性的计算机网络)</p>
<ol>
<li><p>连接建立</p>
</li>
<li><p>数据传送</p>
</li>
<li><p>连接释放</p>
</li>
</ol>
</li>
<li><p>报文交换网络(存储-转发，处理时间长)</p>
</li>
<li><p>分组交换网络(报文较小，会增大目的地址量，降低效率)</p>
</li>
</ul>
<h2 id="5-制定网络协议的组织"><a href="#5-制定网络协议的组织" class="headerlink" title="5. 制定网络协议的组织"></a>5. 制定网络协议的组织</h2><h3 id="网络协议组成元素"><a href="#网络协议组成元素" class="headerlink" title="网络协议组成元素"></a>网络协议组成元素</h3><p>协议是一组控制数据通信的规则，明确规定所交换的数据格式和时序。</p>
<p>网络协议包括3个要素：</p>
<ul>
<li>语法：传输数据的格式</li>
<li>语义：规定了要完成的功能</li>
<li>定时：规定了执行各种操作的条件、时序关系等。</li>
</ul>
<h3 id="网络协议举例"><a href="#网络协议举例" class="headerlink" title="网络协议举例"></a>网络协议举例</h3><p>记几个常见的名称</p>
<p><img src="https://s2.loli.net/2021/12/22/BX6n83tPNiIUGph.png" alt="image-20211222171450997"></p>
<p>Internet工程特别任务组（IRTF）中的标准通常以<strong>RFC(请求评注,Request for Comments)</strong>文档的形式公布.</p>
<h2 id="6-服务质量"><a href="#6-服务质量" class="headerlink" title="6. 服务质量"></a>6. 服务质量</h2><p><img src="https://s2.loli.net/2021/12/22/LE5Hq69c2ROuXJs.png" alt="image-20211222172217157"></p>
<h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><h2 id="7-相关"><a href="#7-相关" class="headerlink" title="7. 相关"></a>7. 相关</h2><ol>
<li><p><strong>面向终端的远程联机系统</strong>是计算机和通信相结合的前驱。以单个<strong>计算机</strong>为中心。</p>
</li>
<li><p>在20世纪70年代，美国的<strong>ARPANET</strong>(具有代表性的，美国国防部)采用了“存储转发-分组交换”的原理，采用<strong>TCP/IP</strong>协议，成为了事实上的国际标准。(Advanced Research Project Agency)</p>
</li>
<li><strong>1984年</strong>，ISO颁布的OSI/RM(Open Systems Interconnection-Reference Model)参考模型。</li>
<li>计算机网络的分类(按照哪个分为几类)</li>
</ol>
<p><img src="https://s2.loli.net/2022/02/21/rF2twM3dSQNCilH.png" alt="image-20220221162306391"></p>
<p><img src="https://s2.loli.net/2022/02/21/AOgc5Nr278dKX3k.png" alt="image-20220221163946294"></p>
<h1 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h1><p><strong>物理层位于OSI参考模型的最低层，直接面向实际承担数据传输的物理介质</strong>(即信道)。它的功能是激活、维持和释放数据链路层实体之间进行比特传输的物理连接(就是，<strong>传输比特流</strong>)。</p>
<h2 id="1-通信速率和信道容量"><a href="#1-通信速率和信道容量" class="headerlink" title="1. 通信速率和信道容量"></a>1. 通信速率和信道容量</h2><h3 id="1-传输速率"><a href="#1-传输速率" class="headerlink" title="1. 传输速率"></a>1. 传输速率</h3><p>数据传输速率是指每秒能传输的二进制信息位数，单位为“位/秒”，记作“b/s”。表示为：</p>
<script type="math/tex; mode=display">
S=\frac{1}{T} \times log_2M(b/s)</script><h3 id="2-信号传输速率（码元速率、调制速率、波特率"><a href="#2-信号传输速率（码元速率、调制速率、波特率" class="headerlink" title="2. 信号传输速率（码元速率、调制速率、波特率)"></a>2. 信号传输速率（码元速率、调制速率、波特率)</h3><p>一个数字脉冲也称为一个码元，M为一个码元所取的有效离散值个数，也成为调制电平数，M一般取2的整数次方值。若一个码元能取M种离散值，则该码元便能携带 $log_2 M$位二进制信息。</p>
<p>表示单位时间内通过信道传输的码元个数，也就是<strong>信号经调制后的传输速率(每秒信号变几次)</strong>，单位为baud(波特)。若信号码元的宽度为T(信号的持续时间s)，则码元速率定义为</p>
<script type="math/tex; mode=display">
B=\frac{1}{T} (baud)</script><p><strong>调制速率和数据传输速率</strong>的对应关系为：</p>
<script type="math/tex; mode=display">
S=B log_2 M(b/s)\quad或\quad B = \frac{S}{log_2 M} (baud)</script><h3 id="3-信道容量"><a href="#3-信道容量" class="headerlink" title="3. 信道容量"></a>3. 信道容量</h3><h4 id="奈奎斯特公式-重要！！！"><a href="#奈奎斯特公式-重要！！！" class="headerlink" title="奈奎斯特公式(重要！！！)"></a>奈奎斯特公式(重要！！！)</h4><script type="math/tex; mode=display">
码元速率的极限值和信道带宽的关系： \\B=2W\quad(baud)\\（W是信道带宽，也称为频率范围，即信道上下限频率的差值，单位是Hz）。
\\表示信道数据传输能力的奈奎斯特公式为：\\C=2W log_2 M\quad(b/s) \\M为携带数据的码元可能取的离散值个数，C为该信道最大的传输速率。</script><h4 id="香农公式-重要！！！"><a href="#香农公式-重要！！！" class="headerlink" title="香农公式(重要！！！)"></a>香农公式(重要！！！)</h4><script type="math/tex; mode=display">
计算信道容量的香农公式：\\C=W log_2(1+\frac{S}{N})\quad(b/s)
\\S为信号功率，N为噪声功率，S/N为信噪比。
\\由于实际使用的信道的信噪比都要足够大，故常表示成10lg(\frac{S}{N})，并以分贝为单位来计量。如30dB对应的是S/N的1000倍。\\(随机热噪声与温度有关，随温度升高，噪声增大)</script><p>误码率</p>
<script type="math/tex; mode=display">
P_e = \frac{N_e}{N}</script><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="https://s2.loli.net/2021/12/27/6YMz8QbIyhuJvEw.png" alt="image-20211227180309974"></p>
<p><img src="https://s2.loli.net/2021/12/27/HKAYq5XcE1tiu2r.png" alt="image-20211227180332179"></p>
<p><img src="https://s2.loli.net/2021/12/27/PYhdymXRw92MsG3.png" alt="image-20211227180401257"></p>
<h2 id="2-传输介质"><a href="#2-传输介质" class="headerlink" title="2.传输介质"></a>2.传输介质</h2><h3 id="1-特殊的方式"><a href="#1-特殊的方式" class="headerlink" title="1. 特殊的方式"></a>1. 特殊的方式</h3><p>烽火、空气、公路</p>
<h3 id="2-有线的方式"><a href="#2-有线的方式" class="headerlink" title="2. 有线的方式"></a>2. 有线的方式</h3><h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h4><ul>
<li>屏蔽（周围干扰较大/信号较弱的场所）</li>
<li>非屏蔽（通常是100米左右，在楼层之内）</li>
</ul>
<h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h4><ul>
<li>细缆（10Mb/s，185米，层间）</li>
<li>粗缆（10Mb/s，500米，楼间）</li>
</ul>
<h4 id="光缆"><a href="#光缆" class="headerlink" title="光缆"></a>光缆</h4><ul>
<li>多模（550米/1000M/模块成本低）</li>
<li>单模（1000米/1000M/模块成本高）单模光纤传输频带宽、容量大，传输距离长，需要用激光源</li>
</ul>
<p>单模光纤的性能要优于多模光纤，它的传输损耗较小。</p>
<p>光纤纤芯质地脆，机械强度低。</p>
<h3 id="3-无线的方式"><a href="#3-无线的方式" class="headerlink" title="3. 无线的方式"></a>3. 无线的方式</h3><ul>
<li>无线局域网（2.4GHz/5GHz）</li>
<li>微波天线与卫星通信</li>
<li>红外线通信</li>
<li>激光通信（OPALS）</li>
</ul>
<h3 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4. 优缺点"></a>4. 优缺点</h3><p>布设的便利性/通信的抗干扰能力</p>
<h2 id="3-编码与识别"><a href="#3-编码与识别" class="headerlink" title="3. 编码与识别"></a>3. 编码与识别</h2><h3 id="1-基本调制技术"><a href="#1-基本调制技术" class="headerlink" title="1. 基本调制技术"></a>1. 基本调制技术</h3><p>数字数据调制技术在发送端将数字信号转换成模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。（数字信号加载到载波信号）</p>
<h4 id="调制方法-最基本的二元调制"><a href="#调制方法-最基本的二元调制" class="headerlink" title="调制方法(最基本的二元调制)"></a>调制方法(最基本的二元调制)</h4><ol>
<li>振幅调制</li>
<li>频率调制</li>
<li>相位调制</li>
<li>多进制调制</li>
</ol>
<h3 id="2-脉冲编码调制技术-PCM"><a href="#2-脉冲编码调制技术-PCM" class="headerlink" title="2. 脉冲编码调制技术(PCM)"></a>2. 脉冲编码调制技术(PCM)</h3><p><strong>PCM基于奈奎斯特采样定理：如果在规定的时间间隔内，以有效信号f(t)最高频率的2倍或2倍以上的速率对该信号进行采样，则这些采样值包含了无混叠而又便于分离的全部原始信息。</strong></p>
<h3 id="3-数字信号的编码技术"><a href="#3-数字信号的编码技术" class="headerlink" title="3. 数字信号的编码技术"></a>3. 数字信号的编码技术</h3><h4 id="1-不归零编码"><a href="#1-不归零编码" class="headerlink" title="1. 不归零编码"></a>1. 不归零编码</h4><h4 id="2-曼彻斯特码"><a href="#2-曼彻斯特码" class="headerlink" title="2. 曼彻斯特码"></a>2. 曼彻斯特码</h4><h5 id="以太网是使用曼彻斯特编码的。"><a href="#以太网是使用曼彻斯特编码的。" class="headerlink" title="以太网是使用曼彻斯特编码的。"></a>以太网是使用曼彻斯特编码的。</h5><h5 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h5><p>一种双相码</p>
<p><strong>用高电平到低电平的转换边表示1，用低电平到高电平的转换边表示0。(高到低为1；低到高为0)</strong></p>
<h4 id="3-差分曼彻斯特码"><a href="#3-差分曼彻斯特码" class="headerlink" title="3. 差分曼彻斯特码"></a>3. 差分曼彻斯特码</h4><h5 id="用在令牌环网中"><a href="#用在令牌环网中" class="headerlink" title="用在令牌环网中"></a>用在令牌环网中</h5><h5 id="编码格式-1"><a href="#编码格式-1" class="headerlink" title="编码格式"></a>编码格式</h5><p>一种双相码</p>
<p>数据表示为在每一位开始处是否有电平转换：<strong>有电平转换表示0，无电平转换表示1(进来啥还是啥)，在信号中间强制转换(翻转)。(1不变，0变化，中间强制变化(以避免出现连续的高电平、低电平))</strong></p>
<p><img src="https://s2.loli.net/2021/12/27/sNz9wp76Ourfqng.png" alt="image-20211227173107104"></p>
<p>差分曼彻斯特编码比曼彻斯特编码的变化要小，因此更适合于传输高速的信息。</p>
<h4 id="4-其他编码"><a href="#4-其他编码" class="headerlink" title="4. 其他编码"></a>4. 其他编码</h4><ul>
<li><p>百兆双绞线的4B/5B</p>
</li>
<li><p>光纤的8B/10B</p>
</li>
</ul>
<h2 id="4-信道复用技术"><a href="#4-信道复用技术" class="headerlink" title="4. 信道复用技术"></a>4. 信道复用技术</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>为了有效地利用数据传输系统，人们希望通过同时携带多个信号来高效率地使用传输介质，这称为多路复用(MUX)。多路复用连接器连接许多低速线路，并将它们各自所需的传输容量组合在一起后，在一条速度较高的线路上传输。</p>
<h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><ul>
<li>频分多路复用</li>
<li>时分多路复用</li>
<li>波分多路复用</li>
<li>码分多路复用</li>
</ul>
<h2 id="5-相关"><a href="#5-相关" class="headerlink" title="5. 相关"></a>5. 相关</h2><ol>
<li>DTE：Data Terminal Equipment，数据终端设备</li>
<li>DCE：Data Communication Equipment，数据通信设备。</li>
<li>一个完整的数据通信系统一般可以划分为三大部分，即<strong>源系统(或发送方)、传输系统和目的系统(或接收方)</strong>。</li>
<li>中继器将接收到的信号<strong>放大整形</strong>，以此来克服数字信号的衰减和畸变。</li>
<li>通信有两种基本方式，即<strong>串行和并行</strong>。</li>
<li>串行数据通信的方向性结构有3种，即<strong>单工(只有在一个方向的通信而没有反方向的交互)、半双工和全双工</strong>。</li>
<li>如果安装正确，在非常短的距离（通常是100米左右）上，5类UTP的传输速率至少可以达到<strong>100Mbps</strong>.</li>
<li>屏蔽双绞线的每一对线都有一个铝箔屏蔽层，四对线合在一起还有一个<strong>公共的金属编织屏蔽层</strong>。</li>
<li>一般粗缆最多可以通过<strong>4个中继器</strong>使得网络范围达到2500m。</li>
<li>细缆每段最长<strong>185m</strong>。</li>
<li>无线传输是指在自由空间(地球上大气的性质也类似于自由空间)中进行电磁波的传输，其传输方法包括：微波传输、无线电传输、红外传输和<strong>激光传输</strong>。</li>
<li>卫星通信是一种特殊的<strong>微波</strong>通信。</li>
<li>无线电频率分为<strong>非管制和管制</strong>的两部分。</li>
<li>信号数字化的转换过程包括：<strong>采样、量化和编码</strong>三个步骤。</li>
<li><strong>信道容量</strong>表示一个信道传输数据的能力，即<strong>单位时间内可能传送的最大比特数，单位为bps</strong>。</li>
<li><img src="https://s2.loli.net/2022/02/21/hSWHc2puTFnC6tX.png" alt="image-20220221172417686"></li>
</ol>
<h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h1><h5 id="相邻主机-同一个广播域内的主机-如一个教室-之间的通信"><a href="#相邻主机-同一个广播域内的主机-如一个教室-之间的通信" class="headerlink" title="相邻主机(同一个广播域内的主机(如一个教室))之间的通信"></a>相邻主机(同一个广播域内的主机(如一个教室))之间的通信</h5><p>数据链路层的作用是加强物理层传输原始位流的功能，并将物理层提供的可能出错的物理连接改造成逻辑上无差错的数据链路。</p>
<p><strong>数据链路层的主要功能是向网络层提供透明的和可靠的数据传输服务。</strong></p>
<h2 id="0-数据链路层的功能"><a href="#0-数据链路层的功能" class="headerlink" title="0.数据链路层的功能"></a>0.数据链路层的功能</h2><h3 id="1-链路管理"><a href="#1-链路管理" class="headerlink" title="1. 链路管理"></a>1. 链路管理</h3><p>当网络中的两个结点要进行通信时，发送方必须确知接收方是处在准备接受数据的状态。为此，通信双方必须要先交换一些必要的信息，建立链路连接，同时在传输数据时要维持数据链路，在传输完毕是要释放数据链路。</p>
<p>数据链路的建立、维持和释放称为<strong>链路管理</strong>，它主要用于面向连接的服务。</p>
<h3 id="2-帧同步"><a href="#2-帧同步" class="headerlink" title="2. 帧同步"></a>2. 帧同步</h3><p>帧同步，即帧的组织结构应当使接收方能从接收到的位流中准确地识别一个帧的开始和结束。</p>
<h3 id="3-流量控制"><a href="#3-流量控制" class="headerlink" title="3. 流量控制"></a>3. 流量控制</h3><p>为了防止接收方缓存能力不足而造成数据的丢失，发送方发送数据的速率必须让接收方来控制。</p>
<p>流量控制实际上就是，限制发送方的数据流量，使其发送速率不致超过接收方的接受能力。</p>
<h3 id="4-差错控制"><a href="#4-差错控制" class="headerlink" title="4. 差错控制"></a>4. 差错控制</h3><p>用以使发送方确定接收方是否正确地接收到了由它发送的数据的方法称为差错控制。</p>
<p>通信系统必须具备发现(即检测)差错的能力，并采取措施加以纠正，使差错控制在尽可能小的范围内。</p>
<p>帧传输中出现的错误包括帧错和位错。</p>
<p>位错是指帧在传输过程中某些位出现差错，通常采用奇偶校验、循环冗余校验等方法发现位错。</p>
<p>对于帧错主要采用自动重传请求方式来重传出错的帧。</p>
<h3 id="5-透明传输"><a href="#5-透明传输" class="headerlink" title="5. 透明传输"></a>5. 透明传输</h3><p>透明传输是指因数据组合的随机性，它可能和某个控制信息完全一样而被接收方误解，必须有措施使接收方不至于将这样的数据当作某种控制信息。</p>
<h3 id="6-寻址"><a href="#6-寻址" class="headerlink" title="6. 寻址"></a>6. 寻址</h3><p>必须保证每一帧能正确地送达目的地，同时又要使接收方知道该帧是由哪个机器发送的。</p>
<h2 id="1-差错检测"><a href="#1-差错检测" class="headerlink" title="1. 差错检测"></a>1. 差错检测</h2><h3 id="1-奇偶校验码"><a href="#1-奇偶校验码" class="headerlink" title="1. 奇偶校验码"></a>1. 奇偶校验码</h3><p>常在计算机内部使用，因为干扰发生的概率小</p>
<ul>
<li><p>水平/垂直校验码：检错码</p>
</li>
<li><p>水平垂直校验码：纠错码(成本较高)</p>
</li>
</ul>
<h3 id="2-循环冗余码-CRC必考"><a href="#2-循环冗余码-CRC必考" class="headerlink" title="2. 循环冗余码(CRC必考)"></a>2. 循环冗余码(CRC必考)</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>任何一个由二进制数位串组成的代码，都可以唯一地与一个只含有0和1两个系数的多项式建立一一对应的关系。例如，代码1010111对应的多项式是 $X^6 + X^4+ X^2+X^1+1$。</p>
<h5 id="各多项式含义"><a href="#各多项式含义" class="headerlink" title="各多项式含义"></a>各多项式含义</h5><p>在发送方编码和接收方校验时，都可以利用事先约定的多项式$G(X)$来得到CRC码。</p>
<p>k位待发送信息位对应于一个k-1次多项式$K(X)$</p>
<p>r位冗余位对应于一个r-1次多项式$R(X)$</p>
<p>由k位信息位后面加上r次冗余位组成的$n=k+r$位码字则对应于一个$n-1$次多项式$T(X)=X^rK(X)+R(X)$。</p>
<p>由信息位产生冗余位的编码过程，就是已知$K(X)$求$R(X)$的过程。先找到一个特定的r次多项式$G(X)$，其最高次项$X^r$的系数恒为1，然后用$X^r \cdot K(X) $除以$G(X)$，得到的余式就是$R(X)$。</p>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p>仍以$K(X)=X^6+X^4+X^3+1(信息位为1011001)(待发送信息)$为例，若$G(X)=X^4+X^3+1(事先约定)(11001)$，则$r=4$，$X^4K(X)=X^{10}+X^8+X^7+X^4(10110010000)$.由模2除法求余式$R(X)$的过程如图所示。</p>
<p><img src="https://s2.loli.net/2022/01/10/Co9XIdpf1bv58Mq.png" alt="image-20220110151925039"></p>
<p>最后得到的余数是1010，就是冗余位，对应于$R(X)=X^3+X$。由于$R(X)$是$X^rK(X)$除以$G(X)$的余式，那么必然满足：</p>
<script type="math/tex; mode=display">
X^rK(X)=G(X)(除式)Q(X)(商式)+R(X)(余式)</script><p>式中，$Q(X)$为商式，根据模2运算法则，$R(X)+R(X)=0$，所以可将上式改记为</p>
<script type="math/tex; mode=display">
\frac{X^rK(X)+R(X)}{G(X)}=Q(X)</script><p>即，$\frac{T(X)}{G(X)}=Q(X)$</p>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p><strong>由此可见，信道上发送的码字多项式$T(X)=X^rK(X)+R(X)$，若传输过程无错，则接收方接收到的码字也对应于此多项式，也就是说接收到的码字多项式能被$G(X)$整除。</strong></p>
<p><strong>因此，接收方的校验过程就是将接收到的码字多项式除以$G(X)$(事先约定)的过程，若余式为0，则认为传输无差错，若余式不为0，则传输有差错。</strong></p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><img src="https://s2.loli.net/2022/01/10/jLYbRSkWFs79EzH.png" alt="image-20220110162900726"></p>
<p><img src="https://s2.loli.net/2022/01/10/4YrCuwzTZGfWOAj.png" alt="image-20220110162950640"></p>
<p><img src="https://s2.loli.net/2022/01/10/wm59PKXcYJgb1I4.png" alt="image-20220110165636498"></p>
<p>在第二个框那里增加0，是错的。</p>
<h2 id="2-帧同步-1"><a href="#2-帧同步-1" class="headerlink" title="2. 帧同步"></a>2. 帧同步</h2><p><img src="https://s2.loli.net/2022/02/16/hm2Ojuwlz8T6VeJ.png" alt="image-20220216185539609"></p>
<h3 id="0比特填充技术"><a href="#0比特填充技术" class="headerlink" title="0比特填充技术(*)"></a>0比特填充技术(*)</h3><h4 id="标志字段-F"><a href="#标志字段-F" class="headerlink" title="标志字段 F"></a>标志字段 F</h4><p>物理层向数据链路层交付的是所收到的一连串的位流，在一个帧的开头和结尾各放入一个字节的特殊标记： “01111110” 作为一个帧的边界，这个标记称为标志字段F(Flag)，共8位。</p>
<p>在接收方，只要找到两个标志字段，那么在这两个标志字段之间的位流就是一个帧的信息。</p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>如果在两个标志字段之间的位流中，出现与标志字段F相同的比特模式时，就会被误认为是帧的边界，从而破坏帧的同步。</p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>为避免这种情况，采用<strong>0比特填充技术</strong>，即发送方在比特流中一旦发现5个连续的1，就在其后填入一个0，从而保证在传输的比特流中不会出现F标志。</p>
<blockquote>
<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><p>在接收一个帧时，在F字段确定的帧的边界之间，若比特流有5个连续1，则将这5个连续1后的一个0删除，将比特流还原。这样，不管出现什么样的比特组合，都不会引起对帧边界的错误判断。</p>
<p><strong>具有这种特点的传输称为透明传输。</strong></p>
</blockquote>
<h2 id="3-停止等待协议"><a href="#3-停止等待协议" class="headerlink" title="3. 停止等待协议"></a>3. 停止等待协议</h2><h3 id="1-差错控制与流量控制"><a href="#1-差错控制与流量控制" class="headerlink" title="1. 差错控制与流量控制"></a>1. 差错控制与流量控制</h3><p><strong>对数据传输进行差错控制和流量控制是数据链路层的关键功能。</strong></p>
<p>目前，进行差错控制和流量控制的基本策略是<strong>反馈机制</strong>，即发送方通过接收方反馈回来的能否继续接受或是否正确收到帧等信息来进行下一步的操作。</p>
<h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><p><strong>差错控制的基本思想是：差错检测、接受确认和出错重传。</strong></p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p><strong>流量控制的基本思想是：使接收方能够控制发送方发送帧的速率。</strong></p>
<p>由接收方控制发送方的速度，以避免发送方发送太快而接收方来不及接受的问题。</p>
<h3 id="2-停止等待协议"><a href="#2-停止等待协议" class="headerlink" title="2. 停止等待协议"></a>2. 停止等待协议</h3><p>每发送一帧就停下来等待确认，若收到确认就发送下一帧。</p>
<h3 id="3-实用的停止等待协议"><a href="#3-实用的停止等待协议" class="headerlink" title="3. 实用的停止等待协议"></a>3. 实用的停止等待协议</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>每发送一帧就停下来等待确认，</p>
<p>若收到确认就发送下一帧。</p>
<p>若在规定的时间内，没有收到确认帧，就重新发送这一帧。</p>
<h5 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h5><p>此时确认帧不需要序号，因为只发送一帧数据，确认无需排序。</p>
<p><strong>若收到重复分组，就丢弃，但同时也要发送确认帧。</strong></p>
<h3 id="4-效率的计算"><a href="#4-效率的计算" class="headerlink" title="4. 效率的计算"></a>4. 效率的计算</h3><ol>
<li><p>发送时延 = 帧长 / 发送速度</p>
</li>
<li><p>传播时延 = 距离 / 电磁波速度</p>
</li>
<li><p>总时延 = 发送时延 + 传播时延 + 确认发送时延 + 确认传播时延</p>
<p> ​             = 发送时延 + 2 * 传播时延    </p>
<p> (因为确认帧的帧长比较短，其发送时延很短，可以忽略不计；但距离和电磁波速度是一样的，故而是2倍。)</p>
</li>
<li><p>效率 = 发送时延 / 总时延</p>
</li>
<li><p>所以提高效率，可以通过增加发送时延。</p>
</li>
</ol>
<h2 id="4-连续ARQ协议"><a href="#4-连续ARQ协议" class="headerlink" title="4. 连续ARQ协议"></a>4. 连续ARQ协议</h2><p>自动请求重发</p>
<p>由于减少了等待时间，整个通信的吞吐量提高。</p>
<p>发送维持一个发送窗口，接收方采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确地收到了。</p>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>每发送N帧就停下来等待确认；接收方按序接收。</p>
<p>一次发送N帧，未收到回复就自动重发。</p>
<p>在连续ARQ协议中，接收方只允许按序接收，当发送方发现未收到前面已发送出去的帧的确认信息，计时器已经超时或收到了否定应答信息，则不得不重发后N帧。因此，又叫后退N帧的滑动窗口协议。</p>
<h3 id="发送窗口和接收窗口-滑动窗口"><a href="#发送窗口和接收窗口-滑动窗口" class="headerlink" title="发送窗口和接收窗口(滑动窗口)"></a>发送窗口和接收窗口(滑动窗口)</h3><h4 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h4><p>发出去还未收到确认的帧</p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>若采用n位二进制编码来给出帧编号，则发送窗口最大只能是$2^n - 1$，即任何时候最多允许有$2^n - 1$个帧未被确认。例如，当n=3时，发送窗口长度为7。</p>
<p>原因1：如果窗口长度为8，则每次发送都是0~7，那么接收窗口无法确认是新8帧还是旧8帧，而长度为7时，第一次发送0-6，第二次发送7-5，可以确认。</p>
<p>原因2：发送窗口为12345670，收到确认帧1，无法确定是重发1，还是发送下一个1。</p>
<h4 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h4><p>准备接受的帧</p>
<h3 id="确认的序号"><a href="#确认的序号" class="headerlink" title="确认的序号"></a>确认的序号</h3><ul>
<li>确认收到</li>
<li>确认没有收到</li>
<li>确认下一帧应该接收(收到后，回复准备接收n+1帧，减少回复次数，提高效率)</li>
</ul>
<h3 id="确认的方式"><a href="#确认的方式" class="headerlink" title="确认的方式"></a>确认的方式</h3><ul>
<li>单独确认帧</li>
<li>捎带确认帧(将确认帧放在反方向的数据帧里)</li>
</ul>
<p><strong>差错控制的基本思想是：差错检测、接受确认和出错重传。</strong></p>
<h2 id="5-选择重传ARQ协议"><a href="#5-选择重传ARQ协议" class="headerlink" title="5. 选择重传ARQ协议"></a>5. 选择重传ARQ协议</h2><p>在连续ARQ协议中，接收窗口的长度为1，浪费了线路带宽。</p>
<h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>每发送N帧，就停下等待确认，接收方不按序接收。</p>
<h3 id="最大发送窗口"><a href="#最大发送窗口" class="headerlink" title="最大发送窗口"></a>最大发送窗口</h3><p><img src="https://s2.loli.net/2022/02/16/cUipqTFg8Db95EC.png" alt="image-20220216183618667"></p>
<p><img src="https://s2.loli.net/2022/02/16/Eebqt1KNcXgBf5a.png" alt="image-20220216184018869"></p>
<p><strong>所以，采用该协议时，窗口长度的最大值应为帧编号的一半。</strong></p>
<h2 id="6-三种协议"><a href="#6-三种协议" class="headerlink" title="6. 三种协议(*)"></a>6. 三种协议(*)</h2><h3 id="都基于滑动窗口协议"><a href="#都基于滑动窗口协议" class="headerlink" title="都基于滑动窗口协议"></a>都基于滑动窗口协议</h3><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><img src="https://s2.loli.net/2022/02/16/WyEBZozvifrDqQK.png" alt="image-20220216184051632"></p>
<p><img src="https://s2.loli.net/2022/02/16/KUDP8zqCTJYsA7E.png" alt="image-20220216185024281"></p>
<h2 id="7-信道使用权分配"><a href="#7-信道使用权分配" class="headerlink" title="7. 信道使用权分配"></a>7. 信道使用权分配</h2><h3 id="频分"><a href="#频分" class="headerlink" title="频分"></a>频分</h3><p>由于网络通信存在突发性，故而在网络中不常用</p>
<h4 id="电话线路"><a href="#电话线路" class="headerlink" title="电话线路"></a>电话线路</h4><p>电话线路的ADSL</p>
<p>电话：4000Hz以下</p>
<p>上网：4000Hz以上</p>
<h3 id="时分"><a href="#时分" class="headerlink" title="时分"></a>时分</h3><h4 id="同步时分"><a href="#同步时分" class="headerlink" title="同步时分"></a>同步时分</h4><p>不适合网络传输的突发性，存在带宽的浪费</p>
<h4 id="异步-统计-时分"><a href="#异步-统计-时分" class="headerlink" title="异步(统计)时分"></a>异步(统计)时分</h4><h5 id="令牌式"><a href="#令牌式" class="headerlink" title="令牌式"></a>令牌式</h5><p>对带宽有一定的浪费</p>
<h5 id="竞争式"><a href="#竞争式" class="headerlink" title="竞争式"></a>竞争式</h5><p>浪费较小，且简单</p>
<h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><p>负载重时，使用令牌式；</p>
<p>负载轻时，使用竞争式。</p>
<h4 id="载波侦听-冲突检测-CSMA-CD"><a href="#载波侦听-冲突检测-CSMA-CD" class="headerlink" title="载波侦听/冲突检测(CSMA/CD)"></a>载波侦听/冲突检测(CSMA/CD)</h4><p>以太网采用的介质访问控制方法就是后来成为IEEE802.3标准的载波侦听多路访问/冲突检测(CSMA/CD)技术。</p>
<p>先多路访问，后侦听同时冲突检测。</p>
<h5 id="1-冲突检测"><a href="#1-冲突检测" class="headerlink" title="1. 冲突检测"></a>1. 冲突检测</h5><h6 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h6><h6 id="1968年夏威夷大学无线广播网"><a href="#1968年夏威夷大学无线广播网" class="headerlink" title="1968年夏威夷大学无线广播网"></a>1968年夏威夷大学无线广播网</h6><p>是1968年由美国夏威夷大学开发的一个以<strong>无线广播</strong>方式工作的分组交换网。</p>
<p>想发就发，边发边听</p>
<p>网上的各站点在任何时刻只要需要，就可以自由地发送信息帧；信息帧发送完毕，然后侦听一段时间，如果在信息帧来回传播的最大延迟时间(两倍于两个间隔最大的站点之间传递信息的时间)再加上一小段固定时间内收到了确认，则说明传输成功；否则，传输站点重发信息帧。若多次重发都失败，则放弃发送该帧。</p>
<p>信道利用率最大只有18%</p>
<h6 id="分槽ALOHA"><a href="#分槽ALOHA" class="headerlink" title="分槽ALOHA"></a>分槽ALOHA</h6><p>整点时刻想发就发，边发边听</p>
<p>分槽ALOHA协议将时间划分为等长的时槽，每个时槽的长度正好等于一个定长分组的传输时间，各站只能在时槽的起始时刻开始发送信息，因此那些冲突的帧完全重叠。</p>
<p>信道利用率最大37%。</p>
<h6 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h6><p><img src="https://s2.loli.net/2022/02/17/KipvxbmWqLCrXRh.png" alt="image-20220217135745945"></p>
<h4 id="2-载波侦听"><a href="#2-载波侦听" class="headerlink" title="2. 载波侦听"></a>2. 载波侦听</h4><p>又称为“先听后说”。</p>
<p>当一个站点要发送数据时，</p>
<h6 id="1坚持CSMA协议"><a href="#1坚持CSMA协议" class="headerlink" title="1坚持CSMA协议"></a>1坚持CSMA协议</h6><p>首先侦听信道，如果信道空闲就立即发送数据。</p>
<p>当侦听到信道忙时，继续坚持侦听信道，当侦听到信道空闲时，发送帧的概率为1，即立即发送数据。</p>
<p>可以充分利用信道，但冲突的可能性也可能会增大</p>
<h6 id="p坚持CSMA协议"><a href="#p坚持CSMA协议" class="headerlink" title="p坚持CSMA协议"></a>p坚持CSMA协议</h6><p>首先侦听信道，当侦听到信道忙时，仍然坚持听下去，直到信道空闲为止。</p>
<p>当听到信道空闲时，以概率P发送数据，并在概率1-P延迟时间$\tau$(端到端的传输时延)后再重新侦听信道。</p>
<h6 id="非坚持CSMA协议"><a href="#非坚持CSMA协议" class="headerlink" title="非坚持CSMA协议"></a>非坚持CSMA协议</h6><p>首先侦听信道，如果信道空闲就立即发送数据。</p>
<p>一旦侦听到信道忙就不再坚持听下去，延迟一段随机时间后再重新侦听。</p>
<ul>
<li>1-持续</li>
<li>p-持续</li>
<li>非持续</li>
</ul>
<h5 id="3-CSMA-CD协议"><a href="#3-CSMA-CD协议" class="headerlink" title="3. CSMA/CD协议"></a>3. CSMA/CD协议</h5><p>“边听边说”</p>
<p>即为了能及时发现冲突，采取边发送边侦听的方式，一旦侦听到冲突，冲突双方就立即停止发送。</p>
<p>先听后发，边听边发，冲突停发，随即重发。</p>
<p>也分为类似以上三种。</p>
<h5 id="4-对比"><a href="#4-对比" class="headerlink" title="4. 对比"></a>4. 对比</h5><p><img src="https://s2.loli.net/2022/02/17/3tKkGr2JZsD4Ng7.png" alt="image-20220217140847613"></p>
<ul>
<li>CSMA/CD协议吞吐量的最大值最大。</li>
<li>当G在相当大的范围内变化时，CSMA/CD协议的吞吐量S都比较接近其最大值，这说明该协议相较而言更稳定</li>
<li>在轻负载时，各种协议的性能都差不多</li>
</ul>
<h2 id="8-寻址"><a href="#8-寻址" class="headerlink" title="8. 寻址"></a>8. 寻址</h2><h3 id="1-地址长度的确定-地址空间和传输效率"><a href="#1-地址长度的确定-地址空间和传输效率" class="headerlink" title="1. 地址长度的确定(地址空间和传输效率)"></a>1. 地址长度的确定(地址空间和传输效率)</h3><h3 id="2-以太网地址"><a href="#2-以太网地址" class="headerlink" title="2. 以太网地址"></a>2. 以太网地址</h3><p>如果该帧的目的地址和一个接受站点的LAN地址相配，则这个结点将从链路层帧中提取出网络层数据报，并将数据报传递给上层协议栈。</p>
<p>LAN地址通常也称为物理地址、以太网地址或介质访问控制(MAC)地址</p>
<h4 id="长度为48位-6字节"><a href="#长度为48位-6字节" class="headerlink" title="长度为48位/6字节(*)"></a>长度为48位/6字节(*)</h4><p>这6个字节的地址，通常用十六位进制数表示。</p>
<p>是永久且唯一的。</p>
<p>(硬件地址-MAC地址-网卡地址-物理地址)</p>
<h2 id="9-面向无连接和不可靠的协议"><a href="#9-面向无连接和不可靠的协议" class="headerlink" title="9. 面向无连接和不可靠的协议"></a>9. 面向无连接和不可靠的协议</h2><p>融合了帧同步、差错检测、信道使用权分配、寻址</p>
<h3 id="IEEE802-3"><a href="#IEEE802-3" class="headerlink" title="IEEE802.3"></a>IEEE802.3</h3><p>发送完，就不再进行冲突检测</p>
<h4 id="以太网长度的限制-发送方检测到冲突"><a href="#以太网长度的限制-发送方检测到冲突" class="headerlink" title="以太网长度的限制(发送方检测到冲突)"></a>以太网长度的限制(发送方检测到冲突)</h4><ul>
<li>发送数据包长度为信道长度的50%——失败</li>
<li>发送数据包长度为信道长度的100%——失败</li>
<li>发送数据包长度为信道长度的200%——成功</li>
</ul>
<h5 id="所以，发送时延-≥-2倍传播时延"><a href="#所以，发送时延-≥-2倍传播时延" class="headerlink" title="所以，发送时延 ≥ 2倍传播时延"></a>所以，发送时延 ≥ 2倍传播时延</h5><p>结合下方以太网和IEEE802.3</p>
<h4 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h4><h3 id="IEE802-4-5"><a href="#IEE802-4-5" class="headerlink" title="IEE802.4/5"></a>IEE802.4/5</h3><h2 id="10-以太网技术"><a href="#10-以太网技术" class="headerlink" title="10. 以太网技术"></a>10. 以太网技术</h2><h5 id="以太网采用基带传输，并且使用曼彻斯特编码。"><a href="#以太网采用基带传输，并且使用曼彻斯特编码。" class="headerlink" title="以太网采用基带传输，并且使用曼彻斯特编码。"></a>以太网采用<strong>基带传输</strong>，并且使用<strong>曼彻斯特编码</strong>。</h5><p>10Base-T：以太网采用双绞线(对应于“T”)(多采用星型结构)，其传输速率为10Mb/s。</p>
<h3 id="1-以太网与IEEE802-3"><a href="#1-以太网与IEEE802-3" class="headerlink" title="1. 以太网与IEEE802.3"></a>1. 以太网与IEEE802.3</h3><p><img src="https://s2.loli.net/2022/02/24/B7KFOfURxwhAITG.png" alt="image-20220224163759256"></p>
<p>发送完，就不再进行冲突检测。</p>
<ul>
<li>前导：由7个字节的位串10101010，被接收站用来建立位同步。</li>
<li>帧起始定界符：这个10101011的序列指明了帧本身的起始位置。</li>
<li>目的地址(DA)和源地址(SA)：分别表示帧的接收节点与发送节点的硬件地址(MAC地址)。</li>
<li>帧校验序列：32位的循环冗余码，校验范围从目的地址段到数据段的末尾。</li>
</ul>
<h3 id="2-以太网的地址"><a href="#2-以太网的地址" class="headerlink" title="2. 以太网的地址"></a>2. 以太网的地址</h3><p>LAN地址通常也称为物理地址、以太网地址或介质访问控制(MAC)地址</p>
<h4 id="长度为48位-6字节-1"><a href="#长度为48位-6字节-1" class="headerlink" title="长度为48位/6字节(*)"></a>长度为48位/6字节(*)</h4><p>这6个字节的地址，通常用十六位进制数表示。</p>
<p>是永久且唯一的。</p>
<h2 id="13-无线网"><a href="#13-无线网" class="headerlink" title="13. 无线网"></a>13. 无线网</h2><h3 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA/CA"></a>CSMA/CA</h3><p>IEEE802.11 介质访问控制协议是一种可以避免冲突的载波侦听多路访问协议。</p>
<h4 id="冲突避免"><a href="#冲突避免" class="headerlink" title="冲突避免"></a>冲突避免</h4><p>没有采用冲突检测机制，而是采用冲突避免机制。</p>
<p>会带来问题，故而有如下：</p>
<h4 id="信道预留机制"><a href="#信道预留机制" class="headerlink" title="信道预留机制"></a>信道预留机制</h4><p>采用信道预留机制。当发送方要发送一个帧时，它能够首先给接收方发送一个RTS(Request To Send)帧，指出数据分组和ACK分组的持续时间。收到RTS帧的接收方用一个CTS(Clear To Send)帧来响应，显式地指出允许发送方发送。</p>
<h2 id="12-局域网互联"><a href="#12-局域网互联" class="headerlink" title="12. 局域网互联"></a>12. 局域网互联</h2><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>在物理层进行局域网互联一般使用的是：</p>
<ul>
<li>中继器：同轴电缆</li>
<li>集线器：双绞线</li>
</ul>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><p>是一个局域网和另一个局域网之间建立连接的桥梁，扩展网络和通信手段。</p>
<p>但网桥互联会带来广播风暴。网桥不阻挡网络中的广播消息，当网络规模较大时(几个网桥，多个以太网段)，有可能引起广播风暴，导致整个网络充满广播信息，直至完全瘫痪。</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol>
<li>隔开冲突域</li>
<li>按照目的地址转发</li>
<li>连接不同的网络(令牌环网与以太网：微波网桥)</li>
</ol>
<ul>
<li><p>隔开冲突域(隔不开广播域。)</p>
</li>
<li><p>可以分辨所上传数据的头部，而物理层设备不能分辨(都发)。</p>
</li>
<li><p>其内存在转发表，可以发送数据给特定的端口和主机。</p>
</li>
</ul>
<h4 id="源路由网桥"><a href="#源路由网桥" class="headerlink" title="源路由网桥"></a>源路由网桥</h4><p>可以指定路径。</p>
<p>路径的选择是由每个帧的发送者来完成的。</p>
<h2 id="14-补充"><a href="#14-补充" class="headerlink" title="14. 补充"></a>14. 补充</h2><h3 id="面向连接的可靠的协议"><a href="#面向连接的可靠的协议" class="headerlink" title="面向连接的可靠的协议"></a>面向连接的可靠的协议</h3><p>HDLC：面向字节的协议(字节整数倍)</p>
<p>PPP：面向位的协议</p>
<h2 id="习题4"><a href="#习题4" class="headerlink" title="习题4"></a>习题4</h2><h3 id="基本技术"><a href="#基本技术" class="headerlink" title="基本技术"></a>基本技术</h3><p>局域网的特性主要是由三个技术因素决定：网络拓扑结构、传播介质和介质访问控制方法。</p>
<h4 id="局域网拓扑结构"><a href="#局域网拓扑结构" class="headerlink" title="局域网拓扑结构"></a>局域网拓扑结构</h4><ul>
<li>总线型拓扑结构</li>
<li>环形拓扑结构</li>
<li>星型拓扑结构</li>
</ul>
<h3 id="设置介质访问控制子层"><a href="#设置介质访问控制子层" class="headerlink" title="设置介质访问控制子层"></a>设置介质访问控制子层</h3><p>网络中链路主要包括两种类型，即点到点链路和广播链路。</p>
<p>对于点到点链路，链路的两端各有一个单一的发送者和接收者，因此不考虑流量控制的影响，结点想要发送就可以发送。PPP和HDLC协议是比较常用的点到点链路上的数据链路层协议。</p>
<p><strong>对于广播链路，多个发送和接收站点连接到同样的、单一的、共享的广播信道上，为了有效、公平、简单和分散地利用这种广播信道进行数据的传输，必须采用一些对传输介质访问的控制方法，这就是介质访问控制(MAC)协议提供的功能。</strong>以太网和无线局域网都是采用广播链路技术的例子。</p>
<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>当有两个或两个以上站点在同一时刻发送信息时，总线上的信息便会混淆不清，无法辨认，造成发送失败。这种因信息在总线上重叠而出错的现象称为<strong>冲突</strong>。</p>
<h4 id="在CSMA-CD上"><a href="#在CSMA-CD上" class="headerlink" title="在CSMA/CD上"></a>在CSMA/CD上</h4><p>它不是采用集中控制的方式解决用户发送信息的顺序，而是各站根据自己的需要随机地发送信息，通过竞争获得发送权。</p>
<p><img src="https://s2.loli.net/2022/02/17/8CKWwmR5fZ1F3r9.png" alt="image-20220217195722590"></p>
<p>标准的10Mb/s局域网的波特率(每秒信号变化多少次)：极限为20Mb/s</p>
<h3 id="以太网特点"><a href="#以太网特点" class="headerlink" title="以太网特点"></a>以太网特点</h3><p>10吉比特以太网的帧格式与10Mb/s、100Mb/s和1Gb/s以太网的帧格式完全相同。</p>
<h3 id="无线和有线的协议"><a href="#无线和有线的协议" class="headerlink" title="无线和有线的协议"></a>无线和有线的协议</h3><p>RTS：信道预约；CTS：信道检测</p>
<p>有线：CSMA/CD：冲突检测</p>
<p>无线：CSMA/CA：冲突避免(结点之间的冲突)</p>
<h3 id="透明网桥与源路由网桥的比较"><a href="#透明网桥与源路由网桥的比较" class="headerlink" title="透明网桥与源路由网桥的比较"></a>透明网桥与源路由网桥的比较</h3><p>源路由网桥主要用于令牌环。透明网桥的缺点在于不能选择最佳路径，因而无法充分利用冗余的网桥来分担负载。但在一个规模不大的网络中，透明网桥的优点却很明显，所以目前市场上大多数网桥为透明网桥。源路由网桥要求主机参与选径，从理论上说，它可以选择最佳路径，因而可以充分利用冗余网桥来分担负载，但实现起来并不容易。</p>
<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><h3 id="考的可能性比较小"><a href="#考的可能性比较小" class="headerlink" title="考的可能性比较小"></a>考的可能性比较小</h3><ol>
<li>HDLC定义<strong>三种类型的站、两种链路配置和三种传输方式</strong>。</li>
<li>三种类型的站包括:主站、从站和复合站。</li>
<li>两种链路配置包括非平衡配置和平衡配置。</li>
<li>PPP协议有3个组成部分，即将IP数据报封装到<strong>串行链路的方法、链路控制协议、网络控制协议(Network Control Protocol，NCP)。</strong></li>
<li>NCP（网络控制协议）给新接入的PC机分配一个临时的<strong>IP地址</strong> ，使PC机成为Internet上的一个主机，然后就可以开始进行数据的传输。</li>
<li>用户使用拨号电话线接入Internet时，一般都是使用<strong>PPP</strong>协议。</li>
<li>PPP不仅适用于拨号用户，而且适用于租用的<strong>路由器对路由器</strong>线路。</li>
<li>采用普通电话线（PSTN网）作为PPP链路介质是一种廉价的常用方式。在这种方式中，通常通过<strong>RS-232</strong>标准异步串行线路传送IP/IPX包。</li>
<li>数据链路层的服务：<img src="https://s2.loli.net/2022/02/22/wyeJrgXHkCMxqlP.png" alt="image-20220222202941409"></li>
<li></li>
</ol>
<h3 id="考的可能性大"><a href="#考的可能性大" class="headerlink" title="考的可能性大"></a>考的可能性大</h3><ol>
<li>通过通信信道后，接受的数据与发送的数据不一致的现象称为<strong>”传输差错“</strong>。</li>
<li>目前，最常用的差错检测方法：<strong>差错检测编码</strong>。</li>
<li>垂直奇偶校验方法能检测出每列中所有的<strong>奇数位</strong>错。</li>
<li>水平垂直奇偶校验不仅可检错，还可用来<strong>纠正部分差错</strong>。</li>
<li>在计算机网络和数据通信中，应用最广泛的检错码是<strong>循环冗余码</strong>。</li>
<li>进行差错控制和流量控制的基本策略是<strong>反馈机制</strong>。</li>
<li>当出现数据帧丢失时，超时重传可以解决问题。但是若确认帧丢失后，超时重传将使结点B收到两个同样的数据帧。要解决重复帧的问题，就必须使每一个数据帧带上<strong>不同的发送序号</strong>。</li>
<li>停等协议在通信线路较长，传输速率较快的情况下将<strong>浪费大量带宽</strong>。</li>
<li>数据链路控制规程分为面向字符和面向<strong>比特</strong>两类。</li>
<li>基于滑动窗口的数据链路协议，可以连续发送数据帧，<strong>其可连续发送的信息帧的个数等于发送窗口W的大小</strong>。</li>
<li>在连续ARQ协议中，接收方的窗口大小总是1，因此<strong>浪费了很多线路带宽</strong>。</li>
<li><img src="https://s2.loli.net/2022/02/22/ziqKnGoxb5mI82O.png" alt="image-20220222191047454"></li>
<li><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220222191120897.png" alt="image-20220222191120897"></li>
<li><img src="https://s2.loli.net/2022/02/22/yOSeH8WYpjQnKr9.png" alt="image-20220222203206570"></li>
<li><img src="https://s2.loli.net/2022/02/22/WfzduRrOZAQ25yK.png" alt="image-20220222203330201"></li>
<li><img src="https://s2.loli.net/2022/02/22/3GBQnUr7D1Nvqjl.png" alt="image-20220222203417519"></li>
<li>计算题：<img src="https://s2.loli.net/2022/02/22/Gi5UaHmFSYzqVQJ.png" alt="image-20220222204513809"></li>
</ol>
<h5 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h5><ol>
<li>数据链路层划分为两个子层：<strong>逻辑链路控制(LLC)子层 和介质访问控制(MAC)子层。</strong></li>
<li>LLC子层为上层用户提供3种类型的服务分别是无确认无连接服务、有连接服务、有确认无连接服务。</li>
<li>网卡的功能主要包括：<strong>串行/并行转换、对数据进行缓存、实现以太网协议等。</strong></li>
<li><img src="https://s2.loli.net/2022/02/24/hfbJItR8YUFGZKg.png" alt="image-20220224161811616"></li>
<li><img src="https://s2.loli.net/2022/02/24/25klyQNR97TeUaJ.png" alt="image-20220224161534391"><img src="https://s2.loli.net/2022/02/24/JVHY8MRtGcUKeZo.png" alt="image-20220224161553329"></li>
<li><img src="https://s2.loli.net/2022/02/24/WqZHkGzMotvPAXY.png" alt="image-20220224161457357"></li>
<li>虽然CSMA协议比纯ALOHA协议和分槽ALOHA协议有效，但是它仍然存在一个明显的低效情况：<strong>一旦有两个帧发生冲突，则在这两个坏帧传输的时间内，其他站点都不能传输。</strong></li>
<li>令牌环的管理包括：<strong>令牌环的初始建立、令牌环在丢失或出现故障时的初始状态恢复</strong>。</li>
<li><strong>透明网桥</strong>又称为生成树网桥，基本功能有过滤、帧转发、地址学习和生成树算法。</li>
<li>对突发性的数据传输，<strong>争用</strong>是常用的策略。在这种方式中，所有的工作站自由竞争发送机会。</li>
<li>IEEE 802.4 是<strong>令牌总线</strong> MAC子层与物理层规范， IEEE 802.5 是<strong>令牌环</strong>MAC子层与物理层规范。</li>
<li><img src="https://s2.loli.net/2022/02/24/LqPIgaJ8cVwOK1b.png" alt="image-20220224173149103"></li>
</ol>
<h1 id="第五章-广域网-虚电路"><a href="#第五章-广域网-虚电路" class="headerlink" title="第五章 广域网(虚电路)"></a>第五章 广域网(虚电路)</h1><h2 id="习题五"><a href="#习题五" class="headerlink" title="习题五"></a>习题五</h2><h3 id="1-数据通信技术"><a href="#1-数据通信技术" class="headerlink" title="1. 数据通信技术"></a>1. 数据通信技术</h3><h4 id="电路方式-实电路"><a href="#电路方式-实电路" class="headerlink" title="电路方式(实电路)"></a>电路方式(实电路)</h4><p>公用电话网(PSTN)、数字数据网(DDN)</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>信息传输 时延小、电路对用户是“透明”的、信息传送的吞吐量大。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>占用的带宽是 固定的 ，所以网络资源的利用率较低。</p>
<h4 id="虚电路方式"><a href="#虚电路方式" class="headerlink" title="虚电路方式"></a>虚电路方式</h4><ul>
<li>分组方式: X.25(不用的方式）</li>
<li>帧方式：帧中继</li>
<li>信元方式：ATM(由信元头和信元净荷组成，以信元为单位进行传送)</li>
</ul>
<h3 id="2-帧中继"><a href="#2-帧中继" class="headerlink" title="2. 帧中继"></a>2. 帧中继</h3><p>当帧中继交换机收到一个帧的头部时，只要一查出帧的目的地址就开始转发该帧。</p>
<p>即中间层不进行差错检测，提高了帧的处理时间。</p>
<p>适合处理大容量突发型数据业务。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>采用虚电路方式，使用逻辑连接。</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>帧中继采用两种拥塞控制方法，即丢弃策略和 拥塞避免 。</p>
<h3 id="3-ATM"><a href="#3-ATM" class="headerlink" title="3. ATM"></a>3. ATM</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>异步传输模式(ATM)是建立在<strong>电路交换和分组交换</strong>的基础上的一种<strong>面向连接</strong>的快速分组交换技术。</p>
<p>它采用<strong>固定长度是53字节</strong>的协议数据单元，这种定长分组称为<strong>信元</strong>。</p>
<p>在ATM中，数据传输速率可达155Mb/s或622Mb/s。</p>
<p>转发时延小，易于硬件实现。</p>
<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点(*)"></a>2. 特点(*)</h4><p>短信元：53字节</p>
<p>固定信元：5字节(头部固定为5字节)+48字节(载荷长度固定)</p>
<h4 id="4-信元结构-不考"><a href="#4-信元结构-不考" class="headerlink" title="4. 信元结构(不考)"></a>4. 信元结构(不考)</h4><p><img src="https://s2.loli.net/2022/02/25/i8IKRtHMVXEb1Dq.png" alt="image-20220225110859544"></p>
<h4 id="5-虚拟连接"><a href="#5-虚拟连接" class="headerlink" title="5. 虚拟连接"></a>5. 虚拟连接</h4><p>分为两级：虚通道连接(VP)与虚通路连接(VC)。</p>
<h5 id="二者关系"><a href="#二者关系" class="headerlink" title="二者关系"></a>二者关系</h5><p>一个虚通道包含有许多<strong>相同端点</strong>的虚通路。</p>
<h1 id="第六章-网络层-数据报"><a href="#第六章-网络层-数据报" class="headerlink" title="第六章 网络层(数据报)"></a>第六章 网络层(数据报)</h1><h2 id="考的可能性大-1"><a href="#考的可能性大-1" class="headerlink" title="考的可能性大"></a>考的可能性大</h2><ol>
<li>网络层的主要功能就是实现整个网络系统的连接，为运输层提供<strong>整个网络范围内两个终端用户之间数据传输的通路</strong>，实现两个端系统之间的数据透明传送。</li>
<li>一般地，当中继系统是<strong>中继器或网桥</strong>时，一般不称为网络互连，因为这仅仅是把一个物理网络扩大了，它仍然是一个网络。</li>
<li>路由器能够阻止从一个子网到另外一个子网的<strong>广播</strong>。</li>
<li>路由器对于流经的任何分组都要检查分组的源IP地址与目的IP地址，然后根据<strong>路由表</strong>确定该分组流向。</li>
<li></li>
</ol>
<h2 id="习题六"><a href="#习题六" class="headerlink" title="习题六"></a>习题六</h2><h3 id="1-网络互连的定义"><a href="#1-网络互连的定义" class="headerlink" title="1. 网络互连的定义"></a>1. 网络互连的定义</h3><ul>
<li>将相同类型的网络或不同类型的网络及其产品连接在一起，组成地理覆盖范围更大、功能更强大的网络</li>
<li>将大的网络拆分为几个子网，实现更为有效的网络管理等。</li>
</ul>
<h3 id="2-网络层的功能"><a href="#2-网络层的功能" class="headerlink" title="2. 网络层的功能"></a>2. 网络层的功能</h3><p>通过数据报服务，实现主机之间的通信</p>
<h3 id="3-虚电路服务和数据报服务对比"><a href="#3-虚电路服务和数据报服务对比" class="headerlink" title="3. 虚电路服务和数据报服务对比"></a>3. 虚电路服务和数据报服务对比</h3><div class="table-container">
<table>
<thead>
<tr>
<th>虚电路</th>
<th>数据报</th>
</tr>
</thead>
<tbody>
<tr>
<td>通信前先建立连接</td>
<td>不建立连接</td>
</tr>
<tr>
<td>虚电路号(局部性)</td>
<td>目的地址(IP唯一，全局性)</td>
</tr>
<tr>
<td>规定传输路径，顺序性</td>
<td>无顺序性，无固定路径</td>
</tr>
<tr>
<td>无法绕开故障点</td>
<td>存在冗余线路时，有可能绕开故障点</td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-三级IP地址格式与划分思想"><a href="#5-三级IP地址格式与划分思想" class="headerlink" title="5. 三级IP地址格式与划分思想"></a>5. 三级IP地址格式与划分思想</h3><p><img src="https://s2.loli.net/2022/02/25/hq4AnST5pCHFVro.png" alt="image-20220225121149080"></p>
<h3 id="6-物理地址与IP地址"><a href="#6-物理地址与IP地址" class="headerlink" title="6. 物理地址与IP地址"></a>6. 物理地址与IP地址</h3><p>物理地址48位，是平面型地址。地址解析原因：交换机根据全部的物理地址来确定转发的目的的地址。</p>
<p>IP地址是层次性地址(IPv4: 32位；IPv6: 128位)。地址解析原因：路由器只根据网络号就可进行转发。</p>
<h3 id="7-CIDR"><a href="#7-CIDR" class="headerlink" title="7. CIDR"></a>7. CIDR</h3><p>无分类域间路由选择</p>
<p>CIDR不再按网络规模对地址进行分类，也不再划分子网，使用网络前缀来代替了网络号和子网号，IP地址里只包括网络前缀和主机号两部分。(取消了子网的概念，但是还使用掩码。)</p>
<p>采用“斜线记法”，即在IP地址后面加上一个斜线”/“，然后写上网络前缀所占的比特数。</p>
<p>如166.100.20.82/20：表示在这个32位的IP地址中，前20位是网络前缀，后12位是主机号。</p>
<h3 id="8-主机数"><a href="#8-主机数" class="headerlink" title="8. 主机数"></a>8. 主机数</h3><p><img src="https://s2.loli.net/2022/02/25/28VFSgzNxGerpnL.png" alt="image-20220225124325419"></p>
<h3 id="9-网络号和主机号"><a href="#9-网络号和主机号" class="headerlink" title="9. 网络号和主机号"></a>9. 网络号和主机号</h3><p><img src="https://s2.loli.net/2022/02/25/k1cxr3PG9gJRa7M.png" alt="image-20220225124418477"></p>
<h3 id="10-IP地址分配规则"><a href="#10-IP地址分配规则" class="headerlink" title="10. IP地址分配规则"></a>10. IP地址分配规则</h3><p><strong>主机号全0或全1称为直接广播地址，不能用。</strong></p>
<p><img src="https://s2.loli.net/2022/02/25/1bIyfgJD26BR3Nh.png" alt="image-20220225124549534"></p>
<p><img src="https://s2.loli.net/2022/02/27/oahdke85i72gjHL.png" alt="image-20220227194632169"></p>
<h3 id="19-路由交换规则"><a href="#19-路由交换规则" class="headerlink" title="19. 路由交换规则"></a>19. 路由交换规则</h3><p>下一跳不同，选近路(A经B、D都可到C，则取近的)</p>
<p>下一跳不同，距离相同，选原路(为维护网络稳定性)</p>
<p>下一跳相同，选新路(A经B到C，原为3；现有A经B到C距离5，则最终A经B到C的距离取5)</p>
<h3 id="20-自治系统"><a href="#20-自治系统" class="headerlink" title="20. 自治系统"></a>20. 自治系统</h3><h3 id="23-子网拆分"><a href="#23-子网拆分" class="headerlink" title="23. 子网拆分"></a>23. 子网拆分</h3><p>如图所示，一个路由器互联了3个局域网(LAN)。</p>
<h4 id="子网掩码的求法"><a href="#子网掩码的求法" class="headerlink" title="子网掩码的求法"></a>子网掩码的求法</h4><p>网段中可容纳$2^n$个主机，对应的子网掩码中前$32-n$位就是1，后$n$位为0。将其换成十进制即可。</p>
<p>子网掩码里有$n$个0，对应的就有$2^n$个主机。</p>
<p><img src="https://s2.loli.net/2022/02/25/2irKzbGujpMUA9D.png" alt="image-20220225130106638"> </p>
<p><img src="https://s2.loli.net/2022/02/25/Su8zGgOndLUlW73.png" alt="image-20220225130210588"></p>
<p>此题没给各个网段的主机数目，考试时会给出主机数目。</p>
<h4 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h4><p><img src="https://s2.loli.net/2022/02/25/Ib3oSPrwjd4nMVp.png" alt="image-20220225130356702"></p>
<h3 id="24-IPv6特点"><a href="#24-IPv6特点" class="headerlink" title="24. IPv6特点"></a>24. IPv6特点</h3><p>头部40字节</p>
<p>简化头部，提高转发速度；长度扩大为128位，实现万物互联。</p>
<ul>
<li>IP地址长度扩大为128字节</li>
<li>高速化<ul>
<li>分组头部的长度固定</li>
<li>不检查传输错误</li>
<li>不需要每个路由器都进行分片处理</li>
</ul>
</li>
<li>任意通信</li>
<li>安全性功能</li>
<li>流标记(flow label)</li>
</ul>
<h3 id="25-IP多播"><a href="#25-IP多播" class="headerlink" title="25. IP多播"></a>25. IP多播</h3><p>IPv4定义了3种IP分组的传输：</p>
<ul>
<li>单播：发送分组到单个目的地，实际上是点对点的传输。</li>
<li>广播：发送分组到同一个广播域或子网内的所有设备</li>
</ul>
<h4 id="多播-组播"><a href="#多播-组播" class="headerlink" title="多播(组播)"></a>多播(组播)</h4><p>也称为多址广播或组播技术，是一种允许一台或多台主机(多播源)发送单一分组到多台主机(一次的、同时的)的TCP/IP网络技术。</p>
<h3 id="26-虚拟专用网VPN"><a href="#26-虚拟专用网VPN" class="headerlink" title="26. 虚拟专用网VPN"></a>26. 虚拟专用网VPN</h3><p>VPN，是指基于公用网络(通常是Internet)所建立的企业网络，并且此企业网络拥有与专用网络相同的安全、管理及功能等特点。</p>
<h3 id="27-网络地址转换NAT"><a href="#27-网络地址转换NAT" class="headerlink" title="27. 网络地址转换NAT"></a>27. 网络地址转换NAT</h3><p>NAT(network address translation，网络地址转换)于1994年提出。</p>
<p>但在专用网内部的一些主机本来已经分配到了本地IP地址(即仅在本专用网内使用的专用地址)，但现在又想和Internet上的主机通信(并不需要加密)时，可使用NAT方法。</p>
<p>NAT不仅能解决IP地址不足的问题，还能有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。</p>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>互联网控制协议</p>
<p>ICMP是Internet中一个差错和控制报文协议，针对网络层的错误诊断、拥塞控制、路径控制和查询服务4大功能，ICMP提供相应的报文。</p>
<p>ICMP主要用于拥塞控制和路径控制。</p>
<p>ICMP报文封装在IP分组的数据区中发送的，因此并不能保证它的可靠性。</p>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>ICMP报文分成报文头和数据区两部分，其中报文头包含类型、代码与校验和三个字段。</p>
<h4 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h4><p>0 ：回应应答</p>
<p>3 ：目的站点不可达</p>
<p>4 ：源抑制</p>
<p>8 ：回应请求</p>
<p>11 ： 分组超时(回复源主机，数据包死亡)</p>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>ping：请求主机发送了4个类型为8的回应请求，接收主机有义务回复4个类型为0的回应应答。 </p>
<p>tracert：依靠 <strong>IP包的生存时间</strong> 确定，发送类型为11的反馈给发送主机。</p>
<h4 id="拥塞控制-1"><a href="#拥塞控制-1" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p><strong>网络负载超过网络容量，产生拥塞，采用各种手段去避免和减轻拥塞，即为拥塞控制</strong></p>
<p>轻拥塞，即为拥塞控制。</p>
<p>发送 类型为4 的反馈给 发送主机。</p>
<h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><p>最早的动态路由协议</p>
<p>将路由表转发给相邻路由器。</p>
<p>下一跳不同，选近路；</p>
<p>下一跳相同，选新路。</p>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>每30秒，就把路由器中的所有路由信息向所有的网络端口广播，进行刷新。</p>
<p>路由超时时钟一般为90s，即如果一条路由在90s之内都没有刷新过，则RIP把路由项置为无效(把其量度值置为16).</p>
<h1 id="第七章-运输层"><a href="#第七章-运输层" class="headerlink" title="第七章 运输层"></a>第七章 运输层</h1><h2 id="习题七"><a href="#习题七" class="headerlink" title="习题七"></a>习题七</h2><h3 id="1-运输层与网络层"><a href="#1-运输层与网络层" class="headerlink" title="1. 运输层与网络层"></a>1. 运输层与网络层</h3><p>网络层为运输层提供主机之间通信的服务，运输层使用网络层提供的服务。</p>
<h3 id="2-运输层端口的作用"><a href="#2-运输层端口的作用" class="headerlink" title="2. 运输层端口的作用"></a>2. 运输层端口的作用</h3><p>用来标识应用层的进程，提供进程之间的寻址，保证数据包到达正确的应用层进程。</p>
<h3 id="4-TCP提供的服务"><a href="#4-TCP提供的服务" class="headerlink" title="4. TCP提供的服务"></a>4. TCP提供的服务</h3><p>TCP是一个面向连接的、可靠的、全双工的通信协议。</p>
<ol>
<li>进程之间的通信</li>
<li>面向连接的，可保证数据的顺序性</li>
<li>有确认的，可靠的</li>
</ol>
<p>(面向连接、可靠性、数据流传输、流量控制、全双工(允许任何一个方向发送数据))</p>
<h3 id="5-TCP建立连接和释放连接过程"><a href="#5-TCP建立连接和释放连接过程" class="headerlink" title="5. TCP建立连接和释放连接过程"></a>5. TCP建立连接和释放连接过程</h3><p>避免建立不必要的连接，浪费计算机资源</p>
<h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>ACK为确认标志：如果ACK=1，则表示TCP段中的确认号是有效的；否则确认号无效。</p>
<p>SYN为同步标志：用来建立连接，让连接双方同步序列号。如果SYN=1且ACK=0，则表示该数据包为连接请求；</p>
<p>如果SYN=1且ACK=1，则表示是接受链接。</p>
<p>FIN为结束标志：表示发送方已经没有数据要求传输了，希望释放连接。</p>
<p>SEQ是数据包序号。</p>
<p>ACKSEQ：准备接收的数据包序号。</p>
<h4 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h4><p>SEQ是序号。</p>
<p><img src="https://s2.loli.net/2022/02/26/iOeMpwD2xV41fEQ.png" alt="image-20220226184448915"></p>
<h5 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h5><ol>
<li><p>三次是因为将确认建立A-&gt;B和请求建立反向连接B-&gt;A的合在一起了。</p>
</li>
<li><p>不这样的话：<strong>当出现延迟的请求建立连接的数据包，会建立没有用的连接，浪费计算机的资源。</strong></p>
</li>
</ol>
<h4 id="四次挥手释放连接"><a href="#四次挥手释放连接" class="headerlink" title="四次挥手释放连接"></a>四次挥手释放连接</h4><p><img src="https://s2.loli.net/2022/02/26/Tl4ud3CbpYILBfr.png" alt="image-20220226185633818"></p>
<h3 id="11-拥塞及解决方法"><a href="#11-拥塞及解决方法" class="headerlink" title="11. 拥塞及解决方法"></a>11. 拥塞及解决方法</h3><p>产生拥塞的原因：网络的负载超过网络的容量</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol>
<li>开环的解决方式：良好的设计来避免(虚电路：许可证法；TCP中慢启动)</li>
<li>闭环的解决方式：通过网络的反馈来减少拥塞(网络层：源抑制报文，控制传输量)</li>
</ol>
<h4 id="TCP中的拥塞控制"><a href="#TCP中的拥塞控制" class="headerlink" title="TCP中的拥塞控制"></a>TCP中的拥塞控制</h4><p>在运输层，采用了慢启动、拥塞避免、快重传和快恢复四种算法。</p>
<p>当TCP收到路由器发来的ICMP源抑制报文，或者发现连续的报文丢失现象或延迟过长而引起的超时重发，就认为发生了拥塞。</p>
<h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><p>在慢启动的初级阶段，TCP发送方以很慢的速率开始发送，但是以指数级的速度快速增长其发送速率。</p>
<h6 id="慢启动门限"><a href="#慢启动门限" class="headerlink" title="慢启动门限"></a>慢启动门限</h6><p>在TCP慢启动阶段，可以发送的报文数量按指数级增加，为了防止拥塞窗口的增长引起网络拥塞，还需要一个状态变量，即<strong>慢启动门限ssthresh</strong>。</p>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>拥塞窗口的大小以MSS为单位。<strong>慢启动门限ssthresh初始时等于8MSS。</strong></p>
<p>注意到当发生丢包事件时，拥塞窗口值为12。于是门限值被设置为Cwnd×0.5=12×0.5=6MSS。</p>
<p>拥塞窗口Cwnd重新设置为1，并开始执行慢启动算法。当Cwnd=6时，改为执行拥塞避免算法。</p>
<h5 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h5><p>也就是说，当到达门限时，就进行缓慢线性增长，如果发生拥塞，那么就变为1，再设置门限(拥塞时的一半)。</p>
<p><img src="https://s2.loli.net/2022/02/26/PL6VN21CaXUKyZj.png" alt="image-20220226191621666"></p>
<h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><p>发送方只要一连收到3个重复的ACK即可判定有分组丢失了，就应立即重传丢失的报文段，而不必继续等待为丢失的那个报文所设置的重传计时器超时。</p>
<h5 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h5><p>当发送方一连收到3个连续重复的ACK时，按“乘法减小”重新设置慢启动门限，与慢启动不同的是，Cwnd不是设置为1，而是设置为ssthresh(慢启动阈值)+3×MSS。</p>
<h3 id="12-流量控制"><a href="#12-流量控制" class="headerlink" title="12. 流量控制"></a>12. 流量控制</h3><p>TCP采用<strong>大小可变的滑动窗口</strong>给应用进程提供流量控制服务。</p>
<p><img src="https://s2.loli.net/2022/02/26/1AvmOCQrHx59yoB.png" alt="image-20220226191746994"></p>
<p>第一次将窗口减小为2048字节，第二次又减小为0字节，即不允许发送方再发送。第三次增加为2048字节。</p>
<h4 id="发送窗口Swnd-MIN-接收窗口，拥塞窗口-。"><a href="#发送窗口Swnd-MIN-接收窗口，拥塞窗口-。" class="headerlink" title="发送窗口Swnd = MIN[接收窗口，拥塞窗口]。"></a><strong>发送窗口Swnd = MIN[接收窗口，拥塞窗口]。</strong></h4><h3 id="13-UDP"><a href="#13-UDP" class="headerlink" title="13. UDP"></a>13. UDP</h3><p>UDP报文由头部和数据两个数据组成，占8个字节。</p>
<p>头部为4个字节。</p>
<p>用户数据报协议（UDP）只在IP协议的数据报服务之上增加了很少一点的功能，即</p>
<p><strong>端口功能和差错检测功能</strong>。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol>
<li>无需建立连接</li>
<li>无连接状态管理</li>
<li>报文头部开销小</li>
<li>应用层能很好的控制要发送的数据和发送时间。</li>
</ol>
<h1 id="第八章-应用层"><a href="#第八章-应用层" class="headerlink" title="第八章 应用层"></a>第八章 应用层</h1><h2 id="习题八"><a href="#习题八" class="headerlink" title="习题八"></a>习题八</h2><h3 id="1-客户-服务器模型和P2P模型"><a href="#1-客户-服务器模型和P2P模型" class="headerlink" title="1. 客户/服务器模型和P2P模型"></a>1. 客户/服务器模型和P2P模型</h3><h4 id="在C-S模型中"><a href="#在C-S模型中" class="headerlink" title="在C/S模型中"></a>在C/S模型中</h4><ul>
<li>服务器处于接受请求的状态</li>
<li>客户机发出请求，并等待接收结果</li>
<li>服务器收到请求后，分析请求，进行必要的处理，得到结果并发送给客户机。</li>
</ul>
<h4 id="在P2P模型中"><a href="#在P2P模型中" class="headerlink" title="在P2P模型中"></a>在P2P模型中</h4><p>P2P的思想是整个网络中的传输内容不再被保存在中心服务器上，每个节点都同时具有下载、上传的功能，即每个结点既是服务器又是客户机。</p>
<p>任意一对计算机称作对等方(Peer)，直接相互通信。</p>
<p>每个结点既作为客户访问其他结点的资源，也作为服务器提供资源给其他结点访问。</p>
<h3 id="2-域名转换DNS"><a href="#2-域名转换DNS" class="headerlink" title="2. 域名转换DNS"></a>2. 域名转换DNS</h3><ol>
<li>使用DNS，域名-&gt;IP(相互转换)</li>
<li>客户机向本地域名服务器发起请求</li>
<li>本地域名服务器和互联网上其他的域名服务器相互配合，将查询结果返回给客户机。</li>
<li><img src="https://s2.loli.net/2022/02/27/vkcY74zwm9fnONI.png" alt="image-20220227195738711"></li>
</ol>
<h3 id="3-域名结构和功能"><a href="#3-域名结构和功能" class="headerlink" title="3. 域名结构和功能"></a>3. 域名结构和功能</h3><p><img src="https://s2.loli.net/2022/02/26/FGlDBjzUMq7c3bn.png" alt="image-20220226200011860"></p>
<h3 id="6-HTML的作用"><a href="#6-HTML的作用" class="headerlink" title="6. HTML的作用"></a>6. HTML的作用</h3><p>HTML是WWW上用于创建超文本的基本语言，可以定义格式化的文本、色彩、图像与超文本链接等，主要用于web主页的创建与制作。</p>
<h3 id="7-FTP的定义及作用"><a href="#7-FTP的定义及作用" class="headerlink" title="7. FTP的定义及作用"></a>7. FTP的定义及作用</h3><p>主要功能是文件上传与下载。</p>
<ol>
<li>文件传输协议</li>
<li>端口21传控制信息</li>
<li>端口20传数据</li>
</ol>
<p><img src="https://s2.loli.net/2022/02/26/7M3cyLDxmYdFVH5.png" alt="image-20220226200212130"></p>
<h3 id="8-Telnet和SSH特点"><a href="#8-Telnet和SSH特点" class="headerlink" title="8. Telnet和SSH特点"></a>8. Telnet和SSH特点</h3><p>Telnet允许用户和远程计算机动态交互。</p>
<p>SSH是加密的远程登录。</p>
<p><img src="https://s2.loli.net/2022/02/26/AVz8YN97JlySRnj.png" alt="image-20220226195929213"></p>
<h3 id="9-电子邮件收发过程"><a href="#9-电子邮件收发过程" class="headerlink" title="9. 电子邮件收发过程"></a>9. 电子邮件收发过程</h3><p><img src="https://s2.loli.net/2022/02/26/oRPywGQ9HcCYesW.png" alt="image-20220226195839467"></p>
<p><img src="https://s2.loli.net/2022/02/26/Ff2VMlmzPShTWCA.png" alt="image-20220226195909957"></p>
<h3 id="10-DHCP定义"><a href="#10-DHCP定义" class="headerlink" title="10. DHCP定义"></a>10. DHCP定义</h3><p>动态主机配置协议(DHCP)负责IP地址的集中和动态分配管理。</p>
<h3 id="11-URL与信息定位"><a href="#11-URL与信息定位" class="headerlink" title="11. URL与信息定位"></a>11. URL与信息定位</h3><p>URL用于定位信息资源所在的位置，描述了浏览器检索资源所用的协议，资源所在的计算机的主机名和资源的路径与文件名。</p>
<h4 id="标准格式"><a href="#标准格式" class="headerlink" title="标准格式(*)"></a>标准格式(*)</h4><p>资源传递协议://存放资源的主机/资源路径与文件名</p>
<p>如果要访问的不是80端口，要指明端口号，即在标准格式后加上    :端口号</p>
<p>ftp://ftp.xaut.edu.cn</p>
<h1 id="第九章-网络安全与网络管理"><a href="#第九章-网络安全与网络管理" class="headerlink" title="第九章 网络安全与网络管理"></a>第九章 网络安全与网络管理</h1><h2 id="加密与认证"><a href="#加密与认证" class="headerlink" title="加密与认证"></a>加密与认证</h2><h3 id="数据加密标准"><a href="#数据加密标准" class="headerlink" title="数据加密标准"></a>数据加密标准</h3><p><strong>数据加密标准</strong>(Data Encryption Standard, DES)是最典型(经典)的对称加密算法，它是由IBM公司提出。</p>
<p>DES使用一个56位(二进制，$2^{56}$)的密钥和附加的8位奇偶校验位，产生长度为64位的分组。</p>
<h2 id="公开密钥加密机制"><a href="#公开密钥加密机制" class="headerlink" title="公开密钥加密机制"></a>公开密钥加密机制</h2><p>每个发送者拥有两个密码，一个是任何人都可得到的公开密钥(公钥)，另一个是只有发送者本人知道的秘密密钥(私钥)。</p>
<p><strong>RSA算法是最流行的公开密钥算法。</strong></p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol>
<li>加密密钥公开，解密密钥私有</li>
<li>从公开密钥推出私有密钥是极其困难的</li>
<li>绝大多数加密机制中，公钥与私钥可以互为加密解密密钥</li>
<li>加密解密速度慢</li>
</ol>
<p>使用非对称的密钥传输对称的密钥，以提升速度。如果是全非对称的话，太慢。</p>
<h2 id="数字签名技术"><a href="#数字签名技术" class="headerlink" title="数字签名技术"></a>数字签名技术</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>数字签名是一种基于密码的身份鉴别技术。</p>
<p>在传统的书信或文件中，通过亲笔签名或印章来证明其真实性，而在计算机网络中，传送的报文通常使用数字签名的技术来模拟日常生活中的亲笔签名。</p>
<h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理(*)"></a>原理(*)</h3><p>在使用公开密钥加密算法进行数字签名前，<strong>通常先使用单向散列函数(Hash Function，又称为哈希函数)对要签名的消息进行处理并生成消息摘要(Message Digest, MD)</strong>，然后对消息摘要进行签名。</p>
<h2 id="电子邮件加密"><a href="#电子邮件加密" class="headerlink" title="电子邮件加密"></a>电子邮件加密</h2><h3 id="PGP安全协议"><a href="#PGP安全协议" class="headerlink" title="PGP安全协议"></a>PGP安全协议</h3><p>PGP（Pretty Good Privacy，PGP）是一种基于RSA密钥加密体制供大众使用的加密协议。它不仅能对用户的邮件加密，还能在邮件上进行数字签名，让收信人确信邮件未被第三方篡改，从而达到安全通信的目的。</p>
<h2 id="防火墙技术"><a href="#防火墙技术" class="headerlink" title="防火墙技术"></a>防火墙技术</h2><p>防火墙(firewall)是把一个组织的内部网络与整个Internet隔离开的软件和硬件的组合，它允许一些数据分组通过，也禁止一些数据分组通过。</p>
<h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><h3 id="ISO功能域"><a href="#ISO功能域" class="headerlink" title="ISO功能域"></a>ISO功能域</h3><p>ISO特别定义了网络管理的5个功能域：配置管理、故障管理、性能管理、安全管理和计费管理。</p>
<h1 id="第十章-网络系统设计与配置"><a href="#第十章-网络系统设计与配置" class="headerlink" title="第十章 网络系统设计与配置"></a>第十章 网络系统设计与配置</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="网络系统层次"><a href="#网络系统层次" class="headerlink" title="网络系统层次"></a>网络系统层次</h3><p>计算机网络系统分为三个层次，即核心层(Core Layer)、汇聚层(Distribution Layer)和访问层(Access Layer)。（网络拓扑结构）</p>
<h2 id="2-局域网设计"><a href="#2-局域网设计" class="headerlink" title="2. 局域网设计"></a>2. 局域网设计</h2><h3 id="1-网络级联"><a href="#1-网络级联" class="headerlink" title="1. 网络级联"></a>1. 网络级联</h3><p>级联是指通过交换机的端口，以普通电缆将两个以上的交换机连接起来的拓展方式。</p>
<p><img src="https://s2.loli.net/2022/02/22/LnZahxl32TwH71j.png" alt="image-20220222213205530"></p>
<h3 id="2-交换机堆叠"><a href="#2-交换机堆叠" class="headerlink" title="2. 交换机堆叠"></a>2. 交换机堆叠</h3><p>堆叠是指若干交换机用特殊电缆通过特殊端口连接起来的拓展方式。</p>
<p>堆叠有两种模式：菊花链和点对点。</p>
<p><img src="https://s2.loli.net/2022/02/22/dmGvp8wFMqtbCIA.png" alt="image-20220222213447853"></p>
<h3 id="端口-链路聚合"><a href="#端口-链路聚合" class="headerlink" title="端口/链路聚合"></a>端口/链路聚合</h3><p>端口/链路聚合(Port Trunk/L2 Trunk)是指将以太网交换机上多个物理端口汇聚成一个逻辑端口。</p>
<h3 id="网络工作组划分"><a href="#网络工作组划分" class="headerlink" title="网络工作组划分"></a>网络工作组划分</h3><h4 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h4><p>虚拟局域网(VLAN)将局域网内的设备逻辑地(而不是物理地)划分成多个网段。</p>
<h4 id="VLAN的分类方式"><a href="#VLAN的分类方式" class="headerlink" title="VLAN的分类方式"></a>VLAN的分类方式</h4><ul>
<li>基于端口</li>
<li>基于MAC</li>
<li>基于网络层</li>
<li>基于IP组播</li>
</ul>
<h3 id="大型路由交换网络"><a href="#大型路由交换网络" class="headerlink" title="大型路由交换网络"></a>大型路由交换网络</h3><p><strong>一次路由，多次交换 </strong></p>
]]></content>
      <tags>
        <tag>复习计算机网络啦！</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2021/11/12/Git/</url>
    <content><![CDATA[<h1 id="The-introduction-of-Git"><a href="#The-introduction-of-Git" class="headerlink" title="The introduction of Git"></a>The introduction of Git</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>要把文档还原到<strong>编辑前</strong>的状态，就需要提前备份且做好命名工作，否则就会乱了套。但每次都要事先复制，而且命名也无法体现修改内容，容易出错。</p>
<p>若是共享文档，还应该加上编辑者的名字。而且，若是多个人同时编辑，后来者会覆盖掉前一个人的编辑内容。</p>
<h2 id="Advantage"><a href="#Advantage" class="headerlink" title="Advantage"></a>Advantage</h2><p>使用Git进行分布式版本管理，可以解决以上问题。</p>
<p>Git可以在任何时间点，把文档的状态作为更新记录保存起来。因此可以把编辑过的文档复原到以前的状态，也可以显示编辑前后的内容差差异。</p>
<p>而且，编辑旧文件后，试图覆盖新的文件的时候（即上传文件到服务器时），系统会发出警告，因此可以避免在无意中覆盖他人的编辑内容。</p>
<h2 id="Premise"><a href="#Premise" class="headerlink" title="Premise"></a>Premise</h2><h3 id="数据库-Repository"><a href="#数据库-Repository" class="headerlink" title="数据库(Repository)"></a>数据库(Repository)</h3><p>数据库是记录文件或目录状态的地方，存储着内容修改的历史记录。在数据库的管理下，把文件和目录修改的历史记录放在对应的目录下。</p>
<p>分为<strong>远程数据库</strong>和<strong>本地数据库</strong>两种：</p>
<p>本地数据库：为了方便用户个人使用，在自己的机器上配置的数据库。</p>
<p>远程数据库：配有给专用的服务器，为了多人共享而建立的数据库。</p>
<h3 id="Submit"><a href="#Submit" class="headerlink" title="Submit"></a>Submit</h3><p>若要把文件或目录的添加和变更保存到数据库，就需要进行提交。</p>
<p>执行提交后，数据库中会生成上次提交的状态与当前状态的差异记录（也叫revision)。</p>
<p>提交是以时间顺序排列状态被保存到数据库中的。凭借该提交和最新的文件状态，就可以知道过去的修改记录以及内容。</p>
<p>不同类型的修改（如bug的修复和功能的添加)要尽量分开提交，方便以后从历史记录中查找特定的修改内容。用心填写提交时的修改信息，方便别人和自己理解。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Git的标准注解</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一行：提交修改内容的摘要</td>
</tr>
<tr>
<td>第二行：空行</td>
</tr>
<tr>
<td>第三行：修改的理由</td>
</tr>
</tbody>
</table>
</div>
<h3 id="工作树和索引"><a href="#工作树和索引" class="headerlink" title="工作树和索引"></a>工作树和索引</h3><p>在Git管理下，大家实际操作的目录被称为工作树。</p>
<p>在数据库和工作树之间有索引，索引是为了向数据库提交做准备的区域。</p>
<p><strong>工具树</strong> ——- <em>注册</em> ——- <strong>索引</strong> ——-<em>提交</em> ——- <strong>数据库</strong></p>
<p>没有加入索引的档案不能被提交。</p>
<p>Git在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库。因此，要提交文件，首先需要被文件加入索引区域中。这样，可以避免不必要的提交，还可以将文件修改内容的一部分加入索引区域提交。</p>
<h3 id="共享数据库"><a href="#共享数据库" class="headerlink" title="共享数据库"></a>共享数据库</h3><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>为了将本地数据库的修改记录共享到远程数据库，必须上传本地数据库中存储的修改记录。</p>
<p>为此，需要在Git执行推送(Push)操作。</p>
<p>执行Push后，本地的修改记录会被上传到远程数据库。所以远程数据库的修改记录就会和本地的数据库修改记录保持同步。</p>
<h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><p>进行克隆(Clone)操作就可以复制远程数据库。</p>
<p>执行克隆后，远程数据库的全部内容都会被下载，包括本地数据库的变更履历。之后就可以像原始数据库一样进行查看记录或其它操作。</p>
<h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><p>若是共享的远程数据库由多人共同作业，那么作业完毕后，所有人都要把修改推送到远程数据库。然后，自己的本地数据库也需要更新其他人推送的变更内容。</p>
<p>进行拉取(pull)操作就可以把远程数据库的内容更新到本地数据库。</p>
<p>进行拉取(pull)操作，就是从远程数据库下载最近的变更日志，并覆盖自己本地数据库的相关内容。相当于是下载。</p>
<h3 id="共享数据库常用操作"><a href="#共享数据库常用操作" class="headerlink" title="共享数据库常用操作"></a>共享数据库常用操作</h3><h4 id="取别名"><a href="#取别名" class="headerlink" title="取别名"></a>取别名</h4><p>$ git remote add <name> <url></p>
<p>如：$ git remote add origin <a href="https://github.com/Phoenix-Nrvn/Ming.git">https://github.com/Phoenix-Nrvn/Ming.git</a></p>
<h4 id="push修改内容"><a href="#push修改内容" class="headerlink" title="push修改内容"></a>push修改内容</h4><p>$ git push <repository> <refspec>…</p>
<p>如：$ git push -u origin master</p>
<p>可以向远程数据库”origin”进行推送。当执行命令时，如果指定了-u选项，那么下一次推送时，就可以省略分支名称。但是，首次运行指令，向空的远程数据库推送时，必须指定远程数据库名称和分支名称。</p>
<h4 id="克隆-1"><a href="#克隆-1" class="headerlink" title="克隆"></a>克隆</h4><p>$ git clone <repository> <directory></p>
<p>将仓库复制到本地指定的文件夹</p>
<h4 id="提交更改"><a href="#提交更改" class="headerlink" title="提交更改"></a>提交更改</h4><p>$ git add sample.txt(更改信息后，重新提交sample)</p>
<p>$ git commit -m “添加add的说明”</p>
<p>$ git push</p>
<h4 id="拉取-1"><a href="#拉取-1" class="headerlink" title="拉取"></a>拉取</h4><p>$ git pull <repository> <refspec>…</p>
<p>$ git pull origin(仓库名) master(分支名)</p>
<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p>$ git log</p>
<h4 id="合并记录"><a href="#合并记录" class="headerlink" title="合并记录"></a>合并记录</h4><p>进行一次pull之后，在进行下一次push之前，如果有其他人对远程数据库进行了更改，那么在对其进行pull之前，所有的push都会被拒绝，即防止他人的push被覆盖。</p>
<p>在这种情况下，需要读取他人push的变更并进行合并操作。一般而言，合并时，Git会自动合并已有的变更点。</p>
<p>若更改的是同一个地方，那么git无法确定选用的内容，即需要手动修改以进行手动合并。</p>
]]></content>
      <tags>
        <tag>It&#39;s time to begin git!</tag>
      </tags>
  </entry>
  <entry>
    <title>GC</title>
    <url>/2021/11/15/GC/</url>
    <content><![CDATA[<h1 id="构造器与垃圾收集器"><a href="#构造器与垃圾收集器" class="headerlink" title="构造器与垃圾收集器"></a>构造器与垃圾收集器</h1><p>It is time to talk about death!</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Like people， 对象也有生有死。如果你要编写Java程序，就必须创建对象，也早晚会将对象释放掉，不然就会出现内存不足的问题。其实，就你的操作而言，并不是亲自消灭对象，你只是声明了放弃。一旦对象被放弃，那么冷血无情的垃圾收集器(GC)就会将他蒸发掉，回收其所占用的内存空间。</p>
<h2 id="开端"><a href="#开端" class="headerlink" title="开端"></a>开端</h2><h3 id="栈与堆：生存空间"><a href="#栈与堆：生存空间" class="headerlink" title="栈与堆：生存空间"></a>栈与堆：生存空间</h3><p>在Java中，程序员只关心两个区域的空间：堆(heap)和栈(stack)。二者，分别是对象的生存空间和方法调用及部分变量的生存空间。</p>
<p>所有的对象都存活在可以进行垃圾回收的堆上，而具体变量的生存空间取决于其本身是实例变量还是局部变量。后者又称为栈变量，明确保存在栈上。</p>
<blockquote>
<p>tips：</p>
<p><strong>实例变量</strong>：是被声明在类而不是方法里面。他们代表每个独立对象的“字段”(每个实例都能有不同的值)。实例变量存在于所属的对象中。(如每个Duck都可以有一个不同的size)</p>
<p><strong>局部变量</strong>：局部变量和方法的参数都是被声明在方法中。他们是暂时的，且生命周期只限于方法被放在栈上的这段期间(也就是方法调用至执行完毕为止)。</p>
</blockquote>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>当你调用一个方法时，该方法会被放在<strong>调用栈的栈顶</strong>。实际上被堆上栈的是堆栈块，它带有方法的状态，包括执行到<em>哪一行程序</em>以及所有的<em>局部变量的值</em>。(若foo中调用了bar，那么bar会放在foo的顶上)</p>
<p>当一个方法执行完成，那么他的堆栈块就会被释放掉。</p>
<p>若在方法中创建了非primitive的变量(其只是对象的引用变量，而不是对象本身)，那么不管对象是否声明或创建，如果局部变量是对对象的引用，只有该引用变量会在栈上，而对象会在堆上。</p>
<p><img src="https://s2.loli.net/2021/12/22/qRVZxtvmHXEc14D.png" alt="image-02"></p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>对象是存放在堆上的。</p>
<p>实例变量存在于对象所属的堆空间上。</p>
<p>如果实例变量是primitive主数据类型的，则Java会留下其数据类型大小的空间。</p>
<p>若实例变量是一个带有对象引用的变量，那么Java会在类中留出一个引用变量的空间，而不是对象本身所占有的空间。而该引用变量所引用的对象，会在堆上被另外分配空间。即此时，引用和对象都是在堆上。</p>
<p><img src="https://s2.loli.net/2021/12/22/7ZdbjieCXWFo3kR.png" alt="image-03"></p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>声明对象和赋值有3个步骤：声明引用变量、创建对象、连接对象和引用(声明、创建和赋值)。</p>
<p>构造函数卡看起来像方法，感觉上也很像方法，但它并不是方法。它带有new的时候会执行的程序代码，也就是新建一个对象的时候会执行。</p>
<p>构造函数的一项关键特征，即其会在对象被赋值给引用之前就执行。可以在对象被使用之前，介入。</p>
<h4 id="About-super"><a href="#About-super" class="headerlink" title="About super( )"></a>About super( )</h4><p>在创建对象时，父类的构造方法也会被执行。在构造函数中，用<strong>super</strong>来调用父类的构造函数，且这条语句，即<strong>super( )一定位于子类构造函数的第一句</strong>。要记得完整的对象需要也是完整的父类核心。就算Animal上的有些变量Hippo不会用到，但Hippo有可能会有某些继承下来的方法必须读取Animal的实例变量。</p>
<p>构造函数在执行的时候，第一件事是去执行它父类的构造函数，这会连锁反应，一直到Object这个类为止。这样的过程被称作构造函数链。</p>
<p><img src="https://s2.loli.net/2021/12/22/JAijMRaoUqPZIKY.png" alt="image-07"></p>
<p>步骤：</p>
<ol>
<li>执行Hippo的构造函数，其进入最上方的堆栈块。</li>
<li>Hippo的构造函数中，引用了Animal的构造函数，故而父类的构造函数此时被放置在堆栈块顶。</li>
<li>Object的构造函数，由于被Animal的构造函数所引用，此时进入堆栈块最上方。</li>
<li>Object构造函数执行完毕，则弹出堆栈块，则依次是Animal的，Hippo的。</li>
<li>即，Hippo的构造函数最早进入堆栈，却最后弹出。</li>
</ol>
<blockquote>
<p>tips：</p>
<p>父类的构造函数调用super( )，一定要在子类的构造函数的第一句。因为父类与子类的关系，就类似于父母与孩子。父类的对象，一定要在子类的对象开始开始构造之前成型。因为在子类构造过程中，可能会动用从父类中继承下来的东西。所以，一定要在子类构造之前，完成父类的构造函数。</p>
</blockquote>
<h4 id="About-this"><a href="#About-this" class="headerlink" title="About this( )"></a>About this( )</h4><p>另外，如果有某个重载版的构造函数除了不能处理不同类型的参数之外，可以进行其余包括实例变量优化在内的一切工作。而且，为了避免维护的不便利性，不希望相同的代码出现在每一个构造函数中。那么，可以考虑让其余所有的构造函数都先调用该构造函数。即，this( )或this(String)等。</p>
<p>但，需要注意，<strong>this( )必须出现在调用者的第一个语句</strong>，那么这，势必会与super( )的位置产生冲突，故而，有：<strong>super( )和this( )不能同时使用</strong>。</p>
<h2 id="转合"><a href="#转合" class="headerlink" title="转合"></a>转合</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对象的生命周期取决于引用到它的“引用”，如果引用变量还活着，那么对象就继续活在堆上。如果引用死了，对象就随之而去。见下方“引用变量”。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量的生命周期取决于其类型。</p>
<h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><ul>
<li><p>随方法的调用而产生，随方法的弹出堆栈块而结束。</p>
</li>
<li><p>范围只限于声明它的方法中。</p>
</li>
<li>若声明它的方法在调用了其他方法，那么该局部变量的状态会被保存，但是不再起作用。</li>
<li>不能被使用，除非声明它的方法正在执行。</li>
</ul>
<h5 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h5><ul>
<li>属于对象，其寿命于对象相同。</li>
<li>若对象存在，则实例变量也存活在堆上。</li>
</ul>
<h5 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h5><ul>
<li><p>引用变量也只能处于它的范围中才能被引用。也就是说，除非引用变量是在它的范围中，不然就不能使用对象的遥控器。</p>
</li>
<li><p>如果有活着的引用，对象也就活着。如果某个对象的引用已经不在它的范围内，但此引用还是活着的，则此对象就会继续活在堆上，</p>
</li>
<li><p>如果对对象的唯一引用死了，对象就会从堆中被踢开，引用变量会跟堆栈块一起解散，因此被踢开的对象也就正式声明出局。</p>
<p>释放引用变量的方法：</p>
<ul>
<li><p>将其放在方法中</p>
</li>
<li><p>将其重新赋值给别的对象</p>
</li>
<li>将其赋值为NULL</li>
</ul>
</li>
</ul>
<p><strong>如果对象没有引用，那么对象的存在毫无意义，不过是白白浪费空间罢了。</strong></p>
<p>一旦对象失去了它的引用，即其就此无法取得了，那么GC(垃圾收集器)就会知道该如何处理。</p>
]]></content>
      <tags>
        <tag>Talkng about GC</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2021/12/17/JDBC/</url>
    <content><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JDBC(Java DataBase Connectivity)是Java程序操作数据库的API，<strong>是Java操作数据库的规范</strong>，由一组<strong>Java语言编写的类和接口组成</strong>，它对数据库的操作提供基本方法，但对于数据库的细节操作由数据库厂商实现，使用JDBC操作数据库，<strong>需要数据库厂商提供数据库的驱动程序</strong>。</p>
<p><img src="https://s2.loli.net/2021/12/22/PaYeSMCIfRs6H3o.png" alt="image-20211217224940532"></p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li><h3 id="注册数据库驱动"><a href="#注册数据库驱动" class="headerlink" title="注册数据库驱动"></a>注册数据库驱动</h3><p>将数据库厂商提供的数据库驱动类注册到JDBC的驱动管理器中。</p>
<p><strong><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></strong></p>
<p><strong>Class的forName( )方法的作用是将指定字符串名的类加载到JVM中，实例中调用该方法来加载数据库驱动，在加载后，数据库驱动程序会把驱动类自动注册到驱动管理器中。</strong></p>
</li>
<li><h3 id="构建数据库连接URL"><a href="#构建数据库连接URL" class="headerlink" title="构建数据库连接URL"></a>构建数据库连接URL</h3><p>基本格式，即”JDBC协议+IP地址或域名+端口+数据库名称”。</p>
<p><strong><code>MySQL: &quot;jdbc:mysql://localhost:3306/db_database10&quot;;</code></strong></p>
<p><code>SQL Server: &quot;jdbc:sqlserver://localhost:1433;databaseName=db_database10&quot;;</code></p>
</li>
<li><h3 id="获取Connection对象"><a href="#获取Connection对象" class="headerlink" title="获取Connection对象"></a>获取Connection对象</h3><p>Connection对象是JDBC封装的数据库连接对象，语法：</p>
<p><strong><code>DriverManager.getConnection(url, username, password);</code></strong></p>
<p>Connection对象的获取需要用到DriverManager对象，DriverManager的getConnection( )</p>
</li>
</ol>
<p>方法通过数据库连接URL、数据库用户名及数据库密码创建Connection对象。</p>
<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line">   <span class="type">String</span> <span class="variable">Driver</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>; </span><br><span class="line">   Class.forName(Driver);<span class="comment">//加载数据库驱动，注册到驱动管理器</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db_database10&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;654321&quot;</span>;</span><br><span class="line">   <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(URL, userName, password);<span class="comment">//创建数据库连接</span></span><br><span class="line">   <span class="keyword">if</span>(conn != <span class="literal">null</span>) &#123;<span class="comment">//判断数据库连接是否为空</span></span><br><span class="line">   out.println(<span class="string">&quot;数据库连接成功!&quot;</span>);</span><br><span class="line">   conn.close()</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   out.println(<span class="string">&quot;数据库连接失败! &quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(ClassNotFoundException cn) &#123;</span><br><span class="line">  cn.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span>(SQLException se) &#123;</span><br><span class="line">se.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="Connection-接口"><a href="#Connection-接口" class="headerlink" title="Connection 接口"></a>Connection 接口</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Connection接口位于java.sql包中，是与特定数据库的连接会话，只有获得特定数据库的连接对象，才能访问数据库、v奥做数据库中的数据表、视图和存储过程等。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="void-close-throws-SQLException"><a href="#void-close-throws-SQLException" class="headerlink" title="void close( ) throws SQLException"></a>void close( ) throws SQLException</h5><p>立即释放此Connection对象的数据库连接占用的JDBC资源。在操作数据库后，应立即调用此方法。</p>
<h5 id="Statement-createStatement-throws-SQLException"><a href="#Statement-createStatement-throws-SQLException" class="headerlink" title="Statement createStatement( ) throws SQLException"></a>Statement createStatement( ) throws SQLException</h5><p>创建一个Statement对象来将SQL语句发送到数据库，此方法返回Statement对象。</p>
<h3 id="DriverManager-类"><a href="#DriverManager-类" class="headerlink" title="DriverManager 类"></a>DriverManager 类</h3><p>使用JDBC操作数据库，需要使用数据库厂商提供的驱动。该类主要作用于用户和驱动程序之间，管理数据库厂商提供的驱动程序，并建立应用程序与数据库之间的连接。<strong>此类的getConnection(String url, String user, String password) throws SQLException根据指定的数据库连接url等，建立数据库连接的Connection对象。</strong></p>
<h3 id="Statement接口"><a href="#Statement接口" class="headerlink" title="Statement接口"></a>Statement接口</h3><p>在创建了数据库连接之后，就可以通过程序来调用SQL语句对数据库进行操作，<strong>而该接口就提供了执行语句和获取查询结果的基本方法</strong>。</p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>boolean execute(String sql) throws SQLException执行指定的SQL语句，如果SQL语句返回结果，此方法返回true，否则返回false。</li>
<li>int executeQuery(String sql) throws SQLException执行SQL语句中的DML类型(insert\update\delete)的SQL语句，返回影响的行数。</li>
<li>ResultSet executeQuery(String sql) throws SQLException执行查询类型的SQL语句，返回查询所获取的结果集ResultSet对象。</li>
</ul>
<h3 id="PreparedStatement接口"><a href="#PreparedStatement接口" class="headerlink" title="PreparedStatement接口"></a>PreparedStatement接口</h3><p>继承于Statement接口，拥有Statement接口中的方法，而且针对带有参数的SQL语句的执行操作进行了拓展。</p>
<h4 id="与上区别"><a href="#与上区别" class="headerlink" title="与上区别"></a>与上区别</h4><ul>
<li><p><strong>应用于PreparedStatement接口中的SQL语句，可以使用占位符”?”来代替SQL语句中的参数，然后再对其进行赋值。</strong></p>
</li>
<li><p>会先初始化SQL，先把这个SQL提交到数据库进行预处理，多次使用可提高效率；createStatement不会初始化，没有预处理，每次都是从0开始执行SQL。</p>
</li>
<li>PreparedStatement是预编译的，对于批量处理可以大大提高效率，也叫JDBC存储过程。当在对数据库进行一次性存取的时候，用createStatement对象进行。</li>
</ul>
<h3 id="ResultSet接口"><a href="#ResultSet接口" class="headerlink" title="ResultSet接口"></a>ResultSet接口</h3><p>在JDBC中使用Resultset对象来接收查询结果集。<strong>ResultSet包含了符合SQL语句的所有行</strong>。zhenduiJava中的数据类型，提供了Getxxx的方法，可以获得每一行的数据。</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul>
<li><p><strong>==其中数据其实放在ResultSet结果集的中间部分，第一行和最后一行都是空的。==</strong></p>
</li>
<li><p><strong>默认情况下，ResultSet的光标位置在第一行数据之前，故在第一次获取数据时就需要移动光标位置。</strong></p>
</li>
</ul>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p><strong>INSERT语句</strong>，语句中的参数可以使用占位符“？”代替，然后通过PreparedStatement对其赋值并执行SQL</p>
<p><code>String sql=&quot;INSERT INTO tb_account(username, password) VALUES (?,?)&quot;;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Config config)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into category values(null,?,?)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DBUtil.getConnection();</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> c.prepareStatement(sql);</span><br><span class="line">            ps.setString(<span class="number">1</span>, config.key);</span><br><span class="line">            ps.setString(<span class="number">2</span>, config.value);</span><br><span class="line">            ps.execute();</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.getGeneratedKeys();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line">                config.id = id;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DBUtil.getConnection();</span><br><span class="line">            <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from category where id = &quot;</span> + id ;</span><br><span class="line">            s.execute(sql);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><em>在AddBook.jsp页面中，首先通过&lt; jsp:useBean &gt;实例化JavaBean对象Book，并通过&lt; jsp:setProperty &gt;对Book对象中的属性赋值，在构建了图书对象后通过JDBC技术，将其写入数据库。</em></p>
<p><strong>&lt; jsp:setProperty &gt;标签的property属性的值可以设置为”<em>“，它的作用是将与表单中同名称的属性值赋给JavaBean对象中的同名属性(\</em>为快速赋值)。</strong></p>
<p><strong>使用PreparedStatement对象给SQL语句的占位符参数赋值，==其参数的下标值不是0，而是1==，与数组的下标有所区别。</strong></p>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p><strong>SELECT语句</strong>，使用JDBC查询数据需要通过一个ResultSet对象来装载查询结果集，从数据表中所查询到的数据都放置在这个集合中。</p>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p><strong>Update语句</strong></p>
<h3 id="删除语句"><a href="#删除语句" class="headerlink" title="删除语句"></a>删除语句</h3><p><strong>DELETE语句</strong></p>
<h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>为了解决数据库频繁连接、关闭操作的问题，JDBC的批处理提供很好的解决方案，批量将SQL语句一次性发送到数据库中进行执行。</p>
<p>代码待补充……</p>
]]></content>
      <tags>
        <tag>Somthing of JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_Ending</title>
    <url>/2021/12/26/Java-Ending/</url>
    <content><![CDATA[<h1 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h1><p><img src="https://s2.loli.net/2021/12/26/AcuBF8l3NnZyqLT.png" alt="image-20211226201329697"></p>
<h2 id="部署的三种选择："><a href="#部署的三种选择：" class="headerlink" title="部署的三种选择："></a>部署的三种选择：</h2><h3 id="本机"><a href="#本机" class="headerlink" title="本机"></a>本机</h3><p>整个程序都在用户的计算机上以独立、可携的GUI执行，并以可执行的Jar来部署。</p>
<h4 id="把程序包进JAR"><a href="#把程序包进JAR" class="headerlink" title="把程序包进JAR"></a>把程序包进JAR</h4><p>JAR就是Java ARchive。这种文件是个pkzip格式的文件，能把一组类文件包装起来，所以交付时只需要一个用jar整理的JAR文件。</p>
<p>问题是用户拿JAR怎么办？</p>
<p>要创建出可执行的JAR！</p>
<p><strong>可执行的JAR代表用户不需要把文件抽出来就能运行。程序可以在类文件保存在JAR的情况下执行。秘诀在于创建出manifest文件，它会带有JAR的信息，告诉Java虚拟机那个类中含有main( )这个方法。</strong></p>
<p><img src="https://s2.loli.net/2021/12/26/k2BsEUqT91JSjAF.png" alt="image-20211226202235036"></p>
<p><img src="https://s2.loli.net/2021/12/26/sGPyLlScK4pIjZU.png" alt="image-20211226202446339"></p>
<p><img src="https://s2.loli.net/2021/12/26/iuhzUtRKg6Wwl32.png" alt="image-20211226202747131"></p>
<h4 id="防止包命名冲突"><a href="#防止包命名冲突" class="headerlink" title="防止包命名冲突"></a>防止包命名冲突</h4><p>Sun建议的命名规则能够大幅降低冲突的可能性——加上你所取得的域名称。即反向使用domain</p>
<p><img src="https://s2.loli.net/2021/12/26/Evz9lf7GkeOdiPZ.png" alt="image-20211226203047748"></p>
<p><img src="https://s2.loli.net/2021/12/26/LbZEgFcA3N1yj9D.png" alt="image-20211226203530158"></p>
<p><img src="https://s2.loli.net/2021/12/26/oxzSFOIr5aswMJ1.png" alt="image-20211226203551529"></p>
<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><p><img src="https://s2.loli.net/2021/12/26/VGsw5lEaxBMZOeK.png" alt="image-20211226203617583"></p>
<h3 id="两者的组合"><a href="#两者的组合" class="headerlink" title="两者的组合"></a>两者的组合</h3><p>应用程序被分散成用户本地系统运行的客户端，连接到执行应用程序服务的服务器部分。</p>
<h3 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h3><p>整个应用程序都在服务器端执行，客户端通过非Java形式，可能是浏览器的装置来存取。 </p>
]]></content>
      <tags>
        <tag>Here comes the end of Head First of Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Head_First_设计模式</title>
    <url>/2022/02/22/Head-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Chapter-1-设计模式入门"><a href="#Chapter-1-设计模式入门" class="headerlink" title="Chapter 1 设计模式入门"></a>Chapter 1 设计模式入门</h1><p>第一个设计原则</p>
<p>找出应用中可能需要变化之处，把它们独立起来，不要和那些不需要变化的代码混在一起。</p>
]]></content>
      <tags>
        <tag>Head First 设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Learing 2</title>
    <url>/2021/05/31/Java-Learing-2/</url>
    <content><![CDATA[<blockquote>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="一、关于Java中的数据类型"><a href="#一、关于Java中的数据类型" class="headerlink" title="一、关于Java中的数据类型:"></a>一、关于Java中的数据类型:</h2><h4 id="1-简单数据类型，即基本数据类型，有固定的存储长度"><a href="#1-简单数据类型，即基本数据类型，有固定的存储长度" class="headerlink" title="1.简单数据类型，即基本数据类型，有固定的存储长度"></a>1.简单数据类型，即基本数据类型，有固定的存储长度</h4><h6 id="包括整数类型，浮点类型，字符类型，布尔类型"><a href="#包括整数类型，浮点类型，字符类型，布尔类型" class="headerlink" title="包括整数类型，浮点类型，字符类型，布尔类型"></a>包括整数类型，浮点类型，字符类型，布尔类型</h6><h4 id="2-复杂数据类型，又名引用类型"><a href="#2-复杂数据类型，又名引用类型" class="headerlink" title="2.复杂数据类型，又名引用类型"></a>2.复杂数据类型，又名引用类型</h4><h6 id="包括数组，类，接口-interface-，其存储空间取决于组成内容-由几个基本数据类型，或几个复合数据类型组成"><a href="#包括数组，类，接口-interface-，其存储空间取决于组成内容-由几个基本数据类型，或几个复合数据类型组成" class="headerlink" title="包括数组，类，接口(interface)，其存储空间取决于组成内容(由几个基本数据类型，或几个复合数据类型组成)"></a>包括数组，类，接口(interface)，其存储空间取决于组成内容(由几个基本数据类型，或几个复合数据类型组成)</h6><hr>
<h2 id="二、数据类型之间的转换"><a href="#二、数据类型之间的转换" class="headerlink" title="二、数据类型之间的转换"></a>二、数据类型之间的转换</h2><h5 id="byte-1-→short-2-→char-2-→int-4-→long-8-→float-4-→double-8"><a href="#byte-1-→short-2-→char-2-→int-4-→long-8-→float-4-→double-8" class="headerlink" title="byte(1)→short(2)→char(2)→int(4)→long(8)→float(4)→double(8)"></a>byte(1)→short(2)→char(2)→int(4)→long(8)→float(4)→double(8)</h5><p><strong><em>特别注意，布尔类型(boolean)(只包括true,false)不与其他类型进行转换</em></strong></p>
<p><strong>在Java中，所有数据类型所占字节数量与平台无关。</strong></p>
<p><strong>此外，Java没有任何无符号的(unsigned)形式的int, long, short或byte类型。</strong></p>
</blockquote>
<hr>
<hr>
<blockquote>
<h1 id="amp-amp-输入输出"><a href="#amp-amp-输入输出" class="headerlink" title="&amp;&amp;输入输出"></a>&amp;&amp;输入输出</h1><h2 id="一、标准输入流输入数据"><a href="#一、标准输入流输入数据" class="headerlink" title="一、标准输入流输入数据:"></a>一、标准输入流输入数据:</h2><p>  <code>byte System.in.read()</code>(即所获取数据为字节类型)</p>
<p>字符串输入:</p>
</blockquote>
<p><code>BufferedReader in = new BufferedReader(new InputStreamReader(System.in))(经过对System.in的层层修饰)</code></p>
<p><code>String s = in.readLine();</code></p>
<blockquote>
<p>  常用:</p>
<p><code>Scanner  sc = new Scanner(System.in);</code></p>
</blockquote>
<p><code>String sr = sc.nextLine();</code></p>
<p><code>int a = sc.nextInt();</code></p>
<p><code>String s = sc.next();</code></p>
<blockquote>
<p>  <code>swing对话框:</code></p>
</blockquote>
<p><code>String s = JOptionPane.showInputDialog(Message)</code></p>
<p><code>int i = Integer.parseInt(s);</code></p>
<blockquote>
<h2 id="二、输出数据"><a href="#二、输出数据" class="headerlink" title="二、输出数据:"></a>二、输出数据:</h2></blockquote>
<ul>
<li><p><code>System.out.println(x);//输出后带换行</code></p>
</li>
<li><p><code>System.out.print(x);//输出后无换行</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（以上两者可用String.format(&quot;%.2f&quot;,x)替换x，以控制x输出格式）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>System.out.printf()(可加输出格式控制，类似C语言中printf)</code></li>
</ul>
]]></content>
      <tags>
        <tag>数据类型与输入输出</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Learning</title>
    <url>/2021/05/29/Java-Learing/</url>
    <content><![CDATA[<p>It’s time to begin the learning of Java!</p>
<blockquote>
<p>​    关于Java的命令行编译运行方式：</p>
<p>​        1.利用记事本/Notepad++建立一个文件，之后重命名为.java文件，<strong><em>Win + R</em></strong>，输入cmd，打开命令行窗口，转换至java文件储存的文件夹内。如：在E盘建立Test.java文件，则在命令行输入E:，转至E盘,转至子文件，则输入<em>cd 子文件名</em></p>
<p>​        2.输入<strong><em>javac Test.java</em>（中有空格，拓展名.java一定要加上）</strong>编译.java文件，此步会生成Test.class这个字节码文件（.java文件中类的数量决定了字节码文件的数量）</p>
<p>​        3.在命令行窗口输入<strong><em>java Test</em>（中有空格，注意不加拓展名.class)</strong>运行字节码文件，即可得运行结果。</p>
<p>​        <em>注：编译过程使用javac.exe（Java编译器），故而编译时要输入指令javac；运行过程使用java.exe（虚拟机）。</em></p>
<p>在Java中，所有数据类型所占字节数量与平台无关。</p>
<p>此外，Java没有任何无符号的(unsigned)形式的int, long, short或byte类型。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>plus</title>
    <url>/2021/10/08/Java-Learning-3%20plus/</url>
    <content><![CDATA[<h1 id="ArrayList与一般数组"><a href="#ArrayList与一般数组" class="headerlink" title="ArrayList与一般数组"></a>ArrayList与一般数组</h1><p>​        相同点：</p>
<ul>
<li><p>二者都为对象，都保存在堆上</p>
</li>
<li><p>二者都可保存数据引用和primitive主数据类型</p>
</li>
<li><p>创建时指定类型</p>
<p>不同点：</p>
<p>| 对比 | 一般数组                                       | ArrayList                                                    |<br>| —— | ——————————————————————— | —————————————————————————————— |<br>| 创建 | 需要指定大小                                   | 只需创建出该类型对象即可，无需指定大小（在增加或删除时，自行调整大小） |<br>| 方法 | 并无方法可调用，最多使用如length这样的实例变量 | 建立的是一个类对象，可以使用“.”运算符来调用其方法            |<br>| 存放 | 必须指定位置，若下标溢出，执行会抛出异常       | 无需指定索引值，可使用add方法，让其自行管理大小              |<br>| 语法 | 可使用特殊语法[ ]来调用数组元素                | 普通对象，不可使用[ ]这样的特殊语法                          |</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Java API extension</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Learning 3</title>
    <url>/2021/06/04/Java-Learning-3/</url>
    <content><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="常见集合"><a href="#常见集合" class="headerlink" title="常见集合"></a>常见集合</h2><p>ArrayList是最常用的API，但不是唯一的。</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p> 以有序的状态保持并可防止重复。</p>
<p>但是如果没有需要让清单保持有序的状态，TreeSet的成本会比想付出的还要多—-每当插入新项目，都要花时间找到合适的位置，而ArrayList只要把项目放在最后面就好。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>可用成对的name/value来保存与取出</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>针对经常插入或删除中间元素所涉及的高效率集合。（实际上ArrayList还是比较实用）</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>防止重复的集合，可快速地找寻相符的元素。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>类似HashMap，但可记住元素插入的顺序，也可以设定成按照元素上次存取的先后来排序。</p>
<p><img src="https://s2.loli.net/2021/12/26/RjgciyJoDFGkQIN.png" alt="image-20211226110456330"></p>
<h2 id="Perface"><a href="#Perface" class="headerlink" title="Perface"></a>Perface</h2><h3 id="Collections-sort"><a href="#Collections-sort" class="headerlink" title="Collections.sort( )"></a>Collections.sort( )</h3><p>鉴于ArrayList是最常用的集合，而且实现了List接口。恰巧，Collections这个类中存在sort( )方法，要用到List。所以多亏了多态机制，可以把ArrayList传给用到了List的方法。也就是说，可以使用Collections.sort( )方法来实现排序。</p>
<p>当歌曲的类型，由String变为Song时，可以明显发现编译器报错。也就是，ArrayList<String> 和 ArrayList<Song>之间的差异导致。</p>
<p><img src="https://s2.loli.net/2021/12/26/XJNW7FbSmytRw39.png" alt="image-20211226115014403"></p>
<h2 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h2><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><h4 id="泛型意味着更好的类型安全性。"><a href="#泛型意味着更好的类型安全性。" class="headerlink" title="泛型意味着更好的类型安全性。"></a>泛型意味着更好的类型安全性。</h4><p>几乎所有会以泛型写的程序都与处理集合有关。虽然泛型也可以用在其他地方，但它的<strong>主要目的还是让你能够写出有安全类型的集合</strong>。也就是，<strong>让编译器能够帮助防止把Dog加到一群Cat中。</strong></p>
<p>在泛型功能出现之前，编译器无法注意到加入集合中的东西是什么，因为所有的集合都写成处理Object类型，可以把任何东西放进ArrayList中，就类似于ArrayList<Object>。<strong>运用泛型，可以创建类型安全更好的集合</strong>，让问题尽可能在编译器就能抓到。</p>
<p><img src="https://s2.loli.net/2021/12/26/9Ph7AzNUo4eEMCm.png" alt="image-20211226120001237"></p>
<p><img src="https://s2.loli.net/2021/12/26/n6eZXf32TVu5sRK.png" alt="image-20211226120459538"></p>
<h4 id="泛型的本质为参数化类型，即程序中的数据类型被指定为一个参数E-Element-。"><a href="#泛型的本质为参数化类型，即程序中的数据类型被指定为一个参数E-Element-。" class="headerlink" title="泛型的本质为参数化类型，即程序中的数据类型被指定为一个参数E(Element)。"></a>泛型的本质为参数化类型，即程序中的数据类型被指定为一个参数E(Element)。</h4><p><strong>E代表用来创建与初始ArrayList的类型。</strong>在编译时，E会被指定的真正类型所取代(又称为类型参数)。这也是为何add( )这个方法无法加入与E所指定类型不兼容的引用的原因。若创建出ArrayList<Dog>, 则add( )会变成add(Dog o)。</p>
<p>其在定义时，不指明参数类型，在用时确定。</p>
<h3 id="运用泛型的方法"><a href="#运用泛型的方法" class="headerlink" title="运用泛型的方法"></a>运用泛型的方法</h3><p>泛型的类代表类的声明用到类型参数，泛型的方法代表方法的声明特征用到类型参数。</p>
<p>在方法中的类型参数有两种不同的运用方式。</p>
<h4 id="使用定义在类声明的类型参数"><a href="#使用定义在类声明的类型参数" class="headerlink" title="使用定义在类声明的类型参数"></a>使用定义在类声明的类型参数</h4><p><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;...&#123;</code></p>
<p><code>public boolean add(E o)</code> //只能在此使用E，因为已经被定义为类的一部分</p>
<p><code>&#125;</code></p>
<p><strong>当声明类的类型参数时，就可以把该类或接口类型用在任何地方。参数的类型声明基本上会以用来初始化类的类型来取代。</strong></p>
<h4 id="使用未定义在类声明的类型参数"><a href="#使用未定义在类声明的类型参数" class="headerlink" title="使用未定义在类声明的类型参数"></a>使用未定义在类声明的类型参数</h4><p><code>public &lt;T extends Animal&gt; void takeThing(ArrayList&lt;T&gt; list)</code></p>
<p><strong>如果类本身没有使用类型参数，可通过在一个不寻常但可行的位置上指定给方法—-在返回类型之前。这意味着T可以是”任何一种Animal”。</strong></p>
<p>附：</p>
<p><img src="https://s2.loli.net/2021/12/26/l7UROxS1a5siVTu.png" alt="image-20211226122852024"></p>
<h3 id="回到引出的那个问题："><a href="#回到引出的那个问题：" class="headerlink" title="回到引出的那个问题："></a>回到引出的那个问题：</h3><p><img src="https://s2.loli.net/2021/12/26/VPBtOAGQiLpyNm6.png" alt="image-20211226123237186"></p>
<p>也就是说，sort( )方法只能接受Comparable对象的list。而Song不是Comparable的子型，所以不能。</p>
<p>但是，根据String的说明：</p>
<p><code>public final class String extends Object implements Serializable, Comparable&lt;String&gt;, CharSequence...</code></p>
<p>也就是说，<strong>String没有继承过Comparable，只有实现，因为Comparable是个接口</strong>，那为什么会是extends？</p>
<h4 id="以泛型的观点来说，extend代表extend或implement。"><a href="#以泛型的观点来说，extend代表extend或implement。" class="headerlink" title="以泛型的观点来说，extend代表extend或implement。"></a>以泛型的观点来说，extend代表extend或implement。</h4><p><strong>对一个泛型而言，extends这个关键词代表“是一个……”，且不管接口或类都能使用。也就是说，适用于extends和implements。</strong></p>
<h4 id="SO"><a href="#SO" class="headerlink" title="SO"></a>SO</h4><p><strong>Song类必须实现Comparable！</strong></p>
<p>只有在这种情况下，才能把ArrayList<Song>传给sort( )方法，因为这个方法就是如此声明的。况且，也需要确定两个Song如何比较的大小。</p>
<p><img src="https://s2.loli.net/2021/12/26/sMv1TYhmF2oknrd.png" alt="image-20211226124605060"></p>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20211226124953490.png" alt="image-20211226124953490"></p>
<p>但是，如果想用多几种进行排序呢?</p>
<p>可以引出另一种sort( )方法—-取用Comparator参数。</p>
<h4 id="Another"><a href="#Another" class="headerlink" title="Another"></a>Another</h4><p>使用自制的Comparator，这是独立于所比较元素类型之外的——它是独立的类！因此，可以有各种不同的比较方法~~</p>
<p>取用Comparator版的sort( )方法会用Comparator而不是元素内置的CompareTo( )方法来比较顺序。也就是说，如果sort( )方法带有Comparator，就不会调用元素的CompareTo( )，而会去调用Comparator的Compare( )方法。</p>
<p><img src="https://s2.loli.net/2021/12/26/NHnioReGCWIEVJj.png" alt="image-20211226171420009"></p>
<h4 id="处理重复"><a href="#处理重复" class="headerlink" title="处理重复"></a>处理重复</h4><h5 id="LIST：对付顺序的好帮手"><a href="#LIST：对付顺序的好帮手" class="headerlink" title="LIST：对付顺序的好帮手"></a>LIST：对付顺序的好帮手</h5><p>一种知道索引位置的集合。</p>
<p>List直到某物在系列集合中的位置。可以有多个元素引用相同的对象。</p>
<h5 id="SET：注重独一无二的性质"><a href="#SET：注重独一无二的性质" class="headerlink" title="SET：注重独一无二的性质"></a>SET：注重独一无二的性质</h5><p>不允许重复的集合。</p>
<p>知道某物是否已经存在于集合中。不会有多个元素引用相同的对象。</p>
<h5 id="MAP：-用key来搜索的专家。"><a href="#MAP：-用key来搜索的专家。" class="headerlink" title="MAP： 用key来搜索的专家。"></a>MAP： 用key来搜索的专家。</h5><p>使用成对的键值和数据值。</p>
<p>Map会维护与key有关联的值。<strong>两个key可以引用相同的对象，但key不能重复</strong>，典型的key是String，但也可以是其他任何对象。</p>
<blockquote>
<p>泛型规则和限制：</p>
<ul>
<li>泛型的类型参数只能是类类型，不能是简单类型</li>
<li>泛型的参数类型可以有多个，如Map<K, V></li>
<li>泛型的参数类型可以使用extends语句，如<T extends M>，但此处的extends并非继承，而是类型限制，即在M范围内的T。</li>
<li>也可以使用通配符类型，即类似于&lt;? Extends M&gt;，是指在M范围内的某个类型，此处的?代表不定型。</li>
</ul>
</blockquote>
<h3 id="Collection-API"><a href="#Collection-API" class="headerlink" title="Collection API"></a>Collection API</h3><p><strong>接口Collection位于Collection API的最高层，定义了所有底层接口或类的公共方法。</strong></p>
<p><img src="https://s2.loli.net/2021/12/26/34MHN52sn7tSmUO.png" alt="image-20211226175620388"></p>
<p><img src="https://s2.loli.net/2021/12/26/4gLxYnumoHhwtPd.png" alt="image-20211226175744747"></p>
<p>所以，此处<strong>使用HashSet取代ArrayList</strong>。</p>
<h3 id="对象的相等"><a href="#对象的相等" class="headerlink" title="对象的相等"></a>对象的相等</h3><h4 id="引用相等性"><a href="#引用相等性" class="headerlink" title="引用相等性"></a>引用相等性</h4><p>堆上同一个对象的两个引用。</p>
<p>引用到堆上同一个对象的两个引用是相等的。如果对两个引用调用hashCode( )，会得到相同的结果。</p>
<blockquote>
<p>如果没有被覆盖的话，hashCode( )默认的行为会返回每个对象特有的序号(大部分Java版本是依据内存位置计算此序号，所以不会有相同的hashcode。)</p>
</blockquote>
<p><strong>要知道两个引用是否相等，可以使用==来比较变量上的字节组合</strong>。如果是相同的对象，字节组合也一样。</p>
<h4 id="对象相等性"><a href="#对象相等性" class="headerlink" title="对象相等性"></a>对象相等性</h4><p>堆上的不同两个对象在意义上是相同的。</p>
<p>如果你想要把两个不同的Song对象视为相等的,就必须覆盖过从Object继承下来的hashCode( )方法与equals()方法。就因为上面所说的内存计算问题, 所以你必须覆盖过hashCode( )才能确保两个对象有相同的hashcode, 也要确保以另一个对象为参数的equals( )调用会返回true。</p>
<p><img src="https://s2.loli.net/2021/12/26/rNl1MoT3asIdGPA.png" alt="image-20211226181219247"></p>
<p><img src="https://s2.loli.net/2021/12/26/ylYvh4RZu2q6CMI.png" alt="image-20211226181200357"></p>
<p><img src="https://s2.loli.net/2021/12/26/MFyzxri8KOEkcDW.png" alt="image-20211226181806418"></p>
<p><img src="https://s2.loli.net/2021/12/26/vMrlW1eN4mhXkwn.png" alt="image-20211226182244389"></p>
<p>API文件有对对象的状态制定出必须遵守的规则:</p>
<p>(1）如果两个对象相等,则hashcode必须也是相等的。</p>
<p>(2）如果两个对象相等, 对其中一个对象调用equals()必须返回true。也就是说,若a.equals(b).则b.equals(a).</p>
<p>(3）如果两个对象有相同的hashcode值, 它们也不一定是相等的。但若两个对象相等, 则hashcode值一定是相等的。</p>
<p>(4）若equals()被覆盖过，则hashCode()也必须被覆盖。</p>
<p>(5) hashCode()的默认行为是对在heap上的对象产生独特的值。如果你没有override过hashCode(),则该class的两个对象怎样都不会被认为是相同的。</p>
<p>(6)equals()的默认行为是执行==的比较。也就是说会去测试两个引用是否对上heap上同一个对象。如果equals()没有被覆盖过,两个对象永远都不会被视为相同的,因为不同的对象有不同的字节组合。</p>
<p><img src="https://s2.loli.net/2021/12/26/BSQdlC9kRIVxru1.png" alt="image-20211226182512343"></p>
<h4 id="Something-About-TreeSet"><a href="#Something-About-TreeSet" class="headerlink" title="Something About TreeSet"></a>Something About TreeSet</h4><p><img src="https://s2.loli.net/2021/12/26/gIQXAxSnyqZz5v2.png" alt="image-20211226182608504"></p>
<p><img src="https://s2.loli.net/2021/12/26/PkmZnsKwjTtXGaQ.png" alt="image-20211226185927531"></p>
<h4 id="1-Collection-接口"><a href="#1-Collection-接口" class="headerlink" title="1. Collection 接口"></a>1. Collection 接口</h4><h5 id="常用的方法："><a href="#常用的方法：" class="headerlink" title="常用的方法："></a>常用的方法：</h5><p>​    boolean add(E obj)</p>
<p>​    boolean isEmpty()</p>
<p>​    Iterator<E> iterator() : 获取手机的Iterator接口实例</p>
<p>​    Object[] toArray() : 将收集变为对象数组</p>
<h5 id="关于Iterator接口"><a href="#关于Iterator接口" class="headerlink" title="关于Iterator接口:"></a>关于Iterator接口:</h5><ol>
<li><p>boolean hasNext(): 是否存在下一个元素</p>
</li>
<li><p>Object next(): 返回要访问的下一个元素，若无，引发异常</p>
</li>
</ol>
<h4 id="2-Set-接口"><a href="#2-Set-接口" class="headerlink" title="2. Set 接口"></a>2. Set 接口</h4><p>特点：不含重复元素，且无序，其中的SortedSet接口用于描述按“自然顺序”组织元素的收集，即其中对象有序。</p>
<p>其判断集合中重复元素的标准为按对象值比较，即使用equals()方法。</p>
<p>迭代器：Iterator it = Set.iterator();</p>
<h4 id="3-List-接口"><a href="#3-List-接口" class="headerlink" title="3. List 接口"></a>3. List 接口</h4><p>特点：其中可含重复元素，且有序。包括ArrayList与LinkedList两个类。</p>
<p>常用方法：</p>
<p>​    void add(E e) : 在尾部添加元素</p>
<p>​    void add(int pos, E e) : 在指定位置添加元素</p>
<p>​    E get(int pos) : 返回指定位置的元素</p>
<p>​    E set(int pos, E e) : 更改指定位置的元素</p>
<p>​    E remove(int pos) : 删除指定位置的元素</p>
<p>ArrayList 与 LinkedList区别：</p>
<p>​    前者使用数组存储元素，可以实现快速访问元素；后者使用双向链表，可以实现快速插入，删除元素。</p>
<h4 id="4-Map-接口"><a href="#4-Map-接口" class="headerlink" title="4. Map 接口"></a>4. Map 接口</h4><h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><p>public Set<K> keySet(): 关键字的集合</p>
<p>public Collection<V> values() : 值的集合</p>
<p>public Set<Map.Entry<K, V> &gt;entrySet : 关键字和值的映射关系的集合</p>
<p>public V get(K key) : 获取关键字对应的值</p>
<p>public V put(K key, V val) : 加入新的映射；若已经存在，修改映射的值，返回原映射的值，否则，返回null</p>
<p>public V remove(Object key) : 删除关键字多对应的映射，返回值同上。</p>
<p>public boolean equals(Object obj) : 判断Map对象与参数对象是否等价，两个相同的Map，其映射关系集合应当一致</p>
<p>public boolean containsKey(Object key): 是否存在于关键值匹配的映射关系</p>
<p>public boolean containsValues(Object value) : 是否存在与键值匹配的映射关系</p>
<h6 id="另："><a href="#另：" class="headerlink" title="另："></a>另：</h6><p>​    <code>通过与Set接口的结合，可以实现由值取关键字。即首先将关键字通过keySet()提取出来进入Set s中，而后通过迭代器for(Iterator it = s.iterator();it.hasNext();),  匹配m.get(it.next()).equals(V value)或 for(T s : s) 遍历(T为Set中元素的数据类型），m.get(s).equals(V value)来查找值对应的关键字</code></p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在普通数组的情况下，Dogs[ ]可以调用Animals[ ]的方法，即可以将其作为参数传入以Animal为参数的方法中。</p>
<p>但在泛型中，这是不允许的。</p>
<p>吃个栗子：<img src="https://s2.loli.net/2021/12/26/MVXCheT5z6G8LQ3.png" alt="image-20211226192723304"></p>
<p>很显然的是，就普通数组而言，不可调用add方法，也就是说，不会出现这种添加情况，编译不会通过。但泛型中存在这种情况，如果允许Dogs[ ]传入，会导致在dog中混入一只cat，这显然不合理。</p>
<p>其实，数组也能进行相应的操作的哦。</p>
<p><strong>数组的类型是在运行期间检查的，但集合的类型检查只会发生在编译期间。</strong></p>
<p>这也就是为何数组这样操作，可以逃过编译(但运行的时候会出错)，而集合却不能。</p>
<p>如果把方法的参数设定为ArrayList<Animal>，那么Array<Cat>和Array<Dog>都不可用。</p>
<h3 id="万用字符"><a href="#万用字符" class="headerlink" title="万用字符"></a>万用字符</h3><p>这样设定方法的参数为ArrayList<Animal>时，就可以接收Animal子型参数了。</p>
<p><img src="https://s2.loli.net/2021/12/26/nwfPWjNJMEtukZ9.png" alt="image-20211226194114402"></p>
<p>但是，注意：</p>
<p><strong>在这种情况下，只能使用list中任何元素的方法，不能在list中新增元素!!!</strong></p>
<p>也就是说，可以操作集合元素，但不能新增集合元素。如此才能保障执行期间的安全性，因为编译器会阻止执行期的恐怖行动。</p>
<p><code>for(Animal a:animals) &#123;</code></p>
<p><code>a.eat();&#125; //可以的</code></p>
<p><code>for (Animal a:animals) &#123;</code> </p>
<p><code>a.add(new Cat());&#125;// 不可以！</code></p>
<p><img src="https://s2.loli.net/2021/12/26/HYxVAqajiUOR1cl.png" alt="image-20211226194715004"></p>
]]></content>
      <tags>
        <tag>Java Learning 3</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Learning-4</title>
    <url>/2021/08/27/Java-Learning-4/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">design</span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		EventQueue.invokeLater(() -&gt; <span class="comment">// 事件分派线程中的执行代码</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotHelloFrame</span>();</span><br><span class="line">			frame.setTitle(<span class="string">&quot;What you buy&quot;</span>);</span><br><span class="line">				frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">			frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotHelloFrame</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">NotHelloFrame</span><span class="params">()</span> &#123;</span><br><span class="line">		add(<span class="keyword">new</span> <span class="title class_">NotHelloComponent</span>());</span><br><span class="line">		pack();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotHelloComponent</span> <span class="keyword">extends</span> <span class="title class_">JComponent</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MESSAGE_X</span> <span class="operator">=</span> <span class="number">75</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MESSAGE_Y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_WIDTH</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_HEIGHT</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paintComponent</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">		g.drawString(<span class="string">&quot;What are you want?&quot;</span>, MESSAGE_X, MESSAGE_Y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Dimension <span class="title function_">getPreferredSize</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dimension</span>(DEFAULT_WIDTH, DEFAULT_HEIGHT);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>绘制图像框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Learning-5</title>
    <url>/2021/11/12/Java-Learning-5/</url>
    <content><![CDATA[<h1 id="Java中的继承"><a href="#Java中的继承" class="headerlink" title="Java中的继承"></a>Java中的继承</h1><h2 id="例：设计动物仿真程序的继承树"><a href="#例：设计动物仿真程序的继承树" class="headerlink" title="例：设计动物仿真程序的继承树"></a>例：设计动物仿真程序的继承树</h2><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li>找出具有共同属性和行为的对象</li>
<li>设计代表共同状态与行为的类</li>
<li>决定子列是否需要让某项行为(也就是方法的实现)有特定不同的运作方式</li>
<li>通过寻找使用共同行为的子类来找出更多抽象化的机会</li>
<li>完成类的继承层次</li>
</ol>
<h4 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h4><p>以Wolf类为例，其包括继承自Animal和Canine两类在内，一共四个方法。具体在调用对象引用的方法时，会调用到与该对象类型最接近的方法。换句话说，最低阶的会胜出！即，Java虚拟机会从继承树最底层(层次树的最下方)Wolf开始，若有符合Wolf版的方法，则直接进行调用。若无，则继续向上，去查找Animal中相应的方法，依此类推，直到找到为止。</p>
]]></content>
      <tags>
        <tag>Extends</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_Thread</title>
    <url>/2021/12/14/Java-Thread/</url>
    <content><![CDATA[<p>The beginning of thread.</p>
<p>Java 有多个线程但只有一种Thread类。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="Some-Basic-Concepts"><a href="#Some-Basic-Concepts" class="headerlink" title="Some Basic Concepts"></a>Some Basic Concepts</h2><p>线程是独立的线程，他代表独立的执行空间。</p>
<p>Thread是Java中用来表示线程的类，要建立线程就得创建Thread。</p>
<p>每一个Java应用程序会启动一个主线程—将main( )放在自己执行空间的最开始出。Java虚拟机会负责主线程的启动(如垃圾回收所需的系统用线程)。程序员要负责启动自己建立的线程。</p>
<h2 id="What-does-having-more-than-one-executing-space-symbolize"><a href="#What-does-having-more-than-one-executing-space-symbolize" class="headerlink" title="What does having more than one executing space symbolize?"></a>What does having more than one executing space symbolize?</h2><p>当有超过一个以上的执行空间时，看起来好像是有好几件事同时发生。但实际上，执行动作可以在执行空间中快速地来回切换。<strong>Java也只是个在底层操作系统上执行的进程</strong>。一旦轮到Java执行时，Java虚拟机会执行<strong>目前执行空间最上面的</strong>。</p>
<p>线程要记录的一项事务是<strong>目前线程执行空间做到哪里</strong>。</p>
<p>举个栗子：</p>
<p>Java虚拟机调用main( )主线程。</p>
<p>main( )中建立了一个Thread对象t，并启动了新线程t.start( )。则此时，堆上新增线程t.start( )，另起一执行空间，启动自建线程中的run( )，在新线程启动期间，main( )会暂停执行。</p>
<p>之后，会在主线程和用户自建线程之间来回切换，直到二者全部执行完毕。</p>
<h2 id="如何启动新的线程？"><a href="#如何启动新的线程？" class="headerlink" title="如何启动新的线程？"></a>如何启动新的线程？</h2><ol>
<li><p>建立Runnable对象(线程的任务)</p>
<p><code>Runnable threadJob = new MyRunnable();</code></p>
</li>
<li><p>建立Thread对象(执行工人)并赋值Runnable(任务)</p>
<p><code>Thread myThread = new Thread(threadJob);</code></p>
<p>把Runnable对象传给Thread的构造函数。这会告诉Thread对象要把那个方法放在执行空间区运行—Runnable的run( )方法。</p>
</li>
<li><p>启动Thread</p>
<p>myThread.start( );</p>
<p>在还没有调用Thread的start( )方法之前，什么也不会发生。当新的线程启动之后，它会把Runnable对象的方法摆到新的执行空间中。<img src="https://s2.loli.net/2021/12/21/sAT4lDncoZfyLRm.png" alt="image-20211221191525894"></p>
</li>
</ol>
<blockquote>
<p>对于Thread而言，它相当于一个工人，对于Runnable而言，它相当于这个工人要完成的工作。Runnable带有会放在执行空间的第一项的方法：run( )。</p>
</blockquote>
<p>Thread对象需要任务，任务是线程在启动时去执行的工作。<strong>run( )该任务是新线程空间上的第一个方法</strong>，且一点更要长得像下面这样:</p>
<p>public void run( ) {</p>
<p>​    //会被新线程执行的代码</p>
<p>}</p>
<p>Runnable定义了一个协约。因为Runnable是个接口，线程的任务可以被定义在任何实现Runnable的类上。线程只在乎传入给Thread的构造函数的参数是否为实现Runnable的类。当把Runnable传给Thread的构造函数时，实际上就是在给Thread取得run( )的方法，即给了Thread一项任务。Runnable接口只有run( )这一个方法。</p>
<blockquote>
<p>在调用start( )开始执行线程之前，对象只是个Thread实例，并不是真正的线程。</p>
</blockquote>
<p><img src="https://s2.loli.net/2021/12/21/7Tycos9U2SWEKnu.png" alt="image-20211221211338659"></p>
<h3 id="新建线程的三个状态"><a href="#新建线程的三个状态" class="headerlink" title="新建线程的三个状态"></a>新建线程的三个状态</h3><ol>
<li><h4 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h4><p>Thread t = new Thread(r);</p>
</li>
</ol>
<p>Thread的实例已经创建，但还没有启动。也就是说，有Thread对象，没有执行中的线程。</p>
<ol>
<li><h4 id="可执行"><a href="#可执行" class="headerlink" title="可执行"></a>可执行</h4><p>t.start( );</p>
</li>
</ol>
<p>当启动线程时，它会变成可执行的状态。这时，线程已经布置好执行空间。</p>
<ol>
<li><h4 id="执行中-线程的目标"><a href="#执行中-线程的目标" class="headerlink" title="执行中(线程的目标)"></a>执行中(线程的目标)</h4><p>轮到它执行</p>
</li>
</ol>
<p>所有的线程都在等待这一刻，成为正在执行中的那一个。这只能靠Java虚拟机的线程调度机制来决定。有时也能对Java虚拟机选择执行的线程给点意见，但无法强迫它把线程从可执行状态移动到执行中。</p>
<blockquote>
<p>一旦线程进入可执行状态，他会在可执行与执行中两种状态中来来去去，同时也有另一种状态：暂时不可执行(又称为被堵塞状态)。</p>
</blockquote>
<h4 id="典型的可执行-执行中循环："><a href="#典型的可执行-执行中循环：" class="headerlink" title="典型的可执行/执行中循环："></a>典型的可执行/执行中循环：</h4><p>通常线程会在可执行与执行中两种状态中来回交替。因为Java虚拟机的线程调度会把线程跳出来运行又把它踢回去以让其他线程有执行机会。</p>
<h4 id="线程有可能会暂时被挡住"><a href="#线程有可能会暂时被挡住" class="headerlink" title="线程有可能会暂时被挡住"></a>线程有可能会暂时被挡住</h4><p>调度器会因为某些原因把线程送进去关一阵子。例如线程执行到等待Socket输入串流的程序段，但没有数据可供读取。调度器会把线程移出可执行状态等。会导致线程暂时失能。</p>
<h2 id="无法掌控的线程调度器"><a href="#无法掌控的线程调度器" class="headerlink" title="无法掌控的线程调度器"></a>无法掌控的线程调度器</h2><p>无法控制调度，没有API可以可调用调度器。调度器在不同的虚拟机上有不同的行为。最重要的是，调度无法确定。</p>
<p>也就是说，同一个多线程的程序，在不同的主机上运行，会导致不同的结果。甚至于同一个程序在同一台主机上运行的结果也是不确定的。不能让程序依靠调度的特定行为来保持执行的正确性！</p>
<p>吃个栗子：</p>
<p><img src="https://s2.loli.net/2021/12/21/UYbLWgKlOd8PzcT.png" alt="image-20211221215408955"></p>
<blockquote>
<p>调度不能保证任何的执行时间和顺序，所以你不能期待他会完全地平均分配执行，最多只能影响sleep的最小保证时间。</p>
</blockquote>
<p><img src="https://s2.loli.net/2021/12/21/9ZMQnxvV1BYprqX.png" alt="image-20211221222504166"></p>
<p>想要确保其他线程有机会执行的话，就把线程放进睡眠状态。</p>
<p><img src="https://s2.loli.net/2021/12/21/Trw8pfKCkvhcVOL.png" alt="image-20211221223345949"></p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="Ryan和Monica的透支银行余额事件"><a href="#Ryan和Monica的透支银行余额事件" class="headerlink" title="Ryan和Monica的透支银行余额事件"></a>Ryan和Monica的透支银行余额事件</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p><img src="https://s2.loli.net/2021/12/23/CdDtVX8cL95JMjP.png" alt="image-20211223154931306"></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><img src="https://s2.loli.net/2021/12/23/x1CTGOcV2d6nUzN.png" alt="image-20211223154659753"></p>
<p>每个对象都有个锁。大部分时间都没有锁上。对象的锁只会在有同步化的方法上起作用。当对象有一个或多个同步化的方法时，线程只有在取得对象锁的钥匙时，才能进入同步化的方法。</p>
<p>锁不是配在方法上的，而是配在对象上。如果对象有两个同步化的方法，就表示两个线程无法进入同一个方法，也表示两个线程无法进入不同的方法。如果有多个方法可能会操作对象的实例变量，则这些方法都应该有同步化的保护。</p>
<p><strong>同步化的目标是要保护重要的数据。但要注意，锁住的不是数据，而是存取数据的方法。</strong></p>
<p>所以线程在开始执行并遇到同步化的方法时，会认知到他需要对象的钥匙才能进入方法。<strong>他会取得钥匙，这是由Java虚拟机来处理的，没有可以存取对象锁的API。那么此时，他会保护好这把钥匙，直到完成同步化方法。</strong>与此同时，其他线程不可以进入该对象的同步化方法，因为只有这一把钥匙。</p>
<blockquote>
<p>只有当对象具有同步化方法时，才会上锁。而且线程只有取得钥匙后，才能进入该方法。也就是说，线程只有在没有其他线程已经进入的情况下，才能进入。</p>
</blockquote>
<h3 id="“丢失更新”问题"><a href="#“丢失更新”问题" class="headerlink" title="“丢失更新”问题"></a>“丢失更新”问题</h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>这是另一个典型的并行性(concurrency)问题。丢失更新(lost update)有一种特定的过程。</p>
<p>吃个栗子：</p>
<ol>
<li>取得账户余额 <code>int i = balance;</code></li>
<li>将账户余额增加 <code>balance = i + 1;</code></li>
</ol>
<blockquote>
<p>正常情况下，都是直接balance++; 但怎么说呢，偶尔会因为表达式的复杂，只得使用以上方法。</p>
</blockquote>
<p>看上去，这样没什么问题。</p>
<p>那么，若此时有两个线程A和B在执行这个方法。</p>
<p>A：取余额0，增加1，变为1；</p>
<p>​    再取余额1，增加1，变为2；</p>
<p>B：取余额2，增加1，变为3；</p>
<p>​    取余额3，B睡了，此时未增加。</p>
<p>A：取余额3，增加1，变为4；</p>
<p>​    取余额4，增加1，变为5。</p>
<p>B：苏醒，将其的i=3，增加1，余额balance变为4…….</p>
<blockquote>
<p>很明显，B更改了A增加的值，丢失了A进行的更新。</p>
</blockquote>
<p>此时，就需要同步化机制来帮忙，将 <code>int i = balance; balance = i + 1;</code>锁成整体，变得不可分割。</p>
<p><img src="https://s2.loli.net/2021/12/23/VGYbOyUdQhtsCwz.png" alt="image-20211223162430700"></p>
<p><img src="https://s2.loli.net/2021/12/23/OPUaqB8yWInmF3R.png" alt="image-20211223162514844"></p>
<h3 id="死锁现象"><a href="#死锁现象" class="headerlink" title="死锁现象"></a>死锁现象</h3><p>死锁会发生是因为两个线程互相持有对方正在等待的东西。没有方法可以脱离这个情况。所以只好一直等，一直等。</p>
<p>Java中没有处理死锁的机制，甚至它都不知道死锁的发生，所以要小心设计程序。如果经常编写多线程的程序，去看看O’Reilly出版的“Java Thread”。</p>
<p><img src="https://s2.loli.net/2021/12/23/rcYB15efjhOKvI7.png" alt="image-20211223162828317"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Thread.sleep()这个静态方法可以强制线程进入等待状态到过了设定的时间为止。</li>
<li>sleep()方法可能会抛出InterruptedException异常，所以要包在try/catch块中，或者把他也声明出来。</li>
<li>可以用setName来给线程命名，通常是用来除错的。</li>
<li>如果两个或以上线程存取堆上相同的对象可能会出现严重的问题。</li>
<li>如果两个或以上的线程存取相同的对象可能会引发数据的损毁。</li>
<li>使用synchronized这个关键词修饰符，可以防止两个线程同时进入同一个对象的同一个方法。</li>
<li>对象就算是有多个同步化的方法，也还是只有一个锁。一旦某个线程进入该对象的同步化方法，其他线程就无法进入该对象上的任何同步化方法。</li>
<li>不只对象有锁，类本身也是有锁的。也就是说，假如有3个Dog对象，那么此时应该是有4个锁。</li>
<li>故而，对静态变量进行同步化，线程想要进入方法就需要先获得类的锁。</li>
<li>同步化的根本目的是为了防止步骤被分割，也就是指定某段工作要在不能分割的状态下执行。单独的操作并不重要，重要的是拥有多个步骤的一个方法。</li>
</ol>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.print.PrinterJobWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/12/23 16:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleChatClient</span> &#123;</span><br><span class="line">    JTextArea incoming;</span><br><span class="line">    JTextField outgoing;</span><br><span class="line">    BufferedReader reader;</span><br><span class="line">    PrintWriter writer;</span><br><span class="line"></span><br><span class="line">    Socket socket;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleChatClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleChatClient</span>();</span><br><span class="line">        client.go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;Ludicrously Simple Chat Client&quot;</span>);</span><br><span class="line">        <span class="type">JPanel</span> <span class="variable">panel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">        incoming = <span class="keyword">new</span> <span class="title class_">JTextArea</span>(<span class="number">15</span>, <span class="number">50</span>);</span><br><span class="line">        incoming.setLineWrap(<span class="literal">true</span>);</span><br><span class="line">        incoming.setWrapStyleWord(<span class="literal">true</span>);</span><br><span class="line">        incoming.setEditable(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">JScrollPane</span> <span class="variable">scrollPane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JScrollPane</span>(incoming);</span><br><span class="line">        scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);</span><br><span class="line">        scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);</span><br><span class="line">        outgoing = <span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">sendButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Send&quot;</span>);</span><br><span class="line">        sendButton.addActionListener(<span class="keyword">new</span> <span class="title class_">SendButtonActionListener</span>());</span><br><span class="line">        panel.add(scrollPane);</span><br><span class="line">        panel.add(outgoing);</span><br><span class="line">        panel.add(sendButton);</span><br><span class="line">        setUpNetworking();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">readerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">IncomingReader</span>());</span><br><span class="line">        readerThread.start();</span><br><span class="line"></span><br><span class="line">        frame.getContentPane().add(BorderLayout.CENTER, panel);</span><br><span class="line">        frame.setSize(<span class="number">400</span>, <span class="number">500</span>);</span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用socket取得输入/输出串流，进行输入/输出事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setUpNetworking</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(host, port);</span><br><span class="line">            <span class="type">InputStreamReader</span> <span class="variable">streamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream());</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(streamReader);</span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream());</span><br><span class="line">            System.out.println(<span class="string">&quot;networking established&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendButtonActionListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent actionEvent)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.println(outgoing.getText());</span><br><span class="line">                writer.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            outgoing.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            outgoing.requestFocus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IncomingReader</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            String message;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((message = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;read &quot;</span> + message);</span><br><span class="line">                    incoming.append(message + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/12/23 17:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleChatServer</span> &#123;</span><br><span class="line">    ArrayList clientOutputStreams;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        BufferedReader reader;</span><br><span class="line">        Socket socket;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ClientHandler</span><span class="params">(Socket clientSocket)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket = clientSocket;</span><br><span class="line">                <span class="type">InputStreamReader</span> <span class="variable">isReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream());</span><br><span class="line">                reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isReader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            String message;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((message = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;read &quot;</span>+ message);</span><br><span class="line">                    tellEveryone(message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SimpleChatServer</span>().go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        clientOutputStreams = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(clientSocket.getOutputStream());</span><br><span class="line">                clientOutputStreams.add(writer);</span><br><span class="line"></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ClientHandler</span>(clientSocket));</span><br><span class="line">                t.start();</span><br><span class="line">                System.out.println(<span class="string">&quot;got a connection&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tellEveryone</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> clientOutputStreams.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> (PrintWriter) it.next();</span><br><span class="line">                writer.println(message);</span><br><span class="line">                writer.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Something about Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb</title>
    <url>/2022/01/09/JavaWeb/</url>
    <content><![CDATA[<h1 id="JavaWeb基础"><a href="#JavaWeb基础" class="headerlink" title="JavaWeb基础"></a>JavaWeb基础</h1><h2 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>一个Java项目基本包括：</p>
<ul>
<li>引入的依赖包</li>
<li>项目的目录结构</li>
<li>配置的环境</li>
<li>等等</li>
</ul>
<p>虽难度不大，但琐碎且耗时，所以需要一个标准化的Java项目管理和构建工具。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Maven就是专门为Java打造的管理和构建工具。主要功能：</p>
<ul>
<li>提供了一套标准化的项目结构；</li>
<li>提供了一套标准化的构建流程（编译，测试，打包，发布……）；</li>
<li>提供了一套依赖管理机制。</li>
</ul>
<h3 id="Maven项目结构："><a href="#Maven项目结构：" class="headerlink" title="Maven项目结构："></a>Maven项目结构：</h3><p>一个使用Maven管理的普通的Java项目，它的目录结构默认如下：</p>
<p><img src="https://s2.loli.net/2022/01/14/B9xbAFmDVcwXrGQ.png" alt="image-20220114171600543"></p>
<p><img src="https://s2.loli.net/2022/01/14/gtv5HIKcRPqiFZd.png" alt="image-20220114191840406"></p>
<p>其中，groupId类似Java中的包名，通常是公司或组织名称，artifactId类似Java中的类名，通常是项目名称。再加上version，一个Maven工程就是由groupId、artifactId和version作为唯一标识的。在引用其他方类库时，也是通过这3个变量确定。例如，依赖<code>commons-logging</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>使用<code>&lt;dependency&gt;</code>声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。</p>
<p><img src="https://s2.loli.net/2022/01/14/qkvcp8RU9W7NO4G.png" alt="image-20220114194907705"></p>
<h2 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>在平时的开发当中，一个项目往往包含了大量的方法，可能有成千上万个。如何去保证这些方法产生的结果是我们想要的呢？当然了，最容易想到的一个方式，就是我们通过System.out来输出我们的结果，看看是不是满足我们的需求，但是项目中这些成千上万个方法，我们总不能在每一个方法中都去输出一遍嘛。</p>
<p>还有就是新建一个main()方法，然后编写测试代码。但若待测试的代码过多，就需要很多的main()方法，或者一个庞大的main()方法。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><strong>使用Junit可以帮助我们快速完成单元测试。</strong></p>
<p>其简化单元测试，写一点测一点，在编写以后的代码中，可以较快地追踪到问题的原因，减小回归错误的纠错难度。</p>
<p>junit如何解决这个问题的呢？答案在于内部提供了一个断言机制，他能够将我们预期的结果和实际的结果进行比对，判断出是否满足我们的期望。</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ol>
<li>每一个测试方法上使用@Test修饰</li>
<li>每一个测试方法必须使用public void进行修饰</li>
<li>每一个测试方法不能携带参数</li>
<li>测试代码和源代码在两个不同的项目路径下</li>
<li>测试类的包应该和被测试类保持一致</li>
<li>测试单元中的每个方法必须可以独立测试</li>
</ol>
<p>Junit也建议在每一个测试方法名加上test前缀，表明这是一个测试方法。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://s2.loli.net/2022/01/15/L4V2aGrQxMBjAkv.png" alt="image-20220115000228233"></p>
<p>如图所示：</p>
<p>assertEquals是一个断言的规则，第一个参数表明我们预期的值，第二个参数表明实际运行的值。</p>
<p>如果运行成功，编辑器的控制台不会出现错误信息，如果有就出现failure等信息。</p>
<p>引用：<a href="https://zhuanlan.zhihu.com/p/86624354">Java程序员必须要知道的单元测试框架Junit详解 - 知乎 (zhihu.com)</a></p>
<h2 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>xml是可拓展的标记性语言。</p>
<p>可拓展是说，xml文件中的标签可以自定义。如图：</p>
<p><img src="https://s2.loli.net/2022/01/09/mnxW4zLSDOrE1H3.png" alt="image-20220109202115434"></p>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>xml的主要作用：</p>
<ul>
<li>用来保存数据()，而且这些数据具有自我描述性</li>
<li>它还可以作为项目或模块的配置文件</li>
<li>可以作为网络传输数据的格式(但都是过去啦，现在都用JSON)</li>
</ul>
<h3 id="xml解析技术介绍"><a href="#xml解析技术介绍" class="headerlink" title="xml解析技术介绍"></a>xml解析技术介绍</h3><p>解析：将xml中的数据转换为程序需要的信息。</p>
<p>xml是可拓展的标记语言。不管是html还是xml，都是标记性文档，都可以使用w3c组织制定的dom技术来解析。</p>
<p><img src="https://s2.loli.net/2022/01/09/SlI8J4COk7PEyYx.png" alt="image-20220109211303542"></p>
<p>document对象表示的是整个文档(可以是html文档，也可以是xml文档)。</p>
<h3 id="xml语法"><a href="#xml语法" class="headerlink" title="xml语法"></a>xml语法</h3><ol>
<li>文档声明</li>
<li>元素(标签)</li>
<li>xml属性</li>
<li>xml注释</li>
<li>文本区域(CDATA区)</li>
</ol>
<h4 id="文档声明"><a href="#文档声明" class="headerlink" title="文档声明"></a>文档声明</h4><p>创建一个xml文件</p>
<p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&gt;   xml声明。</code></p>
<!-- xml声明， version是版本的意思，encoding是编码-->
<!-- 而且这个<?xml要连在一起，否则会报错。 -->
<h4 id="XML文档必须要有根元素"><a href="#XML文档必须要有根元素" class="headerlink" title="XML文档必须要有根元素"></a>XML文档必须要有根元素</h4><p>根元素就是顶级元素</p>
<p>没有父标签的元素，叫顶级元素。</p>
<p>根元素是没有父标签的顶级元素，而且是唯一一个才行。</p>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20220109220730784.png" alt="image-20220109220730784"></p>
<h4 id="XML中的特殊字符"><a href="#XML中的特殊字符" class="headerlink" title="XML中的特殊字符"></a>XML中的特殊字符</h4><p>转化成HTML中的字符。</p>
<p>如：“&gt;”特殊字符，&amp;gt； ；  “&lt;”特殊字符：&amp;lt；</p>
<h4 id="文本区域-CDATA区"><a href="#文本区域-CDATA区" class="headerlink" title="文本区域(CDATA区)"></a>文本区域(CDATA区)</h4><p>CDATA语法可以告诉xml解析器，我CDATA里的文本内容，只是纯文本，不需要xml语法解析</p>
<p>CDATA格式：</p>
<p><code>&lt;![CDATA[这里可以把你输入的字符原样显示，不会解析xml]]&gt;</code></p>
<p><img src="https://s2.loli.net/2022/01/09/iSHNrQ1sWvRT7hg.png" alt="image-20220109221640342"></p>
<p><img src="https://s2.loli.net/2022/01/09/PBAH4aKbRSjdCkn.png" alt="image-20220109221737442"></p>
<h3 id="配置servlet"><a href="#配置servlet" class="headerlink" title="配置servlet"></a>配置servlet</h3><p><img src="https://s2.loli.net/2022/01/09/VNK61QrMv3DCozT.png" alt="image-20220109223034886"></p>
<h3 id="什么是servlet"><a href="#什么是servlet" class="headerlink" title="什么是servlet"></a>什么是servlet</h3><ol>
<li>Servlet是JavaEE规范之一，规范也就是接口的意思。</li>
<li>Servlet是JavaWeb三大组件之一。三大组件分别是：Servlet程序、Filter过滤器、Listener监听器。</li>
<li>Servlet是运行在服务器上的一个java小程序，==它可以接收客户端发送过来的请求，并响应数据给客户端==。</li>
</ol>
<p>手动实现Servlet程序</p>
<ol>
<li>编写一个类去实现Servlet接口</li>
<li>实现service方法，处理请求，并响应数据</li>
<li>在web.xml中去配置Servlet程序的访问地址</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/14/7Ftk8B4l3uK6EwV.png" alt="image-20220114003516156"></p>
<p><img src="https://s2.loli.net/2022/01/14/6y4WUZlRdMNSvTx.png" alt="image-20220114004548054"></p>
<p><img src="https://s2.loli.net/2022/01/14/I7HKBhtumQecaX9.png" alt="image-20220114004704441"></p>
<p>base标签设置页面中所有相对路径工作时，参照的路径，即href属性。</p>
<base href="http://localhost:8080/07_servlet/a_b_c.html">

<p><img src="https://s2.loli.net/2022/01/15/GfJxmqCc2M3Q9rV.png" alt="image-20220115003150399"></p>
<h2 id="JavaEE三层架构"><a href="#JavaEE三层架构" class="headerlink" title="JavaEE三层架构"></a>JavaEE三层架构</h2><p><img src="https://s2.loli.net/2022/01/15/6aWORlNcSgE9bmx.png" alt="image-20220115004626889"></p>
<h3 id="Jdbc-Utils"><a href="#Jdbc-Utils" class="headerlink" title="Jdbc_Utils"></a>Jdbc_Utils</h3><p><img src="https://s2.loli.net/2022/01/15/Rl8OFxPgK4sZJ5I.png" alt="image-20220115010008104"></p>
<p><img src="https://s2.loli.net/2022/01/15/toPDzuvSKcFkCgQ.png" alt="image-20220115010937146"></p>
<p><img src="https://s2.loli.net/2022/01/15/UPxErg1WGwaNLzR.png" alt="image-20220115011020984"></p>
<p><img src="https://s2.loli.net/2022/01/15/RJ8adT4rNfuzm2D.png" alt="image-20220115011610686"></p>
<p><img src="https://s2.loli.net/2022/01/15/uDHnOW2qNFyXESK.png" alt="image-20220115011739243"></p>
<h3 id="专门来复用的Dao抽象类"><a href="#专门来复用的Dao抽象类" class="headerlink" title="专门来复用的Dao抽象类"></a>专门来复用的Dao抽象类</h3><h4 id="选取代码"><a href="#选取代码" class="headerlink" title="选取代码"></a>选取代码</h4><p><img src="https://s2.loli.net/2022/01/15/RMO8Q7DZyKwfL9P.png" alt="image-20220115012311409"></p>
<p><strong>Object … args : 可变长参数</strong>，用来表示sql语句中的作为占位符的？的参数的实际值。</p>
<p>记得增加finally</p>
<h4 id="查询一个："><a href="#查询一个：" class="headerlink" title="查询一个："></a>查询一个：</h4><p><img src="https://s2.loli.net/2022/01/15/vB2mqZOgEAFXCnQ.png" alt="image-20220115012703423"></p>
<h4 id="参数解释及finally"><a href="#参数解释及finally" class="headerlink" title="参数解释及finally"></a>参数解释及finally</h4><p>连接用了之后要及时关闭，不然会占用连接资源，因为sql里边就那几个可用的连接</p>
<p><img src="https://s2.loli.net/2022/01/15/meTfsX4aMkE15b8.png" alt="image-20220115012950145"></p>
<h4 id="查询多个"><a href="#查询多个" class="headerlink" title="查询多个"></a>查询多个</h4><p><img src="https://s2.loli.net/2022/01/15/eWDNHuIlTh7FB9Y.png" alt="image-20220115013250380"></p>
<h4 id="查询一列"><a href="#查询一列" class="headerlink" title="查询一列"></a>查询一列</h4><p><img src="https://s2.loli.net/2022/01/15/MWq3SU6eNI1GP5u.png" alt="image-20220115013448414"></p>
<h3 id="UserDao接口以及其实现类"><a href="#UserDao接口以及其实现类" class="headerlink" title="UserDao接口以及其实现类"></a>UserDao接口以及其实现类</h3><p><img src="https://s2.loli.net/2022/01/15/QNASR3rtDfjzheU.png" alt="image-20220115014005397"></p>
<p><img src="https://s2.loli.net/2022/01/15/nxqjN6HkwLcgzRV.png" alt="image-20220115013925082"></p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/02/14/Linux/</url>
    <content><![CDATA[<h1 id="Content-Introduction"><a href="#Content-Introduction" class="headerlink" title="Content Introduction"></a>Content Introduction</h1><h2 id="1-vmtools"><a href="#1-vmtools" class="headerlink" title="1. vmtools"></a>1. vmtools</h2><p>在主机Windows和虚拟机Linux上进行文件共享所需的工具。</p>
<p>对于共享的部分，若Windows在其中新建文件夹，Linux上可以看到；同时，Linux对文件进行修改，Windows也可以看到。</p>
<p>即，Windows和Linux对文件都有读写的权限，并且都对修改可见。</p>
<h3 id="1-过程"><a href="#1-过程" class="headerlink" title="1. 过程"></a>1. 过程</h3><ol>
<li>虚拟机—&gt;安装/重新安装vmtools(若桌面存在CentOS 7.6的光盘映像，需要先删除)，之后桌面会出现vmtools的光盘映像。</li>
<li>打开光盘映像，将其中的那个压缩包复制到主文件夹中的/opt中，之后解压</li>
<li><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220214163517194.png" alt="image-20220214163517194"></li>
</ol>
<p>​        Tab键 可以补全文件名。</p>
<ol>
<li><p><img src="https://s2.loli.net/2022/02/14/NlkhROvnQUgWi1B.png" alt="image-20220214163726657"></p>
<p> 一直按回车(Enter)即可。</p>
</li>
<li><p><img src="https://s2.loli.net/2022/02/14/73uglCqi19ZnkVh.png" alt="image-20220214163938458"></p>
</li>
</ol>
<p>如图，成功。</p>
<ol>
<li><p><img src="https://s2.loli.net/2022/02/14/2BaFDIeRYsh3V1Z.png" alt="image-20220214164203664"></p>
</li>
<li><p>之后在D:\myshare(Windows)和主文件夹\其他位置\计算机\mnt\hgfs\myshare(Linux)中，双方任意一方进行增加、修改文件等操作的结果，双方都可见。</p>
</li>
</ol>
<h3 id="2-tips"><a href="#2-tips" class="headerlink" title="2. tips"></a>2. tips</h3><p>但在实际开发中，一般远程登陆后，进行上传下载文件，不通过这种方式进行共享。</p>
<h2 id="3-Linux目录结构-重要"><a href="#3-Linux目录结构-重要" class="headerlink" title="3. Linux目录结构(重要)"></a>3. Linux目录结构(重要)</h2><h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><p><strong>Linux会把硬件映射成一个文件来管理。</strong></p>
<ol>
<li>Linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录”/“，然后在此目录下再创建别的目录。</li>
<li>规定了每个目录下存放的文件类型(如/bin下存常用命令等)。</li>
<li><strong>在Linux世界里，一切皆文件。</strong></li>
</ol>
<p><img src="https://s2.loli.net/2022/02/14/F9d6KWpel8MHOzb.png" alt="image-20220214170022218"></p>
<p><img src="https://s2.loli.net/2022/02/14/f7gNkTUv8CYZ15o.png" alt="image-20220214170142179"></p>
<p><img src="https://s2.loli.net/2022/02/14/Mmp7T63CSWsV4fw.png" alt="image-20220214170244070"></p>
<h3 id="2-详解"><a href="#2-详解" class="headerlink" title="2. 详解"></a>2. 详解</h3><p><img src="https://s2.loli.net/2022/02/14/MdZyBbiCIKmz1rs.png" alt="image-20220214171223656"></p>
<p><img src="https://s2.loli.net/2022/02/14/U4ysVScpb5zXmft.png" alt="image-20220214171437594"></p>
<p><img src="https://s2.loli.net/2022/02/14/ylqvWwxmTgcAtNS.png" alt="image-20220214171313425"></p>
<p><strong>/proc和/srv和/sys存放系统文件，如果乱动，极大可能会导致系统崩溃。</strong></p>
<p><img src="https://s2.loli.net/2022/02/14/2hWHTMim3tKdGUz.png" alt="image-20220214172749215"></p>
<p><img src="https://s2.loli.net/2022/02/14/l6OD2K7oQFiEIkB.png" alt="image-20220214172650483"></p>
<h2 id="4-远程登录Linux"><a href="#4-远程登录Linux" class="headerlink" title="4. 远程登录Linux"></a>4. 远程登录Linux</h2><p>不在同一台主机上的登录行为.</p>
<h3 id="1-原因"><a href="#1-原因" class="headerlink" title="1. 原因"></a>1. 原因</h3><ol>
<li>Linux服务器是开发小组共享</li>
<li>正式上线的项目是运行在公网</li>
<li>因此程序员需要远程登录到Linux进行项目管理或者开发</li>
<li>简单的网络拓扑示意图</li>
</ol>
<p><img src="https://s2.loli.net/2022/02/20/oDN1d3QuYSHXyAE.png" alt="image-20220220184654829"></p>
<ol>
<li>远程登录客户端有Xshell(远程登录)，Xftp(文件远程上传下载)等。</li>
</ol>
<h4 id="2-Xshell"><a href="#2-Xshell" class="headerlink" title="2. Xshell"></a>2. Xshell</h4><p><img src="https://s2.loli.net/2022/02/20/96wWaNZoYtFzu4j.png" alt="image-20220220182621199"></p>
<p>输入reboot，可以控制Linux去重启。</p>
<h4 id="3-Xftp"><a href="#3-Xftp" class="headerlink" title="3. Xftp"></a>3. Xftp</h4><p><img src="https://s2.loli.net/2022/02/20/S6HibfG2MyIrkCE.png" alt="image-20220220184936249"></p>
<p><img src="https://s2.loli.net/2022/02/20/6xa2dzDHhGyQAgr.png" alt="image-20220220183955314"></p>
<h2 id="5-vi和vim"><a href="#5-vi和vim" class="headerlink" title="5. vi和vim"></a>5. vi和vim</h2><h3 id="1-基本介绍-1"><a href="#1-基本介绍-1" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><p>Linux会内置vi文本编辑器</p>
<p>Vim具有程序编辑的能力，可以看作是vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能丰富。</p>
<h4 id="1-正常模式"><a href="#1-正常模式" class="headerlink" title="1. 正常模式"></a>1. 正常模式</h4><p>以vim打开一个档案就直接进入一般模式(这是默认的模式)。在这个模式中，可以使用按键来移动光标，可以使用删除字符和删除整行来处理档案内容，也可以复制粘贴。</p>
<h4 id="2-插入模式"><a href="#2-插入模式" class="headerlink" title="2. 插入模式"></a>2. 插入模式</h4><p>可以增加文字进入档案。</p>
<h4 id="3-命令行模式"><a href="#3-命令行模式" class="headerlink" title="3. 命令行模式"></a>3. 命令行模式</h4><p>可以完成读取、存盘、替换、离开vim，显示行号等操作。</p>
<p>先输入esc，再输入”:“后，即可从插入模式进入命令行模式。</p>
<p>那么，输入“:wq”：进入命令行模式，之后write写入，再quit退出。</p>
<p><img src="https://s2.loli.net/2022/03/05/Y2tnZp5ICXJ4WBe.png" alt="image-20220305215742256"></p>
<p>再次进入只需 vim Hello.java。</p>
<h3 id="2-快捷键"><a href="#2-快捷键" class="headerlink" title="2. 快捷键"></a>2. 快捷键</h3><p><img src="https://s2.loli.net/2022/02/20/u3EeAhDqC1i4SW2.png" alt="image-20220220222642750"></p>
<h4 id="1-常用的7个快捷键"><a href="#1-常用的7个快捷键" class="headerlink" title="1. 常用的7个快捷键"></a>1. 常用的7个快捷键</h4><p><img src="https://s2.loli.net/2022/02/20/1p6URexnwAgZTt8.png" alt="image-20220220225039845"></p>
<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>若是想转而查找别的单词，输入”/“即可。</p>
<p>找不到的话，会有提示信息：</p>
<p><img src="https://s2.loli.net/2022/02/20/kwvJVs9gUMAcxjC.png" alt="image-20220220223825590"></p>
<h5 id="设置行号"><a href="#设置行号" class="headerlink" title="设置行号"></a>设置行号</h5><p>nu：number</p>
<p>效果图如下：(若想删除行号，输入”:set nonu”)</p>
<p><img src="https://s2.loli.net/2022/02/20/J1mLkXNTyC7zSwQ.png" alt="image-20220220224009345"></p>
<h4 id="2-tips："><a href="#2-tips：" class="headerlink" title="2. tips："></a>2. tips：</h4><h5 id="先退回一般模式"><a href="#先退回一般模式" class="headerlink" title="先退回一般模式"></a>先退回一般模式</h5><p><strong>注意部分快捷键是要退回一般模式后使用的！</strong></p>
<p>在插入模式下，首先输入”:”，使得下方没有命令显示，只有”:”时，再按ESC退回到一般模式。</p>
<h5 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h5><p>其他还有很多快捷键，但是没必要。实际开发项目时，还是先在熟悉的windows环境中将代码写好，然后上传到Linux中，但不可避免的，肯定也会有远程登录，然后修改代码等的情况，所以快捷键还是要掌握一些，比如列出的7种，一定要掌握的。</p>
<h2 id="6-关机-amp-重启"><a href="#6-关机-amp-重启" class="headerlink" title="6. 关机&amp;重启"></a>6. 关机&amp;重启</h2><p>shutdown -h now : 立刻进行关机</p>
<p>shutdown -h 1 ：给所有登录到该Linux的用户发送一个通知：1分钟后会关机</p>
<p>shutdown -r now ：现在重启计算机(reboot)</p>
<p>halt ：关机，作用和上边的一样</p>
<p>reboot ：现在重启计算机</p>
<p>sync ：把内存的数据同步到磁盘</p>
<p>不管是重启还是关闭系统，首先要运行sync命令，把内存中的数据写到磁盘中</p>
<p>目前的shutdown/reboot/halt等命令均已经在关机前进行了sync，但所谓小心驶得万年船。</p>
<h2 id="7-登录注销"><a href="#7-登录注销" class="headerlink" title="7. 登录注销"></a>7. 登录注销</h2><h3 id="1-基本介绍-2"><a href="#1-基本介绍-2" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><ol>
<li><p>登录时尽量少用root账号登录(实际开发时少用)，因为它是系统管理员，最大的权限，避免操作失误，可以利用普通用户登录，登录后再用”su - 用户名”命令来切换称系统管理员身份。</p>
</li>
<li><p>在提示符下输入logout即可注销用户</p>
</li>
</ol>
<h3 id="2-使用细节"><a href="#2-使用细节" class="headerlink" title="2. 使用细节"></a>2. 使用细节</h3><ol>
<li>logout注销指令在图形运行级别(图形界面)无效，在运行级别 3下有效</li>
<li></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/2022/02/01/Maven/</url>
    <content><![CDATA[<h1 id="Maven：自动化构建工具"><a href="#Maven：自动化构建工具" class="headerlink" title="Maven：自动化构建工具"></a>Maven：自动化构建工具</h1>]]></content>
      <tags>
        <tag>Begin！</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-触发器</title>
    <url>/2021/11/29/MySQL-%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    <content><![CDATA[<h1 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h1><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>MySQL的语句在需要时被执行，包括存储过程也是如此。但是，经常会出现想要某条语句(或某些语句)在事件发生时自动执行的情况。此时，便需要触发器的作用。</p>
<p><strong>触发器</strong> 是MySQL响应以下任意语句而自动执行的一条MySQL语句(或位于BEGIN和END语句之间的一组语句)：<strong>DELETE、UPDATE、INSERT</strong>。其余MySQL语句不支持触发器。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>在创建触发器时，需要给出4条信息：</p>
<ul>
<li><p>唯一的触发器名(每个表唯一，但最好保证整个数据库中唯一)</p>
</li>
<li><p>触发器关联的表</p>
</li>
<li><p>触发器因该相响应的活动(DELETE、INSERT或UPDATE)；</p>
</li>
<li><p>触发器该何时执行(处理之前或之后)。</p>
<p>注意，在触发器中返回结果集是低版本MySQL的做法，书上的代码，不允许触发器返回任何结果，因此使用INTO @变量名，将结果赋值到变量中，用SELECT调用即可。</p>
<p>修改为：</p>
<p>CREATE TRIGGER newp AFTER INSERT ON tb_product</p>
<p>FOR EACH ROW SELECT ‘Product added’ INTO @asd;</p>
<p>可用SELECT @asd；输出变量中结果。</p>
</li>
</ul>
<blockquote>
<p>tips：</p>
<p>触发器按照每个表每个事件定义，单一触发器不能与多个事件或多个表关联。所以，如果你需要一个对INDERT和UPDATE操作执行的触发器，就应该定义两个。</p>
</blockquote>
]]></content>
      <tags>
        <tag>触发器</tag>
      </tags>
  </entry>
  <entry>
    <title>Serializable</title>
    <url>/2021/12/11/Serializable/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Java储存对象"><a href="#Java储存对象" class="headerlink" title="Java储存对象"></a>Java储存对象</h2><h3 id="只有自己写的Java程序会用到"><a href="#只有自己写的Java程序会用到" class="headerlink" title="只有自己写的Java程序会用到"></a>只有自己写的Java程序会用到</h3><ol>
<li><h4 id="用序列化-Serialization"><a href="#用序列化-Serialization" class="headerlink" title="用序列化(Serialization)"></a>用序列化(Serialization)</h4></li>
</ol>
<p>将被序列化的对象写到文件中。然后让程序取文件中读取序列化的对象并展开为原来状态</p>
<p>数据需要被其他程序引用</p>
<ol>
<li><h4 id="放文本文件中。"><a href="#放文本文件中。" class="headerlink" title="放文本文件中。"></a>放文本文件中。</h4></li>
</ol>
<p>用其他程序可以解析的特殊字符写到文件中。</p>
<p>将序列化对象</p>
<h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><h2 id="将序列化对象写入文件"><a href="#将序列化对象写入文件" class="headerlink" title="将序列化对象写入文件"></a>将序列化对象写入文件</h2><h3 id="方法步骤"><a href="#方法步骤" class="headerlink" title="方法步骤"></a>方法步骤</h3><ol>
<li><code>创建出FileOutputStream fileStream = new FileOutputStream(&quot;Mygame.txt&quot;);</code> </li>
<li><code>创建出ObjectOutputStream os = new ObjectOutputStream(fileStream);</code> </li>
<li><code>写入对象os.writeObject(characterOne);</code></li>
<li><code>os.close();</code></li>
</ol>
<p>Java的输入/输出API带有连接类型的串流，他代表来源于目的地之间的连接。连接串流将串流与其他串流连接起来。一般来说，串流要两两连接才能做出有意义的事情—其中一个表示连接，另一个则是要被调用方法的。以FileOutputStream为例。它可以由写入字节的方法，但我们通常不会写入字节，而是以对象层次的观点来写入，所以需要高层的连接串流。<img src="https://s2.loli.net/2021/12/22/oEXO6W9umf7NpTl.png" alt="image-20211211160857891-16392102017261"></p>
<h3 id="对象被序列化"><a href="#对象被序列化" class="headerlink" title="对象被序列化"></a>对象被序列化</h3><ol>
<li>在堆上的对象</li>
</ol>
<p>在堆上的对象有状态——实例变量的值。这些值让同一类的不通事理有了不同的意义。</p>
<ol>
<li>被序列化的对象</li>
</ol>
<p>序列化的对象保存了实例变量的值，因此之后可以在堆上带回一模一样的实例。</p>
<p>如，带有两个primitive主数据类型实例变量(高度、宽度)的对象，会将宽度与高度的实例变量值(二进制格式)与Java虚拟机所需的信息(像是类的名称)被保存在foo.ser文件中。</p>
<p><code>Foo myFoo = new Foo();</code></p>
<p><code>myFoo.setWidth(37);</code></p>
<p><code>myFoo.setHeight(70);</code></p>
<p><code>FileOutputStream fs = new FileOutputStream(&quot;foo.ser&quot;);</code></p>
<p><code>ObjectOutputStream os = new ObjectOutputStream(fs);</code></p>
<p><code>os.writeObject(myFoo);</code></p>
<p>当对象被序列化时，被该对象引用的实例变量也会被序列化。即序列化程序会将对象版图上的所有东西存储起来。被对象的实例变量所引用的所有对象都会被序列化。</p>
<h3 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h3><p>如果想让类能够被序列化，就实现Serializable接口。</p>
<p>其又被称为marker或tag接口，因为此接口并没有任何方法需要实现。使用它唯一的目的就是，实现它的类是可以被序列化的。如果某类可以序列化，那么它的子类也自动地可以序列化。</p>
<p>为了保证正确的序列化，整个对象版图中，<strong>所有牵扯到的类都必须实现Serializable接口</strong>。</p>
<p>若是比较特殊的，比如忘记实现序列化，或者动态数据只有在运行的时候求出，不能或不必保存，那么需要标记为transient(瞬时)的。虽然Java函数库中大部分类可以被序列化，你还是无法将网络联机之类的东西保存下来，他得要在执行期当场创建才有意义。</p>
<h2 id="解序列化"><a href="#解序列化" class="headerlink" title="解序列化"></a>解序列化</h2><h3 id="方法步骤-1"><a href="#方法步骤-1" class="headerlink" title="方法步骤"></a>方法步骤</h3><p><code>1. 创建出FileInputStream fileStream = new FileInputStream(&quot;MyGame.txt&quot;);</code></p>
<p><code>2. 创建出ObjectInputStream os = new ObjectInputStream(fileStream);</code></p>
<p><code>3. 读取对象 Object one = os.readObject();</code></p>
<p><code>4. 转换对象类型 characterOne = (MyGame)one;</code></p>
<p><code>5. 关闭ObjectInputStream os.close();</code>  </p>
<h3 id="对象解序列化时"><a href="#对象解序列化时" class="headerlink" title="对象解序列化时"></a>对象解序列化时</h3><p>当对象被解序列化时，Java虚拟机会通过尝试在堆上创建新的对象，让它维持与被序列化时有相同的状态来恢复对象的原状。但这当然不包括transient的变量，它们不是null(对对象引用而言)就是primitive主数据类型的默认值。<img src="https://s2.loli.net/2021/12/22/QNgyWML1BupCnxS.png" alt="image-0918"></p>
<p>新的对象会被分配到堆上，但构造函数不会执行！很显然，我们只是需要对象回到存储时的状态，而不是要一个全新的对象。</p>
<p>如果该对象在继承树上有一个不可序列化的祖先类，则<strong>该不可序列化类以及在它之上的类的构造函数(就算其上的类是可序列化的也一样)就会执行</strong>。一旦构造函数启动之后将无法停止，也就是说，<strong>从第一个不可序列化的父类开始，全部都会重新初始状态</strong>。</p>
<h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ol>
<li>可以通过序列化来存储对象的状态。</li>
<li>使用ObjectOutputStream来序列化对象</li>
<li>Stream是连接串流或是链接用的串流</li>
<li>连接串流用来表示源或目的地、文件、网络套接字连接。</li>
<li>对象必须实现序列化这个接口，才能被序列化。如果父类实现序列化，则子类也就自动地有实现，不管是否有明确的声明。</li>
<li>当对象被序列化时，整个对象版图都会被序列化。这代表他的实例变量引用的对象也会被序列化。</li>
<li>在解序列化时(deserialization)，所有的类必须都能让虚拟机找到。</li>
<li>若该实例变量被标记为transient，则该变量在还原的时候会被赋予null或primitive主数据类型的默认值。</li>
<li>读取对象的顺序必须与写入的顺序相同。</li>
<li>readObject( )的返回类型是Object</li>
<li>静态变量不会被序列化，因为它属于整个类，而不是一个对象。</li>
</ol>
<h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><h3 id="java-io-File-class"><a href="#java-io-File-class" class="headerlink" title="java.io.File  class"></a>java.io.File  class</h3><p>File这个类代表磁盘上的文件，但并不是文件中的内容分。就似乎可以把File对象想象成文件的路径，而不是文件本身。例如。File并没有读写文件的方法。关于File有个很有用的功能就是就是它提供一种比使用字符串文件名来表示文件更安全的方式。举例来说，在构造函数中，可以用File对象来代替字符串表示的文件名，便于检查路径是否合法，之后再将其作为参数传给FileWriter或FileOutputStream等。</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>缓冲区能让你暂时摆一堆东西一直到满为止。用了缓冲区就可以省下好几趟来回。</p>
<p><code>BufferedWriter writer = new BufferedWriter(new FileWriter(file));</code></p>
<p>缓冲区的奥妙之处在于，可以比没有使用缓冲区的效率更好。也可以直接使用FileWriter的write( )，但他每次都直接写进磁盘，而每趟磁盘操作会比内存操作花费更多的时间。通过BufferedWriter和FileWriter的链接，BufferedWriter可以暂存一堆数据，然后到满的时候再实际写入磁盘，可以减少对磁盘操作的次数。flush().</p>
]]></content>
  </entry>
  <entry>
    <title>Spring-5</title>
    <url>/2022/01/02/Spring-5/</url>
    <content><![CDATA[<h1 id="Spring5-框架"><a href="#Spring5-框架" class="headerlink" title="Spring5 框架"></a>Spring5 框架</h1><h2 id="Spring-概念"><a href="#Spring-概念" class="headerlink" title="Spring 概念"></a>Spring 概念</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>Spring 是轻量级的开源的JavaEE框架(bean生命周期)</li>
<li>Spring可以解决企业应用开发的复杂性</li>
<li>Spring有两个核心部分: IOC和Aop</li>
</ol>
<h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><h3 id="IOC基本概念"><a href="#IOC基本概念" class="headerlink" title="IOC基本概念"></a>IOC基本概念</h3><h4 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h4><p>控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理</p>
<p>使用目的：为了降低耦合度到最低。</p>
<p>做入门案例就是IOC的一种实现。</p>
<h3 id="IOC底层原理"><a href="#IOC底层原理" class="headerlink" title="IOC底层原理"></a>IOC底层原理</h3><ol>
<li>xml解析、工厂模式、反射</li>
<li>画图说明</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/18/s2huD6PySiATa7d.png" alt="image-20220118215648859"></p>
<p>一种降低耦合度的方法：</p>
<p><img src="https://s2.loli.net/2022/01/18/C7Uh3JMa1VXEAw9.png" alt="image-20220118220558909"></p>
<h3 id="IOC过程："><a href="#IOC过程：" class="headerlink" title="IOC过程："></a>IOC过程：</h3><h4 id="第一步-xml配置文件，配置创建的对象"><a href="#第一步-xml配置文件，配置创建的对象" class="headerlink" title="第一步 xml配置文件，配置创建的对象"></a>第一步 xml配置文件，配置创建的对象</h4><bean id="dao" class="com.example.UserDao"></bean>

<h4 id="第二步-有service类和dao类，创建工厂类"><a href="#第二步-有service类和dao类，创建工厂类" class="headerlink" title="第二步 有service类和dao类，创建工厂类"></a>第二步 有service类和dao类，创建工厂类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title function_">getDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">classValue</span> <span class="operator">=</span> class属性值; <span class="comment">// 1. xml解析,com.example.UserDao</span></span><br><span class="line">        <span class="comment">// 2. 通过反射创建对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(classValue); <span class="comment">// 获取类的Class对象</span></span><br><span class="line">        <span class="keyword">return</span> (UserDao)clazz.newInstance(); <span class="comment">// 创建对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步降低耦合度</p>
<h3 id="IOC接口-BeanFactory"><a href="#IOC接口-BeanFactory" class="headerlink" title="IOC接口(BeanFactory)"></a>IOC接口(BeanFactory)</h3><ol>
<li><p>IOC思想基于IOC容器完成，IOC容器底层就是对象工厂</p>
</li>
<li><p>Spring提供IOC容器两种实现方式(两个接口):</p>
<ol>
<li><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory:"></a>BeanFactory:</h4><p>IOC容器基本实现，是Spring内部的使用接口，一般不提供开发人员使用</p>
<p>==<strong>加载配置文件时，不会创建对象，在获取/使用对象时，才会创建对象。</strong>==</p>
<p><img src="https://s2.loli.net/2022/01/19/4sZySd1oKvAmn7i.png" alt="image-20220119004715201"></p>
</li>
<li><h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext:"></a>ApplicationContext:</h4><p>BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员使用</p>
<p><strong>==加载配置文件时，就会把在配置文件中的对象进行创建。==</strong>只要做了bean配置(有bean标签)</p>
<p><img src="https://s2.loli.net/2022/01/19/QhRVEzCJqPykFAi.png" alt="image-20220119005217032"></p>
</li>
</ol>
</li>
</ol>
<h4 id="哪个好？"><a href="#哪个好？" class="headerlink" title="哪个好？"></a>哪个好？</h4><p>第一种虽然可以节约资源，因为用的时候才创建。但因为用的Spring框架，要结合web项目进行使用，即要使用tomcat将服务器启动，则把创建对象这种耗时耗资源的操作，都在项目启动时进行处理。服务器启动过程中，就去创建这个对象，而不是之后操作中才创建。</p>
<h5 id="所以，一般使用第二种！"><a href="#所以，一般使用第二种！" class="headerlink" title="所以，一般使用第二种！"></a>所以，一般使用第二种！</h5><h4 id="ApplicationContext的实现类"><a href="#ApplicationContext的实现类" class="headerlink" title="ApplicationContext的实现类"></a>ApplicationContext的实现类</h4><p>两个主要的：</p>
<p><img src="https://s2.loli.net/2022/01/19/81wFyGMP3BV4WOU.png" alt="image-20220119010458141"></p>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p><strong>1中是加盘符(如E盘)的完整文件路径</strong></p>
<p><strong>2中是文件在类中的路径(相当于相对路径)</strong></p>
<h3 id="什么是Bean管理"><a href="#什么是Bean管理" class="headerlink" title="什么是Bean管理"></a>什么是Bean管理</h3><ol>
<li><p>Bean管理指的是两个操作</p>
</li>
<li><p>Spring创建对象</p>
</li>
<li>Spring注入属性</li>
</ol>
<h4 id="Bean管理操作有两种方式"><a href="#Bean管理操作有两种方式" class="headerlink" title="Bean管理操作有两种方式"></a>Bean管理操作有两种方式</h4><ol>
<li>基于xml配置文件方式实现</li>
<li>基于注解方式实现</li>
</ol>
<h4 id="IOC操作Bean管理-基于xml"><a href="#IOC操作Bean管理-基于xml" class="headerlink" title="IOC操作Bean管理(基于xml)"></a>IOC操作Bean管理(基于xml)</h4><ol>
<li><h5 id="基于xml方式创建对象"><a href="#基于xml方式创建对象" class="headerlink" title="基于xml方式创建对象"></a>基于xml方式创建对象</h5><ol>
<li>在spring配置文件中，使用bean标签，标签里面添加对应属性，就可以实现对象创建</li>
<li><p>在bean标签中，有很多属性</p>
<ul>
<li>id属性：给要获取的对象取的唯一标识</li>
<li>class属性：类全路径(包名.类)</li>
</ul>
</li>
<li><p>构建对象时，默认使用的是无参构造方法</p>
</li>
</ol>
</li>
</ol>
<p>如：</p>
<p><img src="https://s2.loli.net/2022/01/28/pTfkvWKjF9aLJRY.png" alt="image-20220122003902640"></p>
<ol>
<li><h5 id="基于xml方式注入属性"><a href="#基于xml方式注入属性" class="headerlink" title="基于xml方式注入属性"></a>基于xml方式注入属性</h5><p>​    DI：依赖注入，就是注入属性(在创建对象的基础上，进行属性注入)</p>
<ol>
<li><p>第一种注入方式：使用set方法进行注入</p>
<ol>
<li>创建类：定义属性和对应的set方法</li>
<li>在spring配置文件中配置文件创建，配置属性注入</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/98xAQVJtg3IMSdv.png" alt="image-20220123010021903"></p>
</li>
<li><p>第二种注入方式：使用有参构造进行注入</p>
<ol>
<li>创建类，定义属性，创建属性对应的有参构造方法</li>
<li>在spring配置文件中，进行配置</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/JmbNAV1xwlKCyvi.png" alt="image-20220123005934953"></p>
</li>
</ol>
</li>
<li><h5 id="xml注入其他类型属性"><a href="#xml注入其他类型属性" class="headerlink" title="xml注入其他类型属性"></a>xml注入其他类型属性</h5><ol>
<li><h6 id="注入属性—字面量：设置的固定的内容，如属性的值等。"><a href="#注入属性—字面量：设置的固定的内容，如属性的值等。" class="headerlink" title="注入属性—字面量：设置的固定的内容，如属性的值等。"></a>注入属性—字面量：设置的固定的内容，如属性的值等。</h6><ol>
<li>null</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/Sgy4eP7LBfJlpNz.png" alt="image-20220123011606184"></p>
<ol>
<li>设置的属性值中包含特殊符号</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/gKelrsx61DImE4i.png" alt="image-20220123012202077"></p>
</li>
<li><h6 id="注入属性—外部bean-ref，即为注入外部bean的标志"><a href="#注入属性—外部bean-ref，即为注入外部bean的标志" class="headerlink" title="注入属性—外部bean (ref，即为注入外部bean的标志)"></a><strong>注入属性—外部bean (ref，即为注入外部bean的标志)</strong></h6><ol>
<li>创建两个类service类和dao类</li>
<li>在service调用dao里面的方法</li>
<li>在spring配置文件中进行配置</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/F5JRBr8alThvkMn.png" alt="image-20220123015718866"></p>
<p>结果：</p>
<p><img src="https://s2.loli.net/2022/01/23/ewng6kGF4Sm1pVl.png" alt="image-20220123020139091"></p>
</li>
<li><h6 id="注入属性—内部bean和级联赋值"><a href="#注入属性—内部bean和级联赋值" class="headerlink" title="注入属性—内部bean和级联赋值"></a>注入属性—内部bean和级联赋值</h6><p><strong>内部bean：</strong></p>
<ol>
<li>选取1对多的关系：如，部门和员工</li>
<li>表示1对多的关系</li>
<li>在spring配置文件中进行配置</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/z1ImZonDvYBfSjH.png" alt="image-20220123184748289"></p>
<p><strong>级联赋值：</strong>(给emp赋值的同时，给deptName赋值)</p>
<p>给有关联的类的属性同时进行赋值</p>
<p><strong>法1</strong></p>
<p><img src="https://s2.loli.net/2022/01/23/LoQyAkdTpYqIjwg.png" alt="image-20220123192012953"></p>
<p>即，通过外部bean实现属性注入，从而进行级联赋值。</p>
<p><strong>法2</strong></p>
<p><img src="https://s2.loli.net/2022/01/23/2Co6iT19ygu4prM.png" alt="image-20220123193506941"></p>
</li>
<li><h6 id="注入属性—集合类型"><a href="#注入属性—集合类型" class="headerlink" title="注入属性—集合类型"></a>注入属性—集合类型</h6><ol>
<li>数组类型</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/W4Nsgnj7ZpOd1VD.png" alt="image-20220123211318723"></p>
<ol>
<li>list类型</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/OxIYSimJdCk67QN.png" alt="image-20220123211406730"></p>
<ol>
<li>map类型</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/8DFTL6gwMn4tpbA.png" alt="image-20220123211510255"></p>
<ol>
<li>set类型</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/SAfhra5Yb8duELU.png" alt="image-20220123211605712"></p>
<h6 id="7-两个点："><a href="#7-两个点：" class="headerlink" title="7. 两个点："></a>7. 两个点：</h6><p><img src="https://s2.loli.net/2022/01/23/CUKPr67I58MNXoL.png" alt="image-20220123232903521"></p>
<p><img src="https://s2.loli.net/2022/01/24/bcjpBuQ4d3hS7vP.png" alt="image-20220123232809036"></p>
<p><strong>抽取出来，成为公共部分</strong></p>
<p><img src="https://s2.loli.net/2022/01/23/E4XJQ35H2VKDZBp.png" alt="image-20220123233956654"></p>
<p><img src="https://s2.loli.net/2022/01/23/qCKp6bVWUcuYhaO.png" alt="image-20220123233910031"></p>
<p><img src="https://s2.loli.net/2022/01/23/gt3VoPYKT92D5MR.png" alt="image-20220123234546772"></p>
</li>
</ol>
</li>
</ol>
<h4 id="IOC操作Bean管理-FactoryBean"><a href="#IOC操作Bean管理-FactoryBean" class="headerlink" title="IOC操作Bean管理(FactoryBean)"></a>IOC操作Bean管理(FactoryBean)</h4><ol>
<li><p>Spring有两种类型bean，一种普通bean，另一种工厂bean(FactoryBean)</p>
</li>
<li><p>普通bean：在配置文件中定义的bean类型就是返回的类型</p>
</li>
<li><p>工厂bean：在配置文件中定义的bean类型可以和返回的类型不一样</p>
<ol>
<li><p>第一步：创建类，让这个类作为工厂bean，实现接口FactoryBean</p>
</li>
<li><p><img src="https://s2.loli.net/2022/01/24/o9YFxJhQ3tGOg56.png" alt="image-20220124004258839"></p>
</li>
<li><p>第二步：实现接口里面的方法，在实现的方法中定义返回的bean类型</p>
<p><img src="https://s2.loli.net/2022/01/24/c57daHVtYyPGfCz.png" alt="image-20220124004231461"></p>
<h6 id="定义的返回类型是MyBean："><a href="#定义的返回类型是MyBean：" class="headerlink" title="定义的返回类型是MyBean："></a>定义的返回类型是MyBean：</h6><p><img src="https://s2.loli.net/2022/01/24/CKO29r6oQvNWjGY.png" alt="image-20220124004757107"></p>
<h6 id="实际的返回类型是Book："><a href="#实际的返回类型是Book：" class="headerlink" title="实际的返回类型是Book："></a>实际的返回类型是Book：</h6><p><img src="https://s2.loli.net/2022/01/24/EKyx6NGDQwrmUI2.png" alt="image-20220124004417185"></p>
</li>
</ol>
</li>
</ol>
<h4 id="IOC操作Bean管理-Bean作用域"><a href="#IOC操作Bean管理-Bean作用域" class="headerlink" title="IOC操作Bean管理(Bean作用域)"></a>IOC操作Bean管理(Bean作用域)</h4><ol>
<li>在spring里面，设置创建的bean实例是单实例还是多实例。</li>
<li>在spring里面，默认情况下，bean是单实例对象。</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/24/yJIFapERiM9wTbP.png" alt="image-20220124182142662"></p>
<p>也就是说，虽然生成了两个实例，但指的是同一个对象空间，即地址相同。</p>
<ol>
<li><p>设置单实例还是多实例的方法</p>
<ol>
<li><p>在spring中，bean标签里面有scope属性进行设置</p>
</li>
<li><p>scope常用属性值：singleton和prototype</p>
<ol>
<li>singleton：默认值，表示是单实例对象</li>
<li>prototype: 表示是多实例对象</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/24/LWXmsGUIl3afxw7.png" alt="image-20220124185403859"></p>
<p>二者区别：</p>
<pre><code>1. **设置为singleton，在加载spring配置文件时，就会默认进行创建单实例对象**
2. **设置为prototype，在调用getBean方法时，才去创建多实例对象**
</code></pre></li>
</ol>
</li>
</ol>
<h4 id="IOC操作Bean管理-Bean生命周期"><a href="#IOC操作Bean管理-Bean生命周期" class="headerlink" title="IOC操作Bean管理(Bean生命周期)"></a>IOC操作Bean管理(Bean生命周期)</h4><ol>
<li><p>生命周期</p>
<p>对象从创建到销毁的过程</p>
</li>
<li><p>bean生命周期</p>
<ol>
<li>通过构造器创建bean实例(无参数构造)</li>
<li>为bean的属性设置值和对其他bean的引用(调用set方法)</li>
<li>调用bean的初始化方法(需要进行配置)</li>
<li>bean可以使用(获取到对象)</li>
<li>当容器关闭时，调用bean的销毁方法(需要进行配置)</li>
</ol>
</li>
<li><p>代码: </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span>&#123;</span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Orders</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一步 执行无参构造创建bean实例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String oname;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOname</span><span class="params">(String oname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.oname = oname;</span><br><span class="line">        System.out.println(<span class="string">&quot;第二步 调用set方法设置属性值&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建执行的初始化的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第三步 执行初始化的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建执行的销毁的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第五步 执行销毁的方法&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;orders&quot;</span> class=<span class="string">&quot;com.test.spring5.bean.Orders&quot;</span> init-method=<span class="string">&quot;initMethod&quot;</span> destroy-method=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;oname&quot;</span> value=<span class="string">&quot;手机&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBean</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean4.xml&quot;</span>);</span><br><span class="line">    <span class="type">Orders</span> <span class="variable">orders</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;orders&quot;</span>, Orders.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;第四步 获取创建bean实例对象&quot;</span>);</span><br><span class="line">    context.close();</span><br><span class="line">    <span class="comment">/* 或</span></span><br><span class="line"><span class="comment">    ApplicationContext context = </span></span><br><span class="line"><span class="comment">    	new ClassPathXmlApplicationContxt(&quot;bean4.xml&quot;);</span></span><br><span class="line"><span class="comment">    (ClassPathXmlApplicationContext)context.close();</span></span><br><span class="line"><span class="comment">    因为ApplicationContext这个接口没有close方法，所以只能用实现该接口的类的close方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ol>
<li><p>bean的后置处理器，此时bean生命周期有七步：</p>
<ol>
<li>通过构造器创建bean实例(无参数构造)</li>
<li>为bean的属性设置值和对其他bean的引用(调用set方法)</li>
<li>把bean实例传递bean后置处理器的方法</li>
<li>调用bean的初始化方法(需要进行配置)</li>
<li>把bean实例传递bean后置处理器的方法</li>
<li>bean可以使用(获取到对象)</li>
<li>当容器关闭时，调用bean的销毁方法(需要进行配置)</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/25/ue9RpQPyAY1omWn.png" alt="image-20220125001452518"></p>
<p>给其上所有的bean配置都加上后置处理器。</p>
<p><img src="https://s2.loli.net/2022/01/28/8NUhvqbkLtI1XBa.png" alt="image-20220125001800193"></p>
<p><img src="https://s2.loli.net/2022/01/25/hqonRZM74U82T9p.png" alt="image-20220125001607128"></p>
</li>
</ol>
<h4 id="IOC操作Bean管理-xml自动装配"><a href="#IOC操作Bean管理-xml自动装配" class="headerlink" title="IOC操作Bean管理(xml自动装配)"></a>IOC操作Bean管理(xml自动装配)</h4><p>(该方法不常用，一般使用注解方式)</p>
<ol>
<li><h5 id="什么是自动装配"><a href="#什么是自动装配" class="headerlink" title="什么是自动装配"></a>什么是自动装配</h5><ol>
<li>根据指定装配规则(属性名称或属性类型)，Spring自动将匹配的属性进行注入</li>
</ol>
</li>
<li><h5 id="两种方法"><a href="#两种方法" class="headerlink" title="两种方法"></a>两种方法</h5><ol>
<li><h5 id="byName：此时要求，注入的bean名和类中的属性的实例名一样"><a href="#byName：此时要求，注入的bean名和类中的属性的实例名一样" class="headerlink" title="byName：此时要求，注入的bean名和类中的属性的实例名一样"></a>byName：此时要求，注入的bean名和类中的属性的实例名一样</h5><p>即，此处的外部bean中id=”dept”，Emp类中要有一个Dept dept; 这样才可以装配成功</p>
<p><img src="https://s2.loli.net/2022/01/25/KtQqgwumLMJnp5H.png" alt="image-20220125135601553"></p>
</li>
<li><h5 id="byType：此时要求，注入的bean，只能有一个Dept类型的"><a href="#byType：此时要求，注入的bean，只能有一个Dept类型的" class="headerlink" title="byType：此时要求，注入的bean，只能有一个Dept类型的"></a>byType：此时要求，注入的bean，只能有一个Dept类型的</h5><p>否则，不知道对应哪个。</p>
<p><img src="https://s2.loli.net/2022/01/25/uNF9nmZrWvSaphB.png" alt="image-20220125140733132"></p>
</li>
</ol>
</li>
</ol>
<h4 id="IOC操作Bean管理-外部属性文件"><a href="#IOC操作Bean管理-外部属性文件" class="headerlink" title="IOC操作Bean管理(外部属性文件)"></a>IOC操作Bean管理(外部属性文件)</h4><h5 id="将不变的定值部分提取出来，常用于数据库中配置"><a href="#将不变的定值部分提取出来，常用于数据库中配置" class="headerlink" title="将不变的定值部分提取出来，常用于数据库中配置"></a><strong>将不变的定值部分提取出来，常用于数据库中配置</strong></h5><h5 id="两种方式："><a href="#两种方式：" class="headerlink" title="两种方式："></a>两种方式：</h5><ol>
<li><p>直接配置数据库信息</p>
<ol>
<li><p>配置druid连接池</p>
</li>
<li><p>引入druid连接池依赖jar包</p>
<p><img src="https://s2.loli.net/2022/01/25/c8IMAxRjWLwQVqD.png" alt="image-20220125223504046"></p>
<p><img src="https://s2.loli.net/2022/01/25/iuMGlxVDrb5c8kj.png" alt="image-20220125223719398"></p>
</li>
</ol>
</li>
<li><p>引入外部属性文件配置数据库连接池</p>
<ol>
<li><p>创建外部属性文件，.properties格式，写数据库信息</p>
<p><img src="https://s2.loli.net/2022/01/25/RNCoVimge8Wx4sb.png" alt="image-20220125224447186"></p>
</li>
<li><p>把外部properties属性文件引入到spring配置文件中</p>
<ol>
<li><p>引入context命名空间</p>
<p><img src="https://s2.loli.net/2022/01/25/eA57xk84TUygYtr.png" alt="image-20220125224703623"></p>
<p>画横线的上边，所有的beans都改为context即可</p>
</li>
<li><p>在spring配置文件中，使用标签引入外部属性文件</p>
<p><img src="https://s2.loli.net/2022/01/25/7US6JkdrCy3gvcZ.png" alt="image-20220125225142909"></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="IOC操作Bean管理-基于注解"><a href="#IOC操作Bean管理-基于注解" class="headerlink" title="IOC操作Bean管理(基于注解)"></a>IOC操作Bean管理(基于注解)</h4><h5 id="注解的概念"><a href="#注解的概念" class="headerlink" title="注解的概念"></a>注解的概念</h5><ol>
<li>注解是代码特殊标记，格式：@注解名称(属性名称=属性值，…)</li>
<li>注解的位置：可以放在类上面、属性上面、方法上面</li>
<li>使用注解的目的：简化xml配置</li>
</ol>
<h5 id="Spring针对bean管理中的创建对象的注解"><a href="#Spring针对bean管理中的创建对象的注解" class="headerlink" title="Spring针对bean管理中的创建对象的注解"></a>Spring针对bean管理中的创建对象的注解</h5><ol>
<li>@Component(各种都可)</li>
<li>@Service(Service层)</li>
<li>@Controller(Web层)</li>
<li>@Repository(Dao层)</li>
</ol>
<p>功能一样，都可以用来创建bean实例，但为了使代码整体结构明了，常用于不同的层中</p>
<h5 id="基于注解方式实现对象创建"><a href="#基于注解方式实现对象创建" class="headerlink" title="基于注解方式实现对象创建"></a>基于注解方式实现对象创建</h5><ol>
<li><p>引入依赖包</p>
<p><img src="https://s2.loli.net/2022/01/27/lPhf37YjZtLqCN6.png" alt="image-20220127230046239"></p>
</li>
<li><p>开启组件扫描</p>
</li>
<li><p>过程</p>
<p><img src="https://s2.loli.net/2022/01/26/TRegU3IoNQxsSHV.png" alt="image-20220126170012555"></p>
<p><img src="https://s2.loli.net/2022/01/26/OvQacp6xbD25yWn.png" alt="image-20220126170249846"></p>
</li>
</ol>
<p>首先加载配置文件bean1.xml，之后开始进行组件扫描，扫描给定的包中的文件，按照所给注解创建对象，再调用方法输出内容。</p>
<h4 id="IOC操作Bean管理-组件扫描配置"><a href="#IOC操作Bean管理-组件扫描配置" class="headerlink" title="IOC操作Bean管理(组件扫描配置)"></a>IOC操作Bean管理(组件扫描配置)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> &lt;!--这种情况下，会扫描所给包下的所有文件的所有注解--&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.test.spring5&quot;</span>&gt;&lt;/context:component-scan&gt;</span><br><span class="line">    </span><br><span class="line"> &lt;!--示例<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    use-<span class="keyword">default</span>-filters=<span class="string">&quot;false&quot;</span> 表示现在不使用默认filters，自己进行配置</span><br><span class="line">    context:include-filter,设置扫描哪些内容</span><br><span class="line">    也就是说，此时只扫描所给包下，所有的有Controller注解的类</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.test.spring5&quot;</span> use-<span class="keyword">default</span>-filters=<span class="string">&quot;false&quot;</span>&gt;</span><br><span class="line">	&lt;context:include-filter type=<span class="string">&quot;annotation&quot;</span></span><br><span class="line">        					expression=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;    </span><br><span class="line">&lt;/context:component-scan&gt;</span><br><span class="line">    </span><br><span class="line">&lt;!--示例<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    context:exclude-filter, 设置不扫描哪些内容</span><br><span class="line">--&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.test.spring5&quot;</span>&gt;</span><br><span class="line">    &lt;context:exclude-filter type=<span class="string">&quot;annotation&quot;</span></span><br><span class="line">        					expression-<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>
<h4 id="基于注解方式实现属性注入"><a href="#基于注解方式实现属性注入" class="headerlink" title="基于注解方式实现属性注入"></a>基于注解方式实现属性注入</h4><h5 id="AutoWired"><a href="#AutoWired" class="headerlink" title="@AutoWired"></a>@AutoWired</h5><h6 id="根据属性类型进行自动装配"><a href="#根据属性类型进行自动装配" class="headerlink" title="根据属性类型进行自动装配"></a>根据属性类型进行自动装配</h6><p><img src="https://s2.loli.net/2022/01/26/lKsOVnNEo21YXMG.png" alt="image-20220126190154264"></p>
<p><img src="https://s2.loli.net/2022/01/26/cyiwDjpYNbxKPtm.png" alt="image-20220126190223331"></p>
<p><strong>实现类 要有 创建对象 的注解</strong></p>
<p><img src="https://s2.loli.net/2022/01/26/e5bzmya76si1qpc.png" alt="image-20220126190102415"></p>
<h5 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h5><h6 id="根据属性名称进行注入"><a href="#根据属性名称进行注入" class="headerlink" title="根据属性名称进行注入"></a>根据属性名称进行注入</h6><p> 常常放在@AutoWired下面，二者一起使用(当一个接口有多个实现类时，通过实现类名称确定使用哪个)</p>
<p>其值value要与实现类的创建注解中的value一致</p>
<p><img src="https://s2.loli.net/2022/01/28/ciDAnByEufeVLSh.png" alt="image-20220126210553992"></p>
<p><img src="https://s2.loli.net/2022/01/26/uMkRmvZlOb3Exr6.png" alt="image-20220126210420160"></p>
<h5 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h5><h6 id="可以根据类型注入，也可以根据名称注入"><a href="#可以根据类型注入，也可以根据名称注入" class="headerlink" title="可以根据类型注入，也可以根据名称注入"></a>可以根据类型注入，也可以根据名称注入</h6><p>根据类型注入时，直接@Resource即可</p>
<p>根据名称注入：</p>
<p><img src="https://s2.loli.net/2022/01/26/A7mdRxOcqfjSCLi.png" alt="image-20220126211243420"></p>
<blockquote>
<p>因为Resource实质上并不属于Spring，而是属于javax包，故而，Spring官方建议使用前两种。</p>
</blockquote>
<h5 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h5><h6 id="注入普通类型的属性值"><a href="#注入普通类型的属性值" class="headerlink" title="注入普通类型的属性值"></a>注入普通类型的属性值</h6><p><img src="https://s2.loli.net/2022/01/26/p5o2zIWXDc6PCSb.png" alt="image-20220126212117946"></p>
<p><img src="https://s2.loli.net/2022/01/26/DPcTgbeuK7LBXQh.png" alt="image-20220126212143138"></p>
<h4 id="IOC操作Bean管理-完全注解开发"><a href="#IOC操作Bean管理-完全注解开发" class="headerlink" title="IOC操作Bean管理(完全注解开发)"></a>IOC操作Bean管理(完全注解开发)</h4><h5 id="创建配置类，替代xml文件"><a href="#创建配置类，替代xml文件" class="headerlink" title="创建配置类，替代xml文件"></a>创建配置类，替代xml文件</h5><p>注意配置注解@Configuration和组件扫描注解@ComponentScan</p>
<p><img src="https://s2.loli.net/2022/01/26/YNfmIMoj8viDxQ5.png" alt="image-20220126215512250"></p>
<h5 id="创建测试类"><a href="#创建测试类" class="headerlink" title="创建测试类"></a>创建测试类</h5><p><img src="https://s2.loli.net/2022/01/26/iaI2TxNmkyFwQAH.png" alt="image-20220126215751386"></p>
<h2 id="Aop"><a href="#Aop" class="headerlink" title="Aop"></a>Aop</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>面向切面(方面)编程</p>
<ol>
<li><p>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率</p>
</li>
<li><p>即，不修改原本的源代码，在原有的主干功能的基础上，(通过增加模块的方式)增添新的功能</p>
</li>
<li><p>例子：</p>
<p><img src="https://s2.loli.net/2022/01/26/VynzSlPpexdoKUG.png" alt="image-20220126221631626"></p>
</li>
</ol>
<h3 id="AOP底层原理"><a href="#AOP底层原理" class="headerlink" title="AOP底层原理"></a>AOP底层原理</h3><h4 id="AOP底层使用动态代理"><a href="#AOP底层使用动态代理" class="headerlink" title="AOP底层使用动态代理"></a>AOP底层使用动态代理</h4><h5 id="有接口，使用JDK动态代理"><a href="#有接口，使用JDK动态代理" class="headerlink" title="有接口，使用JDK动态代理"></a>有接口，使用JDK动态代理</h5><p>创建接口的实现类代理对象，增强类的方法</p>
<p><img src="https://s2.loli.net/2022/01/26/Zur8WcIRMFXGy3f.png" alt="image-20220126224949978"></p>
<h5 id="无接口，使用CGLIB动态代理"><a href="#无接口，使用CGLIB动态代理" class="headerlink" title="无接口，使用CGLIB动态代理"></a>无接口，使用CGLIB动态代理</h5><p>   创建当前类的子类代理对象，增强类的方法</p>
<p><img src="https://s2.loli.net/2022/01/27/QIh9i6l3tpAdv5U.png" alt="image-20220126225018496"></p>
<h4 id="动态代理实现"><a href="#动态代理实现" class="headerlink" title="动态代理实现"></a>动态代理实现</h4><h5 id="Proxy类"><a href="#Proxy类" class="headerlink" title="Proxy类"></a>Proxy类</h5><h6 id="创建代理对象的方法"><a href="#创建代理对象的方法" class="headerlink" title="创建代理对象的方法"></a>创建代理对象的方法</h6><p><img src="https://s2.loli.net/2022/01/27/gM5ZpkOuAvnWqbG.png" alt="image-20220127160252028"></p>
<p><img src="https://s2.loli.net/2022/01/27/6UrZuQHcXgLktaG.png" alt="image-20220127160608351"></p>
<p>三个参数：</p>
<ul>
<li>类加载器</li>
<li>增强方法所在的类，其实现的接口，支持多个接口</li>
<li>实现InvocationHandler接口，创建代理对象，其中写增强的方法</li>
</ul>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><ol>
<li><p>创建接口和接口实现类</p>
<p><img src="https://s2.loli.net/2022/01/27/u46MYRbWSfxOHFJ.png" alt="image-20220127191831981"></p>
<p><img src="https://s2.loli.net/2022/01/27/uI6AHgsoXvRqSi1.png" alt="image-20220127191811419"></p>
</li>
<li><p>使用Proxy类创建接口的动态代理</p>
<p>使用newProxyInstance( )方法创建代理类UserDao的实例时，第一个参数是当前类的加载器，第二个参数是待创建代理的接口的Class对象，第三个是 将原有方法进行增强的 代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建接口实现类代理对象</span></span><br><span class="line">        Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line">        <span class="type">UserDaoImpl</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">dao</span> <span class="operator">=</span> (UserDao)Proxy.newProxyInstance(JdkProxy.class.getClassLoader(), interfaces, <span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> dao.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 执行下方invoke方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result: &quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 创建代理对象代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/1/27 18:07:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造传递 需要代理对象的类</span></span><br><span class="line">    <span class="comment">// 此处是为了类型的广泛兼容，将UserDao扩展为Object</span></span><br><span class="line">    <span class="comment">// 因为是在之前的方法的基础上进行增强，故而需要获取之前的方法，便于执行</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Desc // 进行方法增强</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@date</span> 2022/1/27 18:45</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Object&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之前执行 &quot;</span> + method.getName());</span><br><span class="line">        <span class="comment">// 此处执行增强前的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;方法之后执行 &quot;</span> + obj);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/27/Jv5yNefrbEdSgPQ.png" alt="image-20220127200058512"></p>
<h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><h4 id="连接点"><a href="#连接点" class="headerlink" title="连接点"></a>连接点</h4><p>类中可以被增强的方法</p>
<h4 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a>切入点</h4><p>类中实际被增强的方法</p>
<h4 id="通知-增强"><a href="#通知-增强" class="headerlink" title="通知(增强)"></a>通知(增强)</h4><p>增强(加)的逻辑部分</p>
<h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><ul>
<li>前置通知：方法之前 执行</li>
<li>后置通知：方法之后 执行</li>
<li>环绕通知：方法之前和之后都有执行，类似上面的代码</li>
<li>异常通知：当方法抛出异常时 执行</li>
<li>最终通知：类似于try/catch块中的finally部分，不管是否抛出异常都会执行，但二者不同</li>
</ul>
<h4 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h4><p>是动作，将通知应用到切入点的过程，比如将权限判断应用到登录中这一过程</p>
<h3 id="AOP操作"><a href="#AOP操作" class="headerlink" title="AOP操作"></a>AOP操作</h3><p><strong>Spring框架一般都是基于AspectJ实现AOP操作</strong></p>
<h4 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h4><p>本来是一个独立的AOP框架，为了开发时方便，一般将其和Spring框架一起使用，进行AOP操作。</p>
<h4 id="基于AspectJ实现AOP操作"><a href="#基于AspectJ实现AOP操作" class="headerlink" title="基于AspectJ实现AOP操作"></a>基于AspectJ实现AOP操作</h4><h5 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h5><p>基于xml配置文件实现</p>
<p>基于注解方式实现(常用)</p>
<h4 id="引入四个依赖包"><a href="#引入四个依赖包" class="headerlink" title="引入四个依赖包"></a>引入四个依赖包</h4><p><img src="https://s2.loli.net/2022/01/27/dFu94iEQP3IRl8b.png" alt="image-20220127225753665"></p>
<h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h4><h5 id="标识-增强的是哪个类中的哪个方法"><a href="#标识-增强的是哪个类中的哪个方法" class="headerlink" title="标识 增强的是哪个类中的哪个方法"></a>标识 增强的是哪个类中的哪个方法</h5><h5 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h5><p>execution({权限修饰符}{返回类型}{类全路径}{方法名称}({参数列表}) )</p>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><ol>
<li>对com.test.spring5.UserDao中的add方法进行增强</li>
</ol>
<p>execution(<em> com.test.spring5.UserDao.add(..)) // 其中</em>表示任一权限，返回类型省略</p>
<ol>
<li>对com.test.spring5.UserDao中的所有方法进行增强</li>
</ol>
<p>execution(<em> com.test.spring5.UserDao.</em>(..))</p>
<ol>
<li>对com.test.spring5中的所有类的所有方法进行增强</li>
</ol>
<p>execution(<em> com.test.spring5.</em>.*(..))</p>
<h4 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h4><ol>
<li><p>创建待增强类和增强类</p>
<p><img src="https://s2.loli.net/2022/01/27/ftL7Z1r6mojARJ5.png" alt="image-20220127222936095"></p>
</li>
<li><p>引入context和aop命名空间，开启注解扫描</p>
<p><img src="https://s2.loli.net/2022/01/27/N32FiG9kyPatj85.png" alt="image-20220127223052786"></p>
</li>
<li><p>用注解的方式@Component生成两个类的实例，并用@Aspect注解标记增强类</p>
<p><img src="https://s2.loli.net/2022/01/27/oUV2Fv9HKlES3ck.png" alt="image-20220127223113029"></p>
<p><img src="https://s2.loli.net/2022/01/27/QlyYEcHOxd5uaCg.png" alt="image-20220127223227676"></p>
</li>
<li><p>创建五种类型的通知，并用注解进行标记</p>
<p>加什么注解，增强后的方法就有什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前置通知</span></span><br><span class="line"><span class="meta">@Before(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终通知</span></span><br><span class="line"><span class="meta">@After(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;After...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置/返回通知</span></span><br><span class="line"><span class="meta">@AfterReturning(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;After returning...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常通知</span></span><br><span class="line"><span class="meta">@AfterThrowing(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrow</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;After throwing...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 环绕通知</span></span><br><span class="line"><span class="meta">@Around(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Before enhancing...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用未增强的方法</span></span><br><span class="line">    proceedingJoinPoint.proceed();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;After enhancing...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<p><img src="https://s2.loli.net/2022/01/27/TNPsru12XWwGRZ3.png" alt="image-20220127223659348"></p>
</li>
<li><p>结果</p>
<p><img src="https://s2.loli.net/2022/01/27/m98c3SVvRnBJFtq.png" alt="image-20220127223625592"></p>
<p>首先执行环绕通知的前部分，然后执行方法的前置通知，原方法执行后，执行环绕通知后半部分，接着是最终通知，而后是后置/返回通知。<strong>若抛出异常，则会执行异常通知，此时其后置通知不会再执行(抛出异常后，其下语句不再执行)，但最终通知执行。</strong></p>
<p><img src="https://s2.loli.net/2022/01/27/QRHOAfT6PdlVSbD.png" alt="image-20220127224220929"></p>
</li>
</ol>
<h4 id="另外两个"><a href="#另外两个" class="headerlink" title="另外两个"></a>另外两个</h4><h5 id="提取出相同的切入点"><a href="#提取出相同的切入点" class="headerlink" title="提取出相同的切入点"></a>提取出相同的切入点</h5><p>比如上边的五个通知，注解中的value是一样的，就可以放在一起。则将来修改时，只用修改一处，也更加方便。</p>
<p>只需增加一个@Pointcut注解</p>
<p><img src="https://s2.loli.net/2022/01/27/bkypg5FzvJB2jn7.png" alt="image-20220127224853590"></p>
<h5 id="设置增强类的执行优先级"><a href="#设置增强类的执行优先级" class="headerlink" title="设置增强类的执行优先级"></a>设置增强类的执行优先级</h5><p>若一个类有多个增强类，那么可以设置各个增强类执行的优先级</p>
<p>增加@Order(数字类型)：数字越小，优先级越高</p>
<p><img src="https://s2.loli.net/2022/01/27/ihZAMfEstm1kv2w.png" alt="image-20220127225050893"></p>
<h2 id="JDBCTemplate"><a href="#JDBCTemplate" class="headerlink" title="JDBCTemplate"></a>JDBCTemplate</h2><h3 id="JdbcTemplate概述"><a href="#JdbcTemplate概述" class="headerlink" title="JdbcTemplate概述"></a>JdbcTemplate概述</h3><p>Spring框架对JDBC进行封装，使用JdbcTemplate方便实现对数据库操作</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="引入相关的依赖"><a href="#引入相关的依赖" class="headerlink" title="引入相关的依赖"></a>引入相关的依赖</h4><p><img src="https://s2.loli.net/2022/01/27/GbmpaTrwkJNQV3B.png" alt="image-20220127231141941"></p>
<h4 id="配置数据库连接池"><a href="#配置数据库连接池" class="headerlink" title="配置数据库连接池"></a>配置数据库连接池</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--配置数据库连接池--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;dataSource&quot;</span> class=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span><br><span class="line">      destroy-method=<span class="string">&quot;close&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;jdbc:mysql://localhost:3306/db_database10&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;654321&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="配置JdbcTemplate对象，注入DataSource"><a href="#配置JdbcTemplate对象，注入DataSource" class="headerlink" title="配置JdbcTemplate对象，注入DataSource"></a>配置JdbcTemplate对象，注入DataSource</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--JdbcTemplate对象--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;jdbcTemplate&quot;</span> class=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span><br><span class="line">    &lt;!--注入DataSource--&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="创建service类和dao类，在dao中注入jdbcTemplate对象"><a href="#创建service类和dao类，在dao中注入jdbcTemplate对象" class="headerlink" title="创建service类和dao类，在dao中注入jdbcTemplate对象"></a>创建service类和dao类，在dao中注入jdbcTemplate对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdcTemplate;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JdbcTemplate操作数据库-添加功能"><a href="#JdbcTemplate操作数据库-添加功能" class="headerlink" title="JdbcTemplate操作数据库(添加功能)"></a>JdbcTemplate操作数据库(添加功能)</h3><h4 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h4><p>创建用户类，以数据表tb_user中的属性值为实例域，并生成getter和setter方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String userStatus;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在类中新增方法"><a href="#在类中新增方法" class="headerlink" title="在类中新增方法"></a>在类中新增方法</h4><h5 id="UserService类中新增addUser方法"><a href="#UserService类中新增addUser方法" class="headerlink" title="UserService类中新增addUser方法"></a>UserService类中新增addUser方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userDao.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="UserDao类中新增add方法"><a href="#UserDao类中新增add方法" class="headerlink" title="UserDao类中新增add方法"></a>UserDao类中新增add方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="UserDaoImpl中实现add方法"><a href="#UserDaoImpl中实现add方法" class="headerlink" title="UserDaoImpl中实现add方法"></a>UserDaoImpl中实现add方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(User user)</span> &#123;</span><br><span class="line">		<span class="comment">// 主要使用JdbcTemplate中的update方法进行新增</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO tb_user VALUES(?,?,?)&quot;</span>;</span><br><span class="line">        Object[] args = &#123; user.getUserId(), user.getUserName(), user.getUserStatus() &#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">addNumber</span> <span class="operator">=</span> jdbcTemplate.update(sql, args);</span><br><span class="line">        System.out.println(addNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE tb_user SET user_id=?, user_name=?, user_status=? WHERE user_id=?&quot;</span>;</span><br><span class="line">        Object[] args = &#123; user.getUserId(), user.getUserName(), user.getUserStatus(), user.getUserId() &#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;DELETE FROM tb_user WHERE user_id = ?&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, id);</span><br><span class="line">        System.out.println(update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT COUNT(*) FROM tb_user&quot;</span>;</span><br><span class="line">        <span class="comment">// 方法的第二个参数为返回值的类类型</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> count;</span><br><span class="line">        <span class="keyword">return</span> count1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserId(<span class="string">&quot;002&quot;</span>);</span><br><span class="line">        user.setUserName(<span class="string">&quot;张四&quot;</span>);</span><br><span class="line">        user.setUserStatus(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        userService.addUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/01/28/xB7mg9XWj5wq8ru.png" alt="image-20220128165149416"></p>
<h3 id="JdbcTemplate操作数据库-查询返回对象"><a href="#JdbcTemplate操作数据库-查询返回对象" class="headerlink" title="JdbcTemplate操作数据库(查询返回对象)"></a>JdbcTemplate操作数据库(查询返回对象)</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><code>T t = queryForObject(String sql, RowMapper&lt;T&gt; rowMapper, Object... args)</code></p>
<h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><h5 id="第一个参数：sql语句"><a href="#第一个参数：sql语句" class="headerlink" title="第一个参数：sql语句"></a>第一个参数：sql语句</h5><h5 id="第二个参数：RowMapper接口"><a href="#第二个参数：RowMapper接口" class="headerlink" title="第二个参数：RowMapper接口"></a>第二个参数：RowMapper接口</h5><p>针对不同返回类型，使用这个接口的实现类完成对数据的封装。泛型具体化为 什么类型，返回时，数据就被封装为 什么类型。</p>
<h5 id="第三个参数：占位符代表的值"><a href="#第三个参数：占位符代表的值" class="headerlink" title="第三个参数：占位符代表的值"></a>第三个参数：占位符代表的值</h5><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><img src="https://s2.loli.net/2022/01/28/Ysbt1yTzgulfwVG.png" alt="image-20220128210514151"></p>
<h3 id="查询返回集合"><a href="#查询返回集合" class="headerlink" title="查询返回集合"></a>查询返回集合</h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p><code>List&lt;T&gt; t = jdbcTemplate.query(sql, RowMapper&lt;T&gt; rowMapper, Object... obj)</code></p>
<p>三个参数同上，最后一个参数可以没有。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAllUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM tb_user&quot;</span>;</span><br><span class="line">    <span class="comment">// 这个方法重要，返回的是集合</span></span><br><span class="line">    List&lt;User&gt; userList = jdbcTemplate.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;User&gt;(User.class));</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="批量增加"><a href="#批量增加" class="headerlink" title="批量增加"></a>批量增加</h3><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><p><code>int[] ints = jdbcTemplate.batchUpdate(sql, List&lt;Object&gt; batchArgs)</code> </p>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><h5 id="第一个参数：sql语句-1"><a href="#第一个参数：sql语句-1" class="headerlink" title="第一个参数：sql语句"></a>第一个参数：sql语句</h5><h5 id="第二个参数：List集合，添加多条记录"><a href="#第二个参数：List集合，添加多条记录" class="headerlink" title="第二个参数：List集合，添加多条记录"></a>第二个参数：List集合，添加多条记录</h5><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p><img src="https://s2.loli.net/2022/01/28/hoScOvU8rME5x63.png" alt="image-20220128213901809"></p>
<p><img src="https://s2.loli.net/2022/01/28/oE4M7xipeT1N5lK.png" alt="image-20220128214324252"></p>
<h3 id="批量删除和修改"><a href="#批量删除和修改" class="headerlink" title="批量删除和修改"></a>批量删除和修改</h3><h4 id="方法一样。"><a href="#方法一样。" class="headerlink" title="方法一样。"></a>方法一样。</h4><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><h5 id="修改和增加的参数差不多"><a href="#修改和增加的参数差不多" class="headerlink" title="修改和增加的参数差不多"></a>修改和增加的参数差不多</h5><h5 id="删除的参数如下："><a href="#删除的参数如下：" class="headerlink" title="删除的参数如下："></a>删除的参数如下：</h5><p><img src="https://s2.loli.net/2022/01/28/3ous86klgJNdOZr.png" alt="image-20220128215811316"></p>
<h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><h3 id="事务基本概念"><a href="#事务基本概念" class="headerlink" title="事务基本概念"></a>事务基本概念</h3><p>事务是数据库操作的最基本单元，逻辑上，一组操作要么都成功，要么都失败。</p>
<h3 id="事务的四个特性-ACID"><a href="#事务的四个特性-ACID" class="headerlink" title="事务的四个特性(ACID)"></a>事务的四个特性(ACID)</h3><ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>永久性</li>
</ul>
<h3 id="事务操作的环境"><a href="#事务操作的环境" class="headerlink" title="事务操作的环境"></a>事务操作的环境</h3><p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20220128221411247.png" alt="image-20220128221411247"></p>
<h4 id="创建数据表，添加记录"><a href="#创建数据表，添加记录" class="headerlink" title="创建数据表，添加记录"></a>创建数据表，添加记录</h4><p><img src="https://s2.loli.net/2022/01/28/SjkdGthBaTyRw8r.png" alt="image-20220128222344884"></p>
<h4 id="创建service，搭建dao，完成对象创建和注入"><a href="#创建service，搭建dao，完成对象创建和注入" class="headerlink" title="创建service，搭建dao，完成对象创建和注入"></a>创建service，搭建dao，完成对象创建和注入</h4><p>同之前一样</p>
<h4 id="事务引入"><a href="#事务引入" class="headerlink" title="事务引入"></a>事务引入</h4><p><img src="https://s2.loli.net/2022/01/28/5KTNFwh6AXa49nS.png" alt="image-20220128224344901"></p>
<h3 id="Spring中事务管理"><a href="#Spring中事务管理" class="headerlink" title="Spring中事务管理"></a>Spring中事务管理</h3><h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>事务添加到JavaEE三层结构里面Service层(业务逻辑层)</p>
<h4 id="在Spring中进行事务管理操作"><a href="#在Spring中进行事务管理操作" class="headerlink" title="在Spring中进行事务管理操作"></a>在Spring中进行事务管理操作</h4><p><strong>有两种方式：编程式事务管理(不常用)和声明式事务管理(常用)</strong></p>
<p>编程式即，将上述过程，全用代码实现，复杂且庞大，故而一般不使用</p>
<p>声明式即，将上述过程，通过配置的方式，进行实现。</p>
<h4 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h4><h5 id="基于注解方式-常用"><a href="#基于注解方式-常用" class="headerlink" title="基于注解方式(常用)"></a>基于注解方式(常用)</h5><h5 id="基于xml文件方式"><a href="#基于xml文件方式" class="headerlink" title="基于xml文件方式"></a>基于xml文件方式</h5><h4 id="底层使用AOP原理"><a href="#底层使用AOP原理" class="headerlink" title="底层使用AOP原理"></a>底层使用AOP原理</h4><h4 id="事务管理API"><a href="#事务管理API" class="headerlink" title="事务管理API"></a>事务管理API</h4><p>提供一个接口，其针对不同的框架，提供了不同的实现类</p>
<p>使用JdbcTemplate(和Mybatis)时</p>
<p><img src="https://s2.loli.net/2022/01/29/3MjaGenVJsqog6Z.png" alt="image-20220129134645032"></p>
<h3 id="声明式事务管理：注解"><a href="#声明式事务管理：注解" class="headerlink" title="声明式事务管理：注解"></a>声明式事务管理：注解</h3><h4 id="配置事务管理器"><a href="#配置事务管理器" class="headerlink" title="配置事务管理器"></a>配置事务管理器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--创建事务管理器--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;transactionManager&quot;</span> class=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br><span class="line">    &lt;!--注入数据源--&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="开启事务注解"><a href="#开启事务注解" class="headerlink" title="开启事务注解"></a>开启事务注解</h4><h5 id="引入名称空间tx"><a href="#引入名称空间tx" class="headerlink" title="引入名称空间tx"></a>引入名称空间tx</h5><p><img src="https://s2.loli.net/2022/01/29/4eMxkqtn72JjPiy.png" alt="image-20220129143603753"></p>
<h5 id="开启事务注解-1"><a href="#开启事务注解-1" class="headerlink" title="开启事务注解"></a>开启事务注解</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;tx:annotation-driven transaction-manager=<span class="string">&quot;transactionManager&quot;</span>&gt;&lt;/tx:annotation-driven&gt;</span><br></pre></td></tr></table></figure>
<h5 id="在service类-或类中方法-上添加事务注解"><a href="#在service类-或类中方法-上添加事务注解" class="headerlink" title="在service类(或类中方法)上添加事务注解"></a>在service类(或类中方法)上添加事务注解</h5><p><img src="https://s2.loli.net/2022/01/29/i9OvuRpnSEFdgW2.png" alt="image-20220129162034905"></p>
<p>可以在类上加该注解，也可以在方法上加。</p>
<p>在类上加时，表示整个类中所有的方法，都具有事务属性</p>
<p>在方法上加，只表示这个方法，是事务，具有事务属性。</p>
<h4 id="管理事务的参数配置"><a href="#管理事务的参数配置" class="headerlink" title="管理事务的参数配置"></a>管理事务的参数配置</h4><p>在service类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数</p>
<h5 id="propagation：事务传播行为"><a href="#propagation：事务传播行为" class="headerlink" title="propagation：事务传播行为"></a>propagation：事务传播行为</h5><p>多个事务方法之间进行调用，这个过程中，事务是如何管理的。(就是，有事务方法调用没有事务方法，没有事务方法调用有事务方法，或者两个有事务方法之间调用之类的。)</p>
<p>事务方法：对数据库表中数据进行变化的操作(查询行为就不是，因为数据未变化)</p>
<h6 id="Spring框架事务传播行为有7种："><a href="#Spring框架事务传播行为有7种：" class="headerlink" title="Spring框架事务传播行为有7种："></a>Spring框架事务传播行为有7种：</h6><p>常用的两个：</p>
<p>REQUIRED: 如果调用方法本身有事务，被调用方法使用当前方法里面的事务；如果调用方法本身没有事务，被调用方法，创建新的事务。(默认是这个)</p>
<p>REQUIRED_NEW：不管调用方法本身有没有事务，被调用方法，都创建新的事务。</p>
<p>@Transactional(propagation=REQUIRED_NEW)</p>
<h5 id="isolation：事务隔离级别"><a href="#isolation：事务隔离级别" class="headerlink" title="isolation：事务隔离级别"></a>isolation：事务隔离级别</h5><p>多事务操作之间不会产生影响。不考虑隔离性会产生很多问题。</p>
<h6 id="三个读问题"><a href="#三个读问题" class="headerlink" title="三个读问题"></a>三个读问题</h6><h6 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h6><p>一个未提交事务读取到另一个未提交事务</p>
<h6 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h6><p>一个未提交事务读取到另一个已提交事务修改的数据</p>
<h6 id="虚-幻读"><a href="#虚-幻读" class="headerlink" title="虚/幻读"></a>虚/幻读</h6><p>一个未提交事务读取到另一个已提交事务增加的数据</p>
<h6 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h6><p>通过设置隔离级别，解决以上三个问题。</p>
<p>默认是REPEATABLE_READ。</p>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20220129235129910.png" alt="image-20220129235129910"></p>
<h5 id="timeout：超时时间"><a href="#timeout：超时时间" class="headerlink" title="timeout：超时时间"></a>timeout：超时时间</h5><p>事务需要在一定时间内提交，超时则进行回滚。</p>
<p>默认值是-1(即，不超时)，设置时间以秒为单位进行计算。</p>
<h5 id="readOnly：是否只读"><a href="#readOnly：是否只读" class="headerlink" title="readOnly：是否只读"></a>readOnly：是否只读</h5><p>读：查询操作；写：添加、修改、删除操作</p>
<p>默认值为false，即可以查询，也可以修改、删除、添加等</p>
<p>设置为true时，即为只能查询。</p>
<h5 id="rollbackFor：回滚"><a href="#rollbackFor：回滚" class="headerlink" title="rollbackFor：回滚"></a>rollbackFor：回滚</h5><p>设置出现哪些异常进行事务回滚</p>
<h5 id="noRollbackFor：不回滚"><a href="#noRollbackFor：不回滚" class="headerlink" title="noRollbackFor：不回滚"></a>noRollbackFor：不回滚</h5><p>设置出现哪些异常不进行事务回滚</p>
<h3 id="完全注解方式"><a href="#完全注解方式" class="headerlink" title="完全注解方式"></a>完全注解方式</h3><h4 id="建立一个配置类"><a href="#建立一个配置类" class="headerlink" title="建立一个配置类"></a>建立一个配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc 配置类注解，组件扫描注解，开启事务注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages =&quot;com.test.spring5&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc 创建一个druid连接池的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/1/30 21:40</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> DruidDataSource&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">getDruidDataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/db_database10&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;654321&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc 创建JdbcTemplate对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/1/30 21:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> JdbcTemplate&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">getJdbcTemplate</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="comment">// 在IOC容器中，已经存在这样一个对象，到IOC容器中，根据类型获取对象</span></span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        jdbcTemplate.setDataSource(getDruidDataSource());</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc 创建事务管理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/1/30 21:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> DataSourceTransactionManager&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">getDataTransactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAccount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(TxConfig.class);</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    userService.accountMoney();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring5-新特性"><a href="#Spring5-新特性" class="headerlink" title="Spring5 新特性"></a>Spring5 新特性</h2><ol>
<li>整个Spring5框架的代码基于Java8，运行时兼容JDK9，许多不建议使用的类和方法在代码库中删除。</li>
<li><p>Spring5自带了通用的日志封装</p>
<ol>
<li><p>Spring5已经移除了Log4jConfigListener，官方建议使用Log4j2</p>
</li>
<li><p>Spring5框架整合Log4j2</p>
<ol>
<li><p>引入jar包</p>
<p><img src="https://s2.loli.net/2022/01/31/yW4GiDsE5ISPOMZ.png" alt="image-20220131203938791"></p>
</li>
<li><p>创建log4j2.xml配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;!--日志级别以及优先级排序：OFF&gt;FATAL&gt;ERROR&gt;WARN&gt;INFO&gt;DEBUG&gt;TRACE&gt;ALL--&gt;</span><br><span class="line">&lt;!--越往右，优先级越高，显示的内容越多--&gt;</span><br><span class="line">&lt;!--Configuration后面的status用于设置log4j2自身内部的信息输出，可以不设置，当设置为trace时，可以看到其内部的各种详细输出--&gt;</span><br><span class="line">&lt;configuration status=<span class="string">&quot;INFO&quot;</span>&gt;</span><br><span class="line">    &lt;appenders&gt;</span><br><span class="line">        &lt;!--输出日志信息到控制台--&gt;</span><br><span class="line">        &lt;console name=<span class="string">&quot;Console&quot;</span> target=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br><span class="line">            &lt;!--控制日志输出的格式--&gt;</span><br><span class="line">            &lt;PatternLayout pattern=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br><span class="line">        &lt;/console&gt;</span><br><span class="line">    &lt;/appenders&gt;</span><br><span class="line">    &lt;!--定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;</span><br><span class="line">    &lt;loggers&gt;</span><br><span class="line">        &lt;!--指定项目的根日志，如果没有单独指定Logger，则会使用root作为默认的日志输出--&gt;</span><br><span class="line">        &lt;root level=<span class="string">&quot;info&quot;</span>&gt;</span><br><span class="line">            &lt;appender-ref ref=<span class="string">&quot;Console&quot;</span>/&gt;</span><br><span class="line">        &lt;/root&gt;</span><br><span class="line">    &lt;/loggers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Nullable注解"><a href="#Nullable注解" class="headerlink" title="@Nullable注解"></a>@Nullable注解</h3><ol>
<li><p>Spring5框架核心容器支持@Nullable注解</p>
</li>
<li><p>@Nullable注解可以使用在方法上面、属性上面、参数上面，表示方法返回可以为空，属性值可以为空，参数值可以为空。</p>
</li>
</ol>
<h3 id="支持函数式风格GenericApplicationContext"><a href="#支持函数式风格GenericApplicationContext" class="headerlink" title="支持函数式风格GenericApplicationContext"></a>支持函数式风格GenericApplicationContext</h3><p>Spring5框架核心容器支持函数式风格。</p>
<p>利用lamda表达式，将手动创建的对象，在spring中，做个注册</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 函数式风格创建对象，交给Spring进行管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">GenericApplicationContextTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建GenericApplicationContext对象</span></span><br><span class="line">	<span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    <span class="comment">// 2. 调用context的方法对象注册</span></span><br><span class="line">    context.refresh();</span><br><span class="line">    context.registerBean(<span class="string">&quot;user1&quot;</span>, User.class,()-&gt;<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">    <span class="comment">// 3. 获取在Spring注册的对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)context.getBean(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整合JUnit5"><a href="#整合JUnit5" class="headerlink" title="整合JUnit5"></a>整合JUnit5</h3><h4 id="整合JUnit4"><a href="#整合JUnit4" class="headerlink" title="整合JUnit4"></a>整合JUnit4</h4><p>先，引入依赖spring-test-5.2.6.RELEASE.jar和JUnit4的library</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:bean1.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Junit4Test</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        userService.selectCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="整合JUnit5-1"><a href="#整合JUnit5-1" class="headerlink" title="整合JUnit5"></a>整合JUnit5</h4><ol>
<li>引入JUnit的jar包</li>
</ol>
<p><img src="https://s2.loli.net/2022/02/01/1EW3SpFRPk9NtaT.png" alt="image-20220201144000598"></p>
<p><img src="https://s2.loli.net/2022/02/01/OVx864NISmwgZly.png" alt="image-20220201144107119"></p>
<p>加上这个导入语句后，就可以选择引入</p>
<ol>
<li><p>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:bean1.xml&quot;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>符合注解，替代两个注解</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(locations=&quot;classpath:bean1.xml&quot;)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>The-core-of-Java</title>
    <url>/2022/01/01/The-core-of-Java/</url>
    <content><![CDATA[<h1 id="第四章-对象与类"><a href="#第四章-对象与类" class="headerlink" title="第四章 对象与类"></a>第四章 对象与类</h1><h2 id="第一节-面向对象程序设计概述"><a href="#第一节-面向对象程序设计概述" class="headerlink" title="第一节 面向对象程序设计概述"></a>第一节 面向对象程序设计概述</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类使构造对象的模板或蓝图。可以将类想象成制作小甜饼的切割机，将对象想象为小甜饼。由类构造对象的过程称为创建类的实例。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>(有时称为数据隐藏)是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在一个包里，并对对象的使用者隐藏了数据的实现方式。对象中的数据称为实例域，操纵数据的过程成为方法。对每个特定的类实例(对象)都有一组特定的实例域值。这些值的集合就是这个对象的当前状态。不管何时，只要向对象发送一个消息，他的状态就有可能发生改变。</p>
<p><strong>实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。</strong></p>
<p>这意味着一个类可以全面地改变存储数据的方式，只要仍然使用同样的方法操作数据，其他对象就不会知道或介意所发生的变化。</p>
<p>OOP的另一个原则会让用户自定义Java类变得轻而易举，这就是：可以通过扩展一个类来建立另一个新的类。事实上，在Java中，所有的类都源自于一个“超类”，他就是Object。</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="对象的三个主要特性："><a href="#对象的三个主要特性：" class="headerlink" title="对象的三个主要特性："></a>对象的三个主要特性：</h4><ul>
<li>对象的行为(behavior) —— 可以对对象施加哪些操作，或可以对对象施法哪些方法？</li>
<li>对象的状态(state) —— 当施加那些方法时，对象如何响应？</li>
<li>对象标识(identity) —— 如何辨别具有相同行为与状态的不同对象？</li>
</ul>
<p>同一个类的所有对象实例，由于支持相同的行为而具有家族式的相似性。对象的行为是用可调用的方法定义的。</p>
<p>此外，每个对象都保存着描述当前特征的信息。这就是对象的装填。对象状态的改变必须通过调用方法实现(如果不经过方法调用就可以改变对象的状态，只能说明封装性遭到了破坏)。</p>
<p>但是，对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份(identity)。也就是说，作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。</p>
<h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>在类之间，最常见的关系有</p>
<ul>
<li>依赖(“uses-a”)</li>
<li>聚合(“has-a”)</li>
<li>继承(“is-a”)</li>
</ul>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>即”uses-a”关系，是一种最明显的、最常见的关系。例如，Order(订单)类使用Account(账户)类是因为Order对象需要访问Account对象查看信用状态。但是Item类不依赖于Account类，这是因为Item对象与客户账户无关。因此，如果一个类的方法操纵另一个类的对象，就说一个类依赖于另一个类。</p>
<p>应该尽可能地将相互依赖的类减至最少。就是让类之间的耦合度最小。</p>
<h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>即”has-a”关系，是一种具体且易于理解的关系。例如，一个Order对象包含一些Item(商品)类。</p>
<p>聚合关系意味着类A的对象包含类B的对象。</p>
<blockquote>
<p>有些方法学家，会更喜欢使用“关联”这个术语，而不喜欢聚合这个概念。</p>
</blockquote>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>即“is-a”关系，是一种用于表示特殊与一般关系的。例如，RushOrder类由Order类继承而来。在具有特殊性的RushOrder类中包含了一些用于优先处理的特殊方法，以及一个计算运费的不同方法。</p>
<h2 id="第二讲-使用预定义类"><a href="#第二讲-使用预定义类" class="headerlink" title="第二讲 使用预定义类"></a>第二讲 使用预定义类</h2><h3 id="更改器方法与访问器方法"><a href="#更改器方法与访问器方法" class="headerlink" title="更改器方法与访问器方法"></a>更改器方法与访问器方法</h3><p><code>LocalDate aThousandDaysLater = newYearsEve.plusDays(1000);</code></p>
<p>这个调用之后newYearsEve会有什么变化？他会改为1000天之后的日期吗？事实上，并没有。plusDays方法会生成一个新的LocalDate对象，然后把这个新对象赋给aThousandDaysLater变量。原来的对象不做任何改动。也就是说plusDays方法没有更改调用这个方法的对象。</p>
<p>则称，只访问对象而不修改对象的方法为<strong>访问器方法</strong>(accessor method)。</p>
<p><strong>更改器方法</strong>(mutator method)调用后，对象的状态会发生改变。</p>
<h2 id="第三讲-用户自定义类"><a href="#第三讲-用户自定义类" class="headerlink" title="第三讲 用户自定义类"></a>第三讲 用户自定义类</h2><h3 id="隐式参数与显式参数"><a href="#隐式参数与显式参数" class="headerlink" title="隐式参数与显式参数"></a>隐式参数与显式参数</h3><p>方法用于操作对象以及存取它们的实例域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">raiseSalary</span> <span class="params">(<span class="type">double</span> byPercent)</span> &#123;</span><br><span class="line">	<span class="type">double</span> <span class="variable">raise</span> <span class="operator">=</span> salary * byPercent/ <span class="number">100</span>;</span><br><span class="line">    salary = raise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有两个参数。第一个参数称为隐式(implicit)参数，是出现在方法名前面Employee对象。第二个参数是位于方法名后面括号中的数值，这是一个显式(explicit)参数。(隐式参数也就是方法调用的目标或接收者)</p>
<h3 id="封装的优点"><a href="#封装的优点" class="headerlink" title="封装的优点"></a>封装的优点</h3><p><code>public double getSalary() &#123;return salary;&#125;</code></p>
<p>如上是典型的访问器方法。由于它们只返回实例域值，因此又称为域访问器。</p>
<p>那将salary域标记为public，以此来取代独立的访问器方法呢？</p>
<p>假如salary是一个只读域，那么一旦在构造器中设置完毕，就没有任何一个方法可以对它进行修改，这样来确保salary域不会受到外界的破坏。</p>
<p>不过，虽然salary不是只读域，但是它只能用raiseSalary方法修改。特别是一旦这个域值出现了错误，只要调试这个方法就可以了。如果salary域是public的，破坏这个域值的捣乱者有可能会出没在任何地方。</p>
<p>在有些时候，需要获得或设置实例域的值。因此，应该提供下面三项内容：</p>
<ul>
<li>一个私有的数据域；</li>
<li>一个公有的域访问器方法；</li>
<li>一个公有的域更改器方法。</li>
</ul>
<p>这样做要比提供一个简单的公有数据域复杂些。但是却有着下列明显的好处：</p>
<p>首先，可以改变内部实现，除了该类的方法之外，不会影响其他代码。</p>
<p>其次，更改器可以进行错误检查，防止一些不合理的赋值。</p>
<h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><p>尽管大多数方法都被设计为公有的，但在某些特殊的情况下，也可能将它们设定为私有的。有时，可能希望将一个计算代码划分成若干独立的辅助方法。通常，这些辅助方法不应该成为公有方法的一部分，这是由于它们往往与当前的实现机制非常紧密，或者需要一个特别的协议以及一个特别的调用次序，最好将这样的方法设计为private的。</p>
<p>对于私有方法，如果改用其它方法实现相应的操作，则不必保留原有方法。如果数据的表达方式发生了变化，这个方法可能就变得难以实现，或者不再需要。然而，只要方法是private，类的设计者就可以确认，<strong>它不会被外部的其他类操作调用，可以将其删除。</strong></p>
<h3 id="final实例域"><a href="#final实例域" class="headerlink" title="final实例域"></a>final实例域</h3><p>可以将一个实例域定义为final，构建对象时，必须初始化这样的域。也就是说，必须在确保一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。</p>
<p>final修饰符大都应用于基本(primitive)类型域，或不可变(immutable)类的域(如果类中的每个方法都不会改变其对象，这种类就是不可变的类。)。</p>
<p>如果final修饰的是类的话，也就表示，该引用变量不能再指向其他对象，但对象的值可以发生改变。</p>
<h2 id="第四讲-静态域与静态方法"><a href="#第四讲-静态域与静态方法" class="headerlink" title="第四讲 静态域与静态方法"></a>第四讲 静态域与静态方法</h2><h3 id="静态域-类域"><a href="#静态域-类域" class="headerlink" title="静态域(类域)"></a>静态域(类域)</h3><p>如果将域定义为static，每个类中只有一个这样的域。它属于类，而不属于任何一个独立的对象。</p>
<p>每个对象对于类的实例域都有自己的一份拷贝。如，100个对象，会有100个实例域，但只有1个静态域。</p>
<h3 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h3><p>静态变量用的比较少，但静态常量却用的多。例如：</p>
<p><img src="https://s2.loli.net/2022/01/03/A5zFJnPmtY7h64w.png" alt="image-20220103161658620"></p>
<p>一般来说，由于任何对象都可以对公有域进行修改，所以，最好不要将域设计为public，但公有常量(final域)却没有关系，因为此时，不允许再赋其他值给它。</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><strong>静态方法是一种不能向对象实施的方法</strong>。例如，Math类中的pow：<code>Math.pow(x,a)</code>，在运算时，不使用任何的Math对象。换句话说，没有隐式的参数。</p>
<h3 id="使用静态方法"><a href="#使用静态方法" class="headerlink" title="使用静态方法"></a>使用静态方法</h3><p>在下面两种情况下使用静态方法：</p>
<ul>
<li>一个方法不需要访问对象状态，其所需的参数都是通过显示参数提供的</li>
<li>一个方法只需要访问类的静态域</li>
</ul>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>静态方法还有另一个用途，类似LocalDate和NumberFormat的类使用静态工厂方法(factory method)来构造对象。如下所示，生成不同风格的格式化对象：</p>
<p><img src="https://s2.loli.net/2022/01/03/YHGeydBEaxTtRFn.png" alt="image-20220103163937139"></p>
<p>为什么不使用构造器？</p>
<ul>
<li>无法命名构造器。构造器的名字必须和类名相同。但是，这里希望将得到的货币实例和百分比实例采用不同的名字。</li>
<li>当使用构造器时，无法改变所构造的对象类型。而Factory方法将返回一个DecimalFormat类对象，这是NumberFormat的子类。</li>
</ul>
<h2 id="第五讲-方法参数"><a href="#第五讲-方法参数" class="headerlink" title="第五讲 方法参数"></a>第五讲 方法参数</h2><p>方法参数一共有两种类型：</p>
<ul>
<li>基本数据类型</li>
<li>对象引用</li>
</ul>
<p>对于Java而言，总是采用按值调用。</p>
<p>也就是说，一个方法不可能修改一个基本数据类型的参数。</p>
<p><img src="https://s2.loli.net/2022/01/03/py5Tt4QFhe6kUr3.png" alt="image-20220103165356193"></p>
<p>而对象引用作为参数就不同了。</p>
<p><img src="https://s2.loli.net/2022/01/03/gh1LAIFiPGyxBTu.png" alt="image-20220103165431987"></p>
<p>因为对象的空间是固定的，拷贝的是引用，二者同时引用同一个对象，即指向一个固定的堆空间。</p>
<p>但要记住，Java程序设计语言总是采用<strong>按值调用</strong>，不是类似C++中的引用。也就是说，传递的不是地址！若是直接将两个对象引用作为参数进行交换操作，并不能实现对象指向的交换。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>一个方法不能修改一个基本数据类型的参数(数值型或布尔型)</li>
<li>一个方法可以改变一个对象参数的状态</li>
<li>一个方法不能让对象参数引用一个新的对象</li>
</ul>
<h2 id="第六讲-对象构造"><a href="#第六讲-对象构造" class="headerlink" title="第六讲 对象构造"></a>第六讲 对象构造</h2><h3 id="显式域初始化"><a href="#显式域初始化" class="headerlink" title="显式域初始化"></a>显式域初始化</h3><p>通过重载类的构造器方法，可以采用多种形式设置类的实例域的初始状态。确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值，这是一种很好的设计习惯。</p>
<h3 id="调用另一个构造器"><a href="#调用另一个构造器" class="headerlink" title="调用另一个构造器"></a>调用另一个构造器</h3><p>关键字this引用方法的隐式参数。不过这个关键字还有另一个含义。</p>
<p>如果构造器的第一个语句形如this(…)，这个构造器将调用同一个类的另一个构造器。</p>
<p><img src="https://s2.loli.net/2022/01/03/INWmxkURs9B2tCY.png" alt="image-20220103202413693"></p>
<p>在调用这个方法时，该方法将去调用Employee(String, double)构造器。</p>
<p>这种方式使用this关键字非常有用，这样对公共的构造器代码部分只编写一次即可。</p>
<blockquote>
<p>但C++中，一个构造器不能调用另一个构造器。</p>
</blockquote>
<h3 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h3><h4 id="初始化数据域的方法"><a href="#初始化数据域的方法" class="headerlink" title="初始化数据域的方法"></a>初始化数据域的方法</h4><ul>
<li>在构造器中设置值</li>
<li>在声明中赋值</li>
<li>初始化块</li>
</ul>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。</p>
<p><img src="https://s2.loli.net/2022/01/03/7qXQc8sgJHDrL2w.png" alt="image-20220103203502225"></p>
<p>这种机制不是必需的，也不常见。通常会直接将初始化代码放在构造器中。</p>
<p><img src="https://s2.loli.net/2022/01/03/vYbOosAtuxQDmaX.png" alt="image-20220103204013531"></p>
<p>当然，应该精心地组织好初始化代码。</p>
<h3 id="静态域初始化"><a href="#静态域初始化" class="headerlink" title="静态域初始化"></a>静态域初始化</h3><ul>
<li>提供一个初始化值</li>
</ul>
<p><code>private static int nextId = 1;</code></p>
<ul>
<li>使用静态的初始化块</li>
</ul>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20220104011743662.png" alt="image-20220104011743662"></p>
<h3 id="对象析构与finalize方法"><a href="#对象析构与finalize方法" class="headerlink" title="对象析构与finalize方法"></a>对象析构与finalize方法</h3><p>在析构器中，最常见的操作是回收分配给对象的存储空间。由于Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器。</p>
<p>当然，某些对象使用了内存之外的其他资源，例如，文件或使用了系统资源的另一个对象的句柄。在这种情况下，当资源不再需要时，将其回收和再利用将显得十分重要。</p>
<p>可以为类添加一个finalize方法。finalize方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用finalize方法回收任何短缺资源，这是因为很难直到这个方法什么时候才能够调用。</p>
<p><strong>如果某个资源需要在使用完毕后立刻被关闭，那么就需要由人工来管理。对象用完时，可以应用一个close方法来完成相应的清理操作。</strong></p>
<h2 id="第七讲-包"><a href="#第七讲-包" class="headerlink" title="第七讲 包"></a>第七讲 包</h2><h3 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h3><p>Java允许将包(package)将类组织起来。</p>
<p>使用包的主要原因时去确保类名的唯一性。</p>
<p>在包中定位类是编译器(compiler)的工作。类文件中的字节码肯定使用完整的包名来引用其他类。</p>
<blockquote>
<p>关于C++中import和#include弄混。</p>
<p>实际上，这两者之间并没有共同之处。在C++中，必须使用#include将外部特性的声明加载进来，这是因为C++编译器无法查看任何文件的内部，除了正在编译的文件以及在头文件中明确包含的文件。Java编译器可以查看其他文件的内容，只要告诉它到哪里去查看就可以了。</p>
<p>在C++中，与包机制类似的是命名空间(namespace)。在Java中。package与import语句类似于C++中的namespace和using指令。</p>
</blockquote>
<h3 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h3><p>前面已经接触过访问修饰符public和private。标记为public的部分可以被任意的类使用，标记为private的部分只能被定义它们的类使用。</p>
<p><strong>如果没有指定public或private，这个部分(类、方法或变量)可以被同一个包的所有方法访问。</strong></p>
<h3 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1）把类放到一个目录中，例如/home/user/classdir。</p>
<p>需要注意，这个目录是包树状结构的基目录。如果希望将com.horstmann.corejava.Employee类添加到其中，这个Employee.class类文件就必须位于子目录/home/user/classdir/com/horstmann/corejava中。</p>
<p>2）将JAR文件放在一个目录中，例如：/home/user/archives。</p>
<p>3）设置类路径（class path）。类路径是所有包含类文件的路径的集合。</p>
<p>在UNIX环境中，类路径中的不同项目之间采用冒号（:)分隔：</p>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20220105154939555.png" alt="image-20220105154939555"></p>
<p>在上述两种情况中，句点（.）表示当前目录。</p>
<p>类路径包括：</p>
<p>●  基目录/home/user/classdir或c:\classes；</p>
<p>●  当前目录(.)；</p>
<p>●  JAR文件/home/user/archives/archive.jar或c:\archives\archive.jar。</p>
<h2 id="第九讲-文档注释"><a href="#第九讲-文档注释" class="headerlink" title="第九讲 文档注释"></a>第九讲 文档注释</h2><h3 id="1-方法注释"><a href="#1-方法注释" class="headerlink" title="1. 方法注释"></a>1. 方法注释</h3><p>每个方法注释必须放在所描述的方法之前。</p>
<p>除了通用标记之外，还可以使用下面的标记：</p>
<ul>
<li>@param 变量描述</li>
</ul>
<p>这个标记将对当前方法的“param”(参数)部分参加一个条目。这个描述可以占据多行，并可以使用HTML标记。一个方法的所有的@param标记必须放在一起。</p>
<ul>
<li>@return 描述</li>
</ul>
<p>这个标记将对当前添加”return”(返回)部分。这个描述可以跨越多行，并可以使用HTML标记。</p>
<ul>
<li>@throws 类描述</li>
</ul>
<p>这个标记将添加一个注释，用于表示这个方法可能抛出异常。</p>
<p><img src="https://s2.loli.net/2022/01/05/jDElf7oyhQ3ZTrv.png" alt="image-20220105160743393"></p>
<p><img src="https://s2.loli.net/2022/01/05/we6qAjmNELdGviu.png" alt="image-20220105161216316"></p>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20220105161131526.png" alt="image-20220105161131526"></p>
<h3 id="2-域注释"><a href="#2-域注释" class="headerlink" title="2. 域注释"></a>2. 域注释</h3><p><img src="https://s2.loli.net/2022/01/05/dGbf7SkvEDAqYpJ.png" alt="image-20220105161654770"></p>
<h3 id="3-通用注释"><a href="#3-通用注释" class="headerlink" title="3. 通用注释"></a>3. 通用注释</h3><ul>
<li>@author 姓名</li>
</ul>
<p>这个标记将产生一个”author”(作者)条目。可以使用多个@author标记，每个@author标记对应一个作者。</p>
<ul>
<li>@version 文本</li>
</ul>
<p>这个标记将产生一个“version”(版本)条目。这里的文本可以是对当前版本的任何描述。</p>
<h4 id="4-下面的标记可以用于所有的文档注释"><a href="#4-下面的标记可以用于所有的文档注释" class="headerlink" title="4. 下面的标记可以用于所有的文档注释"></a>4. 下面的标记可以用于所有的文档注释</h4><ul>
<li>@since 文本</li>
</ul>
<p>这个标记将产生一个“since”(始于)条目。这里的text可以是对引入特性的版本描述。例如，@since version 1.7.1。</p>
<ul>
<li>@deprecated文本</li>
</ul>
<p>这个标记将对类、方法或变量天机一个不再使用的注释。文本中给出了取代的建议。</p>
<p><img src="https://s2.loli.net/2022/01/05/kG4KaUy9HYEJdMR.png" alt="image-20220105162315965"></p>
<p><img src="https://s2.loli.net/2022/01/05/X3oF6BbLTYkrGgQ.png" alt="image-20220105162409646"></p>
<h2 id="类设计的技巧"><a href="#类设计的技巧" class="headerlink" title="类设计的技巧"></a>类设计的技巧</h2><h3 id="1-一定要保证数据私有"><a href="#1-一定要保证数据私有" class="headerlink" title="1. 一定要保证数据私有"></a>1. 一定要保证数据私有</h3><p>这是最重要的！</p>
<p><strong>绝对不要破坏封装性。有时候，需要编写一个访问器方法或更改器方法，但是最好还是保持实例域的私有性。</strong></p>
<p>很多惨痛的经验告诉我们，数据的表示形式很可能会改变，但他们的使用方式却不会经常发生变化。</p>
<p>当数据保持私有时，他们的表示形式的变化不会对类的使用者产生影响，即使出现bug也易于检测。</p>
<h3 id="2-一定要对数据初始化"><a href="#2-一定要对数据初始化" class="headerlink" title="2. 一定要对数据初始化"></a>2. 一定要对数据初始化</h3><p>Java不对局部变量进行初始化，但是会对对象的实力域进行初始化。最好不要依赖于系统的默认值，而是应该显式地初始化所有的数据。</p>
<p>具体的初始化方式可以是提供默认值，也可以是在所有构造器中设置默认值。</p>
<h3 id="3-不要在类中使用过多的基本类型"><a href="#3-不要在类中使用过多的基本类型" class="headerlink" title="3. 不要在类中使用过多的基本类型"></a>3. 不要在类中使用过多的基本类型</h3><p>就是说，用其他的类代替多个相关的基本类型的使用。</p>
<p>这样会使类更加易于理解且易于修改。</p>
<p><img src="https://s2.loli.net/2022/01/05/J4oiebVBCzvHKFk.png" alt="image-20220105163502555"></p>
<h3 id="4-不是所有的域都需要独立的域访问器和域更改器"><a href="#4-不是所有的域都需要独立的域访问器和域更改器" class="headerlink" title="4. 不是所有的域都需要独立的域访问器和域更改器"></a>4. 不是所有的域都需要独立的域访问器和域更改器</h3><p>或许，需要获得或设置雇员的薪金。而一旦构造了雇员对象，就应该禁止更改雇佣日期，并且在对象中，常常包含一些不希望别人获得或设置的实例域。</p>
<h3 id="5-将职责过多的类进行分解"><a href="#5-将职责过多的类进行分解" class="headerlink" title="5. 将职责过多的类进行分解"></a>5. 将职责过多的类进行分解</h3><p>这样说似乎有点含糊不清。</p>
<p>但是，如果明显地可以将一个复杂的类分解成两个更为简单的类，就应该将其分解。</p>
<h3 id="6-类名和方法名要能够体现它们的职责"><a href="#6-类名和方法名要能够体现它们的职责" class="headerlink" title="6. 类名和方法名要能够体现它们的职责"></a>6. 类名和方法名要能够体现它们的职责</h3><p>与变量应该有一个能够反映其含义的名字一样，类也能如此。</p>
<p>命名类名的良好习惯是采用一个名词(Order)、前面有形容词修饰的名词(RushOrder)或动名词(有“-ing”后缀)修饰名词(例如，BillingAddress)。</p>
<p>对于方法来说，习惯是访问器方法用小写get开头(getSalary)，更改器方法用小写的set开头(setSalary)。</p>
<h3 id="7-优先使用不可变的类"><a href="#7-优先使用不可变的类" class="headerlink" title="7. 优先使用不可变的类"></a>7. 优先使用不可变的类</h3><p>LocalDate类以及java.time包中的其他类是不可变的——没有方法能修改对象的状态。类似plusDays的方法并不是更改对象，而是返回状态已修改的新对象。</p>
<p>更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改。</p>
<p>其结果是不可预料的。如果类是不可变的，就可以安全地在多个线程间共享其对象。</p>
<p>因此，要尽可能让类是不可变的，这是一个很好的想法。对于表示值的类，如一个字符串或一个时间点，这尤其容易。计算会生成新值，而不是更新原来的值。</p>
<p>当然，并不是所有类都应当是不可变的。如果员工加薪时让raiseSalary方法返回一个新的Employee对象，这会很奇怪。</p>
<h1 id="第五章-继承"><a href="#第五章-继承" class="headerlink" title="第五章 继承"></a>第五章 继承</h1><h2 id="第一讲-类、超类和子类"><a href="#第一讲-类、超类和子类" class="headerlink" title="第一讲  类、超类和子类"></a>第一讲  类、超类和子类</h2><p>关键字extends表明正在构造的新类派生于一个已存在的类。</p>
<p><img src="https://s2.loli.net/2022/01/06/w4toM6dX5z7RUcm.png" alt="image-20220106213143904"></p>
<p>然而，这个方法并不能运行。这是因为Manager类的getSalary方法不能直接地访问超类的私有域。也就是说，尽管每个Manager对象都拥有一个名为salary的域，但在Manager类的getSalary方法中并不能够直接地访问salary域。只有Employee类的方法才能够访问私有部分。如果Manager类的方法一定要访问私有域，就必须借助于公有的接口，Employee类的公有方法getSalary正是这样一个接口。</p>
<p>这里需要指出：我们希望调用超类Employee的getSalary方法，而不是当前类的这个方法。为此，可以使用特定的关键字super解决这个问题：</p>
<p><img src="https://s2.loli.net/2022/01/06/qjSvxMA6JmKkXZi.png" alt="image-20220106213904248"></p>
<blockquote>
<h3 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h3><p>有些人认为super与this引用是类似的概念，实际上：</p>
<p><strong>super并不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。</strong></p>
<p>this两个用途：</p>
<ul>
<li>引用隐式参数</li>
<li>调用该类的其他的构造器(第一条语句)</li>
</ul>
<p>super两个用途：</p>
<ul>
<li>调用超类的方法</li>
<li>调用超类的构造器(第一条语句)</li>
</ul>
</blockquote>
<p><img src="https://s2.loli.net/2022/01/06/584HmLGXJPiYanW.png" alt="image-20220106214721586"></p>
<p>当e引用Employee对象时，e.getSalary( )调用的是Employee类中的getSalary方法；当e引用Manager对象时，e.getSalary( )调用的是Manager类中的getSalary方法。</p>
<p>虚拟机知道e实际引用的对象类型，因此能够正确地调用相应的方法。</p>
<p>一个对象变量（例如，变量e）可以指示多种实际类型的现象被称为<strong>多态</strong>（polymorphism）。</p>
<p>在运行时能够自动地选择调用哪个方法的现象称为<strong>动态绑定</strong>（dynamic binding）。</p>
<h3 id="第五节-多态"><a href="#第五节-多态" class="headerlink" title="第五节 多态"></a>第五节 多态</h3><p>在Java程序设计语言里，<strong>对象变量是多态的</strong>。一个Employee变量既可以引用一个Employee类的对象，也可以引用一个Employee类的任何一个子类的对象，如Manager对象。</p>
<p><img src="https://s2.loli.net/2022/01/06/GIFhMEeC9s247LB.png" alt="image-20220106215805539"></p>
<p><img src="https://s2.loli.net/2022/01/06/yJeQb6hGTlD2sfV.png" alt="image-20220106215854899"></p>
<p>因为，staff[0]声明的类型是Employee，而setBonus不是Employee类的方法。</p>
<p><img src="https://s2.loli.net/2022/01/06/8ytxkeBmWQTjna1.png" alt="image-20220106220145915"></p>
<p>在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。</p>
<p><img src="https://s2.loli.net/2022/01/06/GXA2CRPaQkOjech.png" alt="image-20220106220331459"></p>
<p>使用new Manager[10]创建的数组是一个经理数组，如果试图存储一个Employee类型的引用就会引发ArrayStoreException异常。</p>
<h3 id="第六节-理解方法调用"><a href="#第六节-理解方法调用" class="headerlink" title="第六节 理解方法调用"></a>第六节 理解方法调用</h3><p>弄清楚如何在对象上应用方法调用非常重要。</p>
<p>下面假设要调用x.f(args)，隐式参数x声明为类C的一个对象。</p>
<h4 id="1-下面是调用过程的详细描述："><a href="#1-下面是调用过程的详细描述：" class="headerlink" title="1. 下面是调用过程的详细描述："></a>1. 下面是调用过程的详细描述：</h4><p><strong>1）编译器查看对象的声明类型和方法名。</strong></p>
<p>假设调用x.f(param)，且隐式参数x声明为C类的对象。需要注意的是：有可能存在多个名字为f，但参数类型不一样的方法。例如，可能存在方法f(int)和方法f(String)。编译器将会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法（超类的私有方法不可访问）。至此，编译器已获得所有可能被调用的候选方法。</p>
<p><strong>2）接下来，编译器将查看调用方法时提供的参数类型。</strong></p>
<p>如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为重载解析（overloading resolution）。例如，对于调用x.f(“Hello”)来说，编译器将会挑选f(String)，而不是f(int)。由于允许类型转换（int可以转换成double, Manager可以转换成Employee，等等），所以这个过程可能很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。</p>
<p>至此，编译器已获得需要调用的方法名字和参数类型。</p>
<blockquote>
<h4 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h4><p>前面曾经说过，<strong>方法的名字和参数列表称为方法的签名。</strong></p>
<p>例如，f(int)和f(String)是两个具有相同名字，不同签名的方法。如果在子类中定义了一个与超类签名相同的方法，那么子类中的这个方法就覆盖了超类中的这个相同签名的方法。</p>
<p>不过，返回类型不是签名的一部分，因此，在覆盖方法时，一定要保证返回类型的兼容性。</p>
<p>允许子类将覆盖方法的返回类型定义为原返回类型的子类型</p>
</blockquote>
<p><strong>3）如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为静态绑定（static binding）。</strong></p>
<p>与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。在我们列举的示例中，编译器采用动态绑定的方式生成一条调用f (String)的指令。</p>
<p><strong>4）当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。</strong></p>
<p>假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就直接调用它；否则，将在D类的超类中寻找f(String)，以此类推。</p>
<h4 id="2-方法表"><a href="#2-方法表" class="headerlink" title="2. 方法表"></a>2. 方法表</h4><p>每次调用方法都要进行搜索，时间开销相当大。</p>
<p>因此，虚拟机预先为每个类创建了一个<strong>方法表（method table）</strong>，其中列出了所有方法的签名和实际调用的方法。</p>
<p>这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。</p>
<p>在前面的例子中，虚拟机搜索D类的方法表，以便寻找与调用f(Sting)相匹配的方法。这个方法既有可能是D.f(String)，也有可能是X.f(String)，这里的X是D的超类。这里需要提醒一点，如果调用super.f(param)，编译器将对隐式参数超类的方法表进行搜索。</p>
<p><img src="https://s2.loli.net/2022/01/06/vgGCnimSphPfyWJ.png" alt="image-20220106222122309"></p>
<p>动态绑定有个非常重要的特性：</p>
<p>无需对现存的代码进行修改，就可以对程序进行拓展。假设增加一个新类Executive，并且变量e有可能引用这个类的对象，我们不需要对包含调用e.getSalary()的代码进行重新编译。如果e恰好引用一个Executive类的对象，就会自动地调用Executive.getSalary()方法。</p>
<h3 id="第八讲-强制类型转换"><a href="#第八讲-强制类型转换" class="headerlink" title="第八讲 强制类型转换"></a>第八讲 强制类型转换</h3><p><img src="https://s2.loli.net/2022/01/06/HyVSjae4CBIZvrg.png" alt="image-20220106222959327"></p>
<h4 id="进行的唯一原因"><a href="#进行的唯一原因" class="headerlink" title="进行的唯一原因"></a>进行的唯一原因</h4><p>在暂时忽视对象的实际类型之后，使用对象的全部功能。</p>
<p>例如，我们需要将数组中引用经理的元素复原成Manager类，以便能够访问新增加的所有变量。</p>
<p><strong>将一个值存入变量时，编译器将检查是否允许该操作。</strong></p>
<p><strong>将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检查。</strong></p>
<h4 id="因此"><a href="#因此" class="headerlink" title="因此"></a>因此</h4><p>应该养成这样一个良好的程序设计习惯：</p>
<p>在进行类型转换之前，先查看一下是否能够成功地转换。这个过程简单地使用instanceof操作符就可以实现。</p>
<p><img src="https://s2.loli.net/2022/01/06/P6xaWHNV2iBznck.png" alt="image-20220106223351872"></p>
<p>在一般情况下，应当尽量少用强制类型转换和instanceof。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>只能在继承层次内进行类型转换。</li>
<li>再将超类转换成子类之前，应该使用instanceof进行检查。</li>
</ul>
<h3 id="第九节-抽象类"><a href="#第九节-抽象类" class="headerlink" title="第九节 抽象类"></a>第九节 抽象类</h3><p><img src="https://s2.loli.net/2022/01/06/n57lrmIu4kg2Q9C.png" alt="image-20220106223848993"></p>
<p>在Person中，</p>
<p><img src="https://s2.loli.net/2022/01/06/k9eO1AjQcEUxDNn.png" alt="image-20220106224101130"></p>
<p><strong>许多程序员认为，在抽象类中不能包含具体方法。建议尽量将通用的域和方法（不管是否是抽象的）放在超类（不管是否是抽象类）中。</strong></p>
<p>抽象方法充当着占位的角色，它们的具体实现在子类中。</p>
<h4 id="1-扩展抽象类可以有两种选择。"><a href="#1-扩展抽象类可以有两种选择。" class="headerlink" title="1. 扩展抽象类可以有两种选择。"></a>1. 扩展抽象类可以有两种选择。</h4><ul>
<li><p>一种是在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类；</p>
</li>
<li><p>另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。</p>
</li>
</ul>
<p>例如，通过扩展抽象Person类，并实现getDescription方法来定义Student类。由于在Student类中不再含有抽象方法，所以不必将这个类声明为抽象的。类即使不含抽象方法，也可以将类声明为抽象类。</p>
<h4 id="2-抽象类不能被实例化。"><a href="#2-抽象类不能被实例化。" class="headerlink" title="2. 抽象类不能被实例化。"></a>2. 抽象类不能被实例化。</h4><p>也就是说，如果将一个类声明为abstract，就不能创建这个类的对象。</p>
<p><strong>需要注意，可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。</strong>例如，</p>
<p><img src="https://s2.loli.net/2022/01/06/pZyfraxLwRIiOUE.png" alt="image-20220106224627968"></p>
<p>这里的p是一个抽象类Person的变量，Person引用了一个非抽象子类Student的实例。</p>
<h3 id="Java用于控制可见性的4个访问修饰符："><a href="#Java用于控制可见性的4个访问修饰符：" class="headerlink" title="Java用于控制可见性的4个访问修饰符："></a>Java用于控制可见性的4个访问修饰符：</h3><ul>
<li>仅对本类可见——private。</li>
<li>对所有类可见——public。</li>
<li>对本包和所有子类可见——protected。</li>
<li>对本包可见——默认（很遗憾），不需要修饰符。</li>
</ul>
<h2 id="第二讲-Object：所有类的超类"><a href="#第二讲-Object：所有类的超类" class="headerlink" title="第二讲 Object：所有类的超类"></a>第二讲 Object：所有类的超类</h2><p>在Java中，只有基本类型不是对象。</p>
<h3 id="第一节-equals-方法"><a href="#第一节-equals-方法" class="headerlink" title="第一节 equals 方法"></a>第一节 equals 方法</h3><p><img src="https://s2.loli.net/2022/01/17/zDTi9tMsyOCfbPg.png" alt="image-20220117213943571"></p>
<blockquote>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p><strong>为了防备name或hireDay可能为null的情况，需要使用Objects.equals方法。</strong></p>
<p>如果两个参数都为null, Objects.equals(a, b)调用将返回true；如果其中一个参数为null，则返回false；否则，如果两个参数都不为null，则调用a.equals(b)。利用这个方法，Employee.equals方法的最后一条语句要改写为：</p>
<p><img src="https://s2.loli.net/2022/01/17/VuKSeBdMj5lN2zc.png" alt="image-20220117225732398"></p>
</blockquote>
<p>在子类中定义equals方法时，首先调用超类的equals。如果检测失败，对象就不可能相等。如果超类中的域都相等，就需要比较子类中的实例域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object otherObject)</span> &#123;</span><br><span class="line">        <span class="comment">// super.equals checked that this and otherObject belong to the same class</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">super</span>.equals(otherObject))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">other</span> <span class="operator">=</span> (Manager) otherObject;</span><br><span class="line">        <span class="type">return</span> <span class="variable">bonus</span> <span class="operator">=</span>= other.bonus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java语言规范要求equals方法具有下列特性：</p>
<ol>
<li><strong>自反性</strong>：对于任何非空引用x,  x.equals(x)应该返回true。</li>
<li><strong>对称性</strong>：对于任何引用x和y，当且仅当y.equals(x)返回true， x.equals(y)也应该返回true。</li>
<li><strong>传递性</strong>：对于任何引用x、y和z，如果x.equals(y)返回true， y.equals(z)返回true， x.equals(z)也应该返回true。</li>
<li><strong>一致性</strong>：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果。</li>
<li><strong>对于任意非空引用x， x.equals(null)应该返回false。</strong></li>
</ol>
<p><img src="https://s2.loli.net/2022/01/17/2pbVS14yPh8EQfC.png" alt="image-20220117232952358"></p>
<h4 id="下面给出编写一个完美的equals方法的建议："><a href="#下面给出编写一个完美的equals方法的建议：" class="headerlink" title="下面给出编写一个完美的equals方法的建议："></a>下面给出编写一个完美的equals方法的建议：</h4><p>1）显式参数命名为otherObject，稍后需要将它转换成另一个叫做other的变量。</p>
<p>2）检测this与otherObject是否引用同一个对象：</p>
<p><code>if (this == otherObject) return true;</code></p>
<p>这条语句只是一个优化。实际上，这是一种经常采用的形式。</p>
<p><strong>因为计算这个等式要比一个一个地比较类中的域所付出的代价小得多。</strong></p>
<p>3）检测otherObject是否为null，如果为null，返回false。这项检测是很必要的。</p>
<p><code>if (otherObject == null) return false;</code></p>
<p>4）比较this与otherObject是否属于同一类。如果equals的语义在每个子类中有所改变，就使用getClass检测：</p>
<p><code>if (getClass() != otherObject.getClass()) return false;</code></p>
<p>如果所有的子类都拥有统一的语义，就使用instanceof检测：</p>
<p><code>if (!(otherObject instanceof ClassName)) return false;</code></p>
<p>5）将otherObject转换为相应的类类型变量：</p>
<p><code>ClassName other = (ClassName) otherObject</code></p>
<p>6）现在开始对所有需要比较的域进行比较了。使用==比较基本类型域，使用equals比较对象域。如果所有的域都匹配，就返回true；否则返回false。</p>
<p><code>return field1 == other.field1 &amp;&amp; Objects.equals(field2, other.fields) &amp;&amp; ...;</code></p>
<p>如果在子类中重新定义equals，就要在其中包含调用super.equals(other)。</p>
<blockquote>
<p>对于数组类型的域，可以使用静态的Arrays.equals方法检测相应的数组元素是否相等。</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/01/18/f19UtvBs7MEOdCH.png" alt="image-20220118001450380"></p>
<h3 id="第二节-hashcode方法"><a href="#第二节-hashcode方法" class="headerlink" title="第二节 hashcode方法"></a>第二节 hashcode方法</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><p>散列码(hashcode)是由对象导出的一个整型值。散列码是没有规律的。如果x和y是两个不同的对象，x.hashCode( )与y.hashCode( )基本上不会相同。</p>
<p><img src="https://s2.loli.net/2022/01/18/KBXh3gSZmtCG4Mx.png" alt="image-20220118003233455"></p>
<p><img src="https://s2.loli.net/2022/01/18/rRsCczkHXWQvZ5d.png" alt="image-20220118003328447"></p>
<h4 id="2-为什么要有hashCode"><a href="#2-为什么要有hashCode" class="headerlink" title="2. 为什么要有hashCode"></a>2. 为什么要有hashCode</h4><p>当你把对象加入HashSet时，HashSet会先计算对象的hashCode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashCode值作比较，如果没有相符的hashCode，HashSet会假设对象没有重复出现。</p>
<p>但是如果发现有相同hashCode值的对象，这是会调用equals( )方法来检查hashCode相等的对象是否真的相同。</p>
<p>若两者相同，HashSet就不会让其加入成功，如果不同的话，就会重新散列到不同的位置。这样就减少了调用equals( )方法的次数，提高了执行速度。</p>
<h4 id="3-equals-和hashCode"><a href="#3-equals-和hashCode" class="headerlink" title="3. equals( )和hashCode( )"></a>3. equals( )和hashCode( )</h4><p>其实，hashCode( )和equals( )都是用于比较两个对象是否相等。</p>
<h5 id="1-同时提供"><a href="#1-同时提供" class="headerlink" title="1. 同时提供"></a>1. 同时提供</h5><p>因为在一些容器中(如HashMap、HashSet)中，有hashCode( )之后，判断元素是否在对应容器中的效率会更高。</p>
<p>当然，如果获得的hashCode( )相同，会使用equals( )判断是否真的相同。</p>
<p>同时，因为hashCode( )所使用的哈希算法，也许刚好会让多个对象传回相同的哈希值(越糟糕的哈希算法越容易碰撞，不过这也与数据值域分布放入特性有关)，这也导致了<strong>两个对象的hashCode值相等，并不代表两个对象就相等</strong>。</p>
<h5 id="2-所以"><a href="#2-所以" class="headerlink" title="2. 所以"></a>2. 所以</h5><ol>
<li>如果两个对象的hashCode值不相等，那么两个对象直接可以认为是不相等的。</li>
<li>如果两个对象的hashCode值相等，那么两个对象也不一定相等(哈希碰撞)。</li>
<li>如果两个对象的hashCode值相等且equals( )方法的返回值为true，则可以认为这两个对象相等。</li>
</ol>
<h5 id="3-重写equals-必须重写hashCode"><a href="#3-重写equals-必须重写hashCode" class="headerlink" title="3. 重写equals()必须重写hashCode()"></a>3. 重写equals()必须重写hashCode()</h5><p><strong>因为两个相等对象的hashCode值必须是相等的。也就是说，如果equals( )方法判断两个对象是相等的，那么这两个对象的hashCode值也要相等。</strong></p>
<p>如果重写equals( )方法时，没有重写hashCode( )方法的话，就可能会导致equals方法判断是相等的两个对象，hashCode值却不相等。 </p>
<h5 id="4-其他佐证"><a href="#4-其他佐证" class="headerlink" title="4. 其他佐证"></a>4. 其他佐证</h5><p><img src="https://s2.loli.net/2022/02/21/xz6jTLfG4s31B5R.png" alt="image-20220221235707389"></p>
<p><img src="https://s2.loli.net/2022/02/21/jGTsLIKUr3Z2QN8.png" alt="image-20220221235746077"></p>
<h4 id="4-重写hashCode方法"><a href="#4-重写hashCode方法" class="headerlink" title="4. 重写hashCode方法"></a>4. 重写hashCode方法</h4><p>hashCode方法应该返回一个整型数值(可以是负数)，并合理地组合实例域的散列码，以便能够让不同的对象产生散列码更加均匀。</p>
<p>首先，最好使用null安全的Objects.hashCode。如果其参数为null，会返回0，否则返回对参数调用hashCode方法的结果。</p>
<p>另外，对double类型的对象，调用静态方法Double.hashCode方法来避免创建Double对象：</p>
<p><img src="https://s2.loli.net/2022/02/22/KMOxUAc7DV4uXbG.png" alt="image-20220222000820113"></p>
<p>同时，需要组合多个散列值时，可以调用Objects.hash并提供多个参数。这个方法会对各个参数调用Objects.hashCode，并组合这些散列值。</p>
<p><img src="https://s2.loli.net/2022/02/22/ln71gMSFscJN6Pv.png" alt="image-20220222000939436"></p>
<h2 id="第三讲-泛型数组列表"><a href="#第三讲-泛型数组列表" class="headerlink" title="第三讲 泛型数组列表"></a>第三讲 泛型数组列表</h2><p>在Java中，允许在运行时确定数组的大小，但并不能在运行时动态更改数组。所以，ArrayList得以广泛应用。</p>
<h3 id="引子-菱形语法"><a href="#引子-菱形语法" class="headerlink" title="引子 菱形语法"></a>引子 菱形语法</h3><p>ArrayList是个采用类型参数(type parameter)的泛型类(generic class)。为了指定数组列表保存的元素对象类型，需要用一堆尖括号将类名括起来加在后面。如：</p>
<p><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(); // 省略了右边的类型参数</code></p>
<p>这被称为菱形语法，因为空尖括号&lt;&gt;就像一个菱形。可以结合new操作符使用菱形语法。编译器会检查新值是什么。如果赋值给一个变量，或传递到某个方法，或者从这个方法返回，编译器会检查这个变量、参数或方法的泛型类型，然后将这个类型放在&lt;&gt;中。在这个例子中，new ArrayList&lt;&gt;()将赋至一个类型为ArrayList<Employee>的变量，所以泛型类型为Employee。</p>
<h3 id="第一节-方法"><a href="#第一节-方法" class="headerlink" title="第一节 方法"></a>第一节 方法</h3><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>在数组列表中，如果调用add并且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。</p>
<h4 id="capacity-和-size"><a href="#capacity-和-size" class="headerlink" title="capacity 和 size"></a>capacity 和 size</h4><p>数组的大小和数组列表的容量有一个非常重要的区别。</p>
<p>如果为数组分配100个元素的存储空间，数组就有100个空位置可以使用。</p>
<p>而容量为100个元素的数组列表只是拥有保存100个元素的潜力。但是在最初，甚至完成了初始化构造之后，数组列表根本就不含有任何元素。</p>
<p>一旦能够确认数组列表的长度不再变化，可以使用trimToSize的方法。这个方法将存储区域的大小调整为当前元素数量所需的存储空间变化。垃圾回收器将回收多余的空间。(此时再添加新元素就需要花时间再次移动存储块，所以应该再确认不会添加任何元素的情况下，再调用trimToSize。)</p>
<h3 id="第二节-访问数组列表元素"><a href="#第二节-访问数组列表元素" class="headerlink" title="第二节 访问数组列表元素"></a>第二节 访问数组列表元素</h3><p>不能使用[ ]语法格式，只能使用set或get方法来实现访问或改变数组元素的操作。</p>
<h5 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h5><p>只有i小于等于数组列表的大小时，才能使用 list.set(i, x) 方法。例如，下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">list.set(<span class="number">0</span>, x); <span class="comment">//no element 0 yet</span></span><br></pre></td></tr></table></figure>
<p>使用add方法添加元素，使用set方法只能改变已有元素的值，不能添加。</p>
<h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><p><code>Employee a = staff.get(i);</code></p>
<h5 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h5><p>可以先使用数组列表创建并添加元素，之后使用.toArray( )方法将其转化为数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee[] x = <span class="keyword">new</span> <span class="title class_">Employee</span>[list.size()];</span><br><span class="line">list.toArray(x);</span><br></pre></td></tr></table></figure>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E object)</span>;</span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E object)</span>; <span class="comment">// 可以不用加index</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>; <span class="comment">// 删除一个元素，并将其后的元素向前移动，被删除的元素由返回值返回。</span></span><br></pre></td></tr></table></figure>
<h3 id="第三节-类型化与原始数组列表的兼容性"><a href="#第三节-类型化与原始数组列表的兼容性" class="headerlink" title="第三节 类型化与原始数组列表的兼容性"></a>第三节 类型化与原始数组列表的兼容性</h3><p>与没有使用类型参数的遗留代码交互操作。</p>
<ol>
<li><p>可以将一个类型化的数组列表作为函数的参数赋值给原始的ArrayList对象，如：</p>
<p> ArrayList<Employee> staff 可以作为参数赋值给ArrayList list，且不需要任何的类型转换。</p>
</li>
<li><p>但是将一个原始的ArrayList赋给一个类型化的ArrayList会得到一个警告信息。如</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> ArrayList <span class="title function_">find</span><span class="params">(String query)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Employee&gt; list = find(query); <span class="comment">// yields warning</span></span><br><span class="line"><span class="comment">// 使用类型转化也无用</span></span><br><span class="line">ArrayList&lt;Employee&gt; list = (ArrayList&lt;Employee&gt;)find(query); <span class="comment">// 指出类型转换有误</span></span><br></pre></td></tr></table></figure>
<p> 这就是Java中不尽如人意的参数化类型的限制所带来的结果。</p>
<p> 鉴于兼容性的考虑，编译器在对类型转换进行检查之后，如果没有发现违反规则的现象，就将所有的类型化类数组列表转换成原始ArrayList对象。</p>
<p> 即，在程序运行时，所有的数组列表都是一样的，没有虚拟机中的类型参数。</p>
</li>
</ol>
<h2 id="第四讲-对象包装器与自动装箱"><a href="#第四讲-对象包装器与自动装箱" class="headerlink" title="第四讲 对象包装器与自动装箱"></a>第四讲 对象包装器与自动装箱</h2><p>&lt; &gt;中的类型参数不允许是基本类型。</p>
<h3 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">3</span>); <span class="comment">// 会自动将其变换成list.add(Integer.valueOf(3));</span></span><br></pre></td></tr></table></figure>
<h3 id="自动拆箱"><a href="#自动拆箱" class="headerlink" title="自动拆箱"></a>自动拆箱</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.get(i); <span class="comment">// 自动变换成list.get(i).intValue();</span></span><br></pre></td></tr></table></figure>
<h2 id="第五讲-参数数量可变的方法"><a href="#第五讲-参数数量可变的方法" class="headerlink" title="第五讲 参数数量可变的方法"></a>第五讲 参数数量可变的方法</h2><p>printf方法是这样定义的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(String fmt, Object... args)</span> &#123; <span class="keyword">return</span> format(fmt, args); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的…是Java代码的一部分，表示可以接收任意数目的变量。</p>
<p>其实，printf方法接收两个参数，一个是格式化字符串，一个是Object[ ]数组。</p>
<p><strong>但是只允许其作为最后一个参数。</strong></p>
<h2 id="第六讲-枚举类"><a href="#第六讲-枚举类" class="headerlink" title="第六讲 枚举类"></a>第六讲 枚举类</h2><p>举个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> enmu Size &#123; SMALL, MEDIUM, LARGE, EXTRA_LARGE &#125;;</span><br></pre></td></tr></table></figure>
<p>这个声明定义的类型是一个类，它刚好有4个实例，在此尽量不要构造新对象。</p>
<p>因此，在比较两个枚举类型的值时，永远不需要调用equels方法，而直接使用”==”即可。</p>
<p>可以添加一些构造器、方法和域。构造器只是在构造枚举常量的时候被调用。</p>
<p><img src="https://s2.loli.net/2022/03/06/zroXSF2fg3sjTp8.png" alt="image-20220306103631328"></p>
<p>所有的枚举类型都是Enum类的子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Size.SMALL.toString() <span class="comment">// 返回&quot;SMALL&quot;</span></span><br><span class="line"><span class="type">Size</span> <span class="variable">s</span> <span class="operator">=</span> Eunm.valueOf(Size.class, <span class="string">&quot;SMALL&quot;</span>); <span class="comment">// 设置Size为Size.SMALL</span></span><br><span class="line"><span class="keyword">static</span> Enum <span class="title function_">valueOf</span><span class="params">(Class enumClass, String name)</span> <span class="comment">// 返回指定名字、给定类的枚举常量</span></span><br><span class="line">Size[] values = Size.values(); <span class="comment">// 返回包含全部枚举值的数组</span></span><br><span class="line">Size.SMALL.ordinal() <span class="comment">// 返回enum声明中枚举常量的位置，从0开始计数，返回0.</span></span><br></pre></td></tr></table></figure>
<h2 id="第七讲-反射"><a href="#第七讲-反射" class="headerlink" title="第七讲 反射"></a>第七讲 反射</h2><h3 id="第0节-概述"><a href="#第0节-概述" class="headerlink" title="第0节 概述"></a>第0节 概述</h3><p>能够分析类能力的程序称为反射(reflective)。</p>
<p>反射机制可以用来：</p>
<ul>
<li>在运行时分析类的能力</li>
<li>在运行时查看对象</li>
<li>实现通用的数组操作代码</li>
<li>利用Method对象，类似C++中的函数指针</li>
</ul>
<h3 id="第一节-Class类"><a href="#第一节-Class类" class="headerlink" title="第一节 Class类"></a>第一节 Class类</h3><p>在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。</p>
<p>这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。</p>
<p>可以通过专门的Java类访问这些信息。保存这些信息的类被称为Class。</p>
<p><strong>一个Class对象将表示一个特定类的属性。</strong></p>
<p>最常用的是getName方法，返回类的名字。</p>
]]></content>
      <tags>
        <tag>核心卷一</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2022/02/01/SpringMVC/</url>
    <content><![CDATA[<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p><img src="https://s2.loli.net/2022/02/01/rqs2WMkTnNxFtGp.png" alt="image-20220201160516467"></p>
<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="MVC的定义"><a href="#MVC的定义" class="headerlink" title="MVC的定义"></a>MVC的定义</h2><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分。</p>
<h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>Model，模型层，指工程中的JavaBean，作用是处理数据。</p>
<h4 id="JavaBean的两类"><a href="#JavaBean的两类" class="headerlink" title="JavaBean的两类"></a>JavaBean的两类</h4><p>一类是实体类Bean：专门存储业务数据的属性和实例域，如User类等</p>
<p>一类是业务处理Bean：指Service或Dao对象，专门用于处理业务逻辑和数据访问</p>
<h3 id="V"><a href="#V" class="headerlink" title="V"></a>V</h3><p>View，视图层，指工程中的html或jsp等页面，作用是，直接与用户交互，展示数据</p>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>Controller，控制层，指工程中的Servlet，作用是接受请求和响应浏览器。</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>用户通过View层发送请求到服务器，在服务器中，请求被Controller层接收，调用相应的Model层，处理请求。完毕后，将处理结果返回给Controller层，Controller层再根据请求处理的结果，找到相应的View层，响应给浏览器，展示到用户。</p>
<h2 id="SpringMVC的定义"><a href="#SpringMVC的定义" class="headerlink" title="SpringMVC的定义"></a>SpringMVC的定义</h2><p>SpringMVC是Spring的一个后续产品，是Spring的一个子项目。</p>
<p>其是Spring为表述层开发提供的一个一整套完备的解决方案。</p>
<h3 id="SpringMVC的特点"><a href="#SpringMVC的特点" class="headerlink" title="SpringMVC的特点"></a>SpringMVC的特点</h3><ul>
<li>Spring家族原生产品，与IOC容器等基础设施无缝对接</li>
<li>基于原生的Servlet，通过功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理，不用自己写Servlet语法的代码</li>
<li>表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案</li>
<li>代码简洁，大幅提升开发效率</li>
<li>内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相关组件即可</li>
<li>性能显著</li>
</ul>
<h1 id="二、HelloWorld"><a href="#二、HelloWorld" class="headerlink" title="二、HelloWorld"></a>二、HelloWorld</h1><h2 id="1-创建maven工程"><a href="#1-创建maven工程" class="headerlink" title="1. 创建maven工程"></a>1. 创建maven工程</h2><p>pom.xml：</p>
<ul>
<li><p>打包方式</p>
</li>
<li><p>引入依赖</p>
</li>
<li>增加web模块(webapp这个Directory和web.xml)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;TestMaven&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.test.mvc&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springMVC&lt;/artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- SpringMVC --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">5.3</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 日志 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- ServletAPI --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">            &lt;!-- 表示当前的服务器中已经提供了servlet-api，不会存在于整合后的war包中 --&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Spring5和Thymeleaf整合包 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.0</span><span class="number">.12</span>.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;<span class="number">8</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;<span class="number">8</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<!-- 这表示当前的服务器中已经提供了servlet-api，不需要导入，也就是说，他不会存在于整合后的war包中 -->
<pre><code>        &lt;scope&gt;provided&lt;/scope&gt;
</code></pre><h3 id="依赖结果"><a href="#依赖结果" class="headerlink" title="依赖结果"></a>依赖结果</h3><p><img src="https://s2.loli.net/2022/02/01/PQUxFGAhluVaMRC.png" alt="image-20220201223036137"></p>
<h2 id="2-配置web-xml"><a href="#2-配置web-xml" class="headerlink" title="2. 配置web.xml"></a>2. 配置web.xml</h2><p>注册SpringMVC的前端控制器DispatcherServlet</p>
<h3 id="a-默认配置方式"><a href="#a-默认配置方式" class="headerlink" title="a. 默认配置方式"></a>a. 默认配置方式</h3><p>此配置作用下，SpringMVC的配置文件默认为与WEB-INF下，默认名称为<servlet-name>-servlet.xml。</p>
<p>例如，以下配置所对应SpringMVC的配置文件将位于WEB-INF下，文件名为SpringMVC-servlet.xml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        设置SpringMVC的核心控制器所能处理的请求的请求路径</span><br><span class="line">        / 能匹配的请求，可以是类似/login(/a之类)或.html或.js或.css方式的请求路径</span><br><span class="line">        但是不能匹配.jsp请求路径的请求，防止被作为一个普通请求被处理，无法显示.jsp界面</span><br><span class="line">        <span class="string">&quot;/*&quot;</span> 包括.jsp请求在内的所有请求</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<p>位置默认，名称默认，但在maven中，配置文件应当放在resource下，所以：</p>
<h3 id="b-拓展配置方式-常用"><a href="#b-拓展配置方式-常用" class="headerlink" title="b. 拓展配置方式(常用)"></a>b. 拓展配置方式(常用)</h3><p>配置SpringMVC配置文件的位置和名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;web-app xmlns=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="line">         version=<span class="string">&quot;4.0&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">        &lt;!-- 配置SpringMVC配置文件的位置和名称 --&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">        &lt;!-- 将前端控制器的初始化时间提前到服务器启动时，防止第一次访问时因加载过多，而影响访问速度 --&gt;</span><br><span class="line">        &lt;load-on-startup&gt;<span class="number">1</span>&lt;/load-on-startup&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>
<h2 id="3-创建请求控制器"><a href="#3-创建请求控制器" class="headerlink" title="3. 创建请求控制器"></a>3. 创建请求控制器</h2><p>由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理方式，因此需要创建处理具体请求的类，即请求控制器。</p>
<p>请求控制器中每一个处理请求的方法称为控制器方法。</p>
<p>因为SpringMVC的控制器由一个POJO(普通Java类)担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给IOC容器管理，此时SoringMVC才能识别控制器的存在。</p>
<h2 id="4-新建SpringMVC的配置文件"><a href="#4-新建SpringMVC的配置文件" class="headerlink" title="4. 新建SpringMVC的配置文件"></a>4. 新建SpringMVC的配置文件</h2><p>包括视图解析器和组件扫描器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.mvc.controller&quot;</span>&gt;&lt;/context:component-scan&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;!-- 配置Thymeleaf视图解析器 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;viewResolver&quot;</span> class=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 视图解析的优先级 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;order&quot;</span> value=<span class="string">&quot;1&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;characterEncoding&quot;</span> value=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;templateEngine&quot;</span>&gt;</span><br><span class="line">            &lt;bean class=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;templateResolver&quot;</span>&gt;</span><br><span class="line">                    &lt;!-- 解析策略 --&gt;</span><br><span class="line">                    &lt;bean class=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span><br><span class="line">                        &lt;!-- 视图前缀 --&gt;</span><br><span class="line">                        &lt;property name=<span class="string">&quot;prefix&quot;</span> value=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span><br><span class="line">                        &lt;!-- 视图后缀 --&gt;</span><br><span class="line">                        &lt;property name=<span class="string">&quot;suffix&quot;</span> value=<span class="string">&quot;.html&quot;</span>/&gt;</span><br><span class="line">                        &lt;property name=<span class="string">&quot;templateMode&quot;</span> value=<span class="string">&quot;HTML5&quot;</span>/&gt;</span><br><span class="line">                        &lt;property name=<span class="string">&quot;characterEncoding&quot;</span> value=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span><br><span class="line">                    &lt;/bean&gt;</span><br><span class="line">                &lt;/property&gt;</span><br><span class="line">            &lt;/bean&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h2 id="5-测试HelloWorld"><a href="#5-测试HelloWorld" class="headerlink" title="5. 测试HelloWorld"></a>5. 测试HelloWorld</h2><p><img src="https://s2.loli.net/2022/02/02/uBiXqUbThdQwjmL.png" alt="image-20220202220621011"></p>
<p><img src="https://s2.loli.net/2022/02/02/TLouqwFOvmsd3A9.png" alt="image-20220202222041226"></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址与控制器的@RequestMapping注解的value属性值进行匹配。若匹配成功，该注解所标识的控制器方法，就是处理请求的方法。处理请求的方法，需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图对应页面。</p>
<ol>
<li>在pom中配置包名、依赖名和版本号，引入相关依赖</li>
<li>创建webapp这个Directry和web.xml配置文件，并配置SpringMVC配置文件的位置和名称</li>
<li>在SpringMVC中配置前端控制器(和视图解析器)。</li>
<li>建立前端控制器类和相关.html等文件</li>
</ol>
<h1 id="三、-RequestMapping注解"><a href="#三、-RequestMapping注解" class="headerlink" title="三、@RequestMapping注解"></a>三、@RequestMapping注解</h1><p>设置的属性越多，要匹配所需的条件越多，匹配得越精确。</p>
<h2 id="注解的功能"><a href="#注解的功能" class="headerlink" title="注解的功能"></a>注解的功能</h2><p>@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系，要保证请求对应的地址是唯一的(只能存在一个@RequestMapping(/target))</p>
<p>SpringMVC接收到指定的请求，就会找到映射关系中对应的控制器方法来处理这个请求。</p>
<h2 id="注解的位置"><a href="#注解的位置" class="headerlink" title="注解的位置"></a>注解的位置</h2><p>@RequestMapping标识一个类：设置映射请求的请求路径的初始信息</p>
<p>@RequestMapping标识一个方法：设置映射请求的请求路径的具体信息</p>
<p><img src="https://s2.loli.net/2022/02/02/3aqkhF9rJLgSlv6.png" alt="image-20220202234334175"></p>
<p><img src="https://s2.loli.net/2022/02/02/XwRgHEvnBlmjo41.png" alt="image-20220202234417856"></p>
<h2 id="注解的value属性"><a href="#注解的value属性" class="headerlink" title="注解的value属性"></a>注解的value属性</h2><p>@RequestMapping注解的value属性，通过请求的请求地址匹配请求映射</p>
<p>@RequestMapping注解的value属性，是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</p>
<p>@RequestMapping注解的value属性，必须设置，至少通过地址匹配请求映射</p>
<p><img src="https://s2.loli.net/2022/02/03/ZeKs7WV69M4CfbO.png" alt="image-20220203232143281"></p>
<h2 id="注解的method属性"><a href="#注解的method属性" class="headerlink" title="注解的method属性"></a>注解的method属性</h2><p>@RequestMapping注解的method属性通过请求的方式(get或post)匹配请求映射(超链接发送的是get请求)</p>
<p>@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能匹配多种请求方式的请求</p>
<p><img src="https://s2.loli.net/2022/02/04/xQWbVFaI2YkeKMr.png" alt="image-20220204182816755"></p>
<p><strong>在默认的情况下，即不设置method属性时，post和get都支持；但设置完之后，只支持设置的那个方式。</strong></p>
<p>若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported</p>
<p><img src="https://s2.loli.net/2022/02/04/OqnPmQxWXDToGHJ.png" alt="image-20220204182905633"></p>
<p><img src="https://s2.loli.net/2022/02/04/Uk1dpJwjV47YToO.png" alt="image-20220204182957386"></p>
<p>上边可行，下边不可行。</p>
<blockquote>
<ol>
<li>对于处理请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解</li>
</ol>
<ul>
<li>处理get请求：@GetMapping</li>
<li>处理post请求：@PostMapping</li>
<li>处理put请求：@PutMapping</li>
<li>处理delete请求：@DeleteMapping</li>
</ul>
<p>常用的请求方式：get、post、put、delete</p>
<ol>
<li>但目前只支持get和post，若设置了其他表单提交的请求方式，则按照默认的get方式处理。</li>
</ol>
</blockquote>
<h2 id="注解的params属性-了解"><a href="#注解的params属性-了解" class="headerlink" title="注解的params属性(了解)"></a>注解的params属性(了解)</h2><p><img src="https://s2.loli.net/2022/02/04/Qt6ZquWkBxh5G9c.png" alt="image-20220204194532789"></p>
<h2 id="SpringMVC支持ant风格的路径"><a href="#SpringMVC支持ant风格的路径" class="headerlink" title="SpringMVC支持ant风格的路径"></a>SpringMVC支持ant风格的路径</h2><h3 id="："><a href="#：" class="headerlink" title="?："></a>?：</h3><p>表示任意的单个字符</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>这个字符不能是?：在地址栏中，?后匹配的是请求参数(也就是get方式提交数据时的情况)，如果是?，那么路径就只剩下请求中前边那个字符了。</p>
<p><img src="https://s2.loli.net/2022/02/04/6xgjGLtJTF9sDh7.png" alt="image-20220204215412314"></p>
<p>也不能是“/”：在路径中是路径分隔符</p>
<h3 id="：-1"><a href="#：-1" class="headerlink" title="*："></a>*：</h3><p>表示任意的0个或多个字符</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>上边两个依旧成立</p>
<h3 id="：-2"><a href="#：-2" class="headerlink" title="**："></a>**：</h3><p>表示任意的一层或多层目录</p>
<h4 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h4><p>使用时，只能用/**/xxx的方式</p>
<p>也就是说，不能是/a**a/xxx这个样子，否则</p>
<p>会被当做两个”*”占位符来使用。</p>
<h2 id="SpringMVC支持路径中的占位符"><a href="#SpringMVC支持路径中的占位符" class="headerlink" title="SpringMVC支持路径中的占位符"></a>SpringMVC支持路径中的占位符</h2><h3 id="原始方式"><a href="#原始方式" class="headerlink" title="原始方式"></a>原始方式</h3><h4 id="deleteUser-id-1"><a href="#deleteUser-id-1" class="headerlink" title="/deleteUser?id=1"></a>/deleteUser?id=1</h4><h3 id="rest方式"><a href="#rest方式" class="headerlink" title="rest方式"></a>rest方式</h3><h4 id="deleteUser-1"><a href="#deleteUser-1" class="headerlink" title="/deleteUser/1"></a>/deleteUser/1</h4><p>SpringMVC路径中的占位符常用于restful风格中，当<strong>请求路径中将某些数据通过路径的方式</strong>传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符(xxx)表示传输的数据，再通过@PathVariable注解，将占位符所表示的数据，赋值给控制方法的形参。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送请求的格式</span></span><br><span class="line">&lt;a th:href=<span class="string">&quot;@&#123;/a1/target/1/admin&#125;&quot;</span>&gt;访问路径占位符**时&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制器中的请求映射格式</span></span><br><span class="line"> <span class="meta">@RequestMapping(&quot;/a1/target/&#123;id&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">target</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id, <span class="meta">@PathVariable(&quot;username&quot;)</span>String username)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id: &quot;</span> + id + <span class="string">&quot; username: &quot;</span> + username);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/02/04/iDfhW1lpAoVa4BQ.png" alt="image-20220204230621610"></p>
<h1 id="四、SpringMVC获取请求参数"><a href="#四、SpringMVC获取请求参数" class="headerlink" title="四、SpringMVC获取请求参数"></a>四、SpringMVC获取请求参数</h1><h2 id="通过ServletAPI获取-一般不用"><a href="#通过ServletAPI获取-一般不用" class="headerlink" title="通过ServletAPI获取(一般不用)"></a>通过ServletAPI获取(一般不用)</h2><p>因为SpringMVC中，已经封装了相关的ServletAPI的内容，并且提供了更为简洁的方式去调用，所以尽量不用原生的ServletAPI。</p>
<p>将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数，表示封装了当前请求的请求报文的对象。</p>
<p><img src="https://s2.loli.net/2022/02/05/vh9AY3Fa2TO1DwU.png" alt="image-20220205231831742"></p>
<p>因为，DispatcherController会根据当前其所包含数据，自动为控制器方法(@RequestMapping注解的方法)的参数赋值。</p>
<p>但此时，不能使用占位符{}了，因为request.getParameter( )方法，只能根据name来获取value。若是占位符的话，只有值value，没有name，导致方法无法使用。</p>
<h2 id="通过控制器方法的形参获取请求参数"><a href="#通过控制器方法的形参获取请求参数" class="headerlink" title="通过控制器方法的形参获取请求参数"></a>通过控制器方法的形参获取请求参数</h2><p>在控制器方法的形参位置，<strong>设置和请求参数同名的形参</strong>(不同名则无法获取到)，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参。</p>
<p><img src="https://s2.loli.net/2022/02/06/RcNvH2VFSqgTMAD.png" alt="image-20220206233040577"></p>
<p><img src="https://s2.loli.net/2022/02/06/MuETIB9ALP8DOVU.png" alt="image-20220206233218936"></p>
<p><img src="https://s2.loli.net/2022/02/06/nE14u8U29oWLbiF.png" alt="image-20220206233326972"></p>
<p><img src="https://s2.loli.net/2022/02/06/1qiVUuDcRErhCm5.png" alt="image-20220206233236981"></p>
<blockquote>
<h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><p>单个请求参数直接获取即可</p>
<p>若为多个同名的请求参数，可以使用字符串类型(逗号分隔开请求参数的每一个值)或字符串数组类型(用Arrays.toString( )方法输出)。</p>
</blockquote>
<h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p> @RequestParam是将请求参数和控制器方法的形参创建映射关系</p>
<p>原本就有一个默认的值，用不用都可以。</p>
<p>@RequestParam注解一共有三个属性：</p>
<ul>
<li><p>value：指定为形参赋值的请求参数的参数名</p>
</li>
<li><p>required：设置是否必须传输此请求参数(不传就报错)，默认值为true</p>
<p>若设置为true，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present; 若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null。</p>
</li>
<li><p>defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为null时，则使用其为形参赋值。</p>
<p><img src="https://s2.loli.net/2022/02/10/lMr5JvcPwZeWxSR.png" alt="image-20220210155004264"></p>
</li>
</ul>
<h2 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h2><p> @RequestHeader是将请求头信息和控制器方法的形参创建映射关系</p>
<p>参数与上边那个一样。</p>
<p><img src="https://s2.loli.net/2022/02/10/sMIzL37SxneqVly.png" alt="image-20220210161901846"></p>
<p>如果输出host，则输出是localhost:8080</p>
<h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h2><p>@CookieValue是将cookie数据和控制器方法的形参创建映射关系。</p>
<p>三个参数，用法同上</p>
<p>第一次调用getSession()时，Set-Cookie JSESSIONID存在于响应报文中的，但创建并相应到服务器之后之后，存在于请求报文中。</p>
<h2 id="通过POJO获取请求参数"><a href="#通过POJO获取请求参数" class="headerlink" title="通过POJO获取请求参数"></a>通过POJO获取请求参数</h2><p>可以在控制器方法的形参位置设置为一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;form th:action=<span class="string">&quot;@&#123;/testBean&#125;&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    用户名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    密码：&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    性别：&lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;sex&quot;</span> value=<span class="string">&quot;女&quot;</span>&gt;女&lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;sex&quot;</span> value=<span class="string">&quot;男&quot;</span>&gt;男&lt;br&gt;</span><br><span class="line">    年龄：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;使用实体类&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testBean&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testBean</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/02/10/yulhCrWIYTp3Jje.png" alt="image-20220210182908632"></p>
<h2 id="解决获取请求参数的乱码问题"><a href="#解决获取请求参数的乱码问题" class="headerlink" title="解决获取请求参数的乱码问题"></a>解决获取请求参数的乱码问题</h2><p>解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置编码过滤器 --&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;!-- 根据源码获得 --&gt;</span><br><span class="line">        &lt;!-- 设置请求的编码格式 --&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;UTF-<span class="number">8</span>&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;!-- 设置响应的编码经过过滤器 --&gt;</span><br><span class="line">        &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;<span class="literal">true</span>&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="注-1"><a href="#注-1" class="headerlink" title="注"></a>注</h3><p>Springmvc中处理编码的过滤器一定要配置到其他过滤器之前，否则无效</p>
<ol>
<li><p>在Tomcat的service.xml中URIEncoding=UTF-8已经设置过编码了，所以，使用get请求传递参数时，不会出现中文乱码(这个是可以一次操作，终身解决的)。</p>
</li>
<li><p>使用post请求传递参数时，DispatcherServlet会去获取请求参数，对已经获取的请求设置请求的编码格式毫无意义，并不会改变编码格式，所以使用request.setEncodingChara-cter没用。也就是说，要在前端控制器获取请求之前，设置传递的编码格式。也就是比Ser-vlet执行更早的组件，需要配置过滤器(Tomcat三大组件加载顺序：监听器、过滤器、Serv-let，由于监听器起到监听作用，监听ServletContext，就是监听创建和销毁，即只执行一次。但过滤器，只要满足设置过的过滤路径，都会进行处理。设置后，每一次发送请求，都会经过过滤器的处理，再交给DisatcherServlet用。由于加载顺序的存在，web.xml中Filter和Servlet配置的前后顺序不产生影响。)</p>
</li>
</ol>
</blockquote>
<h1 id="五、域对象共享数据"><a href="#五、域对象共享数据" class="headerlink" title="五、域对象共享数据"></a>五、域对象共享数据</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>servletcontext(上下文对象)在整个应用范围内有效，也就是服务器开启到服务器关闭这段时间(只创建一次，与浏览器是否关闭无关)。</p>
<p>session在整个浏览器范围内有效，也就是浏览器开启和浏览器关闭这段时间(也就是其中数据与服务器是否关闭无关)。</p>
<p>session中有钝化(服务器关闭，而浏览器未关闭，即会话仍在继续，那么这时，存储在session上的数据，会经过序列化，保存到磁盘上)和活化(浏览器仍未关闭，但服务器重新开启，将钝化过的内容，重新读取到session中)。</p>
<p>只要JSESSIONID所依赖的这个Cookie存在，那么在当前会话中所创建的session，永远都是同一个。</p>
<h2 id="选择域对象"><a href="#选择域对象" class="headerlink" title="选择域对象"></a>选择域对象</h2><p>选择一个能实现功能的，范围最小的(不会浪费资源)。</p>
<h2 id="使用servletAPI向request域对象共享数据"><a href="#使用servletAPI向request域对象共享数据" class="headerlink" title="使用servletAPI向request域对象共享数据"></a>使用servletAPI向request域对象共享数据</h2><p>原生servletAPI，少用咯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequest</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;hello, servletAPI&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;p th:text=<span class="string">&quot;$&#123;testRequestScope&#125;&quot;</span>&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>先调用控制器方法TestController显示出index.html界面，点击超链接，经由thymeleaf视图解析后，跳转到success.html界面，将testServletScope中已经request.setAttribute( )过的域对象，显示出来。</p>
<h2 id="使用ModelAndView向request域对象共享数据-建议用"><a href="#使用ModelAndView向request域对象共享数据-建议用" class="headerlink" title="使用ModelAndView向request域对象共享数据(建议用)"></a>使用ModelAndView向request域对象共享数据(建议用)</h2><h3 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h3><p>SpringMVC提供。</p>
<p>ModelAndView有Model和View的功能</p>
<p><strong>Model主要指的是，向域对象中共享的数据。</strong></p>
<p><strong>View就是视图，指的就是设置好的视图名称。经过视图解析，实现跳转到的指定页面。</strong></p>
<p>不管用什么方法共享数据，最终都会将Model和View封装到ModelAndView这个对象中。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>向request域对象共享数据，设置视图名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelAndView&quot;)</span></span><br><span class="line"><span class="comment">// 返回值必须是ModelAndView，将其交给视图解析器进行解析</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">testModelAndView</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    <span class="comment">// 处理模型数据，向request共享数据</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;Hello, ModelAndView&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置视图名称</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用Model向request域对象共享数据"><a href="#使用Model向request域对象共享数据" class="headerlink" title="使用Model向request域对象共享数据"></a>使用Model向request域对象共享数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testModel</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;Hello, Model&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用map向request域对象共享数据"><a href="#使用map向request域对象共享数据" class="headerlink" title="使用map向request域对象共享数据"></a>使用map向request域对象共享数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testMap</span><span class="params">(Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">    map.put(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;Hello, Map&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用ModelMap向request域对象共享数据"><a href="#使用ModelMap向request域对象共享数据" class="headerlink" title="使用ModelMap向request域对象共享数据"></a>使用ModelMap向request域对象共享数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testModelMap</span><span class="params">(ModelMap modelMap)</span> &#123;</span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;Hello, ModelMap&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Model、ModelMap、Map的关系"><a href="#Model、ModelMap、Map的关系" class="headerlink" title="Model、ModelMap、Map的关系"></a>Model、ModelMap、Map的关系</h2><p>Model、ModelMap、Map类型的参数，本质上都是BindingAwareModelMap类型的(通过Model.getClass().-getName()得到的)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Model</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModelMap</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;String, Object&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendedModelMap</span> <span class="keyword">extends</span> <span class="title class_">ModelMap</span> <span class="keyword">implements</span> <span class="title class_">Mode</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BindingAwareModelMap</span> <span class="keyword">extends</span> <span class="title class_">ExtendedModelMap</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>以上四个方法，都会将模型数据和视图信息封装到一个ModelAndView中，类似：</p>
<p><img src="https://s2.loli.net/2022/02/13/31efY4PZjwzpgik.png" alt="image-20220213205722225"></p>
<h2 id="向session域共享数据"><a href="#向session域共享数据" class="headerlink" title="向session域共享数据"></a>向session域共享数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testSession&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testSession</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">	session.setAttribute(<span class="string">&quot;testSessionScope&quot;</span>, <span class="string">&quot;Hello, session&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="向application域共享数据"><a href="#向application域共享数据" class="headerlink" title="向application域共享数据"></a>向application域共享数据</h2><p>整个工程中要共享的东西，才会放到application中，范围太大</p>
<p>一般都用request和session。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testApplication&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testApplication</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    application.setAttribute(<span class="string">&quot;testApplicationScope&quot;</span>, <span class="string">&quot;Hello, application&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="六、SpringMVC的视图"><a href="#六、SpringMVC的视图" class="headerlink" title="六、SpringMVC的视图"></a>六、SpringMVC的视图</h1><p>SpringMVC中的视图是View接口，视图的作用是渲染数据，将模型Model中的数据展示给用户。</p>
<p>SpringMVC视图的种类有很多，默认有转发视图InternalResourceView和重定向视图RedirectView。</p>
<p>当工程引入jstl的以来，转发视图会自动转换为jstlView</p>
<p>若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView</p>
<h2 id="1-ThymeleafView"><a href="#1-ThymeleafView" class="headerlink" title="1. ThymeleafView"></a>1. ThymeleafView</h2><p>当<strong>控制器方法中所设置的视图名称没有任何前缀时</strong>，此时的视图名称会被SpringMVC配置文件中所配置的Thymeleaf视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过<strong>转发的方式</strong>实现跳转。</p>
<p><img src="https://s2.loli.net/2022/02/14/C8cEGNuyWshHJpw.png" alt="image-20220214210804710"></p>
<h2 id="2-转发视图-用的不是很多"><a href="#2-转发视图-用的不是很多" class="headerlink" title="2. 转发视图(用的不是很多)"></a>2. 转发视图(用的不是很多)</h2><p>SpringMVC中默认的转发视图时InternalResourceView。</p>
<h3 id="情况："><a href="#情况：" class="headerlink" title="情况："></a>情况：</h3><p>当控制器方法中所设置的<strong>视图名称以”forward:”为前缀</strong>时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中的所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过<strong>转发的方式</strong>实现跳转。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p><img src="https://s2.loli.net/2022/02/14/fVYiyWm8usU6NnA.png" alt="image-20220214214405141"></p>
<p><img src="https://s2.loli.net/2022/02/14/MnI9qFLlfKmspPX.png" alt="image-20220214214501985"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testThymeleafView&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testThymeleafView</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testForward</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 转发了一个请求，创建了两个请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/testThymeleafView&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h3><p>只能转发到一个请求，不能直接”forward:”到一个html页面(因为页面必须通过服务器访问，通过转发访问)。</p>
<p>因为Thymeleaf本身就是转发的方式，所以说，这个转发视图用的不多。</p>
<h2 id="3-重定向视图"><a href="#3-重定向视图" class="headerlink" title="3. 重定向视图"></a>3. 重定向视图</h2><p>SpringMVC中默认的重定向视图时RedirectView。</p>
<h3 id="情况"><a href="#情况" class="headerlink" title="情况"></a>情况</h3><p>当控制器方法中所设置的视图名称以”redirect”为前缀时，创建RedirectView视图，此时视图的名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect”去掉，剩余部分作为最终路径通过<strong>重定向的方式</strong>实现跳转。</p>
<h3 id="转发和重定向区别"><a href="#转发和重定向区别" class="headerlink" title="转发和重定向区别"></a>转发和重定向区别</h3><p>转发浏览器只发送一次请求(发生在服务器内部，只能访问内部的页面)，重定向发送两次请求(可以访问服务器外的页面)。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>页面都在WEB-INF下，而WEB-INF下的内容，重定向是无法访问的。再说了现在的页面，都要经过Thymeleaf解析，所以要通过转发去访问Thymeleaf视图，所以要重定向一个请求。</p>
<p><img src="https://s2.loli.net/2022/02/14/ljSBqPiWKIbC7Gt.png" alt="image-20220214220417979"></p>
<p><img src="https://s2.loli.net/2022/02/14/MnI9qFLlfKmspPX.png" alt="image-20220214214501985"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRedirect&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRedirect</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/testThymeleafView&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果对比"><a href="#结果对比" class="headerlink" title="结果对比"></a>结果对比</h3><p><img src="https://s2.loli.net/2022/02/14/yHB8N3ezGEmfW7c.png" alt="image-20220214221223092"></p>
<h4 id="转发时"><a href="#转发时" class="headerlink" title="转发时"></a>转发时</h4><p><img src="https://s2.loli.net/2022/02/14/kGmHx1worAKcFQR.png" alt="image-20220214220956997"></p>
<h4 id="重定向时"><a href="#重定向时" class="headerlink" title="重定向时"></a>重定向时</h4><p><img src="https://s2.loli.net/2022/02/14/D8L4e2MHRk3mElG.png" alt="image-20220214221046150"> </p>
<p>也就是说，虽然发送了一样的请求。</p>
<p>但是转发和重定向，一个，地址栏的地址直接对应的是原请求，即/testForward；而另一个，地址栏的地址变化了，从/testRedirect跳转到了对应的/testThymeleafView。</p>
<h2 id="4-视图控制器view-controller-注意"><a href="#4-视图控制器view-controller-注意" class="headerlink" title="4. 视图控制器view-controller(注意)"></a>4. 视图控制器view-controller(注意)</h2><p>当控制器方法中，仅仅用来实现页面跳转，即只需要设置各种视图名称时，可以将处理器方法使用view-controller标签进行表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">    path：设置处理的请求地址</span><br><span class="line">    view-name：设置请求地址对应的视图名称</span><br><span class="line">--&gt;</span><br><span class="line">&lt;mvc:view-controller path=<span class="string">&quot;/testview&quot;</span> view-name=<span class="string">&quot;success&quot;</span>&gt;&lt;/mvc:view-controller&gt;</span><br></pre></td></tr></table></figure>
<h3 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h3><p>当Springmvc中设置任何一个view-controller时，<strong>控制器中的请求映射将全部失效</strong>。</p>
<p>此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：</p>
<p><code>&lt;mvc:annotation-driven /&gt;</code></p>
<h1 id="七、RESTFul"><a href="#七、RESTFul" class="headerlink" title="七、RESTFul"></a>七、RESTFul</h1><p>REST： Representational State Transfer，表现层(视图+控制层)资源状态转移。</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。</p>
<p>每个资源是服务器上一个可命名的抽象概念，它不仅仅代表服务器文件系统中的一个文件等具体的东西。</p>
<p><strong>资源是以名词为核心来组织的。</strong></p>
<p>首先关注的是名词，一个资源可以由一个或多个URI(统一资源定位符)来标识。URI既是资源的名称，也是资源在Web上的地址，对这个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。</p>
<p>就，知道了要操作的资源是什么，为这个资源设置一个名词，则可以实现通过同一个请求路径实现不同的操作。</p>
<h3 id="资源的表述"><a href="#资源的表述" class="headerlink" title="资源的表述"></a>资源的表述</h3><p>资源的表示是对于资源在某个特定时刻的状态的描述。可以在客户端-服务器之间转移(交换)。</p>
<p>资源的表述可以有多种格式，如HTML/XML/JSON/纯文本/音频等。</p>
<p>资源的表述格式可以通过协商机制来确定。请求-响应的表述通常使用不同的格式。</p>
<h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>状态转移说的是，在客户端和服务器之间转移 (transfer)代表资源状态的 表述(向服务器发送请求，请求什么，服务器就返回什么资源)。通过转移和操作资源的表述(请求路径)，来间接实现操作资源的目的。</p>
<h2 id="2-RESTFul的实现"><a href="#2-RESTFul的实现" class="headerlink" title="2. RESTFul的实现"></a>2. RESTFul的实现</h2><p>具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET(查找)、POST(添加)、PUT(修改)、DELETE(删除)。</p>
<p>REST风格提倡URL地址使用统一的风格设计，<strong>从前到后各个单词使用斜杠分开</strong>，<strong>不使用问号键值对方式携带请求参数</strong>，而是将要发送给服务器的数据作为URL地址的一部分，以保证整体风格的意志。</p>
<p><img src="https://s2.loli.net/2022/02/15/ode2uAYIN8MZvET.png" alt="image-20220215234057710"></p>
<h2 id="3-HiddenHttpMethodFilter"><a href="#3-HiddenHttpMethodFilter" class="headerlink" title="3. HiddenHttpMethodFilter"></a>3. HiddenHttpMethodFilter</h2><p>由于浏览器只支持发送get和post请求，那么如何发送put和delete请求呢？</p>
<p>SpringMVC提供了HiddenHttpMethodFilter来将POST请求转换为DELETE和PUT请求。</p>
<p>要有初始化、执行过滤(重要)、销毁生命周期三个方法。</p>
<p><img src="https://s2.loli.net/2022/02/16/EFekI3uJUSP7gwc.png" alt="image-20220216211605226"></p>
<p>当前过滤器要拦截的请求和响应</p>
<p>获取当前请求的请求方式</p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p><img src="https://s2.loli.net/2022/02/16/bgBsTR47icAuYIW.png" alt="image-20220216213429236"></p>
<ul>
<li>当前请求方式必须为post</li>
<li>当前请求必须传输一个name为“_method”的参数</li>
</ul>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>这个过滤器和设置编码的CharacterEncodingFilter的顺序：</p>
<p>一定是设置请求的编码的CharacterEncodingFilter在前边。在设置编码之前，不能获取任何请求参数。因为如果之前就获取了请求，那么之后对请求设置编码格式自然是无用的。</p>
<h1 id="八、RESTFul案例"><a href="#八、RESTFul案例" class="headerlink" title="八、RESTFul案例"></a>八、RESTFul案例</h1><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>和传统CRUD一样，实现对员工信息的增删改查</p>
<h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><h4 id="1-配置pom-xml"><a href="#1-配置pom-xml" class="headerlink" title="1. 配置pom.xml"></a>1. 配置pom.xml</h4><p>引入依赖：<img src="https://s2.loli.net/2022/02/18/6yr8Ejm54sJBINd.png" alt="image-20220218203617354"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line">&lt;groupId&gt;com.test&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springMVC-rest&lt;/artifactId&gt;</span><br><span class="line">&lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- SpringMVC --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">5.3</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 日志 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- ServletAPI --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;!-- 表示当前的服务器中已经提供了servlet-api，不会存在于整合后的war包中 --&gt;</span><br><span class="line">        &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Spring5和Thymeleaf整合包 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.0</span><span class="number">.12</span>.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-配置web-xml-1"><a href="#2-配置web-xml-1" class="headerlink" title="2. 配置web.xml"></a>2. 配置web.xml</h4><h5 id="1-CharacterEncodingFilter"><a href="#1-CharacterEncodingFilter" class="headerlink" title="1. CharacterEncodingFilter"></a>1. CharacterEncodingFilter</h5><p>确定请求和响应的编码格式为UTF-8</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;!-- 根据源码确定的 --&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;UTF-<span class="number">8</span>&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;<span class="literal">true</span>&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;<span class="literal">true</span>&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;<span class="comment">/*&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">&lt;/filter-mapping&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="2-HiddenHttpMethodFilter"><a href="#2-HiddenHttpMethodFilter" class="headerlink" title="2. HiddenHttpMethodFilter"></a>2. HiddenHttpMethodFilter</h5><p>确定DELETE和PUT两个请求方式可以得到处理</p>
<p>由于请求方式和参数是请求同名的情况下，确定对应的请求处理方式的依据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">  &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">  &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">  &lt;filter-mapping&gt;</span><br><span class="line">      &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">      &lt;url-pattern&gt;<span class="comment">/*&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">  &lt;/filter-mapping&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="3-DispatcherServlet"><a href="#3-DispatcherServlet" class="headerlink" title="3. DispatcherServlet"></a>3. DispatcherServlet</h5><p>配置前端控制器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;!-- 设置使得SpringMVC的配置文件放置在工程中的resources文件夹下 --&gt;</span><br><span class="line">        &lt;param-name&gt;ContextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;load-on-startup&gt;<span class="number">1</span>&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3-建立控制器类xxController-java"><a href="#3-建立控制器类xxController-java" class="headerlink" title="3. 建立控制器类xxController.java"></a>3. 建立控制器类xxController.java</h4><p>用注解@Controller标识创建该控制器对象</p>
<h4 id="4-配置springMVC-xml"><a href="#4-配置springMVC-xml" class="headerlink" title="4. 配置springMVC.xml"></a>4. 配置springMVC.xml</h4><h5 id="1-注解扫描"><a href="#1-注解扫描" class="headerlink" title="1. 注解扫描"></a>1. 注解扫描</h5><h5 id="2-配置视图解析器"><a href="#2-配置视图解析器" class="headerlink" title="2. 配置视图解析器"></a>2. 配置视图解析器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.test&quot;</span>&gt;&lt;/context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置视图解析器 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;viewResolver&quot;</span> class=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span><br><span class="line">    &lt;!-- 视图解析的优先级 --&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;order&quot;</span> value=<span class="string">&quot;1&quot;</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;characterEncoding&quot;</span> value=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;templateEngine&quot;</span>&gt;</span><br><span class="line">        &lt;bean class=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span><br><span class="line">            &lt;property name=<span class="string">&quot;templateResolver&quot;</span>&gt;</span><br><span class="line">                &lt;!-- 解析策略 --&gt;</span><br><span class="line">                &lt;bean class=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span><br><span class="line">                    &lt;!-- 视图前缀 --&gt;</span><br><span class="line">                    &lt;property name=<span class="string">&quot;prefix&quot;</span> value=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span><br><span class="line">                    &lt;!-- 视图后缀 --&gt;</span><br><span class="line">                    &lt;property name=<span class="string">&quot;suffix&quot;</span> value=<span class="string">&quot;.html&quot;</span>/&gt;</span><br><span class="line">                    &lt;property name=<span class="string">&quot;templateMode&quot;</span> value=<span class="string">&quot;HTML5&quot;</span>/&gt;</span><br><span class="line">                    &lt;property name=<span class="string">&quot;characterEncoding&quot;</span> value=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span><br><span class="line">                &lt;/bean&gt;</span><br><span class="line">            &lt;/property&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-准备实体类"><a href="#2-准备实体类" class="headerlink" title="2. 准备实体类"></a>2. 准备实体类</h3><h4 id="1-bean包"><a href="#1-bean包" class="headerlink" title="1. bean包"></a>1. bean包</h4><p>放置实体类(属性、无参构造、有参构造、toString()、getXX()、setXX())</p>
<h4 id="2-Dao包"><a href="#2-Dao包" class="headerlink" title="2. Dao包"></a>2. Dao包</h4><p>代表持久化层、数据访问层，操作数据库的各种方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Employee&gt; employees = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        employees = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Employee&gt;();</span><br><span class="line"></span><br><span class="line">        employees.put(<span class="number">1001</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>, <span class="string">&quot;E-AA&quot;</span>, <span class="string">&quot;aa@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        employees.put(<span class="number">1002</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1002</span>, <span class="string">&quot;E-BB&quot;</span>, <span class="string">&quot;bb@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        employees.put(<span class="number">1003</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1003</span>, <span class="string">&quot;E-CC&quot;</span>, <span class="string">&quot;cc@163.com&quot;</span>, <span class="number">0</span>));</span><br><span class="line">        employees.put(<span class="number">1004</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1004</span>, <span class="string">&quot;E-DD&quot;</span>, <span class="string">&quot;dd@163.com&quot;</span>, <span class="number">0</span>));</span><br><span class="line">        employees.put(<span class="number">1005</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1005</span>, <span class="string">&quot;E-EE&quot;</span>, <span class="string">&quot;ee@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">initId</span> <span class="operator">=</span> <span class="number">1006</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Employee employee)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (employee.getId() == <span class="literal">null</span>) &#123;</span><br><span class="line">            employee.setId(initId++);</span><br><span class="line">        &#125;</span><br><span class="line">        employees.put(employee.getId(), employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;Employee&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> employees.values();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">get</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> employees.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        employees.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-Controller包"><a href="#3-Controller包" class="headerlink" title="3. Controller包"></a>3. Controller包</h4><p>有关的控制器方法</p>
<p>设置资源的名称为employee</p>
<h2 id="2-功能清单"><a href="#2-功能清单" class="headerlink" title="2. 功能清单"></a>2. 功能清单</h2><p>根据请求方式来实现不同功能</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>功能</th>
<th>URL地址</th>
<th>请求方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>访问首页</td>
<td>/</td>
<td>GET</td>
</tr>
<tr>
<td>查询全部数据</td>
<td>/employee</td>
<td>GET</td>
</tr>
<tr>
<td>删除</td>
<td>/employee/2</td>
<td>DELETE</td>
</tr>
<tr>
<td>跳转到添加数据页面</td>
<td>/toAdd</td>
<td>GET</td>
</tr>
<tr>
<td>执行保存</td>
<td>/employee</td>
<td>POST</td>
</tr>
<tr>
<td>跳转到更新数据页面</td>
<td>/employee/3</td>
<td>GET</td>
</tr>
<tr>
<td>执行更新</td>
<td>/employee</td>
<td>PUT</td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-查询所有员工"><a href="#3-查询所有员工" class="headerlink" title="3. 查询所有员工"></a>3. 查询所有员工</h2><p>请求方式为get。</p>
<h3 id="操作：访问首页"><a href="#操作：访问首页" class="headerlink" title="操作：访问首页(*)"></a>操作：访问首页(*)</h3><h4 id="配置springMVC-xml"><a href="#配置springMVC-xml" class="headerlink" title="配置springMVC.xml"></a>配置springMVC.xml</h4><h5 id="1-视图控制器"><a href="#1-视图控制器" class="headerlink" title="1. 视图控制器"></a>1. 视图控制器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置视图控制器 --&gt;</span><br><span class="line">&lt;mvc:view-controller path=<span class="string">&quot;/&quot;</span> view-name=<span class="string">&quot;index&quot;</span>&gt;&lt;/mvc:view-controller&gt;</span><br><span class="line">&lt;mvc:view-controller path=<span class="string">&quot;/toAdd&quot;</span> view-name=<span class="string">&quot;employee_add&quot;</span>&gt;&lt;/mvc:view-controller&gt;</span><br></pre></td></tr></table></figure>
<h5 id="2-访问驱动器"><a href="#2-访问驱动器" class="headerlink" title="2. 访问驱动器"></a>2. 访问驱动器</h5><p>必须要配置，否则除了在视图控制器中声明的请求映射之外，别的在控制器中的请求映射，将无法被处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven /&gt;</span><br></pre></td></tr></table></figure>
<h5 id="3-html页面"><a href="#3-html页面" class="headerlink" title="3. html页面"></a>3. html页面</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span>&gt;</span>查看员工信息<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-html页面"><a href="#1-html页面" class="headerlink" title="1. html页面"></a>1. html页面</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Employee Information<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;dataTable&quot;</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;5&quot;</span>&gt;</span>Employee Information<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>lastName<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>email<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>gender<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>options (<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/toAdd&#125;&quot;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">a</span>&gt;</span>) <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 每次都要循环一行信息，在tr中使用th: 。又因为数据保存在请求域中，所以用$&#123; &#125;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;employee : $&#123;employeeList&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 如果写在&lt;td&gt;$&#123; &#125;&lt;/td&gt;的话，会被当成文本输出，而不是被解析--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 通过超链接来控制一个表单的提交方式，通过vue来处理为其绑定的事件， form表单才是最终的提交方式 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;deleteEmployee&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27; + $&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>delete<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;deleteForm&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;delete&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> vue = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">el</span>:<span class="string">&quot;#dataTable&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">deleteEmployee</span>:<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 根据id获取表单元素</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">var</span> deleteForm = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;deleteForm&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 将触发点击事件的超链接的href属性赋值给表单的action</span></span></span><br><span class="line"><span class="language-javascript">                    deleteForm.<span class="property">action</span> = event.<span class="property">target</span>.<span class="property">href</span>;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 提交表单</span></span></span><br><span class="line"><span class="language-javascript">                    deleteForm.<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 取消超链接的默认行为</span></span></span><br><span class="line"><span class="language-javascript">                    event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-控制器"><a href="#2-控制器" class="headerlink" title="2. 控制器"></a>2. 控制器</h3><p>主要调用了getAll( )方法，将数据库中的数据读取。</p>
<p>之后设置了构成ModelAndView的数据employeeList和(返回了)视图employee_list。</p>
<p>此处的域对象是请求域，因为每次显示数据都需要重新进行查找，所以说这些数据只需在一次请求中有效即可。</p>
<p>选取域对象，要选能实现预期功能的且范围最小的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/employee&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAllEmployees</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    Collection&lt;Employee&gt; employeeList = employeeDao.getAll();</span><br><span class="line">    <span class="comment">// 因为每次都需要重新查，只需在一次请求中有效即可，否则占空间</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;employeeList&quot;</span>, employeeList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;employee_list&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a>4. 删除</h2><p>比较麻烦。</p>
<p>请求方式为delete。</p>
<h3 id="0-思路"><a href="#0-思路" class="headerlink" title="0. 思路"></a>0. 思路</h3><p>首先将delete的超链接绑定到一个表单提交的事件，通过设置表单的提交方式为post并配置参数_method，可以使用HiddenHttpMethodFilter过滤器，将其转换为delete请求方式。</p>
<h3 id="1-设置表单"><a href="#1-设置表单" class="headerlink" title="1. 设置表单"></a>1. 设置表单</h3><ol>
<li>提交方式为post</li>
<li>设置_method参数的值为请求方式delete</li>
</ol>
<p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220218224140190.png" alt="image-20220218224140190"></p>
<h3 id="2-vue设置超链接"><a href="#2-vue设置超链接" class="headerlink" title="2. vue设置超链接"></a>2. vue设置超链接</h3><p>因为在表格中，delete通常是以超链接的形式存在。但是要想发送并能处理这个DELETE请求方式，就必须要通过表单提交的方式(根据HiddenHttpFilter的源码可得)。</p>
<p>所以，这里使用了vue，采取了将超链接绑定一个表单提交的事件的方式，之后通过在控制器中匹配请求名称和请求方式，执行相关的方法。</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>首先根据id获取表单元素</p>
<p>将待点击的超链接的href属性(event.target.href)赋值给表单的action</p>
<p>提交表单.submit( )</p>
<p>取消超链接的默认行为(preventDefaukt( ))。</p>
<p>特别，注意取消超链接默认的点击后跳转行为，否则绑定不生效。</p>
<p><img src="https://s2.loli.net/2022/02/18/oVyTPIF34m8WS7v.png" alt="image-20220218223510735"></p>
<h3 id="3-设置请求格式"><a href="#3-设置请求格式" class="headerlink" title="3. 设置请求格式"></a>3. 设置请求格式</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>采用的发送请求的方式为：通过”/“将参数跟到地址后。</p>
<p>所以要实现在超链接点击后，发送的请求中，要有对应的员工id。</p>
<p><strong>使用Thymeleaf视图解析器的方式，通过增加可解析的参数表达式实现。</strong></p>
<h4 id="错误方式"><a href="#错误方式" class="headerlink" title="错误方式"></a>错误方式</h4><p><img src="https://s2.loli.net/2022/02/17/q9Mnkg3FVoYmQi8.png" alt="image-20220217233308716"></p>
<p><img src="https://s2.loli.net/2022/02/17/WAx37uF6CTotYN1.png" alt="image-20220217233359456"></p>
<p><img src="https://s2.loli.net/2022/02/17/X7VEG1hQabJMnuT.png" alt="image-20220217233427223"></p>
<p>这种写法是错误的，此时只将左右大括号进行了解析，而没有解析表达式(虽不知为何会如此)。</p>
<h4 id="正确方式1："><a href="#正确方式1：" class="headerlink" title="正确方式1："></a>正确方式1：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 放在外边 --&gt;</span><br><span class="line">&lt;a th:href=<span class="string">&quot;@&#123;/employee/&#125; + $&#123;employee.id&#125;&quot;</span>&gt;delete&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<h4 id="正确方式2："><a href="#正确方式2：" class="headerlink" title="正确方式2："></a>正确方式2：</h4><p>前边的会作为路径解析，后边的作为请求参数解析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 放在里边 --&gt;</span><br><span class="line">&lt;a th:href=<span class="string">&quot;@&#123; &#x27;/employee/&#x27;+$&#123;employee.id&#125; &#125;&quot;</span>&gt;delete&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-控制器"><a href="#4-控制器" class="headerlink" title="4. 控制器"></a>4. 控制器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deleteEmployee</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">    <span class="comment">// 将占位符的值和当前形参进行绑定</span></span><br><span class="line">    employeeDao.delete(id);</span><br><span class="line">    <span class="comment">// 删除成功后，再展示数据，与原来的请求无关，故而采用重定向</span></span><br><span class="line">    <span class="comment">// 下面这样，类似于在地址栏重新输入地址，是get方式</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-Tips"><a href="#5-Tips" class="headerlink" title="5. Tips"></a>5. Tips</h3><p>解决当时遇到的405 请求方式无法解析的问题。</p>
<h4 id="1-打包"><a href="#1-打包" class="headerlink" title="1. 打包"></a>1. 打包</h4><p>借助vue.js，将超链接绑定一个表单提交事件的配置没有生效。</p>
<p>因为是在工程运行打包之后，又增加的vue.js文件。所以在当前已经打包过的资源中，它不存在，需要重新打包。</p>
<p>如下图所示：</p>
<p><img src="https://s2.loli.net/2022/02/18/4ZqrSvm1z6wjIbD.png" alt="image-20220218225905824"></p>
<h4 id="2-配置默认的servlet"><a href="#2-配置默认的servlet" class="headerlink" title="2. 配置默认的servlet"></a>2. 配置默认的servlet</h4><p>SpringMVC无法处理静态资源。</p>
<p>所以在重新打包，保证新引入的vue.js文件在打好的war包中后，仍旧会报 404 not found 的问题。</p>
<p>静态资源是要靠默认的servlet来处理的，故而需要在SpringMVC中新增配置，开放对静态资源的访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mvc:<span class="keyword">default</span>-servlet-handler /&gt;</span><br></pre></td></tr></table></figure>
<p>加上之后，所有的请求都会先被DispatcherServlet首先处理，如果找不到对应的请求映射，就会交给默认的servlet处理。</p>
<p>如果默认的servlet可以处理，那就访问，找不到的话，就提示404。</p>
<h5 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h5><p>当然，此时一定要加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven /&gt;</span><br></pre></td></tr></table></figure>
<p>如果不加的话，所有的请求都会被默认的servlet处理。</p>
<h2 id="5-添加"><a href="#5-添加" class="headerlink" title="5. 添加"></a>5. 添加</h2><p>请求方式为post</p>
<h3 id="0-思路-1"><a href="#0-思路-1" class="headerlink" title="0. 思路"></a>0. 思路</h3><p>先跳转到toAdd.html页面，将数据从表单中提交，之后通过在控制器中匹配请求名称和请求方式，执行相关的方法。</p>
<h3 id="1-html页面-1"><a href="#1-html页面-1" class="headerlink" title="1. html页面"></a>1. html页面</h3><p><img src="https://s2.loli.net/2022/02/18/ztSKYaZBFbvHrgp.png" alt="image-20220218233019137"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Add Employee<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    lastName: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    email: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    gender: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>male</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span>female<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;add&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-控制器-1"><a href="#2-控制器-1" class="headerlink" title="2. 控制器"></a>2. 控制器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addEmployee</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">    employeeDao.save(employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-修改"><a href="#6-修改" class="headerlink" title="6. 修改"></a>6. 修改</h2><p>跟delete差不多，但是因为它有独立的页面，可以执行表单提交，所以不用将超链接绑定表单提交事件。</p>
<p>请求方式为put。</p>
<h3 id="0-思路-2"><a href="#0-思路-2" class="headerlink" title="0. 思路"></a>0. 思路</h3><p>首先点击add超链接，根据提交的请求名和请求方式(超链接默认的请求方式是get)，找到第一个控制器方法</p>
<p>进入employee_update页面，回显信息，修改之后，提交信息，找到第二个控制器方法，显示当前所有员工。</p>
<h3 id="1-html页面-2"><a href="#1-html页面-2" class="headerlink" title="1. html页面"></a>1. html页面</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Update Employee<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;put&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span></span><br><span class="line">    lastName: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    email: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    gender: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>male</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>female<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;update&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-控制器方法"><a href="#2-控制器方法" class="headerlink" title="2. 控制器方法"></a>2. 控制器方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getEmployeeById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, Model model)</span> &#123;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeDao.get(id);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;employee&quot;</span>, employee);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;employee_update&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.PUT)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">updateEmployee</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">        employeeDao.save(employee);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所有工程的web.xml文件在Tomcat的conf文件夹中。</p>
<p>若自己工程配置的web.xml，与所有工程的不同(产生冲突)，以就近为准，选择自己的。</p>
<h1 id="九、-HttpMessageConverter"><a href="#九、-HttpMessageConverter" class="headerlink" title="九、 HttpMessageConverter"></a>九、 HttpMessageConverter</h1><p>HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象(要通过Java接收报文)，或将Java对象转换为响应报文(服务器用的是Java语言，但浏览器只能接收响应报文)。</p>
<p>提供了两个注解和两个类型</p>
<p>@RequestBody(将请求报文中的请求体转化为Java对象)</p>
<p><strong>@ResponseBody</strong>(将Java对象转换为响应体)</p>
<p>RequestEntity(请求实体，可以用来接收整个请求报文，既可以用来接受请求头，还能接收请求体)</p>
<p><strong>ResponseEntity</strong>(将Java数据转化为响应报文)。</p>
<p>两个请求用的少，因为请求就可以随便获取。</p>
<p>黑体的两个响应用的多，因为将Java转换为响应报文，用起来会很方便。</p>
<h2 id="1-RequestBody"><a href="#1-RequestBody" class="headerlink" title="1. @RequestBody"></a>1. @RequestBody</h2><p>@RequestBody可以获取请求体，需要在控制器方式设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testRequestBody&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestBody&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestBody</span><span class="params">(<span class="meta">@RequestBody</span> String requestBody)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody: &quot;</span> + requestBody);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220219163030353.png" alt="image-20220219163030353"></p>
<h2 id="2-RequestEntity"><a href="#2-RequestEntity" class="headerlink" title="2. RequestEntity"></a>2. RequestEntity</h2><p>RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders( )获取请求头信息，通过getBody( )获取请求体信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestEntity&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestEntity</span><span class="params">(RequestEntity&lt;String&gt; requestEntity)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestHeader: &quot;</span> + requestEntity.getHeaders());</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody: &quot;</span> + requestEntity.getBody());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/02/19/V3SJZAkdEe45aFb.png" alt="image-20220219170728090"></p>
<h2 id="3-ResponseBody"><a href="#3-ResponseBody" class="headerlink" title="3. @ResponseBody"></a>3. @ResponseBody</h2><p>@RequestBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseBody&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testResponseBody</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若不加注解，则返回的是视图名称；</p>
<p>加上注解之后，返回的是响应体的内容success。</p>
<p><img src="https://s2.loli.net/2022/02/19/nvm8gT4BW37z1US.png" alt="image-20220219172826712"></p>
<h2 id="4-SpringMVC处理Json"><a href="#4-SpringMVC处理Json" class="headerlink" title="4. SpringMVC处理Json"></a>4. SpringMVC处理Json</h2><p>到目前为止都只能return一个(字符串)文本内容，因为浏览器只能接收服务器传过来的字符串内容，它不认识Java对象，也不知道服务器用的什么语言。这是因为Http协议为服务器和浏览器之间制定了一个统一的通信规范，跟浏览器和服务器语言无关，只要按照要求传输请求报文和响应报文就可以实现通信，故而这也导致浏览器并不清楚服务器的处理方式。</p>
<p>此时，如果传输对象(例如user)的话，会：</p>
<p><img src="https://s2.loli.net/2022/02/19/kuEdqOGUeigb8LQ.png" alt="image-20220219214430230"></p>
<p>为了实现顺利传输，使用json。</p>
<p>JSON是一种数据交互格式。</p>
<h3 id="1-引入jackson依赖"><a href="#1-引入jackson依赖" class="headerlink" title="1. 引入jackson依赖"></a>1. 引入jackson依赖</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.12</span><span class="number">.5</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/02/19/Dxa8i2qvmybwGlH.png" alt="image-20220219214859189"></p>
<p>此时user对象转换为json时，转换的是json对象(最外层是{ }，数组(最外层是[ ]))。</p>
<h3 id="2-开启mvc的注解驱动"><a href="#2-开启mvc的注解驱动" class="headerlink" title="2. 开启mvc的注解驱动"></a>2. 开启mvc的注解驱动</h3><p>在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJacksonHttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-ResponseBody注解"><a href="#3-ResponseBody注解" class="headerlink" title="3. @ResponseBody注解"></a>3. @ResponseBody注解</h3><h3 id="4-Java对象作为返回值"><a href="#4-Java对象作为返回值" class="headerlink" title="4. Java对象作为返回值"></a>4. Java对象作为返回值</h3><p>将Java对象直接作为控制器方法的返回值返回，就会自动转换为<strong>Json格式的字符串</strong></p>
<p><img src="https://s2.loli.net/2022/02/19/sDKpjTU6SOZ7kJd.png" alt="image-20220219215721022"></p>
<p>Json对象是放在{ }中，以键值对的方式存储；实体类、Map转换为Json之后，是Json对象。</p>
<p>Json数组是放在[ ]中，存储的是一个一个数据。 List集合是Json数组。</p>
<h2 id="5-SpringMVC处理Ajax"><a href="#5-SpringMVC处理Ajax" class="headerlink" title="5. SpringMVC处理Ajax"></a>5. SpringMVC处理Ajax</h2><p>Ajax本身就是页面不刷新，与服务器交互。所以现在在服务器中不能使用转发和重定向，只能响应浏览器数据。</p>
<p>通过超链接绑定Ajax，但是超链接有默认行为，所以要使用vue来取消。</p>
<p>服务器响应浏览器数据，就是在当前的方法上加上@ResponseBody，将返回的内容变成响应体。</p>
<h3 id="1-发送请求的超链接"><a href="#1-发送请求的超链接" class="headerlink" title="1. 发送请求的超链接"></a>1. 发送请求的超链接</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;testAxios&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testAxios&#125;&quot;</span>&gt;</span>SpringMVC处理ajax<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-通过vue和axios处理点击事件"><a href="#2-通过vue和axios处理点击事件" class="headerlink" title="2. 通过vue和axios处理点击事件"></a>2. 通过vue和axios处理点击事件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/axios.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">testAxios</span>:<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">url</span>:event.<span class="property">target</span>.<span class="property">href</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">params</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">username</span>:<span class="string">&quot;admin&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">password</span>:<span class="string">&quot;123456&quot;</span></span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">alert</span>(response.<span class="property">data</span>)</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">                event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-控制器方法"><a href="#3-控制器方法" class="headerlink" title="3. 控制器方法"></a>3. 控制器方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testAxios&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAxios</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">    System.out.println(username +<span class="string">&quot;,&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello, axios&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-RestController注解"><a href="#6-RestController注解" class="headerlink" title="6. @RestController注解(*)"></a>6. @RestController注解(*)</h2><p>@RestController注解是SpringMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每一个方法增加了@RequestBody注解。</p>
<h2 id="7-ResponseEntity"><a href="#7-ResponseEntity" class="headerlink" title="7. ResponseEntity"></a>7. ResponseEntity</h2><p>ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是相应到浏览器的响应报文。</p>
<p>用于实现文件上传和下载。</p>
<h1 id="十、文件的上传和下载"><a href="#十、文件的上传和下载" class="headerlink" title="十、文件的上传和下载"></a>十、文件的上传和下载</h1><h2 id="1-文件下载"><a href="#1-文件下载" class="headerlink" title="1. 文件下载"></a>1. 文件下载</h2><p>使用ResponseEntity实现下载文件的功能</p>
<p>实现，自定义响应报文来响应浏览器</p>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>根据在工程中的相对路径，获取文件在服务器中的绝对路径</li>
<li>创建输入流，将文件放入输入流</li>
<li>从输入流读文件进入字节数组</li>
<li>将字节数组中的数据，作为响应报文的响应体</li>
<li>创建响应头HttpHeaders()和响应状态码HttpStatus</li>
<li>将以上三部分，放入后构造器方法，创建ResponseEntity对象</li>
<li>关闭输入流</li>
<li>返回ResponseEntity对象作为响应报文</li>
</ol>
<p>inputStream.available()； headers.add(“Content-Disposition”, “attachment;filename=cherry.jpg”);</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- file.html --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 从服务器将文件下载到客户端；将文件上传到服务器中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testDown&#125;&quot;</span>&gt;</span>下载cherry<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUpAndDownController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testDown&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;<span class="type">byte</span>[]&gt; testResponseEntity(HttpSession session) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取ServletContext对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">        <span class="comment">// getRealPath()获取服务器中的工程部署路径，从而获取服务器中文件的真实路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;/static/img/cherry.jpg&quot;</span>);</span><br><span class="line">        System.out.println(realPath);</span><br><span class="line">        <span class="comment">// 文件复制就是先读后写</span></span><br><span class="line">        <span class="comment">// 创建输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath);</span><br><span class="line">        <span class="comment">// 获取字节数组，输入流所对应的文件的所有字节，假如文件里有100个字节，那就是available方法的值就是100。</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[inputStream.available()];</span><br><span class="line">        <span class="comment">// 将流读到字节数组中</span></span><br><span class="line">        inputStream.read(bytes);</span><br><span class="line">        <span class="comment">// 将响应的内容byte数组(响应体)转化为ResponseEntity</span></span><br><span class="line">        <span class="comment">// 创建HttpHeaders对象设置响应头信息</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; headers = <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        <span class="comment">// 设置要下载的方式(attachment:以附件的形式下载)和文件名称(整个语句，只能改文件名称)</span></span><br><span class="line">        headers.add(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=cherry.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置响应状态码为200</span></span><br><span class="line">        <span class="type">HttpStatus</span> <span class="variable">statusCode</span> <span class="operator">=</span> HttpStatus.OK;</span><br><span class="line">        <span class="comment">// 创建ResponseEntity对象</span></span><br><span class="line">        ResponseEntity&lt;<span class="type">byte</span>[]&gt; responseEntity = <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(bytes, headers, statusCode);</span><br><span class="line">        <span class="comment">// 关闭输入流</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        <span class="keyword">return</span> responseEntity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-文件上传"><a href="#2-文件上传" class="headerlink" title="2. 文件上传"></a>2. 文件上传</h2><p>上传按照二进制方式，而不是name=value的映射方式。</p>
<p>post和multi-…一个都不能少，否则会完成不了上传。</p>
<p>显示一个按钮，点击后可以去选择文件。</p>
<p>获取表单属性的name元素值。</p>
<p>当前文件的名字</p>
<p>覆盖的是文件里的内容，当两个文件同名，后者将前者文件里的内容进行了覆盖。</p>
<p><img src="https://s2.loli.net/2022/02/21/hjz9eRDUJQKoY2E.png" alt="image-20220221001840497"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testUp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testUp</span><span class="params">(MultipartFile photo, HttpSession session)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    <span class="comment">// 放置上传文件的文件夹在服务器中的绝对路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">photoPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;photo&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(photoPath);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        file.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> photo.getOriginalFilename();</span><br><span class="line">    <span class="comment">// 获取文件的后缀名，如.jpg</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">suffixName</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="comment">// 随机生成一个文件名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// 组转称一个带有后缀的真正文件名</span></span><br><span class="line">    fileName = uuid + suffixName;</span><br><span class="line">    <span class="comment">// 生成文件的绝对路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">finalPath</span> <span class="operator">=</span> photoPath + File.separator + fileName;</span><br><span class="line">    <span class="comment">// MultipartFile中封装的上传文件的方法</span></span><br><span class="line">    photo.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(finalPath));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十一、拦截器"><a href="#十一、拦截器" class="headerlink" title="十一、拦截器"></a>十一、拦截器</h1><h2 id="1-拦截器的配置"><a href="#1-拦截器的配置" class="headerlink" title="1. 拦截器的配置"></a>1. 拦截器的配置</h2><p>SpringMVC中的拦截器用于拦截控制方法的执行。(Controller方法，也叫Handler方法，也就是处理器方法，</p>
<p>SpringMVC中的拦截器需要实现HandlerInterceptor。</p>
<p>SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当前的拦截器就是FirstInterceptor对象 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对所有的请求进行拦截，使用ref bean也是如此 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;bean class=&quot;com.test.interceptors.FirstInterceptor&quot;&gt;&lt;/bean&gt; </span></span><br><span class="line"><span class="comment">		&lt;ref bean==&quot;firstInterceptor&quot;&gt;&lt;/ref&gt; </span></span><br><span class="line"><span class="comment">		拦截DispatcherServlet中配置的所有请求(因为如果没有控制器方法的话，拦不了)</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">			在拦截器中，/**表示的才是所有请求，/*表示的仅是上下文路径下的第一层目录，如/index之类的 </span></span><br><span class="line"><span class="comment">			排除了访问首页的请求</span></span><br><span class="line"><span class="comment">			设置拦截器为FirstInterceptor类的对象(FirstInterceptor要加注解，注册成为IOC容器中的对象)</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	以上配置方法可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<p>doFilter：调用下一个过滤器，其实就是放行的意思。</p>
<h2 id="2-拦截器的三个抽象方法"><a href="#2-拦截器的三个抽象方法" class="headerlink" title="2. 拦截器的三个抽象方法"></a>2. 拦截器的三个抽象方法</h2><p>SpringMVC中的拦截器有三个抽象方法：</p>
<p>preHandler：控制器方法执行之前执行preHandler( )，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法</p>
<p>postHandler：控制器方法执行之后执行postHandler( )</p>
<p>afterCompletion：处理完视图和模型数据，将模型填充完视图(就是将ModelAndView中的Model填充到View中之后)，即渲染完视图之后执行afterCompletion( )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册成为IOC容器中的对象</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;First Handler --&gt; preHandler&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;First Handler --&gt; postHandler&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;First Handler --&gt; afterCompletion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/04/y6sGFKnoAuwiC5g.png" alt="image-20220304211303104"></p>
<h3 id="3-多个拦截器的执行顺序"><a href="#3-多个拦截器的执行顺序" class="headerlink" title="3. 多个拦截器的执行顺序"></a>3. 多个拦截器的执行顺序</h3><h4 id="1-若每个拦截器的preHandle-都返回true"><a href="#1-若每个拦截器的preHandle-都返回true" class="headerlink" title="1. 若每个拦截器的preHandle()都返回true"></a>1. 若每个拦截器的preHandle()都返回true</h4><p>preHandler：按照配置的顺序执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.interceptorList.size() - <span class="number">1</span>; i++)</span><br></pre></td></tr></table></figure>
<p>postHandler和afterCompletion：按照配置的反序执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.size() - <span class="number">1</span>; i &gt;=<span class="number">0</span> ; i--)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/05/fRGnkNeWdjrybtp.png" alt="image-20220305161717406"></p>
<p><img src="https://s2.loli.net/2022/03/05/vKESaZ7xAf8ib9J.png" alt="image-20220305170713313"></p>
<p><img src="https://s2.loli.net/2022/03/05/tEf9o2JpMOPWSs1.png" alt="image-20220305170926324"></p>
<h4 id="2-若某个拦截器的preHandler-返回了false"><a href="#2-若某个拦截器的preHandler-返回了false" class="headerlink" title="2. 若某个拦截器的preHandler()返回了false"></a>2. 若某个拦截器的preHandler()返回了false</h4><p>preHandle( )返回false和它之前的拦截器的preHandle( )都会执行，postHandle( )都不执行，返回false的拦截器之前的拦截器的afterCompletion( )会执行。</p>
<p><img src="https://s2.loli.net/2022/03/05/pD5AYMTGyLSO9HP.png" alt="image-20220305173638365"></p>
<p>因为一旦preHandle返回了false，那么方法会直接return，即其下的所有语句都不会执行(包括postHandle( )和afterCompletion( ))。</p>
<p><img src="https://s2.loli.net/2022/03/05/6OqsKRAnFB3l9uI.png" alt="image-20220305173800001"></p>
<h1 id="十二、异常处理器"><a href="#十二、异常处理器" class="headerlink" title="十二、异常处理器"></a>十二、异常处理器</h1><h2 id="1-基于配置的异常处理"><a href="#1-基于配置的异常处理" class="headerlink" title="1. 基于配置的异常处理"></a>1. 基于配置的异常处理</h2><p>SpringMVC提供了一个处理控制器方法过程中所出现的异常的接口：HandlerExceptionResolver</p>
<p>该接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver(用于自定义异常处理)。</p>
<p>使用方式：</p>
<p>exceptionAttribute: 存储当前的异常信息，默认将其保存在当前请求域中，以value为该异常信息的键。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置异常处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">				properties的键表示处理器方法执行过程中出现的异常</span></span><br><span class="line"><span class="comment">				properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面</span></span><br><span class="line"><span class="comment">			--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ArithmeticException&quot;</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">		exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享。</span></span><br><span class="line"><span class="comment">		设置将异常信息共享在请求域中的键value，可以在请求域中获取异常信息</span></span><br><span class="line"><span class="comment"> 	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/05/hK6PRFvd97aOzok.png" alt="image-20220305193514369"></p>
<h2 id="2-基于注解的异常处理"><a href="#2-基于注解的异常处理" class="headerlink" title="2. 基于注解的异常处理"></a>2. 基于注解的异常处理</h2><p>此时就不需要在SpringMVC中进行配置了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有将类标识为组件的功能</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value=&#123;ArithmeticException.class, NullPointerException.class&#125;)</span></span><br><span class="line">    <span class="comment">// 这里的Exception指的是当前的出现异常，设置Model是为了将异常放到请求域中</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testException</span><span class="params">(Exception ex, Model model)</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;ex&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十三、-注解配置SpringMVC"><a href="#十三、-注解配置SpringMVC" class="headerlink" title="十三、 注解配置SpringMVC"></a>十三、 注解配置SpringMVC</h1><p>使用配置类和注解代替web.xml和SpringMVC配置文件的功能</p>
<h2 id="1-创建初始化类，代替web-xml"><a href="#1-创建初始化类，代替web-xml" class="headerlink" title="1. 创建初始化类，代替web.xml"></a>1. 创建初始化类，代替web.xml</h2><p>在Servlet3.0的环境中，容器会在类路径中查找实现Javax.servlet.ServletContainerInitializer接口的类，如果找到的话，就用它来配置servlet容器。</p>
<p>Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。</p>
<p>当我们的类拓展了AbstractAnnotationConfigDispatcherServletInitializer(WebApplicationInitializer的一个基础实现)并将其部署到<strong>Servlet3.0容器</strong>的时候，容器会自动发现它，并用它来配置上下文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebInit</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc: 指定Spring的配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Class&lt;?&gt;[]&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/5 21:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="comment">// 返回配置类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc: 指定SpringMVC的配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Class&lt;?&gt;[]&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/5 21:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="comment">// 这个类要有</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc:指定DispatcherServlet的映射规则，即url-pattern</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Class&lt;?&gt;[]&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/5 21:13</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc: 注册过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Filter[]&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/5 21:25</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">characterEncodingFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        characterEncodingFilter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        characterEncodingFilter.setForceRequestEncoding(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">HiddenHttpMethodFilter</span> <span class="variable">hiddenHttpMethodFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HiddenHttpMethodFilter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;characterEncodingFilter, hiddenHttpMethodFilter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-配置WebConfig类，代替SpringMVC-xml"><a href="#2-配置WebConfig类，代替SpringMVC-xml" class="headerlink" title="2. 配置WebConfig类，代替SpringMVC.xml"></a>2. 配置WebConfig类，代替SpringMVC.xml</h2><h3 id="视图解析器部分"><a href="#视图解析器部分" class="headerlink" title="视图解析器部分"></a>视图解析器部分</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> WebConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 代替SpringMVC的配置文件</span></span><br><span class="line"><span class="comment"> * 1. 扫描组件 2.视图解析器 3.view-controller 4.default-servlet-handler 5.mvc注解驱动</span></span><br><span class="line"><span class="comment"> * 6.文件上传解析器 7.异常处理 8.拦截器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/03/2022/3/5 21:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 扫描组件</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="comment">// mvc注解驱动</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc: 生成模板解析器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> org.thymeleaf.templateresolver.ITemplateResolver&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/5 21:42</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ITemplateResolver <span class="title function_">templateResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">WebApplicationContext</span> <span class="variable">webApplicationContext</span> <span class="operator">=</span></span><br><span class="line">                ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">templateResolver</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(</span><br><span class="line">                        webApplicationContext.getServletContext());</span><br><span class="line">        templateResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        templateResolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> templateResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc: 生成模板引擎并为其注入模板解析器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> templateResolver</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> SpringTemplateEngine&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/5 21:41</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SpringTemplateEngine <span class="title function_">templateEngine</span><span class="params">(ITemplateResolver templateResolver)</span> &#123;</span><br><span class="line">        <span class="type">SpringTemplateEngine</span> <span class="variable">templateEngine</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SpringTemplateEngine</span>();</span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> templateEngine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc: 生成视图解析器并将解析器注入模板引擎</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> templateEngine</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> ViewResolver&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/5 21:40</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ViewResolver <span class="title function_">viewResolver</span><span class="params">(SpringTemplateEngine templateEngine)</span> &#123;</span><br><span class="line">        <span class="type">ThymeleafViewResolver</span> <span class="variable">viewResolver</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThymeleafViewResolver</span>();</span><br><span class="line">        viewResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        viewResolver.setTemplateEngine(templateEngine);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>整体的步骤可以根据之前配置的SpringMVC.xml文件中的视图解析器的配置得到。</p>
<p>由其中代码可得：最外部的Thymeleaf视图解析器，其中按照内部bean的方式，配置了一个SpringTemplate-Engine的属性，而对于这个SpringTemplateEngine，其中又以内部bean的方式配置了一个ITemplateResolver的属性。则可得，想要完成这个视图解析器，需要一一将内部的属性给表示出来，并注册到IOC容器中，使属性成为一个可以给参数赋值的bean。</p>
<h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>@Bean这个注解，加上之后，当前方法的返回值就是IOC的一个bean。</li>
</ol>
<p>​        当前创建的IOC容器，如果是Java工程，就是一个ApplicationContext，如果当前工程是一个web环境，就是WebApplicationContext。</p>
<ol>
<li><p>方法中的参数，都是通过自动装配的方式，进行赋值的，这就要求能够使用的参数，必须是当前Spring的IOC容器中已经拥有的bean，可以为该参数赋值的情况下。(当前方法中的参数，必须要符合自动装配的规则，否则会报错，提示could not autowire…)</p>
</li>
<li><p>通过set方法对内部属性进行赋值(自动装配，在Spring中，必须要有set方法，才能在配置文件中进行属性赋值)。</p>
</li>
</ol>
<h3 id="剩余部分"><a href="#剩余部分" class="headerlink" title="剩余部分"></a>剩余部分</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc: 4. default-servlet-handler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> configurer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/7 20:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">    configurer.enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc: 8. 拦截器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/7 20:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    <span class="type">TestInterceptor</span> <span class="variable">testInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestInterceptor</span>();</span><br><span class="line">    registry.addInterceptor(testInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc: 3. view-controller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/7 20:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">    registry.addViewController(<span class="string">&quot;/hello&quot;</span>).setViewName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc: 6. 文件上传解析器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> MultipartResolver&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/7 20:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MultipartResolver <span class="title function_">multipartResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">CommonsMultipartResolver</span> <span class="variable">commonsMultipartResolver</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CommonsMultipartResolver</span>();</span><br><span class="line">    <span class="keyword">return</span> commonsMultipartResolver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc: 7. 异常处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resolvers</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/7 20:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; resolvers)</span> &#123;</span><br><span class="line">    <span class="type">SimpleMappingExceptionResolver</span> <span class="variable">exceptionResolver</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SimpleMappingExceptionResolver</span>();</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    properties.setProperty(<span class="string">&quot;java.lang.ArithmeticException&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    exceptionResolver.setExceptionMappings(properties);</span><br><span class="line">    exceptionResolver.setExceptionAttribute(<span class="string">&quot;exception&quot;</span>);</span><br><span class="line">    resolvers.add(exceptionResolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><p>大部分是通过实现接口WebMvcConfigurer提供的方法。</p>
<p>其中的文件上传解析器，是根据SpringMVC.xml中的配置(只需一个bean标签即可)，自行构造一个Multipart-Resolver接口的实现类commonsMultipartResolver的对象后，将其通过@Bean注解注册到IOC容器中成为一个bean的。</p>
<p>至于其他部分，直接根据待实现的方法，构造参数即可。需要注意的是异常处理的方法。</p>
<h5 id="异常处理部分"><a href="#异常处理部分" class="headerlink" title="异常处理部分"></a>异常处理部分</h5><p>首先它的参数是一个List</p>
<p>其次，这一部分在配置文件中，设置了props标签，所以需要在方法中设置properties这一属性。</p>
<p>而后，由于properties操作属性集properties文件，该文件中存储的键和值都只能是字符串，所以说在操作属性集文件时，不能使用get和set方法，而要使用专门提供的setProperty( )方法。</p>
<h1 id="十四、SpringMVC执行流程"><a href="#十四、SpringMVC执行流程" class="headerlink" title="十四、SpringMVC执行流程"></a>十四、SpringMVC执行流程</h1><h2 id="1-SpringMVC常用组件"><a href="#1-SpringMVC常用组件" class="headerlink" title="1. SpringMVC常用组件"></a>1. SpringMVC常用组件</h2><h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><p>前端控制器，不需要工程师开发，由框架提供。</p>
<p>作用：统一处理请求和响应，是整个流程控制的中心，由他调用其他组件处理用户的请求。</p>
<h3 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h3><p>处理器映射器，不需要工程师开发，由框架提供</p>
<p>作用：根据请求的url、method等信息查找Handler，即控制器方法</p>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>处理器(控制器)，需要工程师开发</p>
<p>作用：在DispatcherServlet的控制下，针对具体的用户请求进行处理</p>
<h3 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h3><p>处理器适配器，不需要工程师开发，由框架提供</p>
<p>作用：通过HandlerAdapter对处理器进行执行</p>
<h3 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h3><p>视图解析器，不需要工程师开发，由框架提供</p>
<p>作用：进行视图解析，得到相应的视图，如ThymeleafView、InternalResourceView、RedirectView</p>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>视图，需要进行页面设置</p>
<p>作用：将模型数据通过页面展示给用户</p>
<h2 id="2-DispatcherServlet初始化过程"><a href="#2-DispatcherServlet初始化过程" class="headerlink" title="2. DispatcherServlet初始化过程"></a>2. DispatcherServlet初始化过程</h2><p>本质上是一个Servlet，所以遵循Servlet的生命周期，所以宏观上是Servlet生命周期来进行调度。</p>
<p><img src="https://s2.loli.net/2022/03/07/6sl8LdIiEZYab9v.png" alt="image-20220307215703655"></p>
<p><img src="https://s2.loli.net/2022/03/07/VphscB7t1LewbrH.png" alt="image-20220307215730504"></p>
<p>Spring的IOC容器为父容器，而SpringMVC的IOC为子容器</p>
<p>FrameworkServlet创建WebApplicationContext后，需要刷新容器，即调用onRefresh(wac)方法(FrameworkServlet中，没有该方法的方法体)。此方法在DispatcherServlet中进行了重写，调用了InitStrategies(context)方法，即初始化策略，初始化DispatcherServlet的各个组件。</p>
<p><img src="https://s2.loli.net/2022/03/07/H5UfF4STskA73tp.png" alt="image-20220307221416187"></p>
<h2 id="3-DispatcherServlet调用组件处理请求"><a href="#3-DispatcherServlet调用组件处理请求" class="headerlink" title="3. DispatcherServlet调用组件处理请求"></a>3. DispatcherServlet调用组件处理请求</h2><h3 id="1-processRequest"><a href="#1-processRequest" class="headerlink" title="1. processRequest()"></a>1. processRequest()</h3><p>向下转型</p>
<h2 id="4-SpringMVC的执行流程"><a href="#4-SpringMVC的执行流程" class="headerlink" title="4. SpringMVC的执行流程"></a>4. SpringMVC的执行流程</h2><ol>
<li>用户向服务器发送请求，请求被SpringMVC前端控制器DispatcherServlet捕获。</li>
<li>DispatcherServlet对请求URL进行解析，得到请求资源标识符(URI)，判断请求URI对应的映射：<ol>
<li>不存在<ol>
<li>再判断是否配置了mvc:default-servlet-handler</li>
<li>如果没配置，则控制台报映射查找不到，客户端展示404错误</li>
<li>如果有配置，则访问目标资源(一般为静态资源，如JS、CSS、HTML)，找不到的话，客户端也会展示404错误</li>
</ol>
</li>
<li>存在则执行下面的流程<ol>
<li>根据该URI，调用HandlerMapping获得该Handler配置的所有相关对象(控制器方法、拦截器集合、拦截器索引)，最后以HandlerExecutionChain执行链对象的形式返回。</li>
<li>DispatcherServlet根据获得的Handler，选择一个合适的HandlerAdapter。</li>
<li>如果成功获得，此时开始执行拦截器的preHandler方法</li>
<li>提取Request中的模型数据，填充Handler入参，开始执行Handler(Controller)方法，处理请求。在填充Handler的入参过程中，根据配置，Spring将：<ol>
<li>HttpMessageConveter：将请求消息(如Json、xml等数据)转换成一个对象，将对象转换成指定的响应信息</li>
<li>数据转换：对请求消息进行数据转换，如String转换成Integer等</li>
<li>数据格式化：对请求消息进行数据格式化，如将字符串转换成格式化数字或格式化日期等</li>
<li>数据验证：验证数据的有效性(长度、格式)，验证结果存储到BindingResult或Error中</li>
<li>Handler执行完成后，向DispatcherServlet返回一个ModelAndView对象</li>
<li>此时将开始执行拦截器的postHandler()方法</li>
<li>根据返回的ModelAndView(此时判断是否存在异常，若存在，则执行HandlerExceptionResolver进行异常处理)，选择合适的ViewResolver视图解析器进行视图解析，根据Model和View来渲染视图。</li>
<li>渲染视图完毕，执行拦截器的afterCompletion()方法</li>
<li>将渲染结果返回给客户端。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="末章-补充信息"><a href="#末章-补充信息" class="headerlink" title="末章 补充信息"></a>末章 补充信息</h1><h2 id="1-ServletContext介绍"><a href="#1-ServletContext介绍" class="headerlink" title="1. ServletContext介绍"></a>1. ServletContext介绍</h2><h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>ServletContext官方叫servlet上下文。</p>
<p>服务器会为每一个工程创建一个对象，这个对象就是ServletContext对象。这个对象全局唯一，而且工程内部的所有servlet都共享这个对象。所以叫，<strong>全局应用程序共享对象</strong>。</p>
<p><img src="https://s2.loli.net/2022/02/20/XrfVwxHI28oMdFO.png" alt="image-20220220123848890"></p>
<h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h3><ul>
<li><p><strong>是一个域对象</strong></p>
</li>
<li><p>可以读取全局配置参数</p>
</li>
<li>可以搜索当前工程目录下面的资源文件</li>
</ul>
<h4 id="1-域对象"><a href="#1-域对象" class="headerlink" title="1. 域对象"></a>1. 域对象</h4><p>域对象是服务器在内存上创建的存储空间，用于在不同动态资源(servlet)之间传递与共享数据。</p>
<h4 id="2-域对象方法"><a href="#2-域对象方法" class="headerlink" title="2. 域对象方法"></a>2. 域对象方法</h4><p>凡是域对象都有如下3个方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>setAttribute(name, value);name为String类型，value是Object类型；</td>
<td>向域对象中添加数据，以key-value形式</td>
</tr>
<tr>
<td>getAttribute(name)；</td>
<td>根据指定的key读取域对象中的数据</td>
</tr>
<tr>
<td>removeAttribute(name);</td>
<td>根据指定的key从域对象中删除数据</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-存储特点"><a href="#3-存储特点" class="headerlink" title="3. 存储特点"></a>3. 存储特点</h4><p>servletContext中的数据，全局共享，所有的动态资源都可以写入和获取</p>
<p>服务器启动的时候创建，服务器关闭的时候销毁，因为这是全局应用程序对象，全局共享对象。</p>
<h4 id="4-可以读取全局配置参数"><a href="#4-可以读取全局配置参数" class="headerlink" title="4. 可以读取全局配置参数"></a>4. 可以读取全局配置参数</h4><p>servletContext读取全局参数的核心方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>getServletContext().getInitParameter(name);</td>
<td>根据指定的参数名获取参数值</td>
</tr>
<tr>
<td>getServletContext().getInitParameterNames();</td>
<td>获取所有参数名称列表</td>
</tr>
</tbody>
</table>
</div>
<p> <img src="https://s2.loli.net/2022/02/20/xKa1uY6ReSy3ft9.png" alt="image-20220220144024285"></p>
<h4 id="5-搜索工程下资源文件"><a href="#5-搜索工程下资源文件" class="headerlink" title="5. 搜索工程下资源文件"></a>5. 搜索工程下资源文件</h4><p>path：相对路径</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>getServletContext().getRealPath(path);</td>
<td>根据相对路径获取服务器上资源的绝对路径</td>
</tr>
<tr>
<td>getServletContext().getResourceAsStream(path);</td>
<td>根据相对路径获取服务器上资源的输入字节流</td>
</tr>
</tbody>
</table>
</div>
<h4 id="6-获取当前工程名字"><a href="#6-获取当前工程名字" class="headerlink" title="6. 获取当前工程名字"></a>6. 获取当前工程名字</h4><p>getServletContext().getContextPath()：获取当前工程名字</p>
<h2 id="2-Servlet三大域对象"><a href="#2-Servlet三大域对象" class="headerlink" title="2. Servlet三大域对象"></a>2. Servlet三大域对象</h2><p>域对象的作用：保存数据、获取数据、共享数据。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>对象名称</th>
<th>对象的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>HttpServletRequest</td>
</tr>
<tr>
<td>session</td>
<td>HttpSession</td>
</tr>
<tr>
<td>application</td>
<td>ServletContext</td>
</tr>
</tbody>
</table>
</div>
<h3 id="1-request"><a href="#1-request" class="headerlink" title="1. request"></a>1. request</h3><p>创建：客户端向服务器发送一次请求，服务器就会创建request对象</p>
<p>销毁：服务器对这次请求做出响应之后就会销毁request对象</p>
<p>有效：仅在当前请求中有效</p>
<p>方法：request.getParameter(); request.setAttribute()。</p>
<h3 id="2-session"><a href="#2-session" class="headerlink" title="2. session"></a>2. session</h3><p>创建：服务器端第一次调用getSession()；(保存在服务器内存中)</p>
<p>销毁：</p>
<ul>
<li>非正常关闭服务器(正常关闭session会序列化，再次启动session会被反序列化)</li>
<li>session过期(Tomcat中为30分钟)</li>
<li>手动调用session.invalidate();</li>
</ul>
<p>有效：从用户打开浏览器会话开始，直到关闭浏览器会话结束。一次会话只创建一个session对象。</p>
<p>方法：(String) request.getSession().getAttribute(“imageMsg”); </p>
<p>request.getSession().setAttribute(“user”, user)；</p>
<h3 id="application"><a href="#application" class="headerlink" title="application"></a>application</h3><p>创建：服务器启动时，为每个web应用创建一个属于该项目的对象ServletContext类；</p>
<p>销毁：服务器关闭或项目从服务器中移除的时候</p>
<p>有效：此信息在整个服务器上被保留</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><img src="https://s2.loli.net/2022/02/20/HAfMwiCgpSoX1nO.png" alt="image-20220220145904822"></p>
<h3 id="附：pageContext-jsp"><a href="#附：pageContext-jsp" class="headerlink" title="附：pageContext(jsp)"></a>附：pageContext(jsp)</h3><p>对象类型：pageContext</p>
<p>有效范围最小。</p>
<p>当前页面有效，超过这个页面就不能使用。</p>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>cache</title>
    <url>/2021/10/31/cache/</url>
    <content><![CDATA[<h1 id="cache存储器"><a href="#cache存储器" class="headerlink" title="cache存储器"></a>cache存储器</h1><h2 id="一-背景"><a href="#一-背景" class="headerlink" title="一  背景"></a>一  背景</h2><p>在计算机系统中，CPU的工作速度远超主存储器的工作速度。一方面，因为高速的静态存储器芯片因为容量小且价格高，并不适合组成大容量的主存储器，故而主存储器一般采用动态存储器实现。但由于其读取速度慢，一定程度上限制了CPU的工作速度。另一方面，通过大量统计发现，程序对存储空间的90%的访问局限于存储空间10%的区域，另外10%的访问则分布在存储空间的90%的区域中。</p>
<p>所谓，时势造英雄。为了中和CPU和主存之间速度的不匹配，诞生了cache这一重要的技术。</p>
<h2 id="二-简介"><a href="#二-简介" class="headerlink" title="二  简介"></a>二  简介</h2><h3 id="1-功能"><a href="#1-功能" class="headerlink" title="1  功能"></a>1  功能</h3><p>cache是介于CPU和主存之间的小容量存储器，存取速度比主存块。它能高速地向CPU提供指令和数据，加快程序的执行速度。它的内容为主存一部分内容的副本。当储存器收到读取指令时，先在cache中查找此信息是否存在，若有，则不经主存，直接从cache中取出，否则直接从主存中取出，同时写出cache，以备再次使用。</p>
<h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2  原理"></a>2  原理</h3><p>CPU与cache之间的数据交换是==以字为单位==，而cache与主存之间的数据交换是==以块为单位==。一个块由若干定长字组成。当CPU读取主存中的一个字时，便发出<strong>此字的地址到cache和主存</strong>。此时cache控制逻辑，依据地址判断此字是否在cache中，若是，此字立即传送给CPU；若非，则用主存读周期把此字从主存读出送到CPU，与此同时，把含有这个字的<strong>整个数据块</strong>从主存读出送到cache中。</p>
<h3 id="3-工作过程"><a href="#3-工作过程" class="headerlink" title="3  工作过程"></a>3  工作过程</h3><p>1.当CPU执行访问指令时，将所要访问的字的地址送到相联存储器(cam)中和主存。</p>
<p>2.在相联存储器中进行地址查找，若相联存储器指出，所要访问的字W在cache中(命中)，则把W直接由cache送入CPU；反之(不命中)，则从主存中读取W，送入CPU，顺便把包含W在内的4个字(一个块)送入cache。(分配给cache的地址，保存在相联存储器(cam)中，它是按照内容寻址的。)</p>
<h3 id="4-cache的命中率"><a href="#4-cache的命中率" class="headerlink" title="4  cache的命中率"></a>4  cache的命中率</h3><p>增加cache的目的，就是在性能上使主存的平均读出时间尽可能接近cache的读出时间。因此，cache的命中率应接近于1。在一个程序执行期间，设Nc表示cache完成存取的次数，Nm表示主存完成存取的总次数，H定义为命中率，则有：</p>
<script type="math/tex; mode=display">
H=Nc/(Nc+Nm)</script><p>若tc表示命中时cache访问时间，tm表示未命中时的主存访问时间，则cache/贮存系统的平均访问时间ta为：</p>
<script type="math/tex; mode=display">
ta=tc*H+(1-H)*tm</script><script type="math/tex; mode=display">
r=tm/tc表示主存慢于cache的倍率，e=tc/ta表示访问效率</script><p>为提高访问效率，命中率H越接近于1越好，r值以5-10为宜，不宜过大。</p>
<p>注：</p>
<ul>
<li>命中率与程序的行为、cache的容量、组织方式、块的大小有关。</li>
<li>程序的行为：程序顺序执行最佳。</li>
<li>cache的容量：容量越大，可存放的部分复本越多，调进调出的动作少。</li>
<li>组织方式：cache与主存的相连方式影响调进调出的次数。</li>
<li>块的大小：块太小，块太大都影响调进调出的次数。</li>
</ul>
<h3 id="5-主存与cache的地址映射"><a href="#5-主存与cache的地址映射" class="headerlink" title="5  主存与cache的地址映射"></a>5  主存与cache的地址映射</h3><p>cache的容量很小，它保存的内容只是主存内容的一个子集，且cache与主存的数据交换是以块为单位。</p>
<p>地址映射即是应用某种方法把主存地址定位到cache中。地址映射的方式有<strong>全相联方式、直接映射方式和组相联方式三种。</strong></p>
<h4 id="1-全相联方式"><a href="#1-全相联方式" class="headerlink" title="1. 全相联方式"></a>1. 全相联方式</h4><p>主存中的一个<strong>块的地址与块的内容</strong>一起存于cache的行中，其中<strong>块地址存于cache行的标记部分</strong>中，是由于此种方式，<strong>内存中的块可以映射到cache任意一行中</strong>。块的大小 = 行的大小。</p>
<p><img src="https://s2.loli.net/2022/02/26/uOPmRoygLaAMlf3.png" alt="image-20220226230105281"></p>
<p>此处的含义其实是，主存一共有256行，用8位来表示主存中的块号。</p>
<p>因为，主存一行中256字，故而还需要一个8位来表示对应块的块内地址。</p>
<p>这就需要一块一块地进行比对，耗时。</p>
<p>由于其电路设计复杂，更多用于小容量cache。<img src="https://s2.loli.net/2021/12/22/dmGe41p2RknPCAt.png" alt="image-20211031151344855"></p>
<h4 id="2-直接映射方式"><a href="#2-直接映射方式" class="headerlink" title="2. 直接映射方式"></a>2. 直接映射方式</h4><p>这也是一种多对一的映射关系，但一个主存块只能拷贝到cache的一个特定行位置上去。</p>
<p>cache的行号i和主存的块号j有如下函数关系：</p>
<script type="math/tex; mode=display">
i=j (mod) m(m为cache的行数)</script><p><img src="https://s2.loli.net/2021/12/22/2AgZ6BmErHPQC1M.png" alt="image-20211031151518192"></p>
<p>注意比较的顺序，另外由于几个内存块对应同一行，容易发生空间冲突。适合于大容量cache。</p>
<h4 id="3-组相联映射"><a href="#3-组相联映射" class="headerlink" title="3.组相联映射"></a>3.组相联映射</h4><p>将cache分为u组，每组v行，主存块存放到哪个组是固定的(直接映射方式)，至于存放到该组哪一行，是灵活的(全相联映射方式)。</p>
<p><img src="https://s2.loli.net/2021/12/22/btAswxjhvFGR92y.png" alt="image-20211031152253327"></p>
<p>注意比较的顺序。</p>
<h3 id="6-替换策略"><a href="#6-替换策略" class="headerlink" title="6  替换策略"></a>6  替换策略</h3><p>cache的工作原理要求其尽可能保存最新的数据，则必然存在将有用的信息从主存调入cache，这样就产生替换。</p>
<blockquote>
<p><strong><em>针对直接映射的cache来说，因为其在cache中的位置是固定的，故而只需把特定位置上的原主存块换出cache即可，将新增信息调进即可。</em></strong></p>
</blockquote>
<p>对<strong>全相联和组相联的cache而言</strong>，就要从允许存放新主存块的若干特定行中选取一行换出，这就涉及到常用的替换算法了。</p>
<h4 id="1-最不长使用法-类似队列先进先出-："><a href="#1-最不长使用法-类似队列先进先出-：" class="headerlink" title="1.最不长使用法(类似队列先进先出)："></a>1.最不长使用法(类似队列先进先出)：</h4><p>将一段时间内，访问次数最少的那行数据换出。即每行设置一计数器，每访问一次，就增加一次计数，最后替换计数最小的一行。</p>
<h4 id="2-近期最少使用法-LRU"><a href="#2-近期最少使用法-LRU" class="headerlink" title="2.近期最少使用法(LRU):"></a>2.近期最少使用法(LRU):</h4><p>将近期长久未被访问过的那行数据换出。即每行设置一计数器，每访问一次，就将所访问者计数器清零，其他计数值加1，最后替换计数最大的一行(可用<em>标记许久未使用的行，<em>*常用</em></em>)。</p>
<h3 id="7-cache的写操作策略"><a href="#7-cache的写操作策略" class="headerlink" title="7  cache的写操作策略"></a>7  cache的写操作策略</h3><p>CPU对cache的写入，更改了cache的内容。为保持主存与cache中信息的一致性，避免CPU在读写过程中，将cache中的新数据遗失，造成错误的读数据，确保cache中数据不会因覆盖而消失，必须将cache中的数据更新及时反映到主存中。</p>
<p>可选用三种写操作策略，以使cache内容和主存内容保持一致。</p>
<h4 id="1-写回法-回写式"><a href="#1-写回法-回写式" class="headerlink" title="1.写回法(回写式)"></a>1.写回法(回写式)</h4><p>​    当CPU写cache命中时，只修改cache内容，而不立即写入内存，只有当此行(块)被换出时，才写回内存。</p>
<p>这种方法减少了CPU访问内存的次数，但存在内存不一致的隐患。</p>
<p>实现这种方法时，每一个cache须设置一个修改位，以反映此行是否被CPU修改过。(常用)</p>
<h4 id="2-全写法-直写式"><a href="#2-全写法-直写式" class="headerlink" title="2.全写法(直写式)"></a>2.全写法(直写式)</h4><p>​    当写cache命中时，cache与主存同时发生写修改，因而较好维护了cache与主存内容的一致性。</p>
<p>当写cache未命中时，直接向主存中写入。cache每行无需设置修改位以及相应的判断逻辑。此时可将修改内容调进cache中，也可不调进。</p>
<p>减弱了cache的效果。</p>
<h4 id="3-写一次法-缓冲直写式"><a href="#3-写一次法-缓冲直写式" class="headerlink" title="3.写一次法(缓冲直写式)"></a>3.写一次法(缓冲直写式)</h4><p>两种方法的结合。写命中与写未命中与写回法相同。只是第一次写命中时，会启动一个存储写周期，即同时写入主存，而其他cache块监听到此周期时，也顺便更新自身该数据块数据。便于维护系统中所有cache的一致性。(奔腾CPU采用)</p>
]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>github</title>
    <url>/2021/12/03/github/</url>
    <content><![CDATA[<blockquote>
<p>首先，喜事：终于成功把第一个小项目放到Github上去啦！</p>
<p>戳<a href="https://github.com/Phoenix-Nrvn/Ming">Phoenix-Nrvn/Ming (github.com)</a>即可访问</p>
</blockquote>
<h1 id="更新Github上的代码"><a href="#更新Github上的代码" class="headerlink" title="更新Github上的代码"></a>更新Github上的代码</h1><h2 id="一、克隆自己Github上的项目代码到本地"><a href="#一、克隆自己Github上的项目代码到本地" class="headerlink" title="一、克隆自己Github上的项目代码到本地"></a>一、克隆自己Github上的项目代码到本地</h2><p>原因嘛，Github上不能删除文件夹的，只能把项目拉到本地删除再更新</p>
<ol>
<li><p>首先随便创建一个文件夹(存放下载下来的代码)</p>
</li>
<li><p>输入指令克隆自己的代码</p>
<p><code>git clone https://github.com/用户名/仓库名.git</code></p>
</li>
</ol>
<h2 id="二、查看一下仓库状态"><a href="#二、查看一下仓库状态" class="headerlink" title="二、查看一下仓库状态"></a>二、查看一下仓库状态</h2><p><code>git status</code></p>
<p>注意要先切换到存储原来GitHub本地代码的位置，不是刚刚下载代码才建的文件夹。</p>
<h2 id="三、更新"><a href="#三、更新" class="headerlink" title="三、更新"></a>三、更新</h2><ol>
<li><p>直接在本地，把改好的文件替换原来的相应部分就好</p>
<p><code>git add *--表示更新全部</code></p>
</li>
<li><p>添加更新说明，commit只是将其提交到缓存区域</p>
<p><code>git commit -m &quot;update&quot;(可将update替换为别的内容)</code></p>
</li>
<li><p>上传</p>
<p><code>git push origin 分支名 --(若是多人同时开发维护，首先git pull，拉取当前分支最新代码)</code></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>A Good Day</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><p>即虚拟机与外界通讯时，要求与主机处于同一个网段。使用桥接模式，需要为虚拟机单独分配IP地址，但IP地址是有限的，会消耗资源，容易造成IP冲突。</p>
<h4 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h4><p>虚拟机分配的IP地址，不需要与主机在同一网段。而且设置后，主机会生成一个虚拟的网卡，在虚拟机和主机之间，建立联系互通，也可以跟外网通讯，且不造成IP冲突。其为网络地址转换模式。内网可以连接外网，但外网不能返回内网，因为内网可以通信，是因为地址转换，即通过了主机代理。</p>
<h4 id="主机模式"><a href="#主机模式" class="headerlink" title="主机模式"></a>主机模式</h4><p>即一个独立的系统，不和外部发生联系，想怎么配怎么配。</p>
]]></content>
  </entry>
  <entry>
    <title>实战Java高并发</title>
    <url>/2022/02/14/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="Chapter1-走入并向世界"><a href="#Chapter1-走入并向世界" class="headerlink" title="Chapter1 走入并向世界"></a>Chapter1 走入并向世界</h1><h2 id="1-一些概念"><a href="#1-一些概念" class="headerlink" title="1. 一些概念"></a>1. 一些概念</h2><h3 id="1-同步-Synchronous-和异步-Asynchronous"><a href="#1-同步-Synchronous-和异步-Asynchronous" class="headerlink" title="1. 同步(Synchronous)和异步(Asynchronous)"></a>1. 同步(Synchronous)和异步(Asynchronous)</h3><p>同步和异步通常用来形容一次方法的调用。</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>同步方法调用一旦开始，必须要等到方法调用结束返回后，才能继续后续的行为。(去现场买一个空调，要等商家调货，等买完之后回家，才能做别的事。)</p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>异步方法调用一旦开始，方法调用就会立即返回，调用者就可以进行后续的操作。而异步方法通常会在另一个线程中“真实地”执行，如果需要返回结果，调用结束后，会通知调用者。(在网上买一个空调，付完钱，就可以去做别的事，而商家则回去设计空调到达的过程。等空调到了之后，去签收即可。)</p>
<p><img src="https://s2.loli.net/2022/02/14/Zwo3rjEmqQFbRGB.png" alt="image-20220214225304471"></p>
<h3 id="2-并发-Concurrency-和并行-Parallelism"><a href="#2-并发-Concurrency-和并行-Parallelism" class="headerlink" title="2. 并发(Concurrency)和并行(Parallelism)"></a>2. 并发(Concurrency)和并行(Parallelism)</h3><p>并发和并行是两个非常容易被混淆的概念。他们都可以表示两个或多个任务一起执行，但偏重点不同。</p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>侧重于多个任务交替执行，而多个任务之间还有可能是串行的。</p>
<h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><p>则是真正意义上的”同时执行”。</p>
<p><img src="https://s2.loli.net/2022/02/14/ARdnbFXZYBPHs2r.png" alt="image-20220214225610517"></p>
<p>严格意义上来说，并行的多个任务是真实的同时执行。</p>
<p>而对于并发来说，这个过程只是交替的，一会儿运行任务A一会儿执行任务B，系统会不停地在两者间切换。但对于外部观察者来说，即使多个任务之间是串行并发的，也会造成多任务间是并行执行的错觉。</p>
<blockquote>
<p>由于并发的最终结果可能是和并行一眼的，因此，如果没有特别的需要，本书不会特别强调两者的区别。</p>
</blockquote>
<h3 id="3-临界区"><a href="#3-临界区" class="headerlink" title="3. 临界区"></a>3. 临界区</h3><p>临界区用来表示一种公共资源或者说是共享资源，可以被多个线程使用。</p>
<p>但是每一次，只能有一个线程在使用它。一旦临界资源被占用，其他线程若想使用，只能等待。</p>
<p>在并行程序中，临界区资源是保护的对象。</p>
<h3 id="4-阻塞-Blocking-和非阻塞-Non-Blocking"><a href="#4-阻塞-Blocking-和非阻塞-Non-Blocking" class="headerlink" title="4. 阻塞(Blocking)和非阻塞(Non-Blocking)"></a>4. 阻塞(Blocking)和非阻塞(Non-Blocking)</h3><p>阻塞和非阻塞，通常用来形容多线程间的相互影响。</p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>比如一个线程占用了临界区资源，那么其他所有需要这个资源的线程就必须在这个临界区中进行等待。等待会导致线程挂起，这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作。</p>
<h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><p>其意思与上相反，它强调没有一个线程可以妨碍其他线程执行。所有的线程都会尝试不断前向执行。</p>
<h3 id="5-死锁-Deadlock-、饥饿-Starvation-和活锁-Livelock"><a href="#5-死锁-Deadlock-、饥饿-Starvation-和活锁-Livelock" class="headerlink" title="5. 死锁(Deadlock)、饥饿(Starvation)和活锁(Livelock)"></a>5. 死锁(Deadlock)、饥饿(Starvation)和活锁(Livelock)</h3><p>死锁、饥饿和活锁都属于多线程的活跃性问题。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>是一个很严重的，并且应该避免和时时小心的问题。</p>
<p><img src="https://s2.loli.net/2022/02/14/2T9t3KHF7C6MuoW.png" alt="image-20220214230702973"></p>
<h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。比如它的线程优先级可能太低，而高优先级的线程不断抢占它需要的资源，导致低优先级线程无法工作。</p>
<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>如果线程的智力不够，且都秉承着“谦让”的原则，主动将资源释放给他人使用，那么就会出现资源不断在两个线程中跳动，而没有一个线程可以同时拿到所有资源而正常执行(两个人相互让路)。</p>
<h2 id="2-并发级别"><a href="#2-并发级别" class="headerlink" title="2. 并发级别"></a>2. 并发级别</h2>]]></content>
      <tags>
        <tag>实战Java高并发程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-1</title>
    <url>/2021/08/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">design</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">//若在IDE使用Console, 出错</span></span><br><span class="line">		System.out.println(<span class="string">&quot;请输入数字A&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		System.out.println(<span class="string">&quot;请选择运算符号(+、-、*、/):&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">B</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入数字B:&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">C</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		<span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> Double.parseDouble(C);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (B.equals(<span class="string">&quot;/&quot;</span>) &amp;&amp; c == <span class="number">0</span>) </span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> clclt(Double.parseDouble(A), B, c);</span><br><span class="line">		System.out.println(<span class="string">&quot;The answer is &quot;</span> + ans);</span><br><span class="line">		</span><br><span class="line">		&#125;<span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;您的输入有误,分母不能为零。故为 &quot;</span> + e.getMessage());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">clclt</span><span class="params">(<span class="type">double</span> A, String operator, <span class="type">double</span> C)</span> &#123;</span><br><span class="line">	<span class="type">double</span> <span class="variable">D</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">switch</span>(operator) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;+&quot;</span> :</span><br><span class="line">			D = A + C;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;-&quot;</span> :</span><br><span class="line">			D = A - C;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;*&quot;</span> :</span><br><span class="line">			D = A * C;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;/&quot;</span> :</span><br><span class="line">				D = A / C;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> D;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，此处使用Console进行输入会报错，原因是Java.io.Console只能用在 标准输入、输出流未被重定向 的原始控制台使用，在Eclipse或其他IDE的控制台是用不了的</p>
<p>增加上简单工厂模式后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operationFactory</span> &#123;</span><br><span class="line">	String operator;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">operationFactory</span><span class="params">(String opt)</span> &#123;</span><br><span class="line">		operator = opt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> operation <span class="title function_">creatOperator</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">		<span class="type">operation</span> <span class="variable">op</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">switch</span>(operator) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;+&quot;</span> :</span><br><span class="line">			op = <span class="keyword">new</span> <span class="title class_">operationAdd</span>(a, b);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;-&quot;</span> :</span><br><span class="line">			op = <span class="keyword">new</span> <span class="title class_">operationSub</span>(a, b);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;*&quot;</span> :</span><br><span class="line">			op = <span class="keyword">new</span> <span class="title class_">operationMul</span>(a, b);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;/&quot;</span> :</span><br><span class="line">			op = <span class="keyword">new</span> <span class="title class_">operationDiv</span>(a, b);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> op;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">operation</span> &#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">double</span> A;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">double</span> B;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">operation</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.A = a;</span><br><span class="line">		<span class="built_in">this</span>.B = b;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">GetResult</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;	</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入数字A&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		<span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> Double.parseDouble(A);</span><br><span class="line">		System.out.println(<span class="string">&quot;请选择运算符号(+、-、*、/):&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">B</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入数字B:&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">C</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		<span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> Double.parseDouble(C);</span><br><span class="line">		<span class="type">operationFactory</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">operationFactory</span>(B);</span><br><span class="line">		<span class="type">operation</span> <span class="variable">prtn</span> <span class="operator">=</span> p.creatOperator(a, c);</span><br><span class="line">		System.out.println(<span class="string">&quot;结果是 &quot;</span> + prtn.GetResult());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operationAdd</span> <span class="keyword">extends</span> <span class="title class_">operation</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">operationAdd</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">GetResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> A + B;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operationSub</span> <span class="keyword">extends</span> <span class="title class_">operation</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">operationSub</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">GetResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> A - B;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operationMul</span> <span class="keyword">extends</span> <span class="title class_">operation</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">operationMul</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">GetResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> A * B;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operationDiv</span> <span class="keyword">extends</span> <span class="title class_">operation</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">operationDiv</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">GetResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (B == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;输入出错，除数不能为零！&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> A / B;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <tags>
        <tag>代码历程</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念三</title>
    <url>/2021/06/01/%E6%96%B0%E6%A6%82%E5%BF%B5%E4%B8%89/</url>
    <content><![CDATA[<blockquote>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>True eccentrics never deliberately set out to draw attention to themselves. They disregard social conventions ==without being conscious that== they are doing anything extraordinary. This invariably wins them the love and respect of others, for they add color to the dull routine of everyday life.</p>
<p>   ==Up to== the time of his death, Richard Colson was one of the most notable figures in our town. He was a shrewd and wealthy businessman, but most people in the town hardly knew anything about this side of his life. He was known to us all as Dickie and his eccentricity had become legendary ==long before he died.==</p>
<p>   Dickie disliked snobs intensely. Though he owned a large car, he hardly ever used it, preferring always to go on foot. Even when it was raining heavily, he refused to carry an umbrella. One day, he walked into an expensive shop after having been caught in a particularly heavy shower. He wanted to buy a ￡300 watch for his wife, but he was in such a bedraggled condition that an assistant refused to serve him. Dickie left the shop without a word and returned carrying a large cloth bag. As it was extremely heavy, he dumped it on the counter. The assistant asked him to leave, but Dickie paid no attention to him and requested to see the manager. ==Recognizing who the customer was==, the manager was most apologetic and reprimanded the assistant severely. When Dickie was given the watch, he presented the assistant with the cloth bag. It contained ￡300 in pennies. He ==insisted on the assistant’s counting the money== before he left — 30,000 pennies in all!</p>
<p>   On another occasion, Dickie invited a number of important critics to see his private collection of modern paintings. This exhibition received a great deal of attention in the press, for though the pictures were supposed to be the work of famous artists, they had in fact been painted by Dickie. ==It took him four years to stage== this elaborate joke simply to prove that critics do not always know what they are talking about.</p>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ol>
<li>disregard v.忽视，不顾                                        </li>
<li>deliberately  adv.故意地；从容不迫地(I went to the woods because I wanted to live deliberately.)</li>
<li>invariably adv.一律地；总是                                 </li>
<li>notable adj.值得注意的；显著的</li>
<li>shrewd adj.精明的(emphasizes mental astuteness and practical understanding)</li>
<li>legendary adj.传说的；声名远扬的</li>
<li>snob n.势利小人</li>
<li>bedraggled adj.蓬乱的；衣衫不整的</li>
<li>apologetic adj.认错的；歉疚的；辩解的</li>
<li>reprimand v.谴责；训斥</li>
</ol>
<h3 id="短语"><a href="#短语" class="headerlink" title="短语"></a>短语</h3><p>in the press 在新闻界（媒体）              a great deal of 大量</p>
<p>set out to 试图                                          present sth to sb 把某物赠送/呈现/提交给某人</p>
</blockquote>
]]></content>
      <tags>
        <tag>Lesson 31 A lovable eccentric</tag>
      </tags>
  </entry>
  <entry>
    <title>Insights</title>
    <url>/2022/03/05/Insights/</url>
    <content><![CDATA[<p>Chapter 1 </p>
<p>经济学的原理告诉我们：所有理性的人都知道必须面对权衡取舍。但在权衡取舍的过程中，我们往往并不理性：我们会被一时的快感牵制，而忘记了真正有价值的事情。当快感消退后，又会重新陷入懊悔之中，我们会因为短暂的不良情绪而无法正常处理事务，但当我们情绪恢复后，又会觉得刚才思考的问题不过是杞人忧天。</p>
<p>所谓专注法则，就是要如何摆脱在纠结和懊悔之间返回徘徊的方法。</p>
<p>如果在你行动之前丝毫没有准则，就会凭借着一时兴起做出决定，就会在很多事情上犯下错误。只有把我的优势在哪里？我要如何最大化优势？目前的紧急任务是什么？我应该怎么做？这一一系列问题原则化，给出自己在不同情况下的行为模式，才能更好地掌控自己。</p>
<h2 id="关于To-do-list"><a href="#关于To-do-list" class="headerlink" title="关于To do list"></a>关于To do list</h2><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>第一、列出应该做的任务，而不是所有需要做的任务</p>
<p>必须要分清楚，什么任务是你真正应该做的，而什么任务时你需要做但是实际上并不会立刻就做的。</p>
<p>第二、为任务规划时间，而不是随意地安排</p>
<p>在正确的时间做正确的事。按照所需要的能力将任务分为四大类：体力、创造力、逻辑思维能力、记忆力，然后思考不同时间段最应该做的事情是什么。寻找自己在什么时间多做什么事情最高效的规律。</p>
<p>第三、制定计划时要面向未来，但最重要的时间是接下来一个小时。</p>
<p>规划较长期的任务是：不要规划的过于复杂，而要集中专注于一件大事。</p>
<p>真正有意义的事，需要你在一段时间内坚持投入时间。</p>
<p>当你决定这个月应该做什么的时候，一定要集中专注于一件大事，并且把它拆解开来，然后分配到每一天。</p>
<p>但无论你在 To do list 中列出了什么，你都要记住最关键的时间永远是接下来的1小时。不要总是把任务一口气安排到最后，看上去井井有条但实际上永远拖延到最后1分钟，这并不是好的时间管理方式。</p>
<p>最好的状态是，如果自己觉得这会儿不错，尽管并没有安排接下来的任务，也不要浪费接下来的1 个小时。每一个“接下来1小时”都是最重要的，这才是时间管理的精髓。</p>
<h3 id="制作任务清单"><a href="#制作任务清单" class="headerlink" title="制作任务清单"></a>制作任务清单</h3><p>第一、每天一件令你有成就感的工作</p>
<p>第二、留出过渡时间，列出备用任务</p>
<p>把每天的任务都塞得足够满，恨不得再多做一些事——但真正执行起来的时候，结果往往不如人意。面对这种情况，你可以每天为自己预留出1~2个小时作为调整和过度。</p>
<p><img src="https://s2.loli.net/2022/03/05/B9q2Sotwj8YE1ax.png" alt="image-20220305154024366"></p>
<p>第三、把To do list当作自己的回顾日志</p>
<ul>
<li>自己今天完成了哪些任务？能不能回顾一下这些任务，加深一遍印象？</li>
<li>有哪些未完成的计划？是自己的状态不佳，还是计划太难，应该要如何调整？</li>
<li>有哪些事情是更值得做的，但是却因为做另一些不那么重要的事情，而被放弃了？应该如何调整？</li>
</ul>
<h3 id="柳比歇夫的时间记录法"><a href="#柳比歇夫的时间记录法" class="headerlink" title="柳比歇夫的时间记录法"></a>柳比歇夫的时间记录法</h3><p>如果你只是列出计划，但却不能完成计划，计划用时和实际用时相差甚远，就会导致执行计划时感到并没有太大的用处：“计划不如变化”，那还不如不列任务清单呢。</p>
<p>把每天的有效工作时间和所做的事项记录下来。</p>
<p><img src="https://s2.loli.net/2022/03/05/zaUV7Y2ET4spM9A.png" alt="image-20220305154610065"></p>
<p>如果你想要实现真正地专注，我建议你试一试这种时间记录法。当你开始记录的时候，千万要知道这份记录不是为了做给别人看，也不是为了炫耀或者满足自己的虚荣心而做，而是切切实实地为掌控自己的时间而做，因此你需要自己监督自己，自己向自己汇报。</p>
<p>记住，这种方法真正的要义在于：了解自己，精确地感知时间。</p>
<h4 id="要义"><a href="#要义" class="headerlink" title="要义"></a>要义</h4><p>一、只记录纯粹工作时间</p>
<p>它是指你真正集中精力、全神贯注工作的那段时间。</p>
<p><img src="https://s2.loli.net/2022/03/05/IYjfGW67p9BlS2z.png" alt="image-20220305154827014"></p>
<p>当你开始把纯粹工作时间从杂七杂八的事项中提取出来，你才能意识到自己有多少时间都被耗费在没有意义的事情上。</p>
<p>这种情况在一开始可能是经常发生的，你需要有意识地去改变。例如事先规定和朋友讨论的时间，设置一个闹钟，防止长时间的瞎侃；搜集资料的时候，从一开始就尽量不点开一些无用的链接，以防自己的注意力被分散。</p>
<p>他感受到，生命只有一次，不可复得，而且生命中的每一天也同样具有这种只有一次、不可复得的性质。</p>
<p>二、可持续是你最应该考虑到的</p>
<p>当你在做这件事情的时候，随时提醒一下自己初衷是什么：是切切实实地自我提升，通过更多时间的工作和学习来充实自己，同时更好地提升效率；而绝不是为了账面上的好看，瞎填些模棱两可的时间和工作记录来哄骗自己。</p>
<p><strong>打破你的仪式感，这是第一步。</strong></p>
<p><strong>最关键的事情，就是从现在开始着手，而不是仅仅停留在“理论上我知道应该这么做”。</strong></p>
<p>接下来你要做的就是坚持下去。你可能有一万种理由坚持不下去，例如今天实在太累，例如已经忘记早上做了什么，例如今天没有带那个用于记录的小本子……我无法列举出所有可能令你终止的情况，但是无论是哪种情况，它其实对我们来说都只是一个借口而已。</p>
<p>三、如何使用这份记录？</p>
<p>时间记录的本身并不是目的，它只是为了对抗两件事：第一件事是我们总是不能清楚地知道我们应该做什么；第二件事是我们总是不能清楚地知道我们做过什么</p>
<p>你可以把时间记录法看作是 To do list 的逆过程：To do list 是在事前对将要做的所有事情进行规划，而时间记录法则是对已做的事情进行总结。</p>
<h3 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h3><p>实际上，番茄工作法的核心规则并不在于用什么软件来记录番茄，也不在于到底是“番茄”计时还是“土豆”计时，而在于这个工作法背后隐藏的关于时间的法则——那就是设定单位时间，以单位时间安排任务，提高对时间的敏感度。</p>
<p>单位时间尺度是番茄工作法的核心：将所有任务都切分为一个一个的时间块，而不是笼统地进行一项任务。</p>
<h3 id="四象限工作法"><a href="#四象限工作法" class="headerlink" title="四象限工作法"></a>四象限工作法</h3><p>将什么样的任务划分在这四个象限中的哪个位置，并不是固定的，而是根据你当时具体的情况决定的。这也就是说，四象限工作法的划分需要你随着时间更改。</p>
<p>你可以每一个月都将自己近期的任务这样分一次类，做成一个表格，最好将这个表格记录下来。这样在你无所事事的时候更容易提醒自己：“哦，我还有书要看，而看书这项任务已经被标记为紧急，我必须完成。”</p>
<p>有一些任务需要长时间投入，因此在这个过程中这项任务几乎都处于不紧急的状态；但当它变得紧急的时候，你才会意识到这项任务如此重要，但又无法在短时间内挽回，最终只能懊悔“我要是早一点开始就好了”。</p>
<p>人们面临的最大困境之一就是短视。</p>
<p>因为只能看到眼前一小段时间的利益，所以总是把紧急不重要的任务放在前面，当完成这些任务之后，便松了口气，觉得那些不紧急的任务，都可以一拖再拖，直到无法再拖下去为止，而运用四象限工作法正是要解决这个问题。</p>
]]></content>
      <tags>
        <tag>读书整理</tag>
      </tags>
  </entry>
</search>
