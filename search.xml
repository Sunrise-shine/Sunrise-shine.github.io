<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>After-reading</title>
    <url>/2021/12/12/After-reading/</url>
    <content><![CDATA[<h1 id="认知觉醒"><a href="#认知觉醒" class="headerlink" title="认知觉醒"></a>认知觉醒</h1><h2 id="上篇"><a href="#上篇" class="headerlink" title="上篇"></a>上篇</h2><h3 id="第一章-大脑：一切问题的根源"><a href="#第一章-大脑：一切问题的根源" class="headerlink" title="第一章 大脑：一切问题的根源"></a>第一章 大脑：一切问题的根源</h3><h4 id="第一节-大脑：重新认识你自己"><a href="#第一节-大脑：重新认识你自己" class="headerlink" title="第一节 大脑：重新认识你自己"></a>第一节 大脑：重新认识你自己</h4><p>大脑主要包括本能脑(约3.6亿年)、情绪脑(约2亿年)和理智脑(约250万年)。</p>
<p>由于理智脑出现时间最短，对大脑的掌控能力很弱，所以，<strong>我们在生活中做的大部分决策，往往源于本能和情绪，而非理智</strong>。</p>
<p>情绪脑和本能脑，是为了适应远古时期的生活，而具有目光短浅和及时满足的特性。</p>
<h5 id="突出的"><a href="#突出的" class="headerlink" title="突出的"></a>突出的</h5><ul>
<li><strong>趋易避难</strong>——只做简单和舒适的事，喜欢在核心区域周边打转，待在舒适区内逃避真正的困难。</li>
<li><strong>急于求成</strong>——凡事希望立即看到结果，对不能马上看到结果的事往往缺乏耐心，非常容易放弃。</li>
</ul>
<p>这就导致，<strong>大多数时候，我们以为自己在思考，其实都是在对自身的行为和欲望合理化。</strong></p>
<p>习惯之所以难以改变，就是因为他是自我巩固的——越用越强，越强越用。要想从既有的习惯中跳出俩，最好的方法不是依靠自制力，而是依靠知识。</p>
<h4 id="第二节-焦虑：焦虑的根源"><a href="#第二节-焦虑：焦虑的根源" class="headerlink" title="第二节 焦虑：焦虑的根源"></a>第二节 焦虑：焦虑的根源</h4><p>事实上，我们应该跟过去的自己比，哪怕好那么一点点，也是值得的。而不是要去跟所谓的成功人士比。</p>
<h5 id="焦虑的几种形式"><a href="#焦虑的几种形式" class="headerlink" title="焦虑的几种形式"></a>焦虑的几种形式</h5><ul>
<li>完成焦虑。日程安排太慢，每天都活在deadline前。</li>
<li>定位焦虑。在零基础阶段就知识该领域的能人们现在的所作所为。</li>
<li>选择焦虑。想做的事情太多，选择太多。</li>
<li>环境焦虑。有些事不想做，却必须花大量的时间去做。有些事想做却做不了。</li>
<li>难度焦虑。有些东西就是很难学。真正能让你变强的东西，其核心困难是无法回避的。</li>
</ul>
<h5 id="焦虑的根源"><a href="#焦虑的根源" class="headerlink" title="焦虑的根源"></a>焦虑的根源</h5><p>焦虑的原因，就两条：<strong>想同时做很多事，又想立即看到效果</strong>。自己的欲望大于能力，又极度缺乏耐心。</p>
<ul>
<li>急于求成：想同时做很多事</li>
<li>避难趋易：想不怎么努力就看到结果</li>
</ul>
<h5 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h5><ul>
<li>克制欲望，不要让自己同时做很多事</li>
<li>面对现实，看清自己真实的能力水平</li>
<li>要事优先，想办法只做最重要的事</li>
<li>接受环境，在局限中做力所能及的事</li>
<li>直面核心，狠狠逼自己一把去突破它</li>
</ul>
<h4 id="第三节-耐心：得耐心者得天下"><a href="#第三节-耐心：得耐心者得天下" class="headerlink" title="第三节 耐心：得耐心者得天下"></a>第三节 耐心：得耐心者得天下</h4><p><strong>要想有所成就，必须保持耐心，延迟满足。</strong>要想保持出色，就必须经受长时间的磨练。</p>
<h5 id="原因和规律"><a href="#原因和规律" class="headerlink" title="原因和规律"></a>原因和规律</h5><p>很多时候，我们对困难事物缺乏耐心是因为看不到全局、不知道自己身在何处，所以总拿着天性这把短视之尺去到处衡量。牢记复利曲线。<img src="https://s2.loli.net/2021/12/22/36EnLCdeK9V2suZ.png" alt="image-20211212153853571"></p>
<p>无论个体还是群体，其能力都以”舒适区—拉伸区—困难区“的形式分布。要想让自己高效成长，必须让自己始终处于舒适区的边缘。</p>
<p><img src="https://s2.loli.net/2021/12/22/OHVMN58ufSXTktL.png" alt="image-2127"></p>
<p>首先要认识到，成长权重对比。</p>
<p>对于学习而言，学习之后的思考，思考之后的行动，行动之后的改变更重要，如果不叮嘱内层的改变量，那么在表层投入再多的学习量也会事倍功半，因此，从权重上看，改变量&gt;行动量&gt;思考量&gt;学习量.</p>
<p>很多人之所以痛苦焦虑，就是因为只盯着表层的学习量。它们读了很多书，报了很多课，天天打卡，日日坚持，但就是没有深入关注过自己的思考、行动和改变。原因仍然是我们的天性在作祟，因为单纯保持学习输入事件单的。</p>
<p>停在表层，我们就会陷入欲望漩涡，什么都想学，什么都想要，忙忙碌碌却收效甚微；若是能深入底层，盯住实际改变，就能跳出盲目、焦虑、浮躁的怪圈。</p>
<p>另一个值得关注的规律就是，学习的平台期。</p>
<p>学习进展和时间的关系并不是想象中的线性关系(学多少是多少)，而是波浪式上升曲线。</p>
<p>当我们清楚了上述规律之后，就能在面对长期的冷寂或挫折失败时做出与他人不同的选择。各自所处的阶段不同，只要持续创造价值，别人的今天就是自己的明天。</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ul>
<li><p><strong>首先，面对天性，放下心理包袱，坦然接纳自己。</strong></p>
<p>从现在开始，对于自己表现出的任何急躁、焦虑和不耐烦，都不要感到自责和内疚，一旦感觉到失去耐心了，就温和地对自己说：”你看，身体里的那个原始人又出来了，让他离开丛林到城市生活，确实挺不容易的，要理解他。“不要指望一下子就能变得很有耐心，如果对自己不能立即变好这件事感到焦虑，着本身就是缺乏耐心的表现。</p>
</li>
<li><p><strong>其次，面对诱惑，学会延迟满足，变对抗为沟通</strong></p>
<p>和自己对话“该有的享受一点都不会少，只是不是现在享受，而是完成重要的事情之后。”  “暂时忍耐一下，先做重要的事情，之后会有专门的半个小时到一个小时的时间，专门玩手机，想怎么玩都行。”</p>
<p><strong>将享乐的快感建立在完成重要任务之后的成就感</strong>上，很放松，很踏实，就像一种奖赏。</p>
</li>
<li><p><strong>最后，面对困难，主动改变视角，赋予行动意义</strong></p>
<p>别人能持之以恒，一个重要原因是，他们更擅长探索原理，会主动改变认知视角，来找到行动的意义和好处。比如当我们知道阅读的本质和意义，我们就更有可能放下手机，主动拿起书本。想办法去看清那些想做之事的意义和好处。</p>
</li>
</ul>
<p>想办法让本能脑和情绪脑感受到困难事物的乐趣并上瘾，这才是理智脑最高级的策略。</p>
<h3 id="第二章-潜意识：生命留给我们的彩蛋"><a href="#第二章-潜意识：生命留给我们的彩蛋" class="headerlink" title="第二章 潜意识：生命留给我们的彩蛋"></a>第二章 潜意识：生命留给我们的彩蛋</h3><h4 id="第一节-模糊：人生是一场消除模糊的比赛"><a href="#第一节-模糊：人生是一场消除模糊的比赛" class="headerlink" title="第一节 模糊：人生是一场消除模糊的比赛"></a>第一节 模糊：人生是一场消除模糊的比赛</h4><h5 id="引证"><a href="#引证" class="headerlink" title="引证"></a>引证</h5><p>领域内的精英无不是比其他人了解的知识更多，他们的盲区更小，认知更清晰，因而也更具影响力。</p>
<p>学习知识的目的是“消除模糊”，而获取知识的方法也是“消除模糊”。</p>
<p>思考力的本质就是：丢弃所有已经消化的信息，让问题的核心浮出水面。</p>
<p>《刻意练习》中的核心方法论是：不要重复练习已经会的，要不断需找那些稍有难度的部分。</p>
<p>《超越感觉》一书，要想拥有清晰的逻辑，就坚持一点：凡事不要凭模糊的感觉判断，而是要寻找清晰的证据。</p>
<p>提升思考能力的方法正是不断明确核心困难和心得感悟，并专注于此。</p>
<p>“学霸”的错题本：他们更愿意花时间明确错误，并集中精力攻克；即谁愿意做高耗能的事——消除模糊，制造清晰。</p>
<h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>人不喜欢主动耗能，所以，多数人为了逃避真正的思考，愿意做任何事。</p>
<p>然而回避痛苦并不会使痛苦消失，反而会使其转入潜意识，变成模糊的感觉。<strong>而具体事件一旦变模糊，其边界就会无限扩大，原本并不困难的小事，也会在模糊的潜意识里变得难以解决。</strong></p>
<p><strong>真正的困难总比想象中的要小很多</strong>。人们拖延、纠结、位居的根本原因往往不是事情本身有多难，而是内心的想法变得模糊。记住，任何痛苦事件都不会自动消失，哪怕再小的事情也是如此。</p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>要想不受其困扰，唯一的办法就是主动正视它、拆解它、看清它，不给它进入潜意识的机会，不给它变模糊的机会；即使已经进入潜意识，也要想办法将它挖出来。所以，当你感到心里有说不清、道不明的难受时，赶紧坐下来，向自己提问。</p>
<ul>
<li>到底是什么让自己烦躁不安？是上台演讲、会见某人，还是思绪纷乱？</li>
<li>具体是什么让自己恐惧担忧？是能力不足，准备不够，还是害怕某事发生？</li>
<li>面对困境，我能做什么？不能做什么？如果做不到或搞砸了，最坏的结果是什么？</li>
</ul>
<h5 id="里清外明，消除行为模糊"><a href="#里清外明，消除行为模糊" class="headerlink" title="里清外明，消除行为模糊"></a>里清外明，消除行为模糊</h5><p>行动力不足的真正原因是选择模糊。</p>
<p>当我们没有清晰的指令或者目标时，就很容易选择享乐，放弃那些本该坚持但比较烧脑的选项。</p>
<p><strong>要想让自己更胜一筹，就必须学会花费更多的脑力和心力去思考如何拥有足够清晰的目标。我们要把目标和过程细化、具体化，在诸多可能性中建立一条单行通道，让自己始终处于“没得选”的状态。</strong></p>
<p>消除认知、情绪和行动上的模糊，主动反本能。</p>
<h4 id="第二节-感性"><a href="#第二节-感性" class="headerlink" title="第二节 感性"></a>第二节 感性</h4><p>潜意识没有思维，只关心眼前的事物，喜欢即刻、确定、简单、舒适，这是属于天性的部分。但他处理信息的速度又极快，<strong>至少可达11,000,000次每秒</strong>，能极其敏锐地感知很多不易察觉的信息。</p>
<p>而意识，即我们的理性思考，处理信息的速度<strong>只有40次每秒</strong>。</p>
<p>二者具有天壤之别！</p>
<h5 id="凭感觉学习"><a href="#凭感觉学习" class="headerlink" title="凭感觉学习"></a>凭感觉学习</h5><p><strong>所谓“熔断不读书法”，意思就是在读书时一旦看到有启发的内容，就触发熔断点，立刻停止阅读，对自己进行提问。</strong></p>
<ul>
<li>为什么刚才这个点让我有启发？</li>
<li>我能够把这个启发点用在3个不同的事情上吗？</li>
<li>这个启发点有没有其他类似的知识？</li>
</ul>
<p>不管是生活中还是学习上，凡是被某件事击中，“动了感情”，就要有意识地追问原因：</p>
<ul>
<li>为什么这个电影桥段让我感动？发生了什么？</li>
<li>为什么这个产品让我这么喜欢？是什么让它这么与众不同？</li>
<li>为什么我不由自主沉溺于这段剧情了？</li>
</ul>
<p>这就是方法：<strong>先用感性能力帮自己选择，再用理性能力帮助自己思考。</strong>这背后的原理就是通过捕捉潜意识发出的信号进行感知。</p>
<p>”只有那种大致能看出点思路，但又要动点脑筋的题目，一定要多做。这个就是中间地带，是你能够进步最快的地方。”</p>
<p>看出端倪没？“凭感觉”之所以被称为顶级的方法，是因为它能帮我们感知真正适合自己并需要的东西，让自己处于学习的“拉伸区”。</p>
<h5 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h5><p>更好的读书方法，或许就是你在读完整本书后，过几天再问自己：<strong>现在你印象最深的触动点是什么？牢牢抓住这个触动点，去关联、去实践，就会获得最大的收获</strong>，而其他的内容则可以先放到一边。这也是我自己的读书方法——<strong>只取一个全书最触动自己的点，然后尽可能去实践、改变</strong>。这样读书不仅收获更大，而且也不会焦虑。</p>
<h5 id="确立人生目标"><a href="#确立人生目标" class="headerlink" title="确立人生目标"></a>确立人生目标</h5><ul>
<li><p>这个世界有很多事情可以做，你最想帮助哪些人？</p>
</li>
<li><p>什么事让你废寝忘食？</p>
</li>
<li><p>你在做什么事情的时候最让自己感动？</p>
</li>
<li><p>你最让人感动的时刻是什么？</p>
</li>
<li><p>如果没有任何经济压力，你会如何度过余生？</p>
</li>
<li><p>闲暇的时候，你关注最多的是哪方面的信息？</p>
<p><strong>我们需要用心去感受什么事情让自己最触动，而不是用脑去思考什么事情最有利</strong>。</p>
</li>
<li><p>设想你即将离开世界，回首一生会为什么事情而后悔？</p>
</li>
<li><p>想一想你最喜欢的人物是谁？</p>
</li>
<li><p>你年轻的时候是怎么度过闲暇时光的？</p>
<p>回答这3个问题同样需要我们动用感知力而不是思考力</p>
</li>
</ul>
<h5 id="捕捉感知"><a href="#捕捉感知" class="headerlink" title="捕捉感知"></a>捕捉感知</h5><ol>
<li><strong>“最”字法</strong>。关注那些最触动自己的点：让你眼前一亮、心中泛起波澜的人和事，脑中灵光乍现的想法，遭遇的痛苦，等等。学会捕捉它们，并深入分析挖掘，往往会有丰厚的收获。</li>
<li><strong>“总”字法</strong>。平时脑子里总是不自觉地跳出来的某些重复念头，或是心里总是挥之不去的事，这些通常都是我们心中最放不下的事，是情绪波动的源头。当我们有意识地去审视并消除它时，自己会变得更加平和。</li>
<li><strong>无意识的第一反应</strong>。关注自己第一次见到某个人、第一次走进某个房间、第一次做某件事时，心中出现的瞬间反应或第一个念头。</li>
<li><strong>梦境</strong>。梦境是潜意识传递信息的一种方式，它可能是内心真实想法的展示，也可能是灵感的启发。</li>
<li><strong>直觉</strong>。丘吉尔。</li>
</ol>
<h3 id="第三章-元认知—人类的终极能力"><a href="#第三章-元认知—人类的终极能力" class="headerlink" title="第三章 元认知—人类的终极能力"></a>第三章 元认知—人类的终极能力</h3><h4 id="第一节-元认知"><a href="#第一节-元认知" class="headerlink" title="第一节 元认知"></a>第一节 元认知</h4><p><img src="https://s2.loli.net/2022/02/05/vzZM9AcLdiUuKGy.png" alt="image-20220205131103870"></p>
<h5 id="反观，是元认知的起点。"><a href="#反观，是元认知的起点。" class="headerlink" title="反观，是元认知的起点。"></a>反观，是元认知的起点。</h5><p>你能意识到自己在想什么，进而意识到这些想法是否明智，再进一步纠正那些不明智的想法，最终做出更好的选择。</p>
<p>缺乏自我意识的人，只能无意识地顺着感觉和喜好行事，无论是生理上还是精神上，都会不自觉地追求眼前的舒适和简单，觉察不到自己当前的思维和行为有什么不妥，直到碰壁。</p>
<p>高级的元认知—时刻帮你从高处、深处、远处看待现在的自己，让自己保持清醒、不迷失，保持动力、不懈怠，保持平和、不冲动。</p>
<p><img src="https://s2.loli.net/2022/02/05/V9dTtGp3mFAosZu.png" alt="image-20220205132904267"></p>
<h5 id="如何获取"><a href="#如何获取" class="headerlink" title="如何获取"></a>如何获取</h5><p>第一，提升元认知能力的工具，需要从“过去”端获取，包括学习前人的智慧和反思自己的经历。</p>
<p>前人的智慧有很多，大多可以从书籍中获取。学习前人的智慧，可以让我们拥有更广的全局视角(高度)、掌握更深的底层规律(深度)，帮我们从无知中跳出来，做出更加正确的选择。</p>
<p>尤其值得关注的是，脑科学和认知科学。</p>
<p>第二，自身的经历更是一种独特的财富。我们每天的生活像河水一样流过，如不做停留则很难攫取生活中的智慧，而反思复盘可以让我们有机会思考有什么经验可以获得、有什么教训可以汲取。</p>
<p>第三，主动运用元认知。</p>
<p>我们总是，一开始就想找一根绳子，最后却牵出一头大象。这都是元认知能力不足的表现—顺着自己的本性做喜欢和舒服的事，精力发散，缺乏觉知，任何偶发的干扰都会分散注意力。</p>
<p>如果有个“灵魂伴侣”一直在监控你，你就能审视自己的行为，从过程中跳出来，告诉自己：“这个事情可做可不做，还是先忍一下，等做完重要的事情再说；停下来，先想清楚什么事情是最重要的，不能盲目地做那些容易但是不重要的事情。”</p>
<p>第四、冥想。冥想就是那种只要静坐在某处，然后放松身体，把注意力完全集中到呼吸和感受上的活动。如果过程中觉察到自己走神了，我们只需柔和地将注意力拉回来。</p>
<p>现在再联系之前提到的“灵魂伴侣”，不难发现这些活动本质上都在做同一件事：监控自己的注意力，然后将其集中到自己需要关注的地方。</p>
<p>反馈是这个世界的进化机制。有反馈，并形成回路，就可能使任何系统开始自我进化，无论机械设计还是软件系统都是如此。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>想拥有和掌握元认知能力并不容易，这需要不断地练习、练习、再练习。</p>
<p>很多时候，你发现自己做得并不好，没关系，重新再来。用不了多久，你就会发现，自己慢慢变得和以前不一样了。</p>
<h4 id="第二节-自控力：我们生而为人就是为了称为思维舵手"><a href="#第二节-自控力：我们生而为人就是为了称为思维舵手" class="headerlink" title="第二节 自控力：我们生而为人就是为了称为思维舵手"></a>第二节 自控力：我们生而为人就是为了称为思维舵手</h4><p>元认知能力就是觉察力和自控力的组合。</p>
<p>从实用角度而言，元认知能力可以被重新定义为：自我审视、主动控制、防止被潜意识左右的能力。</p>
<h5 id="成长就是为了主动控制"><a href="#成长就是为了主动控制" class="headerlink" title="成长就是为了主动控制"></a>成长就是为了主动控制</h5><p>教育的意义就是，教你在遇到一件事的时候如何看待它。当你对这件事进行反应的时候，总是有你自己的天性在里面，比如说有人骂你，你就想骂回去，<strong>但是你在这个反应当中会有一个哪怕是零点几秒的间隔去思考或者审视，这个间隔就是你获得的教育或者经历的意义。</strong></p>
<p>如果你希望自己能从娱乐中抽身，<strong>只需提前告诉自己：“这个视频结束后暂停几秒。”</strong>一旦理智脑拥有了审视和反思的时间，我们通常都能控制住自己。</p>
<p><strong>每当遇到需要选择的情况时，我们要是能先停留几秒思考一下，就有可能激活自己的理智脑，启用元认知来审视当前的思维，然后做出不一样的选择。</strong></p>
<h5 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h5><p>有的人能看到事物更多的意义，赋予目标强烈的价值，因此他们比其他人的专注力、执行力和意志力更强；</p>
<p>有的人能觉察他人的想法，克制自己的言行，从而显得情商更高。</p>
<p>他们真正的竞争力不在于学习能力，而在于强大的元认知能力。</p>
<h5 id="所以"><a href="#所以" class="headerlink" title="所以"></a>所以</h5><p>一定要在选择节点上多花“元时间”。</p>
<h5 id="成为自己人生的思维舵手"><a href="#成为自己人生的思维舵手" class="headerlink" title="成为自己人生的思维舵手"></a>成为自己人生的思维舵手</h5><p>所有面临选择的时间节点，都可以被称作“元时间”。</p>
<p>在元时间要做的只有一件事：想清楚。</p>
<p>应对策略：在选择节点审视自己的第一反应，并产生清晰明确的主张。</p>
<h5 id="一些例子-1"><a href="#一些例子-1" class="headerlink" title="一些例子"></a>一些例子</h5><p>脱口而出的话往往出自本能，如果我们能在那句话说出口前先停一两秒，用理智脑再审视一遍，或许马上就会改变主意、换一种说法，甚至选择保持沉默，毕竟有时候最好的回答就是不回答。</p>
<p>同样，早上醒来的那一瞬间、拿起手机的那一瞬间、回到家的那一瞬间……我们都要面临新的选择，要主动消耗脑力去审视它们。</p>
<p>要想清楚，不仅要有审视第一反应，同时还要有清晰明确的主张。</p>
<p>原能力强的一个突出表现是：对模糊零容忍。也就是，想尽一切办法，让自己找出那个最重要的、唯一的选项，让自己在某一个时间段里，只有一条路可走。</p>
<p>犹豫不决，什么都想做又什么都做不好，才是最大的损失。</p>
<p>自己行动力弱的时候，脑子里对未来的具体行动肯定是模糊不清的。在这个时候，最好的自救方法就是把所有想做的事情都列出来，进行排序，找出最重要的那件事，让脑子清醒。</p>
<p>焦虑的人很少有“元时间”的意识，他们习惯不动脑子、直接行动，喜欢用饱和的行动来感动自己，想与做的时间配比差距悬殊，他们甚至连一丁点儿深入思考的时间都不愿意花，任由本能欲望让自己迷失在自我满足的行动里。</p>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ul>
<li>针对当下的时间，保持觉知，审视第一反应，产生明确的主张；</li>
<li>针对全天的日程，保持清醒，时刻明确下一步要做的事情；</li>
<li>针对长远的目标，保持思考，想清楚长远意义和内在动机。</li>
</ul>
<p>元认知能力强的人就是这样：无论是当下的注意力、当天的日程安排，还是长期的人生目标，他们都力求想清楚意义、进行自我审视和主动控制，而不是随波逐流。</p>
<p>每一次克制自己，就意味着比以前更强大。</p>
<h2 id="下篇-外观世界，借力而行"><a href="#下篇-外观世界，借力而行" class="headerlink" title="下篇 外观世界，借力而行"></a>下篇 外观世界，借力而行</h2><h3 id="第四章-专注力：情绪和智慧的交叉地带"><a href="#第四章-专注力：情绪和智慧的交叉地带" class="headerlink" title="第四章 专注力：情绪和智慧的交叉地带"></a>第四章 专注力：情绪和智慧的交叉地带</h3><h4 id="第一节-情绪专注"><a href="#第一节-情绪专注" class="headerlink" title="第一节 情绪专注"></a>第一节 情绪专注</h4><p>我们的注意力其实都可以分为<strong>“集中在行动上的”</strong>和“<strong>集中在感受上的</strong>”两部分。</p>
<p>起初，行动和感受二者是统一的。我们会在做一件事时，全身心地感受这件事，将注意力全部放在和当前事务相关的事情上，所以跑就是跑，吃就是吃，睡就是睡……</p>
<p>随着行动越来越熟练，我们在行动上集中的注意力越来越少，分散在其他地方的注意力越来越多，于是我们不再去耐心感受行动。</p>
<h5 id="分神的原因"><a href="#分神的原因" class="headerlink" title="分神的原因"></a>分神的原因</h5><ul>
<li>当下太无聊，所以追求更有意思的事情</li>
<li>当下太痛苦，于是追求更舒适的事情</li>
</ul>
<p>换句话说，就是分心走神的成本太低，而人的天性又是急于求成和趋易避难的，所以在默认情况下，我们都会不自觉地待在精神舒适区内。</p>
<h5 id="分神的后果"><a href="#分神的后果" class="headerlink" title="分神的后果"></a>分神的后果</h5><p>走神可以让我们活在任何时候，唯独不能让我们活在当下。</p>
<p>而生命是由当下的一个个片段组成的，身心合一的片段组成的就是幸福专注的高质量人生，身心分离的片段组成的就是分心走神的低质量人生。</p>
<p>分心走神的本质是逃避。</p>
<p>面对困难时，身心分离的人总会不自觉地退回舒适区，而身心合一的人则更容易跳出舒适区，直面困难。</p>
<h5 id="收回感受，回归当下"><a href="#收回感受，回归当下" class="headerlink" title="收回感受，回归当下"></a>收回感受，回归当下</h5><p>跑步时，把感受收回来，悉心体会抬腿摆臂、呼吸吐纳和迎面的微风；睡觉时，把感受收回来，悉心感受身体的紧张与松弛；吃饭时，把感受收回来，感受每一口饭菜的香甜，体会味觉从有到无的整个过程</p>
<p><strong>身体感受永远是进入当下状态最好的媒介，而感受事物消失的过程更是一种很好的专注力训练。它提示我们，身心合一的要领，不仅是专注于当下，更是享受当下。</strong></p>
<p><strong>慢慢练习收回感受，让注意力回到当下，我们的烦恼就会慢慢减少。</strong></p>
<p>得道前，砍柴时惦记着挑水，挑水时惦记着做饭；得道后，砍柴即砍柴，担水即担水，做饭即做饭。</p>
<h4 id="第二节-学习专注"><a href="#第二节-学习专注" class="headerlink" title="第二节 学习专注"></a>第二节 学习专注</h4><p>人类情绪和能力的优劣差异来自于对自身注意力关注方式的差异。</p>
<p>能力弱者极易分心，他们必须在一个理想的环境中才能学习，任何风吹草动都会让他们心神不宁；他们总是忍不住想做点更有趣的事情，一条热点新闻、一段有趣的闲聊都能把他们的注意力从重要的事情上移开。</p>
<p>能力强者则正好相反，他们的优势就在于能够主动屏蔽干扰，选择需要的信息并沉浸其中，为此他们甚至会主动练习，比如有人会故意在声音嘈杂的地方锻炼专注力</p>
<p>因沉浸能力的不同，人最终停留在了不同的层次。</p>
<h5 id="有定义明确的目标"><a href="#有定义明确的目标" class="headerlink" title="有定义明确的目标"></a>有定义明确的目标</h5><p>“连续三次不犯任何错误、以适当的速度弹奏完曲子。”而不是“我要练琴半小时”这样宽泛的目标。</p>
<p>目标定义越明确，注意力的感知精度就会越高，精力越集中，技能越精进。</p>
<p>如果目标太大，那就将它分解成小目标，这样做也是为了使目标更具体、精细。</p>
<h5 id="练习时极度专注"><a href="#练习时极度专注" class="headerlink" title="练习时极度专注"></a>练习时极度专注</h5><p>在短时间内投入100%的精力比长时间投入70%的精力好。</p>
<p>因为专注真正的动力不是毅力和耐心，而是不断发现技巧上的微妙差异和持续存在的关注点，精力越集中，则感知越细微。</p>
<h6 id="变聪明的秘诀就是："><a href="#变聪明的秘诀就是：" class="headerlink" title="变聪明的秘诀就是："></a>变聪明的秘诀就是：</h6><p>先保持极度专注，想不出答案时再将注意力转换到另一件与此毫不相干的事情上。即事前聚精会神，让意识极度投入；事后完全忘记，让意识彻底撒手。这样，灵感和答案就会大概率地出现。</p>
<h6 id="好的学习模式："><a href="#好的学习模式：" class="headerlink" title="好的学习模式："></a>好的学习模式：</h6><p>在做A的时候彻底关注A，在做B的时候，彻底关注B，A和B之间有非常清晰的界限。</p>
<h5 id="能获得有效的反馈"><a href="#能获得有效的反馈" class="headerlink" title="能获得有效的反馈"></a>能获得有效的反馈</h5><p>想方设法得到及时、有效的指导和反馈是不断精进的重要条件。</p>
<p>如果条件有限，反馈也可以通过书籍影像、与他人交流或者自我反思来获取。</p>
<h5 id="始终在拉伸区练习"><a href="#始终在拉伸区练习" class="headerlink" title="始终在拉伸区练习"></a>始终在拉伸区练习</h5><p><img src="https://s2.loli.net/2022/02/12/pSvlT6gBkEuYr8Z.png" alt="image-20220212115955425"></p>
<p>我们每天都要做那些让自己感到有困难但又可以通过努力来完成的事情。</p>
<p><img src="https://s2.loli.net/2022/02/12/FfHEvmaVCGhdSYw.png" alt="image-20220212120112977"></p>
<p><strong>要大量练习！</strong></p>
<ul>
<li>审视自己的注意力——是被动吸引还是主动选择？</li>
<li>审视自己的沉浸度——是分心走神还是极度专注？</li>
<li>审视自己的练习量——是浅尝辄止还是大量投入？</li>
</ul>
<h3 id="第五章-学习力——学习不是一味地努力"><a href="#第五章-学习力——学习不是一味地努力" class="headerlink" title="第五章 学习力——学习不是一味地努力"></a>第五章 学习力——学习不是一味地努力</h3><h4 id="第一节-匹配"><a href="#第一节-匹配" class="headerlink" title="第一节 匹配"></a>第一节 匹配</h4><p>刻意练习的真正核心在于，难易匹配上。</p>
<p>好的成长是始终游走在“舒适区边缘”。</p>
<h5 id="经验1"><a href="#经验1" class="headerlink" title="经验1"></a>经验1</h5><p>找一个自己能坚持做下去的方式，比单纯按照标准化的时间和方式做更重要。</p>
<p>以前一直以为多花时间才能学好、才能达到效果，其实那是因为自己急于求成，想要快速见效，这样反而不容易坚持。</p>
<p>现在降低了难度和标准，自己的行动力反而能持续增强，虽然达到目标所需的时间可能会变长，但是我相信这样的坚持最终可以产生复利效应。</p>
<p>事实上，它就是难易匹配的意思：既不要太难，也不要太容易，难易适中的地带才是学习的心流通道。</p>
<h5 id="经验2"><a href="#经验2" class="headerlink" title="经验2"></a>经验2</h5><p>我们就应该花大量的时间去梳理哪些内容处在自己的拉伸区，即梳理那些“会做但特别容易错或不会做但稍微努力就能懂”的内容.</p>
<p>千万不要认为没有管束的生活很美好，一旦进入完全自由的时间，虽然开始会很舒服，但很快，我们就会迷失在众多选项中——做这个也行，做那个也行。</p>
<p>做选择是一件极为耗能的事情，如果没有与之匹配的清醒和定力，绝大多数人最终都会被强大的天性支配，去选择娱乐消遣。</p>
<p>在有约束的环境下我们反而效率更高，生活更充实。</p>
<h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h5><p>它能帮我们解决行动力中的大问题。</p>
<p>比如，我们每次行动遇阻时都会一筹莫展，但只要细想就能发现，不管你遇到的是什么问题，其根源都是一样的，那就是：这个问题太大、太模糊。</p>
<p>所以，你只要拆解目标——把大目标拆分为小目标，任务就会立即从困难区转移到拉伸区，这样你就愿意行动了。</p>
<p>不信的话，你可以细心观察一下，几乎所有的行动达人都是拆解任务的高手。</p>
<p>掌握了这个原理，我们就能推导出从舒适区到拉伸区的策略：<strong>提炼目标</strong>。</p>
<h5 id="专注"><a href="#专注" class="headerlink" title="专注"></a>专注</h5><p>在拉伸区练习的一大特点就是要有关注点。</p>
<p>关注点越多、越细致，我们的注意力就越集中，提升的效果就越明显。</p>
<p>因此，跳出舒适区的最好办法就是去发现和收集那些要点，也就是每次行动的小目标。</p>
<p>比如练习弹钢琴的时候，不是一遍一遍地重复，而是只练出错最多的地方……</p>
<h5 id="反馈和拉伸"><a href="#反馈和拉伸" class="headerlink" title="反馈和拉伸"></a>反馈和拉伸</h5><p>目标清晰了之后，“极度专注”也自然能做到了，然后通过自我测试、反思、错题本这些方式获得反馈，这样做能不断优化自己关注的要点和小目标。</p>
<h4 id="第二节-深度学习"><a href="#第二节-深度学习" class="headerlink" title="第二节 深度学习"></a>第二节 深度学习</h4><h5 id="什么是深度学习"><a href="#什么是深度学习" class="headerlink" title="什么是深度学习"></a>什么是深度学习</h5><p><img src="https://s2.loli.net/2022/02/12/thl6wSjJV5g4Bbz.png" alt="image-20220212121356159"></p>
<p>以阅读为例，从浅到深依次为：</p>
<p>听书、自己读书、自己读书+摘抄金句、自己读书+思维导图/读书笔记、自己读书+践行操练、自己读书+践行操练+输出教授。</p>
<h5 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h5><p>明明心里想得挺明白，讲的时候就开始语无伦次了，如果再让你把知道的东西写下来呢？你可能会觉得根本无从下笔。</p>
<p>请注意，遇到这种困难才是深度学习真正的开始！</p>
<p>因为你必须动用已有的知识去解释新知识，当你能够把新学的知识解释清楚时，就意味着把它纳入了自己的知识体系，同时达到了可以教授他人的水平，并可能创造新的知识。</p>
<p>所以，逼迫自己获取高质量的知识以及深度缝接新知识，再用自己的语言或文字教授他人，是为深度学习之道。</p>
<h5 id="如何深度学习"><a href="#如何深度学习" class="headerlink" title="如何深度学习"></a>如何深度学习</h5><ul>
<li>获取高质量的知识</li>
<li>深度缝接新知识</li>
<li>输出成果去教授</li>
</ul>
<h5 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h5><p>正确的行动往往是反天性的，让你觉得舒服和容易的事往往得不到好结果，而一开始你认为难受和困难的事才能让你真正产生收获，所以我们可以通过以下几个方法逐步改进。</p>
<h6 id="一、尽可能获取并亲自钻研一手知识。"><a href="#一、尽可能获取并亲自钻研一手知识。" class="headerlink" title="一、尽可能获取并亲自钻研一手知识。"></a>一、尽可能获取并亲自钻研一手知识。</h6><p>比如，我们可以读经典、读原著，甚至读学术论文。放弃那些“几分钟读完……”</p>
<p>读书这件事还是不要请人代劳，从长远看，终归是要自己获得挖矿的能力的。</p>
<h6 id="二、尽可能用自己的话把所学的知识写出来"><a href="#二、尽可能用自己的话把所学的知识写出来" class="headerlink" title="二、尽可能用自己的话把所学的知识写出来"></a>二、尽可能用自己的话把所学的知识写出来</h6><p>每读完一本有价值的好书，就用写作的方式把作者的思想用自己的语言重构出来，尽力结合自身经历、学识、立场，去解释、延伸，而不是简单把书本的要点进行罗列。</p>
<p>只有做到知识转换才能用旧知识体系对新知识进行深度缝接。</p>
<h6 id="三、反思生活"><a href="#三、反思生活" class="headerlink" title="三、反思生活"></a>三、反思生活</h6><p>人与人之间的差距不是来自年龄，甚至不是来自经验，而是来自经验总结、反思和升华的能力。</p>
<p>如果让我推荐一个不可或缺的习惯，我必推每日反思。</p>
<h5 id="深度学习的好处"><a href="#深度学习的好处" class="headerlink" title="深度学习的好处"></a>深度学习的好处</h5><p>人的能力分为知识、技能和才干三个层次：</p>
<p>知识是最不具迁移能力的。你成为医学博士，也照样有可能不会做麻婆豆腐；</p>
<p>技能通常由70%的通用技能和30%的专业技能组成，迁移性要好一些；</p>
<p>而到了才干层面，职业之间的界限就完全被打破了。</p>
<h5 id="为浅学习正名"><a href="#为浅学习正名" class="headerlink" title="为浅学习正名"></a>为浅学习正名</h5><p>娱乐热点并非没有价值，浅层知识也同样具有意义，但前提是你需要具备一定的认知深度——深度之下的广度才是有效的。</p>
<p>专注于深度学习，同时对浅学习保持开放。</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>选择一些值得关注的人，和他们保持联结。他们释放的一些有价值的信息会引领我们走向更广阔的世界，但无论如何，最终要自己去读、自己去想、自己去做。</p>
<p>就像这本书，如果它触动了你，也仅仅是为你开启了一个新的视角，最终能否获取深度学习的能力，只能靠你自己行动，没有人能够代替。</p>
<h4 id="第三节-关联"><a href="#第三节-关联" class="headerlink" title="第三节 关联"></a>第三节 关联</h4><h5 id="无关联，不学习"><a href="#无关联，不学习" class="headerlink" title="无关联，不学习"></a>无关联，不学习</h5><ul>
<li>用自己的语言重述信息，即找到触动自己的信息点；</li>
<li>描述自己的相关经验，即关联生活中的其他知识；</li>
<li>我的应用，即转化为行动，让自己切实改变。</li>
</ul>
<p>这既是有效阅读的三个步骤，也是深度学习的三个层次：</p>
<ul>
<li>知道信息点</li>
<li>关联信息点</li>
<li>行动和改变</li>
</ul>
<p><img src="https://s2.loli.net/2022/02/12/Yu1xRK6sabfkHpv.png" alt="image-20220212123623802"></p>
<p>绝大多数人习惯以孤立的思维看待事物，喜欢花大量时间收集和占有信息；</p>
<p>而另一批先行者则更喜欢拨弄信息之间的关联，从而在不知不觉间变得聪明了起来。</p>
<h5 id="事不关己，不关联"><a href="#事不关己，不关联" class="headerlink" title="事不关己，不关联"></a>事不关己，不关联</h5><p>因为只有真正和自己有关的内容才对自己有用，在这个注意力非常匮乏的时代，没有必要把所有的书或是书中所有的内容都读完。</p>
<p>知识的获取不在于多少，而在于是否与自己有关联，以及这种关联有多充分。</p>
<p>对别人有用的东西可能与自己并没有关系，那就果断将其放弃，把握“与自己有关”的筛选原则，会让关联效能大大提升。</p>
<p>当然，还有一个更重要的隐蔽条件不能忽视：<strong>你需要明确的目标或强烈的需求</strong>。</p>
<h5 id="如何获取关联能力"><a href="#如何获取关联能力" class="headerlink" title="如何获取关联能力"></a>如何获取关联能力</h5><h6 id="首先，手中有锤子。"><a href="#首先，手中有锤子。" class="headerlink" title="首先，手中有锤子。"></a>首先，手中有锤子。</h6><p>如果你对某件事情没有足够的热爱和投入，没有极致的专注和思考，恐怕任何事物对你都没有意义。</p>
<h6 id="其次，输入足够多。"><a href="#其次，输入足够多。" class="headerlink" title="其次，输入足够多。"></a>其次，输入足够多。</h6><p>不管是阅读获取，还是现实经历，知识和阅历越丰富，成功关联的概率就越大。</p>
<p>很难想象空白的头脑和苍白的人生如何建立精彩的关联。所谓巧妇难为无米之炊。</p>
<h6 id="再次，保持好奇心"><a href="#再次，保持好奇心" class="headerlink" title="再次，保持好奇心"></a>再次，保持好奇心</h6><h6 id="最后，常说一句话。"><a href="#最后，常说一句话。" class="headerlink" title="最后，常说一句话。"></a>最后，常说一句话。</h6><p>总有一些话让人听过一次就难以忘记，比如李笑来的这句话我就一直记在脑中：“这个道理还能用在什么地方？”</p>
<p>但凡收获一个感悟、了解一个观点或是学到一个知识，只要触动了自己，就要想办法让它效率最大化，而效率最大化的办法就是主动关联到别处，并让自己的行动发生改变。</p>
<p>所以你不妨也把这句话当作口头禅，时常问自己：<strong>这个道理还能用在什么地方？</strong></p>
<h5 id="一切在于主动"><a href="#一切在于主动" class="headerlink" title="一切在于主动"></a>一切在于主动</h5><h4 id="第四节-体系"><a href="#第四节-体系" class="headerlink" title="第四节 体系"></a>第四节 体系</h4><p>只有当知识能够帮助你做实际决策的时候，它才是你的知识。</p>
<p>在个人成长领域，没有最优、最确定、最权威的认知体系，只有最适合我们当前状态的认知体系。</p>
<h5 id="只学让自己触动的"><a href="#只学让自己触动的" class="headerlink" title="只学让自己触动的"></a>只学让自己触动的</h5><p>在阅读时，唯一要做的是：<strong>寻找触动点</strong></p>
<p>我会在触动自己的地方做标记，在空白处写下大量能联想到的思考，书读完之后，我会放上几天，然后问自己：“这本书最触动自己的是哪个点？”</p>
<p>只要它真正触动我，并能让我发生真实的改变，我就认为这本书超值了，至于其他，忘记就忘记了，我一点也不觉得可惜。而作者的知识体系和框架，又与我何干呢？</p>
<p><img src="https://s2.loli.net/2022/02/12/ATSbCgw4J83vtIe.png" alt="image-20220212124517057"></p>
<p><img src="https://s2.loli.net/2022/02/12/to5DGyesiKJab7S.png" alt="image-20220212124606229"></p>
<h5 id="搭建个人认知体系"><a href="#搭建个人认知体系" class="headerlink" title="搭建个人认知体系"></a>搭建个人认知体系</h5><p>体系的本质就是用独特的视角将一些零散的、独立的知识、概念或观点整合为应对这个世界的方法和技巧。</p>
<p>打碎各家的认知体系，只取其中最触动自己的点或块，然后将其拼接成自己的认知网络。</p>
<h5 id="触动是最好的筛选器"><a href="#触动是最好的筛选器" class="headerlink" title="触动是最好的筛选器"></a>触动是最好的筛选器</h5><p>每日反思不是记流水账，而是留意每天最触动自己的那件事，不管是好的启发还是坏的体验，都写下来复盘，写得越细越好。</p>
<p><img src="https://s2.loli.net/2022/02/12/3qAuPWl96XkLgQH.png" alt="image-20220212124819780"></p>
<h5 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h5><p>一、是用自己的语言重新解释新知识，这会促使自己原有的知识体系对新知识做出反应。</p>
<p>二、是在需要的时候能够顺利提取知识，提取不出来的知识就是伪触动。</p>
<p>但我在写作时，能从那些60秒语音分享中提取出来的观点只占少数，大多数观点都被我忘了。</p>
<p>如果你在读书、写作、交谈的时候想到了一个观点，哪怕你记不清具体的内容，只有一条微弱的线索，你也要极端重视这些内容，因为那些能在需要的时候被提取的知识，是与你真正产生触动的知识，你们之间宝贵的连接还在，所以要想办法主动关联和强化。</p>
<p>三、是在生活中能够经常练习或使用这些知识，因为实践是产生强关联的终极方法。</p>
<p>学习不是为了知道，而是为了发生真实的改变。</p>
<p>当你运用那些知识践行那些道理时，相关细节就会源源不断地显现在你的视野里。</p>
<p>到那时，你不仅能成为认知上的强者，也会成为行动上的巨人。</p>
<p>最终，你会明白，所谓的学习成长，诸如阅读、写作、反思、培养习惯、练习技能、建立认知体系，等等，本质上都是一回事：<strong>在舒适区边缘，一点一点向外扩展。</strong></p>
<h4 id="第五节-打卡"><a href="#第五节-打卡" class="headerlink" title="第五节 打卡"></a>第五节 打卡</h4><p>这就是打卡心态的特性：学不到，假装一下；学到了，立即停止。</p>
<p>只要一个小方法就能立即改变，那就是用记录代替打卡。</p>
<p>每次学习后只做行动记录，不做打卡展示。</p>
<p>把学习过程记录下来，既可以看到自己的学习轨迹，也便于每周复盘</p>
<p>只要专注于学习成长活动本身，体会其中的乐趣，就能保持强烈的学习动机，化被动学习为主动学习。</p>
<p>打卡与记录，看似只是叫法上的不同，但其中的差别非常微妙，需要悉心体会。</p>
<h5 id="设下限，不设上限。"><a href="#设下限，不设上限。" class="headerlink" title="设下限，不设上限。"></a><strong>设下限，不设上限。</strong></h5><p>把任务调整为背5个单词——一个很容易完成的下限。</p>
<p>这样做的好处是：你完成目标毫无负担，且此时刚好进入学习状态，精力旺盛，就愿意顺着惯性继续学下去，毕竟此后多学一个单词都是额外的收获，心态完全不同，身心容易沉浸，不会顾虑什么时候才能完成任务。</p>
<h4 id="第六节-反馈"><a href="#第六节-反馈" class="headerlink" title="第六节 反馈"></a>第六节 反馈</h4><p>是否有及时、持续的正向反馈，正是产生学习效果差异的关键。</p>
<h5 id="正向反馈"><a href="#正向反馈" class="headerlink" title="正向反馈"></a>正向反馈</h5><p>持续的正向反馈才能真正激发本能脑和情绪脑的强大行动力。</p>
<p>因为人类强大的本能脑和情绪脑虽然没有思维、短视愚笨，时常沉溺于游戏、手机、美食、懒觉……</p>
<p>但它们超强的欲望和情绪力量却是非常宝贵的行动力资源，如果能让它们感受到学习的乐趣，它们同样会展现强大的行动力，让自己像沉迷娱乐一样沉迷于学习。</p>
<p>所以科学的学习策略是产出作品、获取反馈，驱动本能脑和情绪脑去“玩玩玩”，而不是一味地努力坚持，让理智脑苦苦地去“学学学”。</p>
<h5 id="有作品意识才会有未来"><a href="#有作品意识才会有未来" class="headerlink" title="有作品意识才会有未来"></a>有作品意识才会有未来</h5><p>有了这种认知，人是会迅速改变的——会拥有清晰而强烈的作品意识，会更加重视输出和运用，会倾心打磨作品，主动换取外界的反馈。</p>
<p>比如以前你学习英语可能会选择每日打卡的方式，但现在你可能会选择直接用：直接翻译一段美文、查询英文文档、阅读英文原版书，或者把手机语言设置成英文……这么做当然会造成一些困难，但为了解决问题，你必定会想办法补全相关知识，所以你的学习行为都能得到即时反馈：要么帮自己或他人解决了一个问题，要么产出了一个有价值的作品，这些反馈带给自己的必然是强烈的成就感和继续行动的欲望。</p>
<h5 id="经验-1"><a href="#经验-1" class="headerlink" title="经验"></a>经验</h5><ul>
<li><p>教是最好的学；</p>
</li>
<li><p>用是最好的学；</p>
</li>
<li><p>输出倒逼输入；</p>
</li>
<li><p>请用作品说话……</p>
<p>那些先行者确实都有相同的品质，他们在学习的时候经常不按常理出牌，不管是不是新知识、技能，他们都直接用、直接做。</p>
<p>当然，一开始常常用不好、做不好，但他们肯定要“鼓捣”出一个东西，然后抛出去获取反馈，不断打磨迭代。</p>
</li>
</ul>
<p>不管是不是新知识、技能，他们都直接用、直接做。当然，一开始常常用不好、做不好，但他们肯定要“鼓捣”出一个东西，然后抛出去获取反馈，不断打磨迭代。</p>
<p>找到自己的高价值区——让自己成为某个领域的头部——再借助头部效应的系统推力，从一个小头部不断地向大头部移动，实现跃迁。</p>
<p><strong>而抢占头部最好的途径莫过于持续打磨高价值的作品，凭借作品换取反馈。</strong></p>
<h5 id="痛苦也是反馈"><a href="#痛苦也是反馈" class="headerlink" title="痛苦也是反馈"></a>痛苦也是反馈</h5><p>首先，分享不是随意分享半成品，而是尽最大力气将作品打磨成自己当前能力范围内可完成的最好的样子。</p>
<p>其次，制定分享策略，展示给那些能力不及你的人。</p>
<p>最后，冷静客观地对待打击。</p>
<p>所有痛苦都是上天给我们的成长提示。</p>
<h5 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h5><p>主动的回想测试是最好的学习方法之一，比坐在那儿被动地重读材料要好得多。</p>
<p><strong>真正的学习成长不是“努力，努力再努力”，而是“反馈，反馈再反馈”。</strong></p>
<p>跳过原理，直接实操的方式仅适用于学习的初级阶段。也就是说，采用这一方式，你快速达到60分的水平是可以的，但到了中级或高级阶段，仍然需要系统学习原理，否则走不远。</p>
<p>不过，反馈的规律是贯穿始终的，无论什么时候，只要能通过产出换取反馈，你就会不自觉地去钻研探索。</p>
<h4 id="第七节-休息"><a href="#第七节-休息" class="headerlink" title="第七节 休息"></a>第七节 休息</h4><p>你肯定记得“刻意练习四要素”：定义明确的目标、极度的专注、有效的反馈、在拉伸区练习。</p>
<p>有效学习的关键是保持极度专注，而非一味比拼毅力和耐心。</p>
<p>不过，保持专注需要花费精力，而我们的精力是有限的，就像一桶水，有的人总量多些，有的人少些，但只要在困难的事情上消耗精力，精力桶的水位就会慢慢下降。</p>
<h5 id="主动休息"><a href="#主动休息" class="headerlink" title="主动休息"></a>主动休息</h5><p><img src="https://s2.loli.net/2022/02/12/luc3gRKXZOdBD6I.png" alt="image-20220212130109139"></p>
<p>学习时从不过度消耗自己，只要感到精力不足，就停下来主动休息，这反而使他们精力桶的水位得到快速回升</p>
<p><img src="https://s2.loli.net/2022/02/12/pKRrhi2WmgvUQFs.png" alt="image-20220212130220452"></p>
<p><img src="https://s2.loli.net/2022/02/12/7TgYsOwSnpV1RyE.png" alt="image-20220212130243972"></p>
<h5 id="保持专注的危机"><a href="#保持专注的危机" class="headerlink" title="保持专注的危机"></a>保持专注的危机</h5><p>高效学习的关键在于保持极度专注。</p>
<p>科学的模式：<strong>极度专注+主动休息，如此反复。</strong></p>
<p>在生活中，最要不得的就是那种明明已经分心走神了，却还要强撑内耗，倒不如遵循“极度专注+主动休息”的模式，让自己先尽力保持短时间的极度专注，到有些累的时候就主动停下来，这是更加明智的生活和学习策略。</p>
<p><img src="https://s2.loli.net/2022/02/12/hLRq9Hf1IKA4SoD.png" alt="image-20220212130425253"></p>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>一个真正的自控高手，不是一个只知道冲刺的人，而是一个善于主动休息、保持平衡的人。</p>
<p>这些人无论面对精力的消耗与恢复，还是面对情绪的波动与还原，都会刻意保持高位富足的状态，避免进入低位稀缺的境地。</p>
<p>一个简单又通用的方法正是前文说的主动培养“极度专注+主动休息”的行为模式。</p>
<p>具体的做法就是：只要开始学习或工作，就尽量保持极度专注的状态，哪怕保持专注的时间很短也是有意义的；一旦发现自己开始因为精力不足而分心走神，就主动停下来调整片刻。</p>
<p>很多人在学习和工作中都不具备不受打扰的理想条件，但只要坚持“极度专注+主动休息”的模式，效果也会让你满意。</p>
<p>不管你能工作几分钟，只要开始了，就尽力保持专注，把无关的事情都放在一边。</p>
]]></content>
      <tags>
        <tag>一篇读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer_Composition_Principle</title>
    <url>/2022/02/14/Computer-Composition-Principle/</url>
    <content><![CDATA[<h1 id="Chapter-1-计算机系统概述-≤5分"><a href="#Chapter-1-计算机系统概述-≤5分" class="headerlink" title="Chapter 1 计算机系统概述(≤5分)"></a>Chapter 1 计算机系统概述(≤5分)</h1><h2 id="1-计算机的分类"><a href="#1-计算机的分类" class="headerlink" title="1. 计算机的分类"></a>1. 计算机的分类</h2><ol>
<li>电子计算机从总体上来说，分为两大类：电子模拟计算机和电子数字计算机。</li>
<li>电子数字计算机进一步又分为专用计算机和通用计算机。</li>
<li>通用计算机可分为：超级计算机、大型机、服务器、PC机、单片机和多核机六类，他们的区别在于体积、简易性、功率损耗、性能指标、数据存储容量、指令系统规模和机器价格。</li>
</ol>
<p><img src="https://s2.loli.net/2022/02/14/szBqT86LX3twZhF.png" alt="image-20220214143435926"></p>
<h2 id="2-计算机的发展"><a href="#2-计算机的发展" class="headerlink" title="2. 计算机的发展"></a>2. 计算机的发展</h2><h3 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h3><p>主要是CPU性能指标、存储器性能指标和I/O吞吐率。</p>
<h4 id="1-吞吐量"><a href="#1-吞吐量" class="headerlink" title="1. 吞吐量"></a>1. 吞吐量</h4><p>表征一台计算机在某一时间间隔内能够处理的信息量。</p>
<h4 id="2-响应时间"><a href="#2-响应时间" class="headerlink" title="2. 响应时间"></a>2. 响应时间</h4><p>表征从输入有效到系统产生响应之间的时间度量，用时间单位来度量。</p>
<h4 id="3-总线宽度"><a href="#3-总线宽度" class="headerlink" title="3. 总线宽度"></a>3. 总线宽度</h4><p>一般指CPU中运算器与存储器之间进行互连的内部总线<strong>二进制位数</strong>。</p>
<h4 id="4-存储器容量"><a href="#4-存储器容量" class="headerlink" title="4. 存储器容量"></a>4. 存储器容量</h4><p>存储器中所有存储单元的总数目，通常用KB、MB、GB、TB来表示。</p>
<h4 id="5-主频-时钟周期"><a href="#5-主频-时钟周期" class="headerlink" title="5. 主频/时钟周期"></a>5. 主频/时钟周期</h4><p>CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，主时钟的频率(f)叫CPU的主频。</p>
<p>主频的倒数称为CPU时钟周期(T)，$T=\frac{1}{f}$。</p>
<h4 id="6-CPU执行时间"><a href="#6-CPU执行时间" class="headerlink" title="6. CPU执行时间"></a>6. CPU执行时间</h4><p>表示CPU执行一般程序所占的CPU时间，计算公式：</p>
<script type="math/tex; mode=display">
CPU执行时间=CPU时钟周期数×CPU时钟周期</script><h4 id="7-CPI"><a href="#7-CPI" class="headerlink" title="7. CPI"></a>7. CPI</h4><p>表示每条指令周期数，即执行一条指令所需的平局时钟周期数。计算公式：</p>
<script type="math/tex; mode=display">
CPI=执行某段程序所需的CPU周期数÷程序所包含的指令条数</script><h4 id="8-存储器带宽"><a href="#8-存储器带宽" class="headerlink" title="8. 存储器带宽"></a>8. 存储器带宽</h4><p>单位时间内从存储器读出的二进制信息量，一般用字节数/秒来表示。</p>
<h4 id="9-处理器字长"><a href="#9-处理器字长" class="headerlink" title="9. 处理器字长"></a>9. 处理器字长</h4><p>指处理机运算器中一次能够完成二进制数运算的位数，如32位、64位。</p>
<h2 id="3-计算机的硬件"><a href="#3-计算机的硬件" class="headerlink" title="3. 计算机的硬件"></a>3. 计算机的硬件</h2><h2 id="4-计算机的软件"><a href="#4-计算机的软件" class="headerlink" title="4. 计算机的软件"></a>4. 计算机的软件</h2><h2 id="5-计算机系统的层次结构"><a href="#5-计算机系统的层次结构" class="headerlink" title="5. 计算机系统的层次结构"></a>5. 计算机系统的层次结构</h2><ol>
<li>计算机系统的层次结构从下至上可分为五级：<strong>微程序级、一般机器级、操作系统级、汇编语言级、高级语言级</strong>组成，每一级上都能进行程序设计，且得到下面各级的支持。</li>
</ol>
<p><img src="https://s2.loli.net/2022/02/14/ojHdKUNcV4ifqng.png" alt="image-20220214150037411"></p>
<h1 id="Chapter-2-运算方法和运算器-20分左右"><a href="#Chapter-2-运算方法和运算器-20分左右" class="headerlink" title="Chapter 2 运算方法和运算器(20分左右)"></a>Chapter 2 运算方法和运算器(20分左右)</h1><p>肯定有个计算题</p>
<h2 id="1-数据与文字的表示方法"><a href="#1-数据与文字的表示方法" class="headerlink" title="1. 数据与文字的表示方法"></a>1. 数据与文字的表示方法</h2><p>计算机中常用的数据表示格式有两种：一是定点格式，二是浮点格式。</p>
<h3 id="1-定点数的表示方法"><a href="#1-定点数的表示方法" class="headerlink" title="1. 定点数的表示方法"></a>1. 定点数的表示方法</h3><p>所谓定点格式，即约定机器中所有数据的小数点位置是固定不变的。</p>
<h4 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h4><p>假设用一个n+1位字来表示一个定点数x，其中一位$x_n$用来表示数的符号，其余位数表示它的量值。则</p>
<p><img src="https://s2.loli.net/2022/02/15/kMfs3KqAv8u19Yt.png" alt="image-20220215211440074"></p>
<h5 id="纯小数"><a href="#纯小数" class="headerlink" title="纯小数"></a>纯小数</h5><p>如果数x表示的是纯小数，那么小数点位于$x_n$和$x_{n-1}$之间。当各位均为0时，数x的绝对值最小，即$|x|_{min}=0$；当各位均为1时，数x的绝对值最大，即$|x|_{max}=1-2^{-n}$。</p>
<h5 id="纯整数"><a href="#纯整数" class="headerlink" title="纯整数"></a>纯整数</h5><p>如果数x表示的时纯整数，那么小数点位于最低位$x_0$的右边，此时数x的表示范围为$0≤|x|≤2^n-1$</p>
<h3 id="2-浮点数的表示方法"><a href="#2-浮点数的表示方法" class="headerlink" title="2. 浮点数的表示方法"></a>2. 浮点数的表示方法</h3><h4 id="浮点表示法"><a href="#浮点表示法" class="headerlink" title="浮点表示法"></a>浮点表示法</h4><p>把一个数的有效数字和数的范围在计算机的一个存储单元中分别予以表示。</p>
<p>这种把数的范围和精度分别表示的方法，相当于数的小数点位置随比例因子的不同而在一定范围内可以自由浮动，所以称作浮点表示法。</p>
<p>任意一个二进制数N可以写成：$N=2^e*M$</p>
<p>其中，<strong>M称为浮点数的尾数，是一个纯小数。</strong></p>
<p><strong>e是比例因子的指数，称为浮点数的指数，是一个整数。</strong></p>
<h4 id="在机器中"><a href="#在机器中" class="headerlink" title="在机器中"></a>在机器中</h4><p>表示一个浮点数时，</p>
<p>一是要给出尾数，用定点小数形式表示。位数部分给出有效数字的位数，因为决定了浮点数的表示精度。</p>
<p>二是要给出指数，用整数形式表示，常称为阶码，阶码指明小数点在数据中的位置，因而决定了浮点数的表示范围。</p>
<p>计算机中，一个浮点数由阶码、尾数及其符号位组成。</p>
<p><img src="https://s2.loli.net/2022/02/15/lQ9uog5xkcSvr42.png" alt="image-20220215220234364"></p>
<h3 id="3-数的机器码表示"><a href="#3-数的机器码表示" class="headerlink" title="3. 数的机器码表示"></a>3. 数的机器码表示</h3><h4 id="1-原码表示法"><a href="#1-原码表示法" class="headerlink" title="1. 原码表示法"></a>1. 原码表示法</h4><p>若定点整数的源码形式为$x_n x_{n-1}…x_1 x_0 (x_n为符号位)$，则原码表示的定义是</p>
<script type="math/tex; mode=display">
[x]_原 = \begin{cases}
x & 2^n＞x≥0 \\ 
2^n - x = 2^n + |x| & 0≥x≥-2^n
\end{cases} \\
式中，[x]_原 是机器数，x是真值。</script><p>增加符号位作为最高位，其后加原数据绝对值。</p>
<p>最大的缺点是加法运算复杂。</p>
<p><img src="https://s2.loli.net/2022/02/16/Lxf5qSJim4Gc1TC.png" alt="image-20220216145144763"></p>
<p><img src="https://s2.loli.net/2022/02/15/gEftjZVW2FniR8o.png" alt="image-20220215222231486"></p>
<h5 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h5><p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220216145301928.png" alt="image-20220216145301928"></p>
<p>其表示范围与原码一致，且0有两种表示方法。</p>
<h4 id="2-补码表示法"><a href="#2-补码表示法" class="headerlink" title="2. 补码表示法"></a>2. 补码表示法</h4><p>正数补码等于原码</p>
<p>负数补码在原码的基础上，符号位不变，其余位数取反加一。</p>
<p>补码的拓展即为符号位的拓展，正数前补0，负数前补1.</p>
<p>补码的取值范围-128-127。</p>
<p><img src="https://s2.loli.net/2022/02/16/7mkTa4O25PA9xdv.png" alt="image-20220216145854118"></p>
<h5 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h5><p><img src="https://s2.loli.net/2022/02/16/yv8A5dPc4N1nthX.png" alt="image-20220216150338907"></p>
<h4 id="3-移码表示法"><a href="#3-移码表示法" class="headerlink" title="3. 移码表示法"></a>3. 移码表示法</h4><p>移码通常用来表示浮点数的阶码。</p>
<p><img src="https://s2.loli.net/2022/02/26/fMboR2hywnZcvdl.png" alt="image-20220215223357232"></p>
<h4 id="4-浮点数的机器表示"><a href="#4-浮点数的机器表示" class="headerlink" title="4. 浮点数的机器表示"></a>4. 浮点数的机器表示</h4><p>当前的计算机都采用统一的IEEE754标准中的格式表示浮点数。如下：</p>
<h5 id="32位短浮点数："><a href="#32位短浮点数：" class="headerlink" title="32位短浮点数："></a>32位短浮点数：</h5><p><img src="https://s2.loli.net/2022/02/15/7TBCrlsdJjVxeyU.png" alt="image-20220215224328269"></p>
<p>64位长浮点数</p>
<p><img src="https://s2.loli.net/2022/02/15/al9TZi3uD6RWStI.png" alt="image-20220215224403466"></p>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>S是浮点数的符号位，占1位，安排在最高位，S=0表示正数，S=1表示负数；</p>
<p>M是尾数，放在低位部分，占用23位/52位，小数点位置放在尾数域最左(最高)有效位的右边；</p>
<p>E是阶码，占用8位/11位，阶符采用隐含的方式，即采用移码的方法来表示正负指数。此时，将浮点数的指数真值e变成阶码E时，应将指数e加上一个固定的偏置常数127，即E=e+127。</p>
<h5 id="规格化表示"><a href="#规格化表示" class="headerlink" title="规格化表示"></a>规格化表示</h5><p>当尾数的值不为0时，尾数域的最高有效位应为1，这称为浮点数的规格化表示。</p>
<p>在IEEE754标准中，一个规格化的32位浮点数x的真值表示为：</p>
<script type="math/tex; mode=display">
x = (-1)^S × (1.M)×2^{E-127} \quad e=E-127</script><p>其中，尾数域所表示的值是1.M。由于尾数域最左边(最高有效位)总是1，故这一位无需存储，而认为隐藏在小数点的左边。于是用23位的字段可以存储24位有效数。</p>
<p><img src="https://s2.loli.net/2022/02/16/tdcgX5bT2U6eIZP.png" alt="image-20220216144706157"></p>
<p><img src="https://s2.loli.net/2022/02/15/KHYbaiTJy5Aw62B.png" alt="image-20220215231236313"></p>
<p><img src="https://s2.loli.net/2022/02/15/HayV5z3XrB7evwU.png" alt="image-20220215231312541"></p>
<p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220215231414891.png" alt="image-20220215231414891"></p>
<h3 id="5-校验码"><a href="#5-校验码" class="headerlink" title="5. 校验码"></a>5. 校验码</h3><p>在每个字上添加一些校验位，用来确定字中出现错误的位置。</p>
<p>最简单且广泛应用的检错码是，采用<strong>一位校验码</strong>的奇校验或偶校验。</p>
<h4 id="1-奇校验"><a href="#1-奇校验" class="headerlink" title="1. 奇校验"></a>1. 奇校验</h4><p>设$X=(x_0 x_1 … x_{n-1})$是一个n位字，则奇校验位$\overline C$定义为</p>
<script type="math/tex; mode=display">
\overline C = x_0 \bigoplus x_1 \bigoplus ... \bigoplus x_{n-1}</script><p>式中，$\bigoplus$表示按位加，表明只有当X中包含奇数个1时，才能使$\overline C = 1，即C=0$。</p>
<h4 id="2-偶校验"><a href="#2-偶校验" class="headerlink" title="2. 偶校验"></a>2. 偶校验</h4><p>偶校验位C定义为</p>
<script type="math/tex; mode=display">
C = x_0 \bigoplus x_1 \bigoplus ... \bigoplus x_{n-1}</script><p>即X中包含偶数个1时，才使C=0。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>若A=41H，即0010 0001增加偶校验位后，为0010 0001 0。</p>
<p><img src="https://s2.loli.net/2022/02/16/zXmiDflgtS4u1T6.png" alt="image-20220216140020946"></p>
<h2 id="2-定点加法、减法运算"><a href="#2-定点加法、减法运算" class="headerlink" title="2. 定点加法、减法运算"></a>2. 定点加法、减法运算</h2><h3 id="常用公式："><a href="#常用公式：" class="headerlink" title="常用公式："></a>常用公式：</h3><p>补码加法：$[x]_补 + [y]_补 = [x+y]_补 \quad (mod \, 2^{n+1})$</p>
<p>补码减法：$[x-y]_补 = [x]_补 - [y]_补 = [x]_补+[-y]_补$</p>
<p>​                   $[-y]_补 = -[y]_补 \quad (mod \, 2_{n+1})$</p>
<p>从$[y]_补求[-y]_补的方法是：对[y]_补连同符号位取反加1$。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="https://s2.loli.net/2022/02/16/NSrs7CmWVylAojt.png" alt="image-20220216142608474"></p>
<h3 id="溢出与检测方法"><a href="#溢出与检测方法" class="headerlink" title="溢出与检测方法"></a>溢出与检测方法</h3><h4 id="溢出概念"><a href="#溢出概念" class="headerlink" title="溢出概念"></a>溢出概念</h4><p>当两个正数相加，其值<strong>大于机器字长所能表示的最大正数</strong>，称为正溢；</p>
<p>当两个负数相加，其值<strong>小于机器字长所能表示的最小负数</strong>，称为负溢。</p>
<h4 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h4><h5 id="双符号位"><a href="#双符号位" class="headerlink" title="双符号位"></a>双符号位</h5><p>这称为“变形补码”。</p>
<p>为了得到两数变形补码之和等于两数和的变形补码，必须：</p>
<ol>
<li>两个符号位都看作数码一样参加运算</li>
<li>两数进行模$2_{n+2}$的加法，即最高位上产生进位要丢掉。</li>
</ol>
<p>采用变形补码后，任何正数，两个符号位都是”0”；任何负数，两个符号为都是”1”。</p>
<p>若两数相加，其结果符号位出现”01”，表示正溢出(结果大于$2^n$)；出现”10”，表示负溢出(结果小于$-2^n$)。</p>
<p>最高符号位永远表示结果的正确符号。</p>
<p><img src="https://s2.loli.net/2022/02/16/DcKbAWxeBkmiS6h.png" alt="image-20220216143907684"></p>
<h3 id="4-基本的二进制加法-减法器"><a href="#4-基本的二进制加法-减法器" class="headerlink" title="4. 基本的二进制加法/减法器"></a>4. 基本的二进制加法/减法器</h3><h4 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h4><p><img src="https://s2.loli.net/2022/02/16/Jm3B5DFwHl8WCpR.png" alt="image-20220216150729104"></p>
<h2 id="3-定点乘法运算"><a href="#3-定点乘法运算" class="headerlink" title="3. 定点乘法运算"></a>3. 定点乘法运算</h2><h3 id="1-不带符号的阵列乘法器"><a href="#1-不带符号的阵列乘法器" class="headerlink" title="1. 不带符号的阵列乘法器"></a>1. 不带符号的阵列乘法器</h3><p>采用与门和全加器(fa)构成阵列乘法。</p>
<h4 id="时间估算"><a href="#时间估算" class="headerlink" title="时间估算"></a>时间估算</h4><p><img src="https://s2.loli.net/2022/02/16/6FlX1poDRkTSu9j.png" alt="image-20220216152154058"></p>
<h3 id="2-带符号的阵列乘法器"><a href="#2-带符号的阵列乘法器" class="headerlink" title="2. 带符号的阵列乘法器"></a>2. 带符号的阵列乘法器</h3><h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><p><img src="https://s2.loli.net/2022/02/16/6naZS5Dkqjcb8zu.png" alt="image-20220216151100556"></p>
<p><img src="https://s2.loli.net/2022/02/16/ldHwSpa9nbWYx1D.png" alt="image-20220216153345959"></p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>在这种逻辑结构中，共使用了三个求补器。</p>
<h5 id="两个算前求补器的作用"><a href="#两个算前求补器的作用" class="headerlink" title="两个算前求补器的作用"></a>两个算前求补器的作用</h5><p>将两个操作数A和B在被不带符号的乘法阵列(核心部件)相乘之前，先变成正整数。</p>
<h5 id="算后求补器的作用"><a href="#算后求补器的作用" class="headerlink" title="算后求补器的作用"></a>算后求补器的作用</h5><p>当两个输入操作数的符号不一致时，把运算结果变换成带符号的数。</p>
<h5 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h5><p>为了完成必需的求补和乘法运算，时间大约比原码阵列乘法增加1倍。</p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><img src="https://s2.loli.net/2022/02/16/ob1DpAYUqvLigJl.png" alt="image-20220216152236154"></p>
<ol>
<li>符号位要单独运算</li>
<li>补码要转换为原码，再进行乘法，不方便</li>
<li><img src="https://s2.loli.net/2022/02/16/hd2vBO1muQXaoV6.png" alt="image-20220216153257787"></li>
</ol>
<h3 id="3-直接补码阵列乘法器"><a href="#3-直接补码阵列乘法器" class="headerlink" title="3. 直接补码阵列乘法器"></a>3. 直接补码阵列乘法器</h3><p><img src="https://s2.loli.net/2022/02/16/Wol642bgEqwZtLG.png" alt="image-20220216152609536"></p>
<h2 id="4-定点除法运算"><a href="#4-定点除法运算" class="headerlink" title="4. 定点除法运算"></a>4. 定点除法运算</h2><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p>机器不会心算，必须先作减法。</p>
<p>若余数为正，才知道够减(商1)；若余数为负, 不够减(商0)。不够减时必须恢复原来的余数，以便再继续往下运算。这种方法称为<strong>恢复余数法。</strong>要恢复原来的余数，只要当前的余数加上除数即可。</p>
<p>实际中常用<strong>加减交替法</strong>。其特点是运算过程中如出现不够减，则不必恢复余数，根据余数符号,可以继续往下运算，因此步数固定，控制简单。</p>
<h3 id="加减交替法"><a href="#加减交替法" class="headerlink" title="加减交替法"></a>加减交替法</h3><p><strong>不用恢复余数。</strong></p>
<p><strong>当余数为正时，商1，余数左移一位，减除数做2ri-|y|运算</strong></p>
<p><strong>当余数为负时，商0，余数左移一位，加除数做2ri+|y| 运算</strong></p>
<p>因为：$-y+y-\frac{1}{2}y = -y + \frac{1}{2}y$</p>
<p><img src="https://s2.loli.net/2022/02/16/WSRwnZdvV4s8K5T.png" alt="image-20220216153321434"></p>
<h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p><img src="https://s2.loli.net/2022/02/24/G3Kbyhnm6A4xd9W.png" alt="image-20220224193547423"></p>
<p><img src="https://s2.loli.net/2022/02/24/IoYjiUPKXaWnmDT.png" alt="image-20220224193915015"></p>
<p>一般都是当商变为1时，根据商的长度，考虑是否到此为止(确定保留几位小数)。</p>
<p>除法运算不加符号，等计算完毕后，再把符号补上。</p>
<h2 id="5-定点运算器的组成"><a href="#5-定点运算器的组成" class="headerlink" title="5. 定点运算器的组成"></a>5. 定点运算器的组成</h2><p>计算机中的逻辑运算，主要是指逻辑非、逻辑加(逻辑或)、逻辑乘(逻辑与)、逻辑异(逻辑异或)四种基本操作。</p>
<h3 id="多功能算数、逻辑运算单元-ALU"><a href="#多功能算数、逻辑运算单元-ALU" class="headerlink" title="多功能算数、逻辑运算单元(ALU)"></a>多功能算数、逻辑运算单元(ALU)</h3><p>多功能算术/逻辑运算单元(ALU)，它不仅具有多种算术运算和逻辑运算的功能，而且具有先行进位逻辑，从而能实现高速运算。</p>
<p><img src="https://s2.loli.net/2022/02/24/oJrZO7l4BPUmxSh.png" alt="image-20220224201931968"></p>
<p><img src="https://s2.loli.net/2022/02/24/f7v51F2IuhwDPoX.png" alt="image-20220224202048320"></p>
<h5 id="组内先行，组间串行"><a href="#组内先行，组间串行" class="headerlink" title="组内先行，组间串行(*)"></a>组内先行，组间串行(*)</h5><h2 id="6-浮点运算方法"><a href="#6-浮点运算方法" class="headerlink" title="6. 浮点运算方法"></a>6. 浮点运算方法</h2><p>设有两个浮点数，分别为：</p>
<p>$ x = 2^{E_x} \cdot M_x$</p>
<p>$ y = 2^{E_y} \cdot M_y$</p>
<p>其中，$E_x 和 E_y分别为数x和y的阶码，M_y和M_x分别是y和x的尾数。$</p>
<p>则，两浮点数进行加法和减法的运算规则是</p>
<script type="math/tex; mode=display">
z=x \pm y = (M_x 2^{E_x-E_y} \pm M_y)2^{E_y}</script><h3 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1. 步骤"></a>1. 步骤</h3><h4 id="0操作数检查"><a href="#0操作数检查" class="headerlink" title="0操作数检查"></a>0操作数检查</h4><p>检查是否有一个操作数为0。</p>
<h4 id="比较阶码大小并完成对阶"><a href="#比较阶码大小并完成对阶" class="headerlink" title="比较阶码大小并完成对阶"></a>比较阶码大小并完成对阶</h4><p>对阶时，小阶向大阶看齐，即小阶的尾数向右移位(相当于小数点左移)</p>
<h4 id="尾数进行加或减运算"><a href="#尾数进行加或减运算" class="headerlink" title="尾数进行加或减运算"></a>尾数进行加或减运算</h4><h4 id="操作数规格化并进行舍入处理"><a href="#操作数规格化并进行舍入处理" class="headerlink" title="操作数规格化并进行舍入处理"></a>操作数规格化并进行舍入处理</h4><h4 id="尾数处理"><a href="#尾数处理" class="headerlink" title="尾数处理"></a>尾数处理</h4><p><img src="https://s2.loli.net/2022/02/24/CrmpNQ7GkxoDiMd.png" alt="image-20220224202407215"></p>
<h5 id="舍入处理法"><a href="#舍入处理法" class="headerlink" title="舍入处理法"></a>舍入处理法</h5><ul>
<li>舍去的数中，有1，那保留的最低位就是1</li>
<li>舍去的数中，最高位是1，那么保留的最低位就是1</li>
</ul>
<h4 id="另外-1"><a href="#另外-1" class="headerlink" title="另外"></a>另外</h4><p><strong>浮点数的溢出，在于阶码溢出。</strong></p>
<h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h3><p>设数的阶码3位，尾数6位，用浮点运算方法：</p>
<p><img src="https://s2.loli.net/2022/02/24/r6odCAghiRlGnmy.png" alt="image-20220224200340588"> </p>
<p>设数的阶码3位，尾数6位，用浮点运算方法：</p>
<p><img src="https://s2.loli.net/2022/02/24/GVZ1X3uiyS2DL8A.png" alt="image-20220224200813157"></p>
<h3 id="3-流水线运算器"><a href="#3-流水线运算器" class="headerlink" title="3. 流水线运算器"></a>3. 流水线运算器</h3><p>加速比 = 串行/并行(一定大于1)。</p>
<p><img src="https://s2.loli.net/2022/02/24/kRBsQeVaEP6K2hq.png" alt="image-20220224202713285"></p>
<h1 id="Chapter-3-存储系统-两个大题"><a href="#Chapter-3-存储系统-两个大题" class="headerlink" title="Chapter 3 存储系统(两个大题)"></a>Chapter 3 存储系统(两个大题)</h1><h2 id="1-存储器概述"><a href="#1-存储器概述" class="headerlink" title="1. 存储器概述"></a>1. 存储器概述</h2><h3 id="三级存储系统"><a href="#三级存储系统" class="headerlink" title="三级存储系统"></a>三级存储系统</h3><p>cache、主存、外存储器。</p>
<p>前两个合起来即为二级存储系统：内存、外存。</p>
<h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><h4 id="读写功能"><a href="#读写功能" class="headerlink" title="读写功能"></a>读写功能</h4><p>只能读出不能写入：ROM(只读存储器)</p>
<p>既能读出也能写入：RAM(随机存取存储器)</p>
<h4 id="信息易失性"><a href="#信息易失性" class="headerlink" title="信息易失性"></a>信息易失性</h4><p>断电后信息消失的存储器：易失性存储器(RAM)</p>
<p>断电后仍能保存信息的存储器：非易失性存储器(ROM)</p>
<p>磁性材料做成的存储器是非易失性存储器。</p>
<h3 id="存储器的技术指标"><a href="#存储器的技术指标" class="headerlink" title="存储器的技术指标"></a>存储器的技术指标</h3><h4 id="1-存储容量"><a href="#1-存储容量" class="headerlink" title="1. 存储容量"></a>1. 存储容量</h4><p>存储容量指一个存储器中可存储的信息比特数。</p>
<p>可表示为：存储字数(存储单元数)×存储字长(每单元的比特数)。</p>
<h4 id="2-存取时间"><a href="#2-存取时间" class="headerlink" title="2. 存取时间"></a>2. 存取时间</h4><p>又称存储器访问时间，是从存储器接收到读/写命令开始，到信息被读出或写入完成所需的时间。</p>
<h4 id="3-存储周期"><a href="#3-存储周期" class="headerlink" title="3. 存储周期"></a>3. 存储周期</h4><p>是在存储器连续读写过程中，一次完整的存取操作所需的时间，即CPU连续两次访问存储器的最小间隔时间。</p>
<p>存储周期略大于存取时间。</p>
<h2 id="2-静态随机存取存储器-必考"><a href="#2-静态随机存取存储器-必考" class="headerlink" title="2. 静态随机存取存储器(必考)"></a>2. 静态随机存取存储器(必考)</h2><p>SRAM的优点是存取速度快，但存储密度和容量不如DRAM大。</p>
<h3 id="1-基本的SRAM逻辑结构"><a href="#1-基本的SRAM逻辑结构" class="headerlink" title="1. 基本的SRAM逻辑结构"></a>1. 基本的SRAM逻辑结构</h3><p><img src="https://s2.loli.net/2022/02/24/xwq5lBe3aCPdykR.png" alt="image-20220224204804844"></p>
<h3 id="2-SRAM的读-写时序"><a href="#2-SRAM的读-写时序" class="headerlink" title="2. SRAM的读/写时序"></a>2. SRAM的读/写时序</h3><h4 id="读周期"><a href="#读周期" class="headerlink" title="读周期"></a>读周期</h4><p>地址线先有效，以便进行地址译码，选中存储单元。$\overline {CS}和\overline{OE}$有效。</p>
<p>这是$t_{RC}$</p>
<p><img src="https://s2.loli.net/2022/02/24/oeg7NKVEyFxZjPw.png" alt="image-20220224205711890"></p>
<h4 id="写周期"><a href="#写周期" class="headerlink" title="写周期"></a>写周期</h4><p>地址线先有效，接着片选信号$\overline{CS}$有效，写命令$\overline{WE}$有效。此时数据总线上必须置 待写入数据。</p>
<p>写入时，地址线不能总变。</p>
<p><img src="https://s2.loli.net/2022/02/24/Fsw3kKND2yifraj.png" alt="image-20220224205809217"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>为了控制方便，常取$t_{RC} = t_{WC}$,通常称为存取周期。</p>
<h3 id="3-存储器容量的扩充"><a href="#3-存储器容量的扩充" class="headerlink" title="3. 存储器容量的扩充"></a>3. 存储器容量的扩充</h3><h4 id="1-位拓展"><a href="#1-位拓展" class="headerlink" title="1. 位拓展"></a>1. 位拓展</h4><p>拓展数据线。</p>
<h4 id="2-字拓展"><a href="#2-字拓展" class="headerlink" title="2. 字拓展"></a>2. 字拓展</h4><p>拓展地址线。</p>
<h4 id="3-字位拓展"><a href="#3-字位拓展" class="headerlink" title="3. 字位拓展"></a>3. 字位拓展</h4><p>二者都拓展。</p>
<h2 id="4-DRAM"><a href="#4-DRAM" class="headerlink" title="4. DRAM"></a>4. DRAM</h2><p>DRAM的存储元所需元件更少，所以存储密度更高。</p>
<h3 id="DRAM的刷新策略"><a href="#DRAM的刷新策略" class="headerlink" title="DRAM的刷新策略"></a>DRAM的刷新策略</h3><p>DRAM存储位元是基于电容器上的电荷量存储信息的，DRAM的读操作是破坏性的，会使电容器上的电荷流失，因为读出后必须刷新(读被读出的数据，将其重新写入)。</p>
<p>而未读写的存储元也要定期刷新，因为电荷量会逐渐泄露而减少。</p>
<h2 id="5-cache"><a href="#5-cache" class="headerlink" title="5. cache"></a>5. cache</h2><h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><h4 id="题型1"><a href="#题型1" class="headerlink" title="题型1"></a>题型1</h4><p><img src="https://s2.loli.net/2022/02/25/ubRFgBvWiTq39ec.png" alt="image-20220225231927296"></p>
<h4 id="题型2"><a href="#题型2" class="headerlink" title="题型2"></a>题型2</h4><p><img src="https://s2.loli.net/2022/02/25/mQ5ygktUGXr2Yow.png" alt="image-20220225231708983"></p>
<p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220225231840941.png" alt="image-20220225231840941"></p>
<h2 id="6-虚拟存储器"><a href="#6-虚拟存储器" class="headerlink" title="6. 虚拟存储器"></a>6. 虚拟存储器</h2><p>用户在编制程序时，使用的地址为虚地址或逻辑地址，其对应的存储空间称为虚存空间，是程序员所看到的地址范围。</p>
<p>而计算机物理内存的访问地址则称为实地址或物理地址，对应的存储空间称为物理存储空间或主存空间。程序进行虚地址到实地址转换的过程称为程序的再定位。</p>
<h3 id="1-功能"><a href="#1-功能" class="headerlink" title="1. 功能"></a>1. 功能</h3><p><strong>虚拟存储器的一个重要用途是解决计算机中主存储器的容量问题，在不明显降低平均访问速度的前提下增加程序的访问空间。</strong></p>
<h3 id="2-两种存储系统的区别"><a href="#2-两种存储系统的区别" class="headerlink" title="2. 两种存储系统的区别"></a>2. 两种存储系统的区别</h3><p>在虚拟存储器中未命中的性能损失要远大于cache系统中未命中的损失（因为磁盘的存取时间是主存存取时间的上千倍）。主存存取时间是cache的存取时间的5～10倍。</p>
<p>cache是通过硬件实现的，虚拟存储器是通过软件(操作系统)实现的。</p>
<h3 id="3-页式虚拟存储器"><a href="#3-页式虚拟存储器" class="headerlink" title="3. 页式虚拟存储器"></a>3. 页式虚拟存储器</h3><p><img src="https://s2.loli.net/2022/02/26/XPucjEiNYwpSd1B.png" alt="image-20220226221911029"></p>
<p><img src="https://s2.loli.net/2022/02/26/kqFEH9eUWbDwdM5.png" alt="image-20220226222027358"></p>
<p><img src="https://s2.loli.net/2022/02/26/hurljqTQZi3sPLK.png" alt="image-20220226222252150"></p>
<h3 id="4-段式虚拟存储器"><a href="#4-段式虚拟存储器" class="headerlink" title="4. 段式虚拟存储器"></a>4. 段式虚拟存储器</h3><p><strong>在段式虚拟存储系统中，段是按照程序的逻辑结构划分的，各个段的长度因程序而异。</strong></p>
<p><img src="https://s2.loli.net/2022/02/26/C6pScNbjUX2aAlr.png" alt="image-20220226222825964"></p>
<p><img src="https://s2.loli.net/2022/02/26/kKQj8P2sOXrtRYh.png" alt="image-20220226222855961"></p>
<p>实存地址=段起地址 + 段内地址。</p>
<h3 id="5-段页式虚拟存储器"><a href="#5-段页式虚拟存储器" class="headerlink" title="5. 段页式虚拟存储器"></a>5. 段页式虚拟存储器</h3><p><img src="https://s2.loli.net/2022/02/26/quk52C7th1wTvXg.png" alt="image-20220226223319885"></p>
<p><img src="https://s2.loli.net/2022/02/26/km6AvEIRjygpHY1.png" alt="image-20220226223341265"></p>
<p>表示的是：通过基号C，到基址寄存器获取程序C段的起始地址，找到其中序号为1的段，再去寻段中的第2页。</p>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p>①根据基号C执行SC加1（段号）操作，得到段表相应行地址，其内容为页表的起始地址ｂ。</p>
<p>②执行b+2（页号），得到物理页号的地址，其内容即为物理页10。</p>
<p>③物理页号与页内地址拼接即得物理地址。</p>
<p><strong>如果，计算机只有一个基址寄存器，基号可不要，多道程序切换时，操作系统修改基址寄存器内容。</strong></p>
<p><strong>可以看出，段页式虚拟存储系统由虚拟地址向主存地址的变换至少需要查两次表。</strong> </p>
<h5 id="页面替换是由操作系统实现的。"><a href="#页面替换是由操作系统实现的。" class="headerlink" title="页面替换是由操作系统实现的。"></a>页面替换是由操作系统实现的。</h5><h1 id="Chapter-4-指令系统"><a href="#Chapter-4-指令系统" class="headerlink" title="Chapter 4 指令系统"></a>Chapter 4 指令系统</h1><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><h3 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h3><p>指令中包含着操作数的地址，操作数在累加寄存器中</p>
<h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><p>地址字段放的是操作数的值</p>
<h4 id="操作数-A"><a href="#操作数-A" class="headerlink" title="操作数=A"></a>操作数=A</h4><h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>地址字段放的是操作数在内存中的地址</p>
<h4 id="EA-A"><a href="#EA-A" class="headerlink" title="EA=A"></a>EA=A</h4><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>地址字段放的是存放 操作数在内存中的地址 的内存地址</p>
<h4 id="EA-A-1"><a href="#EA-A-1" class="headerlink" title="EA=(A)"></a>EA=(A)</h4><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>操作数放在寄存器中，地址字段放的是寄存器的编号</p>
<h4 id="EA-R"><a href="#EA-R" class="headerlink" title="EA=R"></a>EA=R</h4><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p>操作数地址放在寄存器中，地址字段放的是寄存器的编号</p>
<h4 id="EA-R-1"><a href="#EA-R-1" class="headerlink" title="EA=(R)"></a>EA=(R)</h4><h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><p>偏移量即为PC</p>
<h4 id="EA-A-PC"><a href="#EA-A-PC" class="headerlink" title="EA=A+(PC)"></a>EA=A+(PC)</h4><h3 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h3><p>被引用的基址寄存器中放的是操作数在内存中的起始地址，另一个地址字段放的是偏移量</p>
<h4 id="EA-A-R"><a href="#EA-A-R" class="headerlink" title="EA=A+(R)"></a>EA=A+(R)</h4><h3 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h3><p>被引用的寄存器中放的是偏移量，另一个地址字段放的是操作数在内存中的起始地址。</p>
<h4 id="EA-A-R-1"><a href="#EA-A-R-1" class="headerlink" title="EA=A+(R)"></a>EA=A+(R)</h4><h2 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h2><h3 id="1-定长设计出多少条指令"><a href="#1-定长设计出多少条指令" class="headerlink" title="1. 定长设计出多少条指令"></a>1. 定长设计出多少条指令</h3><p><img src="https://s2.loli.net/2022/02/26/CU6a24uVJKAdxnR.png" alt="image-20220226011505296"></p>
<h3 id="2-变长设计出指令数目"><a href="#2-变长设计出指令数目" class="headerlink" title="2. 变长设计出指令数目"></a>2. 变长设计出指令数目</h3><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><p>由于操作码的长度不固定，那么2地址指令给操作码分配的地址长度n，不可能在设计2地址指令时用完。也就是说，不可能会是$2^n$条2地址指令，因为还要留出一部分的二级制数字组合，存放1地址指令的前四位和0地址指令的前4位。此时，使用$2^n-m$，其中m为2地址指令的数目，可得当前剩余的n位的2进制组合的数目。</p>
<p><img src="https://s2.loli.net/2022/02/26/5sCmxlB4R8DkHjX.png" alt="image-20220226011553541"></p>
<h3 id="3-综合题"><a href="#3-综合题" class="headerlink" title="3. 综合题"></a>3. 综合题</h3><p><img src="https://s2.loli.net/2022/02/26/X2iRSm4VuqyaQK8.png" alt="image-20220226011705292"></p>
<p><img src="https://s2.loli.net/2022/02/26/lqNuFiafBOXtb5k.png" alt="image-20220226011752472"></p>
]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>DataBase-System</title>
    <url>/2022/01/06/DataBase-System/</url>
    <content><![CDATA[<h1 id="第一章-数据库系统世界"><a href="#第一章-数据库系统世界" class="headerlink" title="第一章 数据库系统世界"></a>第一章 数据库系统世界</h1><p>数据库的能力来自于已发展了数十年的知识和技术，这些知识和技术蕴藏在名为<strong>数据库管理系统(Database Management System)</strong> 的软件中。该软件也叫DBMS，或更通俗地称为“数据库系统”。</p>
<h2 id="第二节-数据库管理系统概述"><a href="#第二节-数据库管理系统概述" class="headerlink" title="第二节 数据库管理系统概述"></a>第二节 数据库管理系统概述</h2><p>如图所示，是一个完整的DBMS结构，其中单线框表示系统构成，双线框表示内存中的数据结构，实线表示控制和数据流，虚线只表示数据流。</p>
<p>首先，在顶部有两个命令源将命令发给DBMS：</p>
<ol>
<li>通常的用户和应用程序，发出查询数据或修改数据命令。</li>
<li>数据库管理员(Administrator)，一个人或一批人，负责数据库结构或模式。</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/06/drTh2xNimCMFBlg.png" alt="image-20220106211555051"></p>
<h3 id="数据定义语言命令"><a href="#数据定义语言命令" class="headerlink" title="数据定义语言命令"></a>数据定义语言命令</h3><p><img src="https://s2.loli.net/2022/01/07/gQmTNBluVt7sIpr.png" alt="image-20220107003044094"></p>
<h3 id="查询处理概述"><a href="#查询处理概述" class="headerlink" title="查询处理概述"></a>查询处理概述</h3><p>与DBMS交互最重要的工作使沿着图所示左边的路径。</p>
<p>用户或应用程序使用数据库操作语言(DML)启动一些不影响数据库模式的操作，但是这些操作可能会影响数据库的内容，或者是从数据库中抽取数据。DML语言由两个独立的子系统处理。</p>
<h4 id="查询处理"><a href="#查询处理" class="headerlink" title="查询处理"></a>查询处理</h4><p>查询通过查询编译器(query compiler)完成语法分析和优化。</p>
<p>编译的结果使查询计划(query plan)或是由DBMS执行并获得查询结果的操作序列，它们将被送给执行引擎(execution engine)。执行引擎向资源管理器发出一系列获取小块数据的请求，典型的小块数据关系是记录或元组。</p>
<p><strong>资源管理器知道数据文件(data file, 存放关系的条件)、数据文件的格式和记录大小以及索引文件(index file)等。</strong>这些信息对于快速从数据文件中找到响应数据元素是有用的。</p>
<p>数据请求又被传送给缓冲区管理器(buffer manager)。缓冲区管理器的任务是从二级存取器(通常是磁盘，永久地保存数据)中获取数据送入主存缓冲区中。</p>
<p>一般情况下，页或“磁盘块”是缓冲区和磁盘间的传送单位。</p>
<p>为了从磁盘中得到数据，缓冲区管理器与存储器管理器进行通信。存储器管理器可能包含操作系统命令，但是最典型的是DBMS直接向磁盘控制器发命令。</p>
<h4 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h4><p>查询或其他DML操作被组织成事务(transaction)。事务是必须原子性执行的单位，执行中的事务之间还必须相互隔离。任何一个查询或修改操作本身，就可以是一个事务。另外，事务的执行必须持久(durable)，也就是说任何已完成事务的作用必须被保持，即使是事务刚刚完成系统就失败时也应如此。是五处理器被分成两个主要部分：</p>
<ol>
<li>并发控制管理器(concurrency-control manager)或调度器(scheduler)，保证事务的原子性和独立性。</li>
<li>日志(logging)和恢复管理器(recovery manager)，负责事务的持久性。</li>
</ol>
<h3 id="存储器和缓冲区管理器"><a href="#存储器和缓冲区管理器" class="headerlink" title="存储器和缓冲区管理器"></a>存储器和缓冲区管理器</h3><p>数据库数据平常存储在二级存储器中。计算机系统中的“二级存储器”一般指磁盘。可是，对数据的操作只能在主存中执行。存储器管理器( storage manager）的任务就是控制数据在磁盘上的位置存放和在磁盘与主存间的移动。</p>
<p>在一个简单数据库系统中，存储器管理器可以就是操作系统下的文件系统。可是，为了提高效率，DBMS常常直接控制磁盘上的存储，至少是在某些环境下如此。存储器管理器保持跟踪磁盘上的文件位置，根据请求从缓冲区管理器中获取含有请求文件的一个或多个磁盘块。</p>
<p><strong>缓冲区管理器负责把可用主存分割成缓冲区(buffer)</strong>，缓冲区是包含若干个页面的区域，其中可以传输磁盘块。于是，所有需要从磁盘中获取信息的DBMS组件，都或是直接或是通过执行引擎的方式，与缓冲区和缓冲区管理器交互。</p>
<h4 id="各个组件可能需要的信息种类有"><a href="#各个组件可能需要的信息种类有" class="headerlink" title="各个组件可能需要的信息种类有:"></a>各个组件可能需要的信息种类有:</h4><ol>
<li>数据：数据库本身的内容</li>
<li>元数据：描述数据库结构及其约束的数据库模式</li>
<li>日志记录：对数据库新近修改的信息，该信息支持数据库的持久性</li>
<li>统计数据：由DBMS手机和存储的关于数据特征的数据。例如，数据库大小、数据库中的值、数据库中的各种关系和其他成分。</li>
<li>索引：支持对数据库中数据有效存取的数据结构。</li>
</ol>
<h3 id="事务处理-1"><a href="#事务处理-1" class="headerlink" title="事务处理"></a>事务处理</h3><p>通常将一个或一组数据库操作组成一个事务。</p>
<p>事务的执行满足原子性，并且与其他事务的执行互相隔离。另外，DBMS还要保证事务的持久性:已完成事务的工作永不丢失。</p>
<p>事务管理器（(transaction manager）接收来自应用的事务命令( transaction command)，这些命令告诉事务管理器事务何时开始，何时结束，以及应用期望的信息（例如，某些应用可能不需要原子性)。</p>
<p>事务处理器执行如下一些任务:</p>
<ol>
<li><p><strong>记日志(logging): </strong>为了保证持久性，数据库的每一个变化都单独地记录在磁盘上。</p>
<p>日志管理器( tog manager）遵循一种设计原则，无论何时系统失败或“崩溃”，恢复管理器都能够通过检查日志中的修改记录，把数据库恢复到某个一致状态。</p>
<p>日志管理器先把日志写人缓冲区，然后与缓冲区管理器协商以确保缓冲区在合适的时间被写入磁盘（磁盘数据可以在系统崩溃后幸存下来)。</p>
</li>
<li><p><strong>并发控制(concurrency control):事务必须独立执行。</strong></p>
<p>但是在大多数系统中，很多事务都是同时在执行。因此，调度器（并发控制管理器）必须保证多个事务的单个动作是按某个次序在执行，按该次序执行的效果应该与系统一次只执行一个事务一样。</p>
<p>典型的调度器是通过在数据库的某些片断上加锁（lock)的方式工作。锁将防止两个事务用不正确的交互方式对同一数据片段存取。如图1-1所示，锁通常保存在主存的锁表(lock table)中，调度器通过阻止执行引擎对已加锁的数据库内容的存取来影响查询和其他数据库操作。</p>
</li>
<li><p><strong>消除死锁（deadlock resolution): </strong>当事务通过调度器获取锁以竞争其所需的资源时，系统可能会陷人一种状态。</p>
<p><strong>在该状态中，因为每个事务需要的资源都被另一个事务占有，所以没有一个事务能够继续执行。</strong></p>
<p>此时，事务管理器有责任调解，并删除（“回滚”或“终止”)一个或多个事务，以便其他事物可以继续执行。<br><img src="https://s2.loli.net/2022/01/07/jZcvXrLtJOzDWFI.png" alt="image-20220107012544181"></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库系统基础教程</tag>
      </tags>
  </entry>
  <entry>
    <title>DataBase</title>
    <url>/2021/12/22/DataBase/</url>
    <content><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="1-1-数据库系统概论"><a href="#1-1-数据库系统概论" class="headerlink" title="1.1 数据库系统概论"></a>1.1 数据库系统概论</h2><h3 id="1-4个基本概念"><a href="#1-4个基本概念" class="headerlink" title="1. 4个基本概念"></a>1. 4个基本概念</h3><h4 id="1-数据"><a href="#1-数据" class="headerlink" title="1. 数据"></a>1. 数据</h4><p><strong>描述事物的符号记录称为数据</strong>。数据的种类有数字、文字、图形、图像、声音、正文等。</p>
<p>数据的含义称为数据的语义，数据与其语义是不可分的。</p>
<h4 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2. 数据库"></a>2. 数据库</h4><p>数据库是<strong>长期储存</strong>在计算机内、<strong>有组织的</strong>、<strong>可共享的</strong>大量数据的集合。</p>
<h5 id="数据库的基本特征："><a href="#数据库的基本特征：" class="headerlink" title="数据库的基本特征："></a>数据库的基本特征：</h5><ul>
<li>数据按一定的数据规模组织、描述和储存</li>
<li>可为各种用户共享</li>
<li>冗余度较小</li>
<li>数据独立性较高</li>
<li>易拓展</li>
</ul>
<h4 id="3-数据库管理系统-DBMS"><a href="#3-数据库管理系统-DBMS" class="headerlink" title="3. 数据库管理系统(DBMS)"></a>3. 数据库管理系统(DBMS)</h4><ul>
<li>位于用户与操作系统之间的一层数据管理软件</li>
<li><p>是基础软件，是一个大型复杂的软件系统</p>
</li>
<li><p>可以科学地组织和存储数据、高效地获取和维护数据</p>
</li>
</ul>
<h5 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h5><ul>
<li>数据定义功能</li>
<li>数据组织、存储和管理功能</li>
<li>数据操纵功能</li>
<li>数据库的事务管理和运行管理</li>
<li>数据库的建立和维护功能</li>
<li>其他功能，如不同数据库之间的互访和互操作功能等。</li>
</ul>
<h4 id="4-数据库系统"><a href="#4-数据库系统" class="headerlink" title="4. 数据库系统"></a>4. 数据库系统</h4><p>由数据库、数据库管理系统(及其应用开发工具)、应用程序、数据库管理员四部分构成。</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>数据结构化</li>
<li>数据的共享性高，冗余度低，易扩充</li>
<li>数据独立性高</li>
<li>数据由DBMS统一管理和控制</li>
</ol>
<h3 id="2-数据模型"><a href="#2-数据模型" class="headerlink" title="2. 数据模型"></a>2. 数据模型</h3><p>数据模型通常是由数据结构、数据操作和完整性约束三部分组成。</p>
<p>数据模型是数据库系统的基础。</p>
<h4 id="三种数据模型"><a href="#三种数据模型" class="headerlink" title="三种数据模型"></a>三种数据模型</h4><p>数据库管理系统常见的数据模型有层次模型、网状模型和关系模型。</p>
<h5 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h5><p>满足下面两个条件的基本层次联系的集合：</p>
<ul>
<li>有且只有一个结点没有双亲结点，这个结点称为根节点；</li>
<li>根以外的其他结点有且只有一个双亲结点。</li>
</ul>
<h5 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h5><p>满足下面两个条件的基本层次联系的集合：</p>
<ul>
<li>允许一个以上的结点无双亲；</li>
<li>一个结点可以有多于一个的双亲。 </li>
</ul>
<h3 id="3-三级模式结构"><a href="#3-三级模式结构" class="headerlink" title="3. 三级模式结构"></a>3. 三级模式结构</h3><p>数据库系统的三级模式结构由外模式、模式和内模式组成。</p>
<h4 id="外模式"><a href="#外模式" class="headerlink" title="外模式"></a>外模式</h4><p>亦称子模式或用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图。</p>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p>亦称逻辑模式，是数据库全体数据的逻辑结构和特性的描述，是所有用户的公共数据视图。模式描述的是数据的全局逻辑结构。外模式通常是模式的子集。</p>
<h4 id="内模式"><a href="#内模式" class="headerlink" title="内模式"></a>内模式</h4><p>亦称存储模式，是数据在数据库系统内部的表示，即对数据的物理结构和存储方式的描述。</p>
<p>(内模式是数据库在物理存储方面的描述，定义所有的内部记录类型、 <strong>索引</strong> 和 <strong>文件</strong> 的组织方式，以及数据控制方面的细节。)</p>
<h4 id="两级映像"><a href="#两级映像" class="headerlink" title="两级映像"></a>两级映像</h4><p>为了能够在内部实现这三个抽象层次的联系和转换，数据库系统在这三级模式之间提供了两级映像：外模式/模式映像和模式/内模式映像，保证了数据库系统中数据较高的逻辑独立性和物理独立性。</p>
<h3 id="4-数据独立性"><a href="#4-数据独立性" class="headerlink" title="4. 数据独立性"></a>4. 数据独立性</h3><h4 id="数据的物理独立性"><a href="#数据的物理独立性" class="headerlink" title="数据的物理独立性"></a>数据的物理独立性</h4><p>当数据库的存储结构发生改变时，由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变，这就是数据与程序的物理独立性。</p>
<h4 id="数据的逻辑独立性"><a href="#数据的逻辑独立性" class="headerlink" title="数据的逻辑独立性"></a>数据的逻辑独立性</h4><p>当数据的逻辑结构即模式改变时，由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变，从而应用程序不必修改，这就是数据与程序的逻辑独立性。</p>
<h4 id="而"><a href="#而" class="headerlink" title="而"></a>而</h4><p>DBMS在三级模式之间提供的两级映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。</p>
<h3 id="5-术语"><a href="#5-术语" class="headerlink" title="5. 术语"></a>5. 术语</h3><h4 id="实体中"><a href="#实体中" class="headerlink" title="实体中"></a>实体中</h4><p>实体：客观存在并可以相互区分的事物。</p>
<p>实体型：用实体名及其属性名集合来抽象和刻画同类实体。</p>
<p> 实体集：同型实体的集合。</p>
<p> 实体之间的联系：包括实体(型)内部的联系(各属性之间的联系)和实体(型)之间的联系(不同实体集之间的联系)。有一对一、一对多、多对多。</p>
<h4 id="关系模型中"><a href="#关系模型中" class="headerlink" title="关系模型中"></a>关系模型中</h4><p>关系模型是由关系数据结构、关系操作集合和关系完整性约束三部分组成。在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。</p>
<p>关系：一个关系对应通常说的是一张表。</p>
<p>属性(关系模型中)：表中的一列即为一个属性。</p>
<p>域：属性的取值范围。</p>
<p>元组：表中的一行即为一个元组。</p>
<p>码(关系模型中)：表中的某个属性组，可以唯一确定一个元组。</p>
<p>分量：元组中的一个属性值。</p>
<p>关系模式：对关系的描述，一般表示为关系名（属性1，属性2，··· ，属性n）</p>
<h4 id="语言及其他"><a href="#语言及其他" class="headerlink" title="语言及其他"></a>语言及其他</h4><p>DDL：数据定义语言，用来定义数据库模式、外模式、内模式的语言。</p>
<p>DML：数据操纵语言，用来对数据库中的数据进行查询、插入、删除和修改的语句。</p>
<p>E-R模型是数据库的 <strong>概念模型</strong> 设计阶段的一个有力工具。</p>
<p>E-R图中包括 <strong>实体</strong> 、<strong>属性</strong> 和联系三种基本图素。</p>
<p>数据库中的文件组织方式是：顺序文件、索引文件、散列文件、倒排文件。</p>
]]></content>
      <tags>
        <tag>数据库...</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer_Network</title>
    <url>/2021/12/22/Computer-Network/</url>
    <content><![CDATA[<h1 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h1><h5 id="计算机网络涉及通信与计算机两个领域，它的发展过程是计算机与通信融合的过程。"><a href="#计算机网络涉及通信与计算机两个领域，它的发展过程是计算机与通信融合的过程。" class="headerlink" title="计算机网络涉及通信与计算机两个领域，它的发展过程是计算机与通信融合的过程。"></a>计算机网络涉及通信与计算机两个领域，它的发展过程是计算机与通信融合的过程。</h5><h2 id="1-四个阶段"><a href="#1-四个阶段" class="headerlink" title="1. 四个阶段"></a>1. 四个阶段</h2><p>计算机网络的发展经历了四个阶段：</p>
<ol>
<li>第一阶段：<strong>面向终端</strong>的计算机网络(以<strong>单个计算机为中心</strong>的<strong>远程联机系统</strong>)，特点为连接。</li>
<li>第二阶段：<strong>互不兼容</strong>的计算机网络(多台计算机通过通信线路互联的计算机网络，完成了网络体系结构与协议的研究)(协议是计算机之间沟通的基本规则)(通过网关实现SNA和DNA之间的通信，适合异种网络规模较小的场合)</li>
<li>第三阶段：<strong>标准的开放的</strong>计算机网络(具有统一的网络体系结构，遵循国际通信标准化协议的计算机网络，提出了开放系统互联参考模型与协议)</li>
<li>第四阶段：Internet发展和普及阶段(计算机网络向互联、高速、智能化方向发展，获得广泛应用)</li>
</ol>
<blockquote>
<p>在计算网络的发展过程中，最具代表性的是20世纪70年代美国国防部高级研究计划局的<strong>ARPANET(ARPA网)</strong>，采用了<strong>“存储转发-分组交换”</strong>原理，标志着计算机网络的兴起。</p>
</blockquote>
<h2 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h2><p>国外经典：计算机网络是自主计算机的互联集合。(就这个吧)</p>
<p>谢希仁：一些相互连接的、自治的计算机集合。</p>
<p>书上：计算机网络是通过通信设施(通信网络)，将地理上分散的<strong>具有自治功能的多个计算机系统(主体)互连起来(形式)</strong>，进行信息交换，实现资源共享、互操作和协同工作的系统。</p>
<h2 id="3-模型"><a href="#3-模型" class="headerlink" title="3. 模型"></a>3. 模型</h2><h3 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h3><p><strong>1984年，ISO正式颁布了一个称为“开放系统互联基本参考模型”的国际标准ISO7498，简称OSI/RM。该模型分为7个层次，有时也称OSI 7层模型</strong>。<img src="https://s2.loli.net/2021/12/22/tsJdIEiZFnVfwu7.png" alt="image-20211222154318373"></p>
<h4 id="分层及介绍"><a href="#分层及介绍" class="headerlink" title="分层及介绍"></a>分层及介绍</h4><h5 id="第一层：物理层"><a href="#第一层：物理层" class="headerlink" title="第一层：物理层"></a>第一层：<strong>物理层</strong></h5><ul>
<li>是整个OSI参考模型的最低层，提供物理连接。</li>
<li>其功能是在物理媒体上<strong>透明地传输原始比特流(进行二进制传输)</strong></li>
<li>接口标准：EIA-232、EIA/TIA RS-449等</li>
</ul>
<h5 id="第二层：数据链路层"><a href="#第二层：数据链路层" class="headerlink" title="第二层：数据链路层"></a>第二层：<strong>数据链路层</strong></h5><ul>
<li>建立在物理传输能力的基础上，以<strong>帧为单位</strong>传输数据</li>
<li>主要功能包括：成帧、差错控制、流量控制和传输管理等。主要考虑相邻节点之间的数据交换</li>
<li>可用的协议：PPP，X.25，帧中继。</li>
<li>工作在数据链路层上的交换机俗称“第二层交换机”。</li>
</ul>
<h5 id="第三层：网络层"><a href="#第三层：网络层" class="headerlink" title="第三层：网络层"></a>第三层：<strong>网络层</strong></h5><ul>
<li>通过网络连接交换运输层实体发出的数据，以<strong>分组</strong>为传送单位。</li>
<li>主要功能：选择合适的路由，使发送站的传输层传下来的分组能够正确无误地按照地址找到目的站，并交付目的站的运输层，以及实现拥塞控制、网络互连等功能。</li>
<li>协议有：IP、ARP、RARP等。</li>
</ul>
<h5 id="第四层：运输层-传输层"><a href="#第四层：运输层-传输层" class="headerlink" title="第四层：运输层(传输层)"></a>第四层：<strong>运输层(传输层)</strong></h5><ul>
<li>在底层服务的基础上，提供一种通用的传输服务。</li>
<li>运输层向上一层提供一个可靠的端到端的服务，使会话层不知道运输层以下的数据通信的细节。运输层只存在于端系统(主机)种，运输层以上的层不再考虑信息传输的问题。</li>
<li>主要功能：传输地址到网络地址的映射、多路复用与分用、传输连接的建立与释放、分段与重新组装、组块与分块。</li>
</ul>
<h5 id="第五层：会话层"><a href="#第五层：会话层" class="headerlink" title="第五层：会话层"></a>第五层：<strong>会话层</strong></h5><ul>
<li><p>不参与具体的数据传输，但管理数据，为相互合作的表示层进程之间提供一套会话设施。会话的意思是，两个应用进程之间为交换面向进程的信息而按一定规则建立起来的一个暂时联系</p>
</li>
<li><p>主要功能：会话连接到传输连接的映射、数据传送、会话连接的恢复和释放、会话管理、令牌管理和活动管理。</p>
</li>
</ul>
<h5 id="第六层：表示层"><a href="#第六层：表示层" class="headerlink" title="第六层：表示层"></a>第六层：<strong>表示层</strong></h5><ul>
<li>表示层为异种计算机通信提供了一种公共语言，完成应用层数据所需的任何转换，以便能进行互操作。</li>
<li>主要功能：数据语法转换、语法表示、表示层连接管理、数据加密和数据压缩。</li>
</ul>
<h5 id="第七层：应用层"><a href="#第七层：应用层" class="headerlink" title="第七层：应用层"></a>第七层：<strong>应用层</strong></h5><ul>
<li>应用层是OSI体系结构的最高层。这一层的协议直接为端用户服务，提供分布式处理环境。</li>
<li>应用层不仅要提供应用进程所需要的信息变换和远程操作，而且还要作为相互作用的应用进程的用户代理，来完成一些进行语义上有意义的信息的交换所必需的功能。</li>
</ul>
<h4 id="数据的封装与实际传送过程"><a href="#数据的封装与实际传送过程" class="headerlink" title="数据的封装与实际传送过程"></a>数据的封装与实际传送过程</h4><p><img src="https://s2.loli.net/2021/12/22/EzOWNewC9PLvM18.png" alt="image-20211222165453663"></p>
<blockquote>
<p>下层是通信服务的提供者，上层是通信服务的使用者。</p>
<p>N-1层使用N-2层提供的服务以及本层的功能。</p>
</blockquote>
<h3 id="TCP-IP-参考模型"><a href="#TCP-IP-参考模型" class="headerlink" title="TCP/IP 参考模型"></a>TCP/IP 参考模型</h3><p><strong>1977~1979年，ARPANET推出TCP/IP体系结构和协议(传输控制协议/网际协议为代表的协议栈)</strong>。</p>
<p><img src="https://s2.loli.net/2021/12/22/s1fY2Eqt8jU7p5x.png" alt="image-20211222170621802"></p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>协议：远程登录协议(TELNET)、文件传送协议(FTP)、简单邮件传送协议(SMTP)、域名服务器(DNS)、超文本传输协议(HTTP)等。</p>
<h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><p>协议：TCP(面向连接的可靠的协议)、UDP(无连接的、不可靠的协议)</p>
<h4 id="网际层"><a href="#网际层" class="headerlink" title="网际层"></a>网际层</h4><p>定义了正式的分组交换格式和协议，即IP协议。</p>
<h4 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h4><p>功能就类似于OSI的物理层和数据链路层，但实际上TCP/IP协议并没有真正描述这一部分。</p>
<h3 id="二者的对比"><a href="#二者的对比" class="headerlink" title="二者的对比"></a>二者的对比</h3><p><img src="https://s2.loli.net/2022/02/15/BOmxQ5HEI4ApYdJ.png" alt="image-20220215105935188"></p>
<p>事实上，OSI参考模型和TCP/IP参考模型的原理和概念都是一样的，只是在定义上和细节处理上不同而已。</p>
<p>第一、OSI参考模型精确地定义了三个主要概念：服务、协议和接口，与现代的面向对象程序设计思想非常吻合。而TCP/IP模型在这三个概念上却没有明确区分(不符合软件工程的思想)。</p>
<p>第二、OSI参考模型产生在协议发明之前，没有偏向于任何特定的协议，通用性良好。TCP/IP模型实际上是对已有协议的描述，因此不会出现协议不能匹配模型的情况(不适合非TCP/IP模型的协议栈)。</p>
<p>第三、OSI参考模型在网络层支持无连接和面向连接的通信，但在运输层仅有面向连接的通信，而TCP/IP模型认为可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式，但在运输层支持无连接和面向连接两种模式。</p>
<p>OSI参考模型缺乏市场与商业动力，结构复杂，实现周期长，运行效率低。</p>
<p><img src="https://s2.loli.net/2022/02/15/NXTg2uRIZ8W3qac.png" alt="image-20220215111501221"></p>
<h2 id="4-计算机网络的分类"><a href="#4-计算机网络的分类" class="headerlink" title="4. 计算机网络的分类"></a>4. 计算机网络的分类</h2><p>记得大致分了几类。</p>
<h3 id="按地理位置分"><a href="#按地理位置分" class="headerlink" title="按地理位置分"></a>按地理位置分</h3><ul>
<li>广域网(覆盖范围通常是几十到几千公里(一公里=一千米)的区域。)</li>
<li>城域网(覆盖范围通常是10~100km。)</li>
<li>局域网(覆盖范围通常是几十米到几千米)(最常用的是以太网)</li>
<li>个人区域网(10米左右)</li>
</ul>
<h3 id="按网络拓扑结构分"><a href="#按网络拓扑结构分" class="headerlink" title="按网络拓扑结构分"></a>按网络拓扑结构分</h3><ul>
<li>星型</li>
<li>环型</li>
<li>总线型</li>
</ul>
<h3 id="按传输介质分"><a href="#按传输介质分" class="headerlink" title="按传输介质分"></a>按传输介质分</h3><ul>
<li>有线网络</li>
<li>无线网络</li>
</ul>
<h3 id="按交换技术分"><a href="#按交换技术分" class="headerlink" title="按交换技术分"></a>按交换技术分</h3><ul>
<li><p>电路交换网络(适用于持续通信，不适于具有突发性的计算机网络)</p>
<ol>
<li><p>连接建立</p>
</li>
<li><p>数据传送</p>
</li>
<li><p>连接释放</p>
</li>
</ol>
</li>
<li><p>报文交换网络(存储-转发，处理时间长)</p>
</li>
<li><p>分组交换网络(报文较小，会增大目的地址量，降低效率)</p>
</li>
</ul>
<h2 id="5-制定网络协议的组织"><a href="#5-制定网络协议的组织" class="headerlink" title="5. 制定网络协议的组织"></a>5. 制定网络协议的组织</h2><h3 id="网络协议组成元素"><a href="#网络协议组成元素" class="headerlink" title="网络协议组成元素"></a>网络协议组成元素</h3><p>协议是一组控制数据通信的规则，明确规定所交换的数据格式和时序。</p>
<p>网络协议包括3个要素：</p>
<ul>
<li>语法：传输数据的格式</li>
<li>语义：规定了要完成的功能</li>
<li>定时：规定了执行各种操作的条件、时序关系等。</li>
</ul>
<h3 id="网络协议举例"><a href="#网络协议举例" class="headerlink" title="网络协议举例"></a>网络协议举例</h3><p>记几个常见的名称</p>
<p><img src="https://s2.loli.net/2021/12/22/BX6n83tPNiIUGph.png" alt="image-20211222171450997"></p>
<p>Internet工程特别任务组（IRTF）中的标准通常以<strong>RFC(请求评注,Request for Comments)</strong>文档的形式公布.</p>
<h2 id="6-服务质量"><a href="#6-服务质量" class="headerlink" title="6. 服务质量"></a>6. 服务质量</h2><p><img src="https://s2.loli.net/2021/12/22/LE5Hq69c2ROuXJs.png" alt="image-20211222172217157"></p>
<h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><h2 id="7-相关"><a href="#7-相关" class="headerlink" title="7. 相关"></a>7. 相关</h2><ol>
<li><p><strong>面向终端的远程联机系统</strong>是计算机和通信相结合的前驱。以单个<strong>计算机</strong>为中心。</p>
</li>
<li><p>在20世纪70年代，美国的<strong>ARPANET</strong>(具有代表性的，美国国防部)采用了“存储转发-分组交换”的原理，采用<strong>TCP/IP</strong>协议，成为了事实上的国际标准。(Advanced Research Project Agency)</p>
</li>
<li><strong>1984年</strong>，ISO颁布的OSI/RM(Open Systems Interconnection-Reference Model)参考模型。</li>
<li>计算机网络的分类(按照哪个分为几类)</li>
</ol>
<p><img src="https://s2.loli.net/2022/02/21/rF2twM3dSQNCilH.png" alt="image-20220221162306391"></p>
<p><img src="https://s2.loli.net/2022/02/21/AOgc5Nr278dKX3k.png" alt="image-20220221163946294"></p>
<h1 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h1><p><strong>物理层位于OSI参考模型的最低层，直接面向实际承担数据传输的物理介质</strong>(即信道)。它的功能是激活、维持和释放数据链路层实体之间进行比特传输的物理连接(就是，<strong>传输比特流</strong>)。</p>
<h2 id="1-通信速率和信道容量"><a href="#1-通信速率和信道容量" class="headerlink" title="1. 通信速率和信道容量"></a>1. 通信速率和信道容量</h2><h3 id="1-传输速率"><a href="#1-传输速率" class="headerlink" title="1. 传输速率"></a>1. 传输速率</h3><p>数据传输速率是指每秒能传输的二进制信息位数，单位为“位/秒”，记作“b/s”。表示为：</p>
<script type="math/tex; mode=display">
S=\frac{1}{T} \times log_2M(b/s)</script><h3 id="2-信号传输速率（码元速率、调制速率、波特率"><a href="#2-信号传输速率（码元速率、调制速率、波特率" class="headerlink" title="2. 信号传输速率（码元速率、调制速率、波特率)"></a>2. 信号传输速率（码元速率、调制速率、波特率)</h3><p>一个数字脉冲也称为一个码元，M为一个码元所取的有效离散值个数，也成为调制电平数，M一般取2的整数次方值。若一个码元能取M种离散值，则该码元便能携带 $log_2 M$位二进制信息。</p>
<p>表示单位时间内通过信道传输的码元个数，也就是<strong>信号经调制后的传输速率(每秒信号变几次)</strong>，单位为baud(波特)。若信号码元的宽度为T(信号的持续时间s)，则码元速率定义为</p>
<script type="math/tex; mode=display">
B=\frac{1}{T} (baud)</script><p><strong>调制速率和数据传输速率</strong>的对应关系为：</p>
<script type="math/tex; mode=display">
S=B log_2 M(b/s)\quad或\quad B = \frac{S}{log_2 M} (baud)</script><h3 id="3-信道容量"><a href="#3-信道容量" class="headerlink" title="3. 信道容量"></a>3. 信道容量</h3><h4 id="奈奎斯特公式-重要！！！"><a href="#奈奎斯特公式-重要！！！" class="headerlink" title="奈奎斯特公式(重要！！！)"></a>奈奎斯特公式(重要！！！)</h4><script type="math/tex; mode=display">
码元速率的极限值和信道带宽的关系： \\B=2W\quad(baud)\\（W是信道带宽，也称为频率范围，即信道上下限频率的差值，单位是Hz）。
\\表示信道数据传输能力的奈奎斯特公式为：\\C=2W log_2 M\quad(b/s) \\M为携带数据的码元可能取的离散值个数，C为该信道最大的传输速率。</script><h4 id="香农公式-重要！！！"><a href="#香农公式-重要！！！" class="headerlink" title="香农公式(重要！！！)"></a>香农公式(重要！！！)</h4><script type="math/tex; mode=display">
计算信道容量的香农公式：\\C=W log_2(1+\frac{S}{N})\quad(b/s)
\\S为信号功率，N为噪声功率，S/N为信噪比。
\\由于实际使用的信道的信噪比都要足够大，故常表示成10lg(\frac{S}{N})，并以分贝为单位来计量。如30dB对应的是S/N的1000倍。\\(随机热噪声与温度有关，随温度升高，噪声增大)</script><p>误码率</p>
<script type="math/tex; mode=display">
P_e = \frac{N_e}{N}</script><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="https://s2.loli.net/2021/12/27/6YMz8QbIyhuJvEw.png" alt="image-20211227180309974"></p>
<p><img src="https://s2.loli.net/2021/12/27/HKAYq5XcE1tiu2r.png" alt="image-20211227180332179"></p>
<p><img src="https://s2.loli.net/2021/12/27/PYhdymXRw92MsG3.png" alt="image-20211227180401257"></p>
<h2 id="2-传输介质"><a href="#2-传输介质" class="headerlink" title="2.传输介质"></a>2.传输介质</h2><h3 id="1-特殊的方式"><a href="#1-特殊的方式" class="headerlink" title="1. 特殊的方式"></a>1. 特殊的方式</h3><p>烽火、空气、公路</p>
<h3 id="2-有线的方式"><a href="#2-有线的方式" class="headerlink" title="2. 有线的方式"></a>2. 有线的方式</h3><h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h4><ul>
<li>屏蔽（周围干扰较大/信号较弱的场所）</li>
<li>非屏蔽（通常是100米左右，在楼层之内）</li>
</ul>
<h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h4><ul>
<li>细缆（10Mb/s，185米，层间）</li>
<li>粗缆（10Mb/s，500米，楼间）</li>
</ul>
<h4 id="光缆"><a href="#光缆" class="headerlink" title="光缆"></a>光缆</h4><ul>
<li>多模（550米/1000M/模块成本低）</li>
<li>单模（1000米/1000M/模块成本高）单模光纤传输频带宽、容量大，传输距离长，需要用激光源</li>
</ul>
<p>单模光纤的性能要优于多模光纤，它的传输损耗较小。</p>
<p>光纤纤芯质地脆，机械强度低。</p>
<h3 id="3-无线的方式"><a href="#3-无线的方式" class="headerlink" title="3. 无线的方式"></a>3. 无线的方式</h3><ul>
<li>无线局域网（2.4GHz/5GHz）</li>
<li>微波天线与卫星通信</li>
<li>红外线通信</li>
<li>激光通信（OPALS）</li>
</ul>
<h3 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4. 优缺点"></a>4. 优缺点</h3><p>布设的便利性/通信的抗干扰能力</p>
<h2 id="3-编码与识别"><a href="#3-编码与识别" class="headerlink" title="3. 编码与识别"></a>3. 编码与识别</h2><h3 id="1-基本调制技术"><a href="#1-基本调制技术" class="headerlink" title="1. 基本调制技术"></a>1. 基本调制技术</h3><p>数字数据调制技术在发送端将数字信号转换成模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。（数字信号加载到载波信号）</p>
<h4 id="调制方法-最基本的二元调制"><a href="#调制方法-最基本的二元调制" class="headerlink" title="调制方法(最基本的二元调制)"></a>调制方法(最基本的二元调制)</h4><ol>
<li>振幅调制</li>
<li>频率调制</li>
<li>相位调制</li>
<li>多进制调制</li>
</ol>
<h3 id="2-脉冲编码调制技术-PCM"><a href="#2-脉冲编码调制技术-PCM" class="headerlink" title="2. 脉冲编码调制技术(PCM)"></a>2. 脉冲编码调制技术(PCM)</h3><p><strong>PCM基于奈奎斯特采样定理：如果在规定的时间间隔内，以有效信号f(t)最高频率的2倍或2倍以上的速率对该信号进行采样，则这些采样值包含了无混叠而又便于分离的全部原始信息。</strong></p>
<h3 id="3-数字信号的编码技术"><a href="#3-数字信号的编码技术" class="headerlink" title="3. 数字信号的编码技术"></a>3. 数字信号的编码技术</h3><h4 id="1-不归零编码"><a href="#1-不归零编码" class="headerlink" title="1. 不归零编码"></a>1. 不归零编码</h4><h4 id="2-曼彻斯特码"><a href="#2-曼彻斯特码" class="headerlink" title="2. 曼彻斯特码"></a>2. 曼彻斯特码</h4><h5 id="以太网是使用曼彻斯特编码的。"><a href="#以太网是使用曼彻斯特编码的。" class="headerlink" title="以太网是使用曼彻斯特编码的。"></a>以太网是使用曼彻斯特编码的。</h5><h5 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h5><p>一种双相码</p>
<p><strong>用高电平到低电平的转换边表示1，用低电平到高电平的转换边表示0。(高到低为1；低到高为0)</strong></p>
<h4 id="3-差分曼彻斯特码"><a href="#3-差分曼彻斯特码" class="headerlink" title="3. 差分曼彻斯特码"></a>3. 差分曼彻斯特码</h4><h5 id="用在令牌环网中"><a href="#用在令牌环网中" class="headerlink" title="用在令牌环网中"></a>用在令牌环网中</h5><h5 id="编码格式-1"><a href="#编码格式-1" class="headerlink" title="编码格式"></a>编码格式</h5><p>一种双相码</p>
<p>数据表示为在每一位开始处是否有电平转换：<strong>有电平转换表示0，无电平转换表示1(进来啥还是啥)，在信号中间强制转换(翻转)。(1不变，0变化，中间强制变化(以避免出现连续的高电平、低电平))</strong></p>
<p><img src="https://s2.loli.net/2021/12/27/sNz9wp76Ourfqng.png" alt="image-20211227173107104"></p>
<p>差分曼彻斯特编码比曼彻斯特编码的变化要小，因此更适合于传输高速的信息。</p>
<h4 id="4-其他编码"><a href="#4-其他编码" class="headerlink" title="4. 其他编码"></a>4. 其他编码</h4><ul>
<li><p>百兆双绞线的4B/5B</p>
</li>
<li><p>光纤的8B/10B</p>
</li>
</ul>
<h2 id="4-信道复用技术"><a href="#4-信道复用技术" class="headerlink" title="4. 信道复用技术"></a>4. 信道复用技术</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>为了有效地利用数据传输系统，人们希望通过同时携带多个信号来高效率地使用传输介质，这称为多路复用(MUX)。多路复用连接器连接许多低速线路，并将它们各自所需的传输容量组合在一起后，在一条速度较高的线路上传输。</p>
<h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><ul>
<li>频分多路复用</li>
<li>时分多路复用</li>
<li>波分多路复用</li>
<li>码分多路复用</li>
</ul>
<h2 id="5-相关"><a href="#5-相关" class="headerlink" title="5. 相关"></a>5. 相关</h2><ol>
<li>DTE：Data Terminal Equipment，数据终端设备</li>
<li>DCE：Data Communication Equipment，数据通信设备。</li>
<li>一个完整的数据通信系统一般可以划分为三大部分，即<strong>源系统(或发送方)、传输系统和目的系统(或接收方)</strong>。</li>
<li>中继器将接收到的信号<strong>放大整形</strong>，以此来克服数字信号的衰减和畸变。</li>
<li>通信有两种基本方式，即<strong>串行和并行</strong>。</li>
<li>串行数据通信的方向性结构有3种，即<strong>单工(只有在一个方向的通信而没有反方向的交互)、半双工和全双工</strong>。</li>
<li>如果安装正确，在非常短的距离（通常是100米左右）上，5类UTP的传输速率至少可以达到<strong>100Mbps</strong>.</li>
<li>屏蔽双绞线的每一对线都有一个铝箔屏蔽层，四对线合在一起还有一个<strong>公共的金属编织屏蔽层</strong>。</li>
<li>一般粗缆最多可以通过<strong>4个中继器</strong>使得网络范围达到2500m。</li>
<li>细缆每段最长<strong>185m</strong>。</li>
<li>无线传输是指在自由空间(地球上大气的性质也类似于自由空间)中进行电磁波的传输，其传输方法包括：微波传输、无线电传输、红外传输和<strong>激光传输</strong>。</li>
<li>卫星通信是一种特殊的<strong>微波</strong>通信。</li>
<li>无线电频率分为<strong>非管制和管制</strong>的两部分。</li>
<li>信号数字化的转换过程包括：<strong>采样、量化和编码</strong>三个步骤。</li>
<li><strong>信道容量</strong>表示一个信道传输数据的能力，即<strong>单位时间内可能传送的最大比特数，单位为bps</strong>。</li>
<li><img src="https://s2.loli.net/2022/02/21/hSWHc2puTFnC6tX.png" alt="image-20220221172417686"></li>
</ol>
<h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h1><h5 id="相邻主机-同一个广播域内的主机-如一个教室-之间的通信"><a href="#相邻主机-同一个广播域内的主机-如一个教室-之间的通信" class="headerlink" title="相邻主机(同一个广播域内的主机(如一个教室))之间的通信"></a>相邻主机(同一个广播域内的主机(如一个教室))之间的通信</h5><p>数据链路层的作用是加强物理层传输原始位流的功能，并将物理层提供的可能出错的物理连接改造成逻辑上无差错的数据链路。</p>
<p><strong>数据链路层的主要功能是向网络层提供透明的和可靠的数据传输服务。</strong></p>
<h2 id="0-数据链路层的功能"><a href="#0-数据链路层的功能" class="headerlink" title="0.数据链路层的功能"></a>0.数据链路层的功能</h2><h3 id="1-链路管理"><a href="#1-链路管理" class="headerlink" title="1. 链路管理"></a>1. 链路管理</h3><p>当网络中的两个结点要进行通信时，发送方必须确知接收方是处在准备接受数据的状态。为此，通信双方必须要先交换一些必要的信息，建立链路连接，同时在传输数据时要维持数据链路，在传输完毕是要释放数据链路。</p>
<p>数据链路的建立、维持和释放称为<strong>链路管理</strong>，它主要用于面向连接的服务。</p>
<h3 id="2-帧同步"><a href="#2-帧同步" class="headerlink" title="2. 帧同步"></a>2. 帧同步</h3><p>帧同步，即帧的组织结构应当使接收方能从接收到的位流中准确地识别一个帧的开始和结束。</p>
<h3 id="3-流量控制"><a href="#3-流量控制" class="headerlink" title="3. 流量控制"></a>3. 流量控制</h3><p>为了防止接收方缓存能力不足而造成数据的丢失，发送方发送数据的速率必须让接收方来控制。</p>
<p>流量控制实际上就是，限制发送方的数据流量，使其发送速率不致超过接收方的接受能力。</p>
<h3 id="4-差错控制"><a href="#4-差错控制" class="headerlink" title="4. 差错控制"></a>4. 差错控制</h3><p>用以使发送方确定接收方是否正确地接收到了由它发送的数据的方法称为差错控制。</p>
<p>通信系统必须具备发现(即检测)差错的能力，并采取措施加以纠正，使差错控制在尽可能小的范围内。</p>
<p>帧传输中出现的错误包括帧错和位错。</p>
<p>位错是指帧在传输过程中某些位出现差错，通常采用奇偶校验、循环冗余校验等方法发现位错。</p>
<p>对于帧错主要采用自动重传请求方式来重传出错的帧。</p>
<h3 id="5-透明传输"><a href="#5-透明传输" class="headerlink" title="5. 透明传输"></a>5. 透明传输</h3><p>透明传输是指因数据组合的随机性，它可能和某个控制信息完全一样而被接收方误解，必须有措施使接收方不至于将这样的数据当作某种控制信息。</p>
<h3 id="6-寻址"><a href="#6-寻址" class="headerlink" title="6. 寻址"></a>6. 寻址</h3><p>必须保证每一帧能正确地送达目的地，同时又要使接收方知道该帧是由哪个机器发送的。</p>
<h2 id="1-差错检测"><a href="#1-差错检测" class="headerlink" title="1. 差错检测"></a>1. 差错检测</h2><h3 id="1-奇偶校验码"><a href="#1-奇偶校验码" class="headerlink" title="1. 奇偶校验码"></a>1. 奇偶校验码</h3><p>常在计算机内部使用，因为干扰发生的概率小</p>
<ul>
<li><p>水平/垂直校验码：检错码</p>
</li>
<li><p>水平垂直校验码：纠错码(成本较高)</p>
</li>
</ul>
<h3 id="2-循环冗余码-CRC必考"><a href="#2-循环冗余码-CRC必考" class="headerlink" title="2. 循环冗余码(CRC必考)"></a>2. 循环冗余码(CRC必考)</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>任何一个由二进制数位串组成的代码，都可以唯一地与一个只含有0和1两个系数的多项式建立一一对应的关系。例如，代码1010111对应的多项式是 $X^6 + X^4+ X^2+X^1+1$。</p>
<h5 id="各多项式含义"><a href="#各多项式含义" class="headerlink" title="各多项式含义"></a>各多项式含义</h5><p>在发送方编码和接收方校验时，都可以利用事先约定的多项式$G(X)$来得到CRC码。</p>
<p>k位待发送信息位对应于一个k-1次多项式$K(X)$</p>
<p>r位冗余位对应于一个r-1次多项式$R(X)$</p>
<p>由k位信息位后面加上r次冗余位组成的$n=k+r$位码字则对应于一个$n-1$次多项式$T(X)=X^rK(X)+R(X)$。</p>
<p>由信息位产生冗余位的编码过程，就是已知$K(X)$求$R(X)$的过程。先找到一个特定的r次多项式$G(X)$，其最高次项$X^r$的系数恒为1，然后用$X^r \cdot K(X) $除以$G(X)$，得到的余式就是$R(X)$。</p>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p>仍以$K(X)=X^6+X^4+X^3+1(信息位为1011001)(待发送信息)$为例，若$G(X)=X^4+X^3+1(事先约定)(11001)$，则$r=4$，$X^4K(X)=X^{10}+X^8+X^7+X^4(10110010000)$.由模2除法求余式$R(X)$的过程如图所示。</p>
<p><img src="https://s2.loli.net/2022/01/10/Co9XIdpf1bv58Mq.png" alt="image-20220110151925039"></p>
<p>最后得到的余数是1010，就是冗余位，对应于$R(X)=X^3+X$。由于$R(X)$是$X^rK(X)$除以$G(X)$的余式，那么必然满足：</p>
<script type="math/tex; mode=display">
X^rK(X)=G(X)(除式)Q(X)(商式)+R(X)(余式)</script><p>式中，$Q(X)$为商式，根据模2运算法则，$R(X)+R(X)=0$，所以可将上式改记为</p>
<script type="math/tex; mode=display">
\frac{X^rK(X)+R(X)}{G(X)}=Q(X)</script><p>即，$\frac{T(X)}{G(X)}=Q(X)$</p>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p><strong>由此可见，信道上发送的码字多项式$T(X)=X^rK(X)+R(X)$，若传输过程无错，则接收方接收到的码字也对应于此多项式，也就是说接收到的码字多项式能被$G(X)$整除。</strong></p>
<p><strong>因此，接收方的校验过程就是将接收到的码字多项式除以$G(X)$(事先约定)的过程，若余式为0，则认为传输无差错，若余式不为0，则传输有差错。</strong></p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><img src="https://s2.loli.net/2022/01/10/jLYbRSkWFs79EzH.png" alt="image-20220110162900726"></p>
<p><img src="https://s2.loli.net/2022/01/10/4YrCuwzTZGfWOAj.png" alt="image-20220110162950640"></p>
<p><img src="https://s2.loli.net/2022/01/10/wm59PKXcYJgb1I4.png" alt="image-20220110165636498"></p>
<p>在第二个框那里增加0，是错的。</p>
<h2 id="2-帧同步-1"><a href="#2-帧同步-1" class="headerlink" title="2. 帧同步"></a>2. 帧同步</h2><p><img src="https://s2.loli.net/2022/02/16/hm2Ojuwlz8T6VeJ.png" alt="image-20220216185539609"></p>
<h3 id="0比特填充技术"><a href="#0比特填充技术" class="headerlink" title="0比特填充技术(*)"></a>0比特填充技术(*)</h3><h4 id="标志字段-F"><a href="#标志字段-F" class="headerlink" title="标志字段 F"></a>标志字段 F</h4><p>物理层向数据链路层交付的是所收到的一连串的位流，在一个帧的开头和结尾各放入一个字节的特殊标记： “01111110” 作为一个帧的边界，这个标记称为标志字段F(Flag)，共8位。</p>
<p>在接收方，只要找到两个标志字段，那么在这两个标志字段之间的位流就是一个帧的信息。</p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>如果在两个标志字段之间的位流中，出现与标志字段F相同的比特模式时，就会被误认为是帧的边界，从而破坏帧的同步。</p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>为避免这种情况，采用<strong>0比特填充技术</strong>，即发送方在比特流中一旦发现5个连续的1，就在其后填入一个0，从而保证在传输的比特流中不会出现F标志。</p>
<blockquote>
<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><p>在接收一个帧时，在F字段确定的帧的边界之间，若比特流有5个连续1，则将这5个连续1后的一个0删除，将比特流还原。这样，不管出现什么样的比特组合，都不会引起对帧边界的错误判断。</p>
<p><strong>具有这种特点的传输称为透明传输。</strong></p>
</blockquote>
<h2 id="3-停止等待协议"><a href="#3-停止等待协议" class="headerlink" title="3. 停止等待协议"></a>3. 停止等待协议</h2><h3 id="1-差错控制与流量控制"><a href="#1-差错控制与流量控制" class="headerlink" title="1. 差错控制与流量控制"></a>1. 差错控制与流量控制</h3><p><strong>对数据传输进行差错控制和流量控制是数据链路层的关键功能。</strong></p>
<p>目前，进行差错控制和流量控制的基本策略是<strong>反馈机制</strong>，即发送方通过接收方反馈回来的能否继续接受或是否正确收到帧等信息来进行下一步的操作。</p>
<h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><p><strong>差错控制的基本思想是：差错检测、接受确认和出错重传。</strong></p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p><strong>流量控制的基本思想是：使接收方能够控制发送方发送帧的速率。</strong></p>
<p>由接收方控制发送方的速度，以避免发送方发送太快而接收方来不及接受的问题。</p>
<h3 id="2-停止等待协议"><a href="#2-停止等待协议" class="headerlink" title="2. 停止等待协议"></a>2. 停止等待协议</h3><p>每发送一帧就停下来等待确认，若收到确认就发送下一帧。</p>
<h3 id="3-实用的停止等待协议"><a href="#3-实用的停止等待协议" class="headerlink" title="3. 实用的停止等待协议"></a>3. 实用的停止等待协议</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>每发送一帧就停下来等待确认，</p>
<p>若收到确认就发送下一帧。</p>
<p>若在规定的时间内，没有收到确认帧，就重新发送这一帧。</p>
<h5 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h5><p>此时确认帧不需要序号，因为只发送一帧数据，确认无需排序。</p>
<p><strong>若收到重复分组，就丢弃，但同时也要发送确认帧。</strong></p>
<h3 id="4-效率的计算"><a href="#4-效率的计算" class="headerlink" title="4. 效率的计算"></a>4. 效率的计算</h3><ol>
<li><p>发送时延 = 帧长 / 发送速度</p>
</li>
<li><p>传播时延 = 距离 / 电磁波速度</p>
</li>
<li><p>总时延 = 发送时延 + 传播时延 + 确认发送时延 + 确认传播时延</p>
<p> ​             = 发送时延 + 2 * 传播时延    </p>
<p> (因为确认帧的帧长比较短，其发送时延很短，可以忽略不计；但距离和电磁波速度是一样的，故而是2倍。)</p>
</li>
<li><p>效率 = 发送时延 / 总时延</p>
</li>
<li><p>所以提高效率，可以通过增加发送时延。</p>
</li>
</ol>
<h2 id="4-连续ARQ协议"><a href="#4-连续ARQ协议" class="headerlink" title="4. 连续ARQ协议"></a>4. 连续ARQ协议</h2><p>自动请求重发</p>
<p>由于减少了等待时间，整个通信的吞吐量提高。</p>
<p>发送维持一个发送窗口，接收方采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确地收到了。</p>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>每发送N帧就停下来等待确认；接收方按序接收。</p>
<p>一次发送N帧，未收到回复就自动重发。</p>
<p>在连续ARQ协议中，接收方只允许按序接收，当发送方发现未收到前面已发送出去的帧的确认信息，计时器已经超时或收到了否定应答信息，则不得不重发后N帧。因此，又叫后退N帧的滑动窗口协议。</p>
<h3 id="发送窗口和接收窗口-滑动窗口"><a href="#发送窗口和接收窗口-滑动窗口" class="headerlink" title="发送窗口和接收窗口(滑动窗口)"></a>发送窗口和接收窗口(滑动窗口)</h3><h4 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h4><p>发出去还未收到确认的帧</p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>若采用n位二进制编码来给出帧编号，则发送窗口最大只能是$2^n - 1$，即任何时候最多允许有$2^n - 1$个帧未被确认。例如，当n=3时，发送窗口长度为7。</p>
<p>原因1：如果窗口长度为8，则每次发送都是0~7，那么接收窗口无法确认是新8帧还是旧8帧，而长度为7时，第一次发送0-6，第二次发送7-5，可以确认。</p>
<p>原因2：发送窗口为12345670，收到确认帧1，无法确定是重发1，还是发送下一个1。</p>
<h4 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h4><p>准备接受的帧</p>
<h3 id="确认的序号"><a href="#确认的序号" class="headerlink" title="确认的序号"></a>确认的序号</h3><ul>
<li>确认收到</li>
<li>确认没有收到</li>
<li>确认下一帧应该接收(收到后，回复准备接收n+1帧，减少回复次数，提高效率)</li>
</ul>
<h3 id="确认的方式"><a href="#确认的方式" class="headerlink" title="确认的方式"></a>确认的方式</h3><ul>
<li>单独确认帧</li>
<li>捎带确认帧(将确认帧放在反方向的数据帧里)</li>
</ul>
<p><strong>差错控制的基本思想是：差错检测、接受确认和出错重传。</strong></p>
<h2 id="5-选择重传ARQ协议"><a href="#5-选择重传ARQ协议" class="headerlink" title="5. 选择重传ARQ协议"></a>5. 选择重传ARQ协议</h2><p>在连续ARQ协议中，接收窗口的长度为1，浪费了线路带宽。</p>
<h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>每发送N帧，就停下等待确认，接收方不按序接收。</p>
<h3 id="最大发送窗口"><a href="#最大发送窗口" class="headerlink" title="最大发送窗口"></a>最大发送窗口</h3><p><img src="https://s2.loli.net/2022/02/16/cUipqTFg8Db95EC.png" alt="image-20220216183618667"></p>
<p><img src="https://s2.loli.net/2022/02/16/Eebqt1KNcXgBf5a.png" alt="image-20220216184018869"></p>
<p><strong>所以，采用该协议时，窗口长度的最大值应为帧编号的一半。</strong></p>
<h2 id="6-三种协议"><a href="#6-三种协议" class="headerlink" title="6. 三种协议(*)"></a>6. 三种协议(*)</h2><h3 id="都基于滑动窗口协议"><a href="#都基于滑动窗口协议" class="headerlink" title="都基于滑动窗口协议"></a>都基于滑动窗口协议</h3><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><img src="https://s2.loli.net/2022/02/16/WyEBZozvifrDqQK.png" alt="image-20220216184051632"></p>
<p><img src="https://s2.loli.net/2022/02/16/KUDP8zqCTJYsA7E.png" alt="image-20220216185024281"></p>
<h2 id="7-信道使用权分配"><a href="#7-信道使用权分配" class="headerlink" title="7. 信道使用权分配"></a>7. 信道使用权分配</h2><h3 id="频分"><a href="#频分" class="headerlink" title="频分"></a>频分</h3><p>由于网络通信存在突发性，故而在网络中不常用</p>
<h4 id="电话线路"><a href="#电话线路" class="headerlink" title="电话线路"></a>电话线路</h4><p>电话线路的ADSL</p>
<p>电话：4000Hz以下</p>
<p>上网：4000Hz以上</p>
<h3 id="时分"><a href="#时分" class="headerlink" title="时分"></a>时分</h3><h4 id="同步时分"><a href="#同步时分" class="headerlink" title="同步时分"></a>同步时分</h4><p>不适合网络传输的突发性，存在带宽的浪费</p>
<h4 id="异步-统计-时分"><a href="#异步-统计-时分" class="headerlink" title="异步(统计)时分"></a>异步(统计)时分</h4><h5 id="令牌式"><a href="#令牌式" class="headerlink" title="令牌式"></a>令牌式</h5><p>对带宽有一定的浪费</p>
<h5 id="竞争式"><a href="#竞争式" class="headerlink" title="竞争式"></a>竞争式</h5><p>浪费较小，且简单</p>
<h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><p>负载重时，使用令牌式；</p>
<p>负载轻时，使用竞争式。</p>
<h4 id="载波侦听-冲突检测-CSMA-CD"><a href="#载波侦听-冲突检测-CSMA-CD" class="headerlink" title="载波侦听/冲突检测(CSMA/CD)"></a>载波侦听/冲突检测(CSMA/CD)</h4><p>以太网采用的介质访问控制方法就是后来成为IEEE802.3标准的载波侦听多路访问/冲突检测(CSMA/CD)技术。</p>
<p>先多路访问，后侦听同时冲突检测。</p>
<h5 id="1-冲突检测"><a href="#1-冲突检测" class="headerlink" title="1. 冲突检测"></a>1. 冲突检测</h5><h6 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h6><h6 id="1968年夏威夷大学无线广播网"><a href="#1968年夏威夷大学无线广播网" class="headerlink" title="1968年夏威夷大学无线广播网"></a>1968年夏威夷大学无线广播网</h6><p>是1968年由美国夏威夷大学开发的一个以<strong>无线广播</strong>方式工作的分组交换网。</p>
<p>想发就发，边发边听</p>
<p>网上的各站点在任何时刻只要需要，就可以自由地发送信息帧；信息帧发送完毕，然后侦听一段时间，如果在信息帧来回传播的最大延迟时间(两倍于两个间隔最大的站点之间传递信息的时间)再加上一小段固定时间内收到了确认，则说明传输成功；否则，传输站点重发信息帧。若多次重发都失败，则放弃发送该帧。</p>
<p>信道利用率最大只有18%</p>
<h6 id="分槽ALOHA"><a href="#分槽ALOHA" class="headerlink" title="分槽ALOHA"></a>分槽ALOHA</h6><p>整点时刻想发就发，边发边听</p>
<p>分槽ALOHA协议将时间划分为等长的时槽，每个时槽的长度正好等于一个定长分组的传输时间，各站只能在时槽的起始时刻开始发送信息，因此那些冲突的帧完全重叠。</p>
<p>信道利用率最大37%。</p>
<h6 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h6><p><img src="https://s2.loli.net/2022/02/17/KipvxbmWqLCrXRh.png" alt="image-20220217135745945"></p>
<h4 id="2-载波侦听"><a href="#2-载波侦听" class="headerlink" title="2. 载波侦听"></a>2. 载波侦听</h4><p>又称为“先听后说”。</p>
<p>当一个站点要发送数据时，</p>
<h6 id="1坚持CSMA协议"><a href="#1坚持CSMA协议" class="headerlink" title="1坚持CSMA协议"></a>1坚持CSMA协议</h6><p>首先侦听信道，如果信道空闲就立即发送数据。</p>
<p>当侦听到信道忙时，继续坚持侦听信道，当侦听到信道空闲时，发送帧的概率为1，即立即发送数据。</p>
<p>可以充分利用信道，但冲突的可能性也可能会增大</p>
<h6 id="p坚持CSMA协议"><a href="#p坚持CSMA协议" class="headerlink" title="p坚持CSMA协议"></a>p坚持CSMA协议</h6><p>首先侦听信道，当侦听到信道忙时，仍然坚持听下去，直到信道空闲为止。</p>
<p>当听到信道空闲时，以概率P发送数据，并在概率1-P延迟时间$\tau$(端到端的传输时延)后再重新侦听信道。</p>
<h6 id="非坚持CSMA协议"><a href="#非坚持CSMA协议" class="headerlink" title="非坚持CSMA协议"></a>非坚持CSMA协议</h6><p>首先侦听信道，如果信道空闲就立即发送数据。</p>
<p>一旦侦听到信道忙就不再坚持听下去，延迟一段随机时间后再重新侦听。</p>
<ul>
<li>1-持续</li>
<li>p-持续</li>
<li>非持续</li>
</ul>
<h5 id="3-CSMA-CD协议"><a href="#3-CSMA-CD协议" class="headerlink" title="3. CSMA/CD协议"></a>3. CSMA/CD协议</h5><p>“边听边说”</p>
<p>即为了能及时发现冲突，采取边发送边侦听的方式，一旦侦听到冲突，冲突双方就立即停止发送。</p>
<p>先听后发，边听边发，冲突停发，随即重发。</p>
<p>也分为类似以上三种。</p>
<h5 id="4-对比"><a href="#4-对比" class="headerlink" title="4. 对比"></a>4. 对比</h5><p><img src="https://s2.loli.net/2022/02/17/3tKkGr2JZsD4Ng7.png" alt="image-20220217140847613"></p>
<ul>
<li>CSMA/CD协议吞吐量的最大值最大。</li>
<li>当G在相当大的范围内变化时，CSMA/CD协议的吞吐量S都比较接近其最大值，这说明该协议相较而言更稳定</li>
<li>在轻负载时，各种协议的性能都差不多</li>
</ul>
<h2 id="8-寻址"><a href="#8-寻址" class="headerlink" title="8. 寻址"></a>8. 寻址</h2><h3 id="1-地址长度的确定-地址空间和传输效率"><a href="#1-地址长度的确定-地址空间和传输效率" class="headerlink" title="1. 地址长度的确定(地址空间和传输效率)"></a>1. 地址长度的确定(地址空间和传输效率)</h3><h3 id="2-以太网地址"><a href="#2-以太网地址" class="headerlink" title="2. 以太网地址"></a>2. 以太网地址</h3><p>如果该帧的目的地址和一个接受站点的LAN地址相配，则这个结点将从链路层帧中提取出网络层数据报，并将数据报传递给上层协议栈。</p>
<p>LAN地址通常也称为物理地址、以太网地址或介质访问控制(MAC)地址</p>
<h4 id="长度为48位-6字节"><a href="#长度为48位-6字节" class="headerlink" title="长度为48位/6字节(*)"></a>长度为48位/6字节(*)</h4><p>这6个字节的地址，通常用十六位进制数表示。</p>
<p>是永久且唯一的。</p>
<p>(硬件地址-MAC地址-网卡地址-物理地址)</p>
<h2 id="9-面向无连接和不可靠的协议"><a href="#9-面向无连接和不可靠的协议" class="headerlink" title="9. 面向无连接和不可靠的协议"></a>9. 面向无连接和不可靠的协议</h2><p>融合了帧同步、差错检测、信道使用权分配、寻址</p>
<h3 id="IEEE802-3"><a href="#IEEE802-3" class="headerlink" title="IEEE802.3"></a>IEEE802.3</h3><p>发送完，就不再进行冲突检测</p>
<h4 id="以太网长度的限制-发送方检测到冲突"><a href="#以太网长度的限制-发送方检测到冲突" class="headerlink" title="以太网长度的限制(发送方检测到冲突)"></a>以太网长度的限制(发送方检测到冲突)</h4><ul>
<li>发送数据包长度为信道长度的50%——失败</li>
<li>发送数据包长度为信道长度的100%——失败</li>
<li>发送数据包长度为信道长度的200%——成功</li>
</ul>
<h5 id="所以，发送时延-≥-2倍传播时延"><a href="#所以，发送时延-≥-2倍传播时延" class="headerlink" title="所以，发送时延 ≥ 2倍传播时延"></a>所以，发送时延 ≥ 2倍传播时延</h5><p>结合下方以太网和IEEE802.3</p>
<h4 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h4><h3 id="IEE802-4-5"><a href="#IEE802-4-5" class="headerlink" title="IEE802.4/5"></a>IEE802.4/5</h3><h2 id="10-以太网技术"><a href="#10-以太网技术" class="headerlink" title="10. 以太网技术"></a>10. 以太网技术</h2><h5 id="以太网采用基带传输，并且使用曼彻斯特编码。"><a href="#以太网采用基带传输，并且使用曼彻斯特编码。" class="headerlink" title="以太网采用基带传输，并且使用曼彻斯特编码。"></a>以太网采用<strong>基带传输</strong>，并且使用<strong>曼彻斯特编码</strong>。</h5><p>10Base-T：以太网采用双绞线(对应于“T”)(多采用星型结构)，其传输速率为10Mb/s。</p>
<h3 id="1-以太网与IEEE802-3"><a href="#1-以太网与IEEE802-3" class="headerlink" title="1. 以太网与IEEE802.3"></a>1. 以太网与IEEE802.3</h3><p><img src="https://s2.loli.net/2022/02/24/B7KFOfURxwhAITG.png" alt="image-20220224163759256"></p>
<p>发送完，就不再进行冲突检测。</p>
<ul>
<li>前导：由7个字节的位串10101010，被接收站用来建立位同步。</li>
<li>帧起始定界符：这个10101011的序列指明了帧本身的起始位置。</li>
<li>目的地址(DA)和源地址(SA)：分别表示帧的接收节点与发送节点的硬件地址(MAC地址)。</li>
<li>帧校验序列：32位的循环冗余码，校验范围从目的地址段到数据段的末尾。</li>
</ul>
<h3 id="2-以太网的地址"><a href="#2-以太网的地址" class="headerlink" title="2. 以太网的地址"></a>2. 以太网的地址</h3><p>LAN地址通常也称为物理地址、以太网地址或介质访问控制(MAC)地址</p>
<h4 id="长度为48位-6字节-1"><a href="#长度为48位-6字节-1" class="headerlink" title="长度为48位/6字节(*)"></a>长度为48位/6字节(*)</h4><p>这6个字节的地址，通常用十六位进制数表示。</p>
<p>是永久且唯一的。</p>
<h2 id="13-无线网"><a href="#13-无线网" class="headerlink" title="13. 无线网"></a>13. 无线网</h2><h3 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA/CA"></a>CSMA/CA</h3><p>IEEE802.11 介质访问控制协议是一种可以避免冲突的载波侦听多路访问协议。</p>
<h4 id="冲突避免"><a href="#冲突避免" class="headerlink" title="冲突避免"></a>冲突避免</h4><p>没有采用冲突检测机制，而是采用冲突避免机制。</p>
<p>会带来问题，故而有如下：</p>
<h4 id="信道预留机制"><a href="#信道预留机制" class="headerlink" title="信道预留机制"></a>信道预留机制</h4><p>采用信道预留机制。当发送方要发送一个帧时，它能够首先给接收方发送一个RTS(Request To Send)帧，指出数据分组和ACK分组的持续时间。收到RTS帧的接收方用一个CTS(Clear To Send)帧来响应，显式地指出允许发送方发送。</p>
<h2 id="12-局域网互联"><a href="#12-局域网互联" class="headerlink" title="12. 局域网互联"></a>12. 局域网互联</h2><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>在物理层进行局域网互联一般使用的是：</p>
<ul>
<li>中继器：同轴电缆</li>
<li>集线器：双绞线</li>
</ul>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><p>是一个局域网和另一个局域网之间建立连接的桥梁，扩展网络和通信手段。</p>
<p>但网桥互联会带来广播风暴。网桥不阻挡网络中的广播消息，当网络规模较大时(几个网桥，多个以太网段)，有可能引起广播风暴，导致整个网络充满广播信息，直至完全瘫痪。</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol>
<li>隔开冲突域</li>
<li>按照目的地址转发</li>
<li>连接不同的网络(令牌环网与以太网：微波网桥)</li>
</ol>
<ul>
<li><p>隔开冲突域(隔不开广播域。)</p>
</li>
<li><p>可以分辨所上传数据的头部，而物理层设备不能分辨(都发)。</p>
</li>
<li><p>其内存在转发表，可以发送数据给特定的端口和主机。</p>
</li>
</ul>
<h4 id="源路由网桥"><a href="#源路由网桥" class="headerlink" title="源路由网桥"></a>源路由网桥</h4><p>可以指定路径。</p>
<p>路径的选择是由每个帧的发送者来完成的。</p>
<h2 id="14-补充"><a href="#14-补充" class="headerlink" title="14. 补充"></a>14. 补充</h2><h3 id="面向连接的可靠的协议"><a href="#面向连接的可靠的协议" class="headerlink" title="面向连接的可靠的协议"></a>面向连接的可靠的协议</h3><p>HDLC：面向字节的协议(字节整数倍)</p>
<p>PPP：面向位的协议</p>
<h2 id="习题4"><a href="#习题4" class="headerlink" title="习题4"></a>习题4</h2><h3 id="基本技术"><a href="#基本技术" class="headerlink" title="基本技术"></a>基本技术</h3><p>局域网的特性主要是由三个技术因素决定：网络拓扑结构、传播介质和介质访问控制方法。</p>
<h4 id="局域网拓扑结构"><a href="#局域网拓扑结构" class="headerlink" title="局域网拓扑结构"></a>局域网拓扑结构</h4><ul>
<li>总线型拓扑结构</li>
<li>环形拓扑结构</li>
<li>星型拓扑结构</li>
</ul>
<h3 id="设置介质访问控制子层"><a href="#设置介质访问控制子层" class="headerlink" title="设置介质访问控制子层"></a>设置介质访问控制子层</h3><p>网络中链路主要包括两种类型，即点到点链路和广播链路。</p>
<p>对于点到点链路，链路的两端各有一个单一的发送者和接收者，因此不考虑流量控制的影响，结点想要发送就可以发送。PPP和HDLC协议是比较常用的点到点链路上的数据链路层协议。</p>
<p><strong>对于广播链路，多个发送和接收站点连接到同样的、单一的、共享的广播信道上，为了有效、公平、简单和分散地利用这种广播信道进行数据的传输，必须采用一些对传输介质访问的控制方法，这就是介质访问控制(MAC)协议提供的功能。</strong>以太网和无线局域网都是采用广播链路技术的例子。</p>
<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>当有两个或两个以上站点在同一时刻发送信息时，总线上的信息便会混淆不清，无法辨认，造成发送失败。这种因信息在总线上重叠而出错的现象称为<strong>冲突</strong>。</p>
<h4 id="在CSMA-CD上"><a href="#在CSMA-CD上" class="headerlink" title="在CSMA/CD上"></a>在CSMA/CD上</h4><p>它不是采用集中控制的方式解决用户发送信息的顺序，而是各站根据自己的需要随机地发送信息，通过竞争获得发送权。</p>
<p><img src="https://s2.loli.net/2022/02/17/8CKWwmR5fZ1F3r9.png" alt="image-20220217195722590"></p>
<p>标准的10Mb/s局域网的波特率(每秒信号变化多少次)：极限为20Mb/s</p>
<h3 id="以太网特点"><a href="#以太网特点" class="headerlink" title="以太网特点"></a>以太网特点</h3><p>10吉比特以太网的帧格式与10Mb/s、100Mb/s和1Gb/s以太网的帧格式完全相同。</p>
<h3 id="无线和有线的协议"><a href="#无线和有线的协议" class="headerlink" title="无线和有线的协议"></a>无线和有线的协议</h3><p>RTS：信道预约；CTS：信道检测</p>
<p>有线：CSMA/CD：冲突检测</p>
<p>无线：CSMA/CA：冲突避免(结点之间的冲突)</p>
<h3 id="透明网桥与源路由网桥的比较"><a href="#透明网桥与源路由网桥的比较" class="headerlink" title="透明网桥与源路由网桥的比较"></a>透明网桥与源路由网桥的比较</h3><p>源路由网桥主要用于令牌环。透明网桥的缺点在于不能选择最佳路径，因而无法充分利用冗余的网桥来分担负载。但在一个规模不大的网络中，透明网桥的优点却很明显，所以目前市场上大多数网桥为透明网桥。源路由网桥要求主机参与选径，从理论上说，它可以选择最佳路径，因而可以充分利用冗余网桥来分担负载，但实现起来并不容易。</p>
<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><h3 id="考的可能性比较小"><a href="#考的可能性比较小" class="headerlink" title="考的可能性比较小"></a>考的可能性比较小</h3><ol>
<li>HDLC定义<strong>三种类型的站、两种链路配置和三种传输方式</strong>。</li>
<li>三种类型的站包括:主站、从站和复合站。</li>
<li>两种链路配置包括非平衡配置和平衡配置。</li>
<li>PPP协议有3个组成部分，即将IP数据报封装到<strong>串行链路的方法、链路控制协议、网络控制协议(Network Control Protocol，NCP)。</strong></li>
<li>NCP（网络控制协议）给新接入的PC机分配一个临时的<strong>IP地址</strong> ，使PC机成为Internet上的一个主机，然后就可以开始进行数据的传输。</li>
<li>用户使用拨号电话线接入Internet时，一般都是使用<strong>PPP</strong>协议。</li>
<li>PPP不仅适用于拨号用户，而且适用于租用的<strong>路由器对路由器</strong>线路。</li>
<li>采用普通电话线（PSTN网）作为PPP链路介质是一种廉价的常用方式。在这种方式中，通常通过<strong>RS-232</strong>标准异步串行线路传送IP/IPX包。</li>
<li>数据链路层的服务：<img src="https://s2.loli.net/2022/02/22/wyeJrgXHkCMxqlP.png" alt="image-20220222202941409"></li>
<li></li>
</ol>
<h3 id="考的可能性大"><a href="#考的可能性大" class="headerlink" title="考的可能性大"></a>考的可能性大</h3><ol>
<li>通过通信信道后，接受的数据与发送的数据不一致的现象称为<strong>”传输差错“</strong>。</li>
<li>目前，最常用的差错检测方法：<strong>差错检测编码</strong>。</li>
<li>垂直奇偶校验方法能检测出每列中所有的<strong>奇数位</strong>错。</li>
<li>水平垂直奇偶校验不仅可检错，还可用来<strong>纠正部分差错</strong>。</li>
<li>在计算机网络和数据通信中，应用最广泛的检错码是<strong>循环冗余码</strong>。</li>
<li>进行差错控制和流量控制的基本策略是<strong>反馈机制</strong>。</li>
<li>当出现数据帧丢失时，超时重传可以解决问题。但是若确认帧丢失后，超时重传将使结点B收到两个同样的数据帧。要解决重复帧的问题，就必须使每一个数据帧带上<strong>不同的发送序号</strong>。</li>
<li>停等协议在通信线路较长，传输速率较快的情况下将<strong>浪费大量带宽</strong>。</li>
<li>数据链路控制规程分为面向字符和面向<strong>比特</strong>两类。</li>
<li>基于滑动窗口的数据链路协议，可以连续发送数据帧，<strong>其可连续发送的信息帧的个数等于发送窗口W的大小</strong>。</li>
<li>在连续ARQ协议中，接收方的窗口大小总是1，因此<strong>浪费了很多线路带宽</strong>。</li>
<li><img src="https://s2.loli.net/2022/02/22/ziqKnGoxb5mI82O.png" alt="image-20220222191047454"></li>
<li><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220222191120897.png" alt="image-20220222191120897"></li>
<li><img src="https://s2.loli.net/2022/02/22/yOSeH8WYpjQnKr9.png" alt="image-20220222203206570"></li>
<li><img src="https://s2.loli.net/2022/02/22/WfzduRrOZAQ25yK.png" alt="image-20220222203330201"></li>
<li><img src="https://s2.loli.net/2022/02/22/3GBQnUr7D1Nvqjl.png" alt="image-20220222203417519"></li>
<li>计算题：<img src="https://s2.loli.net/2022/02/22/Gi5UaHmFSYzqVQJ.png" alt="image-20220222204513809"></li>
</ol>
<h5 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h5><ol>
<li>数据链路层划分为两个子层：<strong>逻辑链路控制(LLC)子层 和介质访问控制(MAC)子层。</strong></li>
<li>LLC子层为上层用户提供3种类型的服务分别是无确认无连接服务、有连接服务、有确认无连接服务。</li>
<li>网卡的功能主要包括：<strong>串行/并行转换、对数据进行缓存、实现以太网协议等。</strong></li>
<li><img src="https://s2.loli.net/2022/02/24/hfbJItR8YUFGZKg.png" alt="image-20220224161811616"></li>
<li><img src="https://s2.loli.net/2022/02/24/25klyQNR97TeUaJ.png" alt="image-20220224161534391"><img src="https://s2.loli.net/2022/02/24/JVHY8MRtGcUKeZo.png" alt="image-20220224161553329"></li>
<li><img src="https://s2.loli.net/2022/02/24/WqZHkGzMotvPAXY.png" alt="image-20220224161457357"></li>
<li>虽然CSMA协议比纯ALOHA协议和分槽ALOHA协议有效，但是它仍然存在一个明显的低效情况：<strong>一旦有两个帧发生冲突，则在这两个坏帧传输的时间内，其他站点都不能传输。</strong></li>
<li>令牌环的管理包括：<strong>令牌环的初始建立、令牌环在丢失或出现故障时的初始状态恢复</strong>。</li>
<li><strong>透明网桥</strong>又称为生成树网桥，基本功能有过滤、帧转发、地址学习和生成树算法。</li>
<li>对突发性的数据传输，<strong>争用</strong>是常用的策略。在这种方式中，所有的工作站自由竞争发送机会。</li>
<li>IEEE 802.4 是<strong>令牌总线</strong> MAC子层与物理层规范， IEEE 802.5 是<strong>令牌环</strong>MAC子层与物理层规范。</li>
<li><img src="https://s2.loli.net/2022/02/24/LqPIgaJ8cVwOK1b.png" alt="image-20220224173149103"></li>
</ol>
<h1 id="第五章-广域网-虚电路"><a href="#第五章-广域网-虚电路" class="headerlink" title="第五章 广域网(虚电路)"></a>第五章 广域网(虚电路)</h1><h2 id="习题五"><a href="#习题五" class="headerlink" title="习题五"></a>习题五</h2><h3 id="1-数据通信技术"><a href="#1-数据通信技术" class="headerlink" title="1. 数据通信技术"></a>1. 数据通信技术</h3><h4 id="电路方式-实电路"><a href="#电路方式-实电路" class="headerlink" title="电路方式(实电路)"></a>电路方式(实电路)</h4><p>公用电话网(PSTN)、数字数据网(DDN)</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>信息传输 时延小、电路对用户是“透明”的、信息传送的吞吐量大。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>占用的带宽是 固定的 ，所以网络资源的利用率较低。</p>
<h4 id="虚电路方式"><a href="#虚电路方式" class="headerlink" title="虚电路方式"></a>虚电路方式</h4><ul>
<li>分组方式: X.25(不用的方式）</li>
<li>帧方式：帧中继</li>
<li>信元方式：ATM(由信元头和信元净荷组成，以信元为单位进行传送)</li>
</ul>
<h3 id="2-帧中继"><a href="#2-帧中继" class="headerlink" title="2. 帧中继"></a>2. 帧中继</h3><p>当帧中继交换机收到一个帧的头部时，只要一查出帧的目的地址就开始转发该帧。</p>
<p>即中间层不进行差错检测，提高了帧的处理时间。</p>
<p>适合处理大容量突发型数据业务。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>采用虚电路方式，使用逻辑连接。</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>帧中继采用两种拥塞控制方法，即丢弃策略和 拥塞避免 。</p>
<h3 id="3-ATM"><a href="#3-ATM" class="headerlink" title="3. ATM"></a>3. ATM</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>异步传输模式(ATM)是建立在<strong>电路交换和分组交换</strong>的基础上的一种<strong>面向连接</strong>的快速分组交换技术。</p>
<p>它采用<strong>固定长度是53字节</strong>的协议数据单元，这种定长分组称为<strong>信元</strong>。</p>
<p>在ATM中，数据传输速率可达155Mb/s或622Mb/s。</p>
<p>转发时延小，易于硬件实现。</p>
<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点(*)"></a>2. 特点(*)</h4><p>短信元：53字节</p>
<p>固定信元：5字节(头部固定为5字节)+48字节(载荷长度固定)</p>
<h4 id="4-信元结构-不考"><a href="#4-信元结构-不考" class="headerlink" title="4. 信元结构(不考)"></a>4. 信元结构(不考)</h4><p><img src="https://s2.loli.net/2022/02/25/i8IKRtHMVXEb1Dq.png" alt="image-20220225110859544"></p>
<h4 id="5-虚拟连接"><a href="#5-虚拟连接" class="headerlink" title="5. 虚拟连接"></a>5. 虚拟连接</h4><p>分为两级：虚通道连接(VP)与虚通路连接(VC)。</p>
<h5 id="二者关系"><a href="#二者关系" class="headerlink" title="二者关系"></a>二者关系</h5><p>一个虚通道包含有许多<strong>相同端点</strong>的虚通路。</p>
<h1 id="第六章-网络层-数据报"><a href="#第六章-网络层-数据报" class="headerlink" title="第六章 网络层(数据报)"></a>第六章 网络层(数据报)</h1><h2 id="考的可能性大-1"><a href="#考的可能性大-1" class="headerlink" title="考的可能性大"></a>考的可能性大</h2><ol>
<li>网络层的主要功能就是实现整个网络系统的连接，为运输层提供<strong>整个网络范围内两个终端用户之间数据传输的通路</strong>，实现两个端系统之间的数据透明传送。</li>
<li>一般地，当中继系统是<strong>中继器或网桥</strong>时，一般不称为网络互连，因为这仅仅是把一个物理网络扩大了，它仍然是一个网络。</li>
<li>路由器能够阻止从一个子网到另外一个子网的<strong>广播</strong>。</li>
<li>路由器对于流经的任何分组都要检查分组的源IP地址与目的IP地址，然后根据<strong>路由表</strong>确定该分组流向。</li>
<li></li>
</ol>
<h2 id="习题六"><a href="#习题六" class="headerlink" title="习题六"></a>习题六</h2><h3 id="1-网络互连的定义"><a href="#1-网络互连的定义" class="headerlink" title="1. 网络互连的定义"></a>1. 网络互连的定义</h3><ul>
<li>将相同类型的网络或不同类型的网络及其产品连接在一起，组成地理覆盖范围更大、功能更强大的网络</li>
<li>将大的网络拆分为几个子网，实现更为有效的网络管理等。</li>
</ul>
<h3 id="2-网络层的功能"><a href="#2-网络层的功能" class="headerlink" title="2. 网络层的功能"></a>2. 网络层的功能</h3><p>通过数据报服务，实现主机之间的通信</p>
<h3 id="3-虚电路服务和数据报服务对比"><a href="#3-虚电路服务和数据报服务对比" class="headerlink" title="3. 虚电路服务和数据报服务对比"></a>3. 虚电路服务和数据报服务对比</h3><div class="table-container">
<table>
<thead>
<tr>
<th>虚电路</th>
<th>数据报</th>
</tr>
</thead>
<tbody>
<tr>
<td>通信前先建立连接</td>
<td>不建立连接</td>
</tr>
<tr>
<td>虚电路号(局部性)</td>
<td>目的地址(IP唯一，全局性)</td>
</tr>
<tr>
<td>规定传输路径，顺序性</td>
<td>无顺序性，无固定路径</td>
</tr>
<tr>
<td>无法绕开故障点</td>
<td>存在冗余线路时，有可能绕开故障点</td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-三级IP地址格式与划分思想"><a href="#5-三级IP地址格式与划分思想" class="headerlink" title="5. 三级IP地址格式与划分思想"></a>5. 三级IP地址格式与划分思想</h3><p><img src="https://s2.loli.net/2022/02/25/hq4AnST5pCHFVro.png" alt="image-20220225121149080"></p>
<h3 id="6-物理地址与IP地址"><a href="#6-物理地址与IP地址" class="headerlink" title="6. 物理地址与IP地址"></a>6. 物理地址与IP地址</h3><p>物理地址48位，是平面型地址。地址解析原因：交换机根据全部的物理地址来确定转发的目的的地址。</p>
<p>IP地址是层次性地址(IPv4: 32位；IPv6: 128位)。地址解析原因：路由器只根据网络号就可进行转发。</p>
<h3 id="7-CIDR"><a href="#7-CIDR" class="headerlink" title="7. CIDR"></a>7. CIDR</h3><p>无分类域间路由选择</p>
<p>CIDR不再按网络规模对地址进行分类，也不再划分子网，使用网络前缀来代替了网络号和子网号，IP地址里只包括网络前缀和主机号两部分。(取消了子网的概念，但是还使用掩码。)</p>
<p>采用“斜线记法”，即在IP地址后面加上一个斜线”/“，然后写上网络前缀所占的比特数。</p>
<p>如166.100.20.82/20：表示在这个32位的IP地址中，前20位是网络前缀，后12位是主机号。</p>
<h3 id="8-主机数"><a href="#8-主机数" class="headerlink" title="8. 主机数"></a>8. 主机数</h3><p><img src="https://s2.loli.net/2022/02/25/28VFSgzNxGerpnL.png" alt="image-20220225124325419"></p>
<h3 id="9-网络号和主机号"><a href="#9-网络号和主机号" class="headerlink" title="9. 网络号和主机号"></a>9. 网络号和主机号</h3><p><img src="https://s2.loli.net/2022/02/25/k1cxr3PG9gJRa7M.png" alt="image-20220225124418477"></p>
<h3 id="10-IP地址分配规则"><a href="#10-IP地址分配规则" class="headerlink" title="10. IP地址分配规则"></a>10. IP地址分配规则</h3><p><strong>主机号全0或全1称为直接广播地址，不能用。</strong></p>
<p><img src="https://s2.loli.net/2022/02/25/1bIyfgJD26BR3Nh.png" alt="image-20220225124549534"></p>
<p><img src="https://s2.loli.net/2022/02/27/oahdke85i72gjHL.png" alt="image-20220227194632169"></p>
<h3 id="19-路由交换规则"><a href="#19-路由交换规则" class="headerlink" title="19. 路由交换规则"></a>19. 路由交换规则</h3><p>下一跳不同，选近路(A经B、D都可到C，则取近的)</p>
<p>下一跳不同，距离相同，选原路(为维护网络稳定性)</p>
<p>下一跳相同，选新路(A经B到C，原为3；现有A经B到C距离5，则最终A经B到C的距离取5)</p>
<h3 id="20-自治系统"><a href="#20-自治系统" class="headerlink" title="20. 自治系统"></a>20. 自治系统</h3><h3 id="23-子网拆分"><a href="#23-子网拆分" class="headerlink" title="23. 子网拆分"></a>23. 子网拆分</h3><p>如图所示，一个路由器互联了3个局域网(LAN)。</p>
<h4 id="子网掩码的求法"><a href="#子网掩码的求法" class="headerlink" title="子网掩码的求法"></a>子网掩码的求法</h4><p>网段中可容纳$2^n$个主机，对应的子网掩码中前$32-n$位就是1，后$n$位为0。将其换成十进制即可。</p>
<p>子网掩码里有$n$个0，对应的就有$2^n$个主机。</p>
<p><img src="https://s2.loli.net/2022/02/25/2irKzbGujpMUA9D.png" alt="image-20220225130106638"> </p>
<p><img src="https://s2.loli.net/2022/02/25/Su8zGgOndLUlW73.png" alt="image-20220225130210588"></p>
<p>此题没给各个网段的主机数目，考试时会给出主机数目。</p>
<h4 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h4><p><img src="https://s2.loli.net/2022/02/25/Ib3oSPrwjd4nMVp.png" alt="image-20220225130356702"></p>
<h3 id="24-IPv6特点"><a href="#24-IPv6特点" class="headerlink" title="24. IPv6特点"></a>24. IPv6特点</h3><p>头部40字节</p>
<p>简化头部，提高转发速度；长度扩大为128位，实现万物互联。</p>
<ul>
<li>IP地址长度扩大为128字节</li>
<li>高速化<ul>
<li>分组头部的长度固定</li>
<li>不检查传输错误</li>
<li>不需要每个路由器都进行分片处理</li>
</ul>
</li>
<li>任意通信</li>
<li>安全性功能</li>
<li>流标记(flow label)</li>
</ul>
<h3 id="25-IP多播"><a href="#25-IP多播" class="headerlink" title="25. IP多播"></a>25. IP多播</h3><p>IPv4定义了3种IP分组的传输：</p>
<ul>
<li>单播：发送分组到单个目的地，实际上是点对点的传输。</li>
<li>广播：发送分组到同一个广播域或子网内的所有设备</li>
</ul>
<h4 id="多播-组播"><a href="#多播-组播" class="headerlink" title="多播(组播)"></a>多播(组播)</h4><p>也称为多址广播或组播技术，是一种允许一台或多台主机(多播源)发送单一分组到多台主机(一次的、同时的)的TCP/IP网络技术。</p>
<h3 id="26-虚拟专用网VPN"><a href="#26-虚拟专用网VPN" class="headerlink" title="26. 虚拟专用网VPN"></a>26. 虚拟专用网VPN</h3><p>VPN，是指基于公用网络(通常是Internet)所建立的企业网络，并且此企业网络拥有与专用网络相同的安全、管理及功能等特点。</p>
<h3 id="27-网络地址转换NAT"><a href="#27-网络地址转换NAT" class="headerlink" title="27. 网络地址转换NAT"></a>27. 网络地址转换NAT</h3><p>NAT(network address translation，网络地址转换)于1994年提出。</p>
<p>但在专用网内部的一些主机本来已经分配到了本地IP地址(即仅在本专用网内使用的专用地址)，但现在又想和Internet上的主机通信(并不需要加密)时，可使用NAT方法。</p>
<p>NAT不仅能解决IP地址不足的问题，还能有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。</p>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>互联网控制协议</p>
<p>ICMP是Internet中一个差错和控制报文协议，针对网络层的错误诊断、拥塞控制、路径控制和查询服务4大功能，ICMP提供相应的报文。</p>
<p>ICMP主要用于拥塞控制和路径控制。</p>
<p>ICMP报文封装在IP分组的数据区中发送的，因此并不能保证它的可靠性。</p>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>ICMP报文分成报文头和数据区两部分，其中报文头包含类型、代码与校验和三个字段。</p>
<h4 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h4><p>0 ：回应应答</p>
<p>3 ：目的站点不可达</p>
<p>4 ：源抑制</p>
<p>8 ：回应请求</p>
<p>11 ： 分组超时(回复源主机，数据包死亡)</p>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>ping：请求主机发送了4个类型为8的回应请求，接收主机有义务回复4个类型为0的回应应答。 </p>
<p>tracert：依靠 <strong>IP包的生存时间</strong> 确定，发送类型为11的反馈给发送主机。</p>
<h4 id="拥塞控制-1"><a href="#拥塞控制-1" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p><strong>网络负载超过网络容量，产生拥塞，采用各种手段去避免和减轻拥塞，即为拥塞控制</strong></p>
<p>轻拥塞，即为拥塞控制。</p>
<p>发送 类型为4 的反馈给 发送主机。</p>
<h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><p>最早的动态路由协议</p>
<p>将路由表转发给相邻路由器。</p>
<p>下一跳不同，选近路；</p>
<p>下一跳相同，选新路。</p>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>每30秒，就把路由器中的所有路由信息向所有的网络端口广播，进行刷新。</p>
<p>路由超时时钟一般为90s，即如果一条路由在90s之内都没有刷新过，则RIP把路由项置为无效(把其量度值置为16).</p>
<h1 id="第七章-运输层"><a href="#第七章-运输层" class="headerlink" title="第七章 运输层"></a>第七章 运输层</h1><h2 id="习题七"><a href="#习题七" class="headerlink" title="习题七"></a>习题七</h2><h3 id="1-运输层与网络层"><a href="#1-运输层与网络层" class="headerlink" title="1. 运输层与网络层"></a>1. 运输层与网络层</h3><p>网络层为运输层提供主机之间通信的服务，运输层使用网络层提供的服务。</p>
<h3 id="2-运输层端口的作用"><a href="#2-运输层端口的作用" class="headerlink" title="2. 运输层端口的作用"></a>2. 运输层端口的作用</h3><p>用来标识应用层的进程，提供进程之间的寻址，保证数据包到达正确的应用层进程。</p>
<h3 id="4-TCP提供的服务"><a href="#4-TCP提供的服务" class="headerlink" title="4. TCP提供的服务"></a>4. TCP提供的服务</h3><p>TCP是一个面向连接的、可靠的、全双工的通信协议。</p>
<ol>
<li>进程之间的通信</li>
<li>面向连接的，可保证数据的顺序性</li>
<li>有确认的，可靠的</li>
</ol>
<p>(面向连接、可靠性、数据流传输、流量控制、全双工(允许任何一个方向发送数据))</p>
<h3 id="5-TCP建立连接和释放连接过程"><a href="#5-TCP建立连接和释放连接过程" class="headerlink" title="5. TCP建立连接和释放连接过程"></a>5. TCP建立连接和释放连接过程</h3><p>避免建立不必要的连接，浪费计算机资源</p>
<h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>ACK为确认标志：如果ACK=1，则表示TCP段中的确认号是有效的；否则确认号无效。</p>
<p>SYN为同步标志：用来建立连接，让连接双方同步序列号。如果SYN=1且ACK=0，则表示该数据包为连接请求；</p>
<p>如果SYN=1且ACK=1，则表示是接受链接。</p>
<p>FIN为结束标志：表示发送方已经没有数据要求传输了，希望释放连接。</p>
<p>SEQ是数据包序号。</p>
<p>ACKSEQ：准备接收的数据包序号。</p>
<h4 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h4><p>SEQ是序号。</p>
<p><img src="https://s2.loli.net/2022/02/26/iOeMpwD2xV41fEQ.png" alt="image-20220226184448915"></p>
<h5 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h5><ol>
<li><p>三次是因为将确认建立A-&gt;B和请求建立反向连接B-&gt;A的合在一起了。</p>
</li>
<li><p>不这样的话：<strong>当出现延迟的请求建立连接的数据包，会建立没有用的连接，浪费计算机的资源。</strong></p>
</li>
</ol>
<h4 id="四次挥手释放连接"><a href="#四次挥手释放连接" class="headerlink" title="四次挥手释放连接"></a>四次挥手释放连接</h4><p><img src="https://s2.loli.net/2022/02/26/Tl4ud3CbpYILBfr.png" alt="image-20220226185633818"></p>
<h3 id="11-拥塞及解决方法"><a href="#11-拥塞及解决方法" class="headerlink" title="11. 拥塞及解决方法"></a>11. 拥塞及解决方法</h3><p>产生拥塞的原因：网络的负载超过网络的容量</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol>
<li>开环的解决方式：良好的设计来避免(虚电路：许可证法；TCP中慢启动)</li>
<li>闭环的解决方式：通过网络的反馈来减少拥塞(网络层：源抑制报文，控制传输量)</li>
</ol>
<h4 id="TCP中的拥塞控制"><a href="#TCP中的拥塞控制" class="headerlink" title="TCP中的拥塞控制"></a>TCP中的拥塞控制</h4><p>在运输层，采用了慢启动、拥塞避免、快重传和快恢复四种算法。</p>
<p>当TCP收到路由器发来的ICMP源抑制报文，或者发现连续的报文丢失现象或延迟过长而引起的超时重发，就认为发生了拥塞。</p>
<h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><p>在慢启动的初级阶段，TCP发送方以很慢的速率开始发送，但是以指数级的速度快速增长其发送速率。</p>
<h6 id="慢启动门限"><a href="#慢启动门限" class="headerlink" title="慢启动门限"></a>慢启动门限</h6><p>在TCP慢启动阶段，可以发送的报文数量按指数级增加，为了防止拥塞窗口的增长引起网络拥塞，还需要一个状态变量，即<strong>慢启动门限ssthresh</strong>。</p>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>拥塞窗口的大小以MSS为单位。<strong>慢启动门限ssthresh初始时等于8MSS。</strong></p>
<p>注意到当发生丢包事件时，拥塞窗口值为12。于是门限值被设置为Cwnd×0.5=12×0.5=6MSS。</p>
<p>拥塞窗口Cwnd重新设置为1，并开始执行慢启动算法。当Cwnd=6时，改为执行拥塞避免算法。</p>
<h5 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h5><p>也就是说，当到达门限时，就进行缓慢线性增长，如果发生拥塞，那么就变为1，再设置门限(拥塞时的一半)。</p>
<p><img src="https://s2.loli.net/2022/02/26/PL6VN21CaXUKyZj.png" alt="image-20220226191621666"></p>
<h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><p>发送方只要一连收到3个重复的ACK即可判定有分组丢失了，就应立即重传丢失的报文段，而不必继续等待为丢失的那个报文所设置的重传计时器超时。</p>
<h5 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h5><p>当发送方一连收到3个连续重复的ACK时，按“乘法减小”重新设置慢启动门限，与慢启动不同的是，Cwnd不是设置为1，而是设置为ssthresh(慢启动阈值)+3×MSS。</p>
<h3 id="12-流量控制"><a href="#12-流量控制" class="headerlink" title="12. 流量控制"></a>12. 流量控制</h3><p>TCP采用<strong>大小可变的滑动窗口</strong>给应用进程提供流量控制服务。</p>
<p><img src="https://s2.loli.net/2022/02/26/1AvmOCQrHx59yoB.png" alt="image-20220226191746994"></p>
<p>第一次将窗口减小为2048字节，第二次又减小为0字节，即不允许发送方再发送。第三次增加为2048字节。</p>
<h4 id="发送窗口Swnd-MIN-接收窗口，拥塞窗口-。"><a href="#发送窗口Swnd-MIN-接收窗口，拥塞窗口-。" class="headerlink" title="发送窗口Swnd = MIN[接收窗口，拥塞窗口]。"></a><strong>发送窗口Swnd = MIN[接收窗口，拥塞窗口]。</strong></h4><h3 id="13-UDP"><a href="#13-UDP" class="headerlink" title="13. UDP"></a>13. UDP</h3><p>UDP报文由头部和数据两个数据组成，占8个字节。</p>
<p>头部为4个字节。</p>
<p>用户数据报协议（UDP）只在IP协议的数据报服务之上增加了很少一点的功能，即</p>
<p><strong>端口功能和差错检测功能</strong>。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol>
<li>无需建立连接</li>
<li>无连接状态管理</li>
<li>报文头部开销小</li>
<li>应用层能很好的控制要发送的数据和发送时间。</li>
</ol>
<h1 id="第八章-应用层"><a href="#第八章-应用层" class="headerlink" title="第八章 应用层"></a>第八章 应用层</h1><h2 id="习题八"><a href="#习题八" class="headerlink" title="习题八"></a>习题八</h2><h3 id="1-客户-服务器模型和P2P模型"><a href="#1-客户-服务器模型和P2P模型" class="headerlink" title="1. 客户/服务器模型和P2P模型"></a>1. 客户/服务器模型和P2P模型</h3><h4 id="在C-S模型中"><a href="#在C-S模型中" class="headerlink" title="在C/S模型中"></a>在C/S模型中</h4><ul>
<li>服务器处于接受请求的状态</li>
<li>客户机发出请求，并等待接收结果</li>
<li>服务器收到请求后，分析请求，进行必要的处理，得到结果并发送给客户机。</li>
</ul>
<h4 id="在P2P模型中"><a href="#在P2P模型中" class="headerlink" title="在P2P模型中"></a>在P2P模型中</h4><p>P2P的思想是整个网络中的传输内容不再被保存在中心服务器上，每个节点都同时具有下载、上传的功能，即每个结点既是服务器又是客户机。</p>
<p>任意一对计算机称作对等方(Peer)，直接相互通信。</p>
<p>每个结点既作为客户访问其他结点的资源，也作为服务器提供资源给其他结点访问。</p>
<h3 id="2-域名转换DNS"><a href="#2-域名转换DNS" class="headerlink" title="2. 域名转换DNS"></a>2. 域名转换DNS</h3><ol>
<li>使用DNS，域名-&gt;IP(相互转换)</li>
<li>客户机向本地域名服务器发起请求</li>
<li>本地域名服务器和互联网上其他的域名服务器相互配合，将查询结果返回给客户机。</li>
<li><img src="https://s2.loli.net/2022/02/27/vkcY74zwm9fnONI.png" alt="image-20220227195738711"></li>
</ol>
<h3 id="3-域名结构和功能"><a href="#3-域名结构和功能" class="headerlink" title="3. 域名结构和功能"></a>3. 域名结构和功能</h3><p><img src="https://s2.loli.net/2022/02/26/FGlDBjzUMq7c3bn.png" alt="image-20220226200011860"></p>
<h3 id="6-HTML的作用"><a href="#6-HTML的作用" class="headerlink" title="6. HTML的作用"></a>6. HTML的作用</h3><p>HTML是WWW上用于创建超文本的基本语言，可以定义格式化的文本、色彩、图像与超文本链接等，主要用于web主页的创建与制作。</p>
<h3 id="7-FTP的定义及作用"><a href="#7-FTP的定义及作用" class="headerlink" title="7. FTP的定义及作用"></a>7. FTP的定义及作用</h3><p>主要功能是文件上传与下载。</p>
<ol>
<li>文件传输协议</li>
<li>端口21传控制信息</li>
<li>端口20传数据</li>
</ol>
<p><img src="https://s2.loli.net/2022/02/26/7M3cyLDxmYdFVH5.png" alt="image-20220226200212130"></p>
<h3 id="8-Telnet和SSH特点"><a href="#8-Telnet和SSH特点" class="headerlink" title="8. Telnet和SSH特点"></a>8. Telnet和SSH特点</h3><p>Telnet允许用户和远程计算机动态交互。</p>
<p>SSH是加密的远程登录。</p>
<p><img src="https://s2.loli.net/2022/02/26/AVz8YN97JlySRnj.png" alt="image-20220226195929213"></p>
<h3 id="9-电子邮件收发过程"><a href="#9-电子邮件收发过程" class="headerlink" title="9. 电子邮件收发过程"></a>9. 电子邮件收发过程</h3><p><img src="https://s2.loli.net/2022/02/26/oRPywGQ9HcCYesW.png" alt="image-20220226195839467"></p>
<p><img src="https://s2.loli.net/2022/02/26/Ff2VMlmzPShTWCA.png" alt="image-20220226195909957"></p>
<h3 id="10-DHCP定义"><a href="#10-DHCP定义" class="headerlink" title="10. DHCP定义"></a>10. DHCP定义</h3><p>动态主机配置协议(DHCP)负责IP地址的集中和动态分配管理。</p>
<h3 id="11-URL与信息定位"><a href="#11-URL与信息定位" class="headerlink" title="11. URL与信息定位"></a>11. URL与信息定位</h3><p>URL用于定位信息资源所在的位置，描述了浏览器检索资源所用的协议，资源所在的计算机的主机名和资源的路径与文件名。</p>
<h4 id="标准格式"><a href="#标准格式" class="headerlink" title="标准格式(*)"></a>标准格式(*)</h4><p>资源传递协议://存放资源的主机/资源路径与文件名</p>
<p>如果要访问的不是80端口，要指明端口号，即在标准格式后加上    :端口号</p>
<p>ftp://ftp.xaut.edu.cn</p>
<h1 id="第九章-网络安全与网络管理"><a href="#第九章-网络安全与网络管理" class="headerlink" title="第九章 网络安全与网络管理"></a>第九章 网络安全与网络管理</h1><h2 id="加密与认证"><a href="#加密与认证" class="headerlink" title="加密与认证"></a>加密与认证</h2><h3 id="数据加密标准"><a href="#数据加密标准" class="headerlink" title="数据加密标准"></a>数据加密标准</h3><p><strong>数据加密标准</strong>(Data Encryption Standard, DES)是最典型(经典)的对称加密算法，它是由IBM公司提出。</p>
<p>DES使用一个56位(二进制，$2^{56}$)的密钥和附加的8位奇偶校验位，产生长度为64位的分组。</p>
<h2 id="公开密钥加密机制"><a href="#公开密钥加密机制" class="headerlink" title="公开密钥加密机制"></a>公开密钥加密机制</h2><p>每个发送者拥有两个密码，一个是任何人都可得到的公开密钥(公钥)，另一个是只有发送者本人知道的秘密密钥(私钥)。</p>
<p><strong>RSA算法是最流行的公开密钥算法。</strong></p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol>
<li>加密密钥公开，解密密钥私有</li>
<li>从公开密钥推出私有密钥是极其困难的</li>
<li>绝大多数加密机制中，公钥与私钥可以互为加密解密密钥</li>
<li>加密解密速度慢</li>
</ol>
<p>使用非对称的密钥传输对称的密钥，以提升速度。如果是全非对称的话，太慢。</p>
<h2 id="数字签名技术"><a href="#数字签名技术" class="headerlink" title="数字签名技术"></a>数字签名技术</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>数字签名是一种基于密码的身份鉴别技术。</p>
<p>在传统的书信或文件中，通过亲笔签名或印章来证明其真实性，而在计算机网络中，传送的报文通常使用数字签名的技术来模拟日常生活中的亲笔签名。</p>
<h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理(*)"></a>原理(*)</h3><p>在使用公开密钥加密算法进行数字签名前，<strong>通常先使用单向散列函数(Hash Function，又称为哈希函数)对要签名的消息进行处理并生成消息摘要(Message Digest, MD)</strong>，然后对消息摘要进行签名。</p>
<h2 id="电子邮件加密"><a href="#电子邮件加密" class="headerlink" title="电子邮件加密"></a>电子邮件加密</h2><h3 id="PGP安全协议"><a href="#PGP安全协议" class="headerlink" title="PGP安全协议"></a>PGP安全协议</h3><p>PGP（Pretty Good Privacy，PGP）是一种基于RSA密钥加密体制供大众使用的加密协议。它不仅能对用户的邮件加密，还能在邮件上进行数字签名，让收信人确信邮件未被第三方篡改，从而达到安全通信的目的。</p>
<h2 id="防火墙技术"><a href="#防火墙技术" class="headerlink" title="防火墙技术"></a>防火墙技术</h2><p>防火墙(firewall)是把一个组织的内部网络与整个Internet隔离开的软件和硬件的组合，它允许一些数据分组通过，也禁止一些数据分组通过。</p>
<h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><h3 id="ISO功能域"><a href="#ISO功能域" class="headerlink" title="ISO功能域"></a>ISO功能域</h3><p>ISO特别定义了网络管理的5个功能域：配置管理、故障管理、性能管理、安全管理和计费管理。</p>
<h1 id="第十章-网络系统设计与配置"><a href="#第十章-网络系统设计与配置" class="headerlink" title="第十章 网络系统设计与配置"></a>第十章 网络系统设计与配置</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="网络系统层次"><a href="#网络系统层次" class="headerlink" title="网络系统层次"></a>网络系统层次</h3><p>计算机网络系统分为三个层次，即核心层(Core Layer)、汇聚层(Distribution Layer)和访问层(Access Layer)。（网络拓扑结构）</p>
<h2 id="2-局域网设计"><a href="#2-局域网设计" class="headerlink" title="2. 局域网设计"></a>2. 局域网设计</h2><h3 id="1-网络级联"><a href="#1-网络级联" class="headerlink" title="1. 网络级联"></a>1. 网络级联</h3><p>级联是指通过交换机的端口，以普通电缆将两个以上的交换机连接起来的拓展方式。</p>
<p><img src="https://s2.loli.net/2022/02/22/LnZahxl32TwH71j.png" alt="image-20220222213205530"></p>
<h3 id="2-交换机堆叠"><a href="#2-交换机堆叠" class="headerlink" title="2. 交换机堆叠"></a>2. 交换机堆叠</h3><p>堆叠是指若干交换机用特殊电缆通过特殊端口连接起来的拓展方式。</p>
<p>堆叠有两种模式：菊花链和点对点。</p>
<p><img src="https://s2.loli.net/2022/02/22/dmGvp8wFMqtbCIA.png" alt="image-20220222213447853"></p>
<h3 id="端口-链路聚合"><a href="#端口-链路聚合" class="headerlink" title="端口/链路聚合"></a>端口/链路聚合</h3><p>端口/链路聚合(Port Trunk/L2 Trunk)是指将以太网交换机上多个物理端口汇聚成一个逻辑端口。</p>
<h3 id="网络工作组划分"><a href="#网络工作组划分" class="headerlink" title="网络工作组划分"></a>网络工作组划分</h3><h4 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h4><p>虚拟局域网(VLAN)将局域网内的设备逻辑地(而不是物理地)划分成多个网段。</p>
<h4 id="VLAN的分类方式"><a href="#VLAN的分类方式" class="headerlink" title="VLAN的分类方式"></a>VLAN的分类方式</h4><ul>
<li>基于端口</li>
<li>基于MAC</li>
<li>基于网络层</li>
<li>基于IP组播</li>
</ul>
<h3 id="大型路由交换网络"><a href="#大型路由交换网络" class="headerlink" title="大型路由交换网络"></a>大型路由交换网络</h3><p><strong>一次路由，多次交换 </strong></p>
]]></content>
      <tags>
        <tag>复习计算机网络啦！</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2021/11/12/Git/</url>
    <content><![CDATA[<h1 id="The-introduction-of-Git"><a href="#The-introduction-of-Git" class="headerlink" title="The introduction of Git"></a>The introduction of Git</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>要把文档还原到<strong>编辑前</strong>的状态，就需要提前备份且做好命名工作，否则就会乱了套。但每次都要事先复制，而且命名也无法体现修改内容，容易出错。</p>
<p>若是共享文档，还应该加上编辑者的名字。而且，若是多个人同时编辑，后来者会覆盖掉前一个人的编辑内容。</p>
<h2 id="Advantage"><a href="#Advantage" class="headerlink" title="Advantage"></a>Advantage</h2><p>使用Git进行分布式版本管理，可以解决以上问题。</p>
<p>Git可以在任何时间点，把文档的状态作为更新记录保存起来。因此可以把编辑过的文档复原到以前的状态，也可以显示编辑前后的内容差差异。</p>
<p>而且，编辑旧文件后，试图覆盖新的文件的时候（即上传文件到服务器时），系统会发出警告，因此可以避免在无意中覆盖他人的编辑内容。</p>
<h2 id="Premise"><a href="#Premise" class="headerlink" title="Premise"></a>Premise</h2><h3 id="数据库-Repository"><a href="#数据库-Repository" class="headerlink" title="数据库(Repository)"></a>数据库(Repository)</h3><p>数据库是记录文件或目录状态的地方，存储着内容修改的历史记录。在数据库的管理下，把文件和目录修改的历史记录放在对应的目录下。</p>
<p>分为<strong>远程数据库</strong>和<strong>本地数据库</strong>两种：</p>
<p>本地数据库：为了方便用户个人使用，在自己的机器上配置的数据库。</p>
<p>远程数据库：配有给专用的服务器，为了多人共享而建立的数据库。</p>
<h3 id="Submit"><a href="#Submit" class="headerlink" title="Submit"></a>Submit</h3><p>若要把文件或目录的添加和变更保存到数据库，就需要进行提交。</p>
<p>执行提交后，数据库中会生成上次提交的状态与当前状态的差异记录（也叫revision)。</p>
<p>提交是以时间顺序排列状态被保存到数据库中的。凭借该提交和最新的文件状态，就可以知道过去的修改记录以及内容。</p>
<p>不同类型的修改（如bug的修复和功能的添加)要尽量分开提交，方便以后从历史记录中查找特定的修改内容。用心填写提交时的修改信息，方便别人和自己理解。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Git的标准注解</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一行：提交修改内容的摘要</td>
</tr>
<tr>
<td>第二行：空行</td>
</tr>
<tr>
<td>第三行：修改的理由</td>
</tr>
</tbody>
</table>
</div>
<h3 id="工作树和索引"><a href="#工作树和索引" class="headerlink" title="工作树和索引"></a>工作树和索引</h3><p>在Git管理下，大家实际操作的目录被称为工作树。</p>
<p>在数据库和工作树之间有索引，索引是为了向数据库提交做准备的区域。</p>
<p><strong>工具树</strong> ——- <em>注册</em> ——- <strong>索引</strong> ——-<em>提交</em> ——- <strong>数据库</strong></p>
<p>没有加入索引的档案不能被提交。</p>
<p>Git在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库。因此，要提交文件，首先需要被文件加入索引区域中。这样，可以避免不必要的提交，还可以将文件修改内容的一部分加入索引区域提交。</p>
<h3 id="共享数据库"><a href="#共享数据库" class="headerlink" title="共享数据库"></a>共享数据库</h3><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>为了将本地数据库的修改记录共享到远程数据库，必须上传本地数据库中存储的修改记录。</p>
<p>为此，需要在Git执行推送(Push)操作。</p>
<p>执行Push后，本地的修改记录会被上传到远程数据库。所以远程数据库的修改记录就会和本地的数据库修改记录保持同步。</p>
<h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><p>进行克隆(Clone)操作就可以复制远程数据库。</p>
<p>执行克隆后，远程数据库的全部内容都会被下载，包括本地数据库的变更履历。之后就可以像原始数据库一样进行查看记录或其它操作。</p>
<h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><p>若是共享的远程数据库由多人共同作业，那么作业完毕后，所有人都要把修改推送到远程数据库。然后，自己的本地数据库也需要更新其他人推送的变更内容。</p>
<p>进行拉取(pull)操作就可以把远程数据库的内容更新到本地数据库。</p>
<p>进行拉取(pull)操作，就是从远程数据库下载最近的变更日志，并覆盖自己本地数据库的相关内容。相当于是下载。</p>
<h3 id="共享数据库常用操作"><a href="#共享数据库常用操作" class="headerlink" title="共享数据库常用操作"></a>共享数据库常用操作</h3><h4 id="取别名"><a href="#取别名" class="headerlink" title="取别名"></a>取别名</h4><p>$ git remote add <name> <url></p>
<p>如：$ git remote add origin <a href="https://github.com/Phoenix-Nrvn/Ming.git">https://github.com/Phoenix-Nrvn/Ming.git</a></p>
<h4 id="push修改内容"><a href="#push修改内容" class="headerlink" title="push修改内容"></a>push修改内容</h4><p>$ git push <repository> <refspec>…</p>
<p>如：$ git push -u origin master</p>
<p>可以向远程数据库”origin”进行推送。当执行命令时，如果指定了-u选项，那么下一次推送时，就可以省略分支名称。但是，首次运行指令，向空的远程数据库推送时，必须指定远程数据库名称和分支名称。</p>
<h4 id="克隆-1"><a href="#克隆-1" class="headerlink" title="克隆"></a>克隆</h4><p>$ git clone <repository> <directory></p>
<p>将仓库复制到本地指定的文件夹</p>
<h4 id="提交更改"><a href="#提交更改" class="headerlink" title="提交更改"></a>提交更改</h4><p>$ git add sample.txt(更改信息后，重新提交sample)</p>
<p>$ git commit -m “添加add的说明”</p>
<p>$ git push</p>
<h4 id="拉取-1"><a href="#拉取-1" class="headerlink" title="拉取"></a>拉取</h4><p>$ git pull <repository> <refspec>…</p>
<p>$ git pull origin(仓库名) master(分支名)</p>
<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p>$ git log</p>
<h4 id="合并记录"><a href="#合并记录" class="headerlink" title="合并记录"></a>合并记录</h4><p>进行一次pull之后，在进行下一次push之前，如果有其他人对远程数据库进行了更改，那么在对其进行pull之前，所有的push都会被拒绝，即防止他人的push被覆盖。</p>
<p>在这种情况下，需要读取他人push的变更并进行合并操作。一般而言，合并时，Git会自动合并已有的变更点。</p>
<p>若更改的是同一个地方，那么git无法确定选用的内容，即需要手动修改以进行手动合并。</p>
]]></content>
      <tags>
        <tag>It&#39;s time to begin git!</tag>
      </tags>
  </entry>
  <entry>
    <title>GC</title>
    <url>/2021/11/15/GC/</url>
    <content><![CDATA[<h1 id="构造器与垃圾收集器"><a href="#构造器与垃圾收集器" class="headerlink" title="构造器与垃圾收集器"></a>构造器与垃圾收集器</h1><p>It is time to talk about death!</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Like people， 对象也有生有死。如果你要编写Java程序，就必须创建对象，也早晚会将对象释放掉，不然就会出现内存不足的问题。其实，就你的操作而言，并不是亲自消灭对象，你只是声明了放弃。一旦对象被放弃，那么冷血无情的垃圾收集器(GC)就会将他蒸发掉，回收其所占用的内存空间。</p>
<h2 id="开端"><a href="#开端" class="headerlink" title="开端"></a>开端</h2><h3 id="栈与堆：生存空间"><a href="#栈与堆：生存空间" class="headerlink" title="栈与堆：生存空间"></a>栈与堆：生存空间</h3><p>在Java中，程序员只关心两个区域的空间：堆(heap)和栈(stack)。二者，分别是对象的生存空间和方法调用及部分变量的生存空间。</p>
<p>所有的对象都存活在可以进行垃圾回收的堆上，而具体变量的生存空间取决于其本身是实例变量还是局部变量。后者又称为栈变量，明确保存在栈上。</p>
<blockquote>
<p>tips：</p>
<p><strong>实例变量</strong>：是被声明在类而不是方法里面。他们代表每个独立对象的“字段”(每个实例都能有不同的值)。实例变量存在于所属的对象中。(如每个Duck都可以有一个不同的size)</p>
<p><strong>局部变量</strong>：局部变量和方法的参数都是被声明在方法中。他们是暂时的，且生命周期只限于方法被放在栈上的这段期间(也就是方法调用至执行完毕为止)。</p>
</blockquote>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>当你调用一个方法时，该方法会被放在<strong>调用栈的栈顶</strong>。实际上被堆上栈的是堆栈块，它带有方法的状态，包括执行到<em>哪一行程序</em>以及所有的<em>局部变量的值</em>。(若foo中调用了bar，那么bar会放在foo的顶上)</p>
<p>当一个方法执行完成，那么他的堆栈块就会被释放掉。</p>
<p>若在方法中创建了非primitive的变量(其只是对象的引用变量，而不是对象本身)，那么不管对象是否声明或创建，如果局部变量是对对象的引用，只有该引用变量会在栈上，而对象会在堆上。</p>
<p><img src="https://s2.loli.net/2021/12/22/qRVZxtvmHXEc14D.png" alt="image-02"></p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>对象是存放在堆上的。</p>
<p>实例变量存在于对象所属的堆空间上。</p>
<p>如果实例变量是primitive主数据类型的，则Java会留下其数据类型大小的空间。</p>
<p>若实例变量是一个带有对象引用的变量，那么Java会在类中留出一个引用变量的空间，而不是对象本身所占有的空间。而该引用变量所引用的对象，会在堆上被另外分配空间。即此时，引用和对象都是在堆上。</p>
<p><img src="https://s2.loli.net/2021/12/22/7ZdbjieCXWFo3kR.png" alt="image-03"></p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>声明对象和赋值有3个步骤：声明引用变量、创建对象、连接对象和引用(声明、创建和赋值)。</p>
<p>构造函数卡看起来像方法，感觉上也很像方法，但它并不是方法。它带有new的时候会执行的程序代码，也就是新建一个对象的时候会执行。</p>
<p>构造函数的一项关键特征，即其会在对象被赋值给引用之前就执行。可以在对象被使用之前，介入。</p>
<h4 id="About-super"><a href="#About-super" class="headerlink" title="About super( )"></a>About super( )</h4><p>在创建对象时，父类的构造方法也会被执行。在构造函数中，用<strong>super</strong>来调用父类的构造函数，且这条语句，即<strong>super( )一定位于子类构造函数的第一句</strong>。要记得完整的对象需要也是完整的父类核心。就算Animal上的有些变量Hippo不会用到，但Hippo有可能会有某些继承下来的方法必须读取Animal的实例变量。</p>
<p>构造函数在执行的时候，第一件事是去执行它父类的构造函数，这会连锁反应，一直到Object这个类为止。这样的过程被称作构造函数链。</p>
<p><img src="https://s2.loli.net/2021/12/22/JAijMRaoUqPZIKY.png" alt="image-07"></p>
<p>步骤：</p>
<ol>
<li>执行Hippo的构造函数，其进入最上方的堆栈块。</li>
<li>Hippo的构造函数中，引用了Animal的构造函数，故而父类的构造函数此时被放置在堆栈块顶。</li>
<li>Object的构造函数，由于被Animal的构造函数所引用，此时进入堆栈块最上方。</li>
<li>Object构造函数执行完毕，则弹出堆栈块，则依次是Animal的，Hippo的。</li>
<li>即，Hippo的构造函数最早进入堆栈，却最后弹出。</li>
</ol>
<blockquote>
<p>tips：</p>
<p>父类的构造函数调用super( )，一定要在子类的构造函数的第一句。因为父类与子类的关系，就类似于父母与孩子。父类的对象，一定要在子类的对象开始开始构造之前成型。因为在子类构造过程中，可能会动用从父类中继承下来的东西。所以，一定要在子类构造之前，完成父类的构造函数。</p>
</blockquote>
<h4 id="About-this"><a href="#About-this" class="headerlink" title="About this( )"></a>About this( )</h4><p>另外，如果有某个重载版的构造函数除了不能处理不同类型的参数之外，可以进行其余包括实例变量优化在内的一切工作。而且，为了避免维护的不便利性，不希望相同的代码出现在每一个构造函数中。那么，可以考虑让其余所有的构造函数都先调用该构造函数。即，this( )或this(String)等。</p>
<p>但，需要注意，<strong>this( )必须出现在调用者的第一个语句</strong>，那么这，势必会与super( )的位置产生冲突，故而，有：<strong>super( )和this( )不能同时使用</strong>。</p>
<h2 id="转合"><a href="#转合" class="headerlink" title="转合"></a>转合</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对象的生命周期取决于引用到它的“引用”，如果引用变量还活着，那么对象就继续活在堆上。如果引用死了，对象就随之而去。见下方“引用变量”。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量的生命周期取决于其类型。</p>
<h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><ul>
<li><p>随方法的调用而产生，随方法的弹出堆栈块而结束。</p>
</li>
<li><p>范围只限于声明它的方法中。</p>
</li>
<li>若声明它的方法在调用了其他方法，那么该局部变量的状态会被保存，但是不再起作用。</li>
<li>不能被使用，除非声明它的方法正在执行。</li>
</ul>
<h5 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h5><ul>
<li>属于对象，其寿命于对象相同。</li>
<li>若对象存在，则实例变量也存活在堆上。</li>
</ul>
<h5 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h5><ul>
<li><p>引用变量也只能处于它的范围中才能被引用。也就是说，除非引用变量是在它的范围中，不然就不能使用对象的遥控器。</p>
</li>
<li><p>如果有活着的引用，对象也就活着。如果某个对象的引用已经不在它的范围内，但此引用还是活着的，则此对象就会继续活在堆上，</p>
</li>
<li><p>如果对对象的唯一引用死了，对象就会从堆中被踢开，引用变量会跟堆栈块一起解散，因此被踢开的对象也就正式声明出局。</p>
<p>释放引用变量的方法：</p>
<ul>
<li><p>将其放在方法中</p>
</li>
<li><p>将其重新赋值给别的对象</p>
</li>
<li>将其赋值为NULL</li>
</ul>
</li>
</ul>
<p><strong>如果对象没有引用，那么对象的存在毫无意义，不过是白白浪费空间罢了。</strong></p>
<p>一旦对象失去了它的引用，即其就此无法取得了，那么GC(垃圾收集器)就会知道该如何处理。</p>
]]></content>
      <tags>
        <tag>Talkng about GC</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2021/12/17/JDBC/</url>
    <content><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JDBC(Java DataBase Connectivity)是Java程序操作数据库的API，<strong>是Java操作数据库的规范</strong>，由一组<strong>Java语言编写的类和接口组成</strong>，它对数据库的操作提供基本方法，但对于数据库的细节操作由数据库厂商实现，使用JDBC操作数据库，<strong>需要数据库厂商提供数据库的驱动程序</strong>。</p>
<p><img src="https://s2.loli.net/2021/12/22/PaYeSMCIfRs6H3o.png" alt="image-20211217224940532"></p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li><h3 id="注册数据库驱动"><a href="#注册数据库驱动" class="headerlink" title="注册数据库驱动"></a>注册数据库驱动</h3><p>将数据库厂商提供的数据库驱动类注册到JDBC的驱动管理器中。</p>
<p><strong><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></strong></p>
<p><strong>Class的forName( )方法的作用是将指定字符串名的类加载到JVM中，实例中调用该方法来加载数据库驱动，在加载后，数据库驱动程序会把驱动类自动注册到驱动管理器中。</strong></p>
</li>
<li><h3 id="构建数据库连接URL"><a href="#构建数据库连接URL" class="headerlink" title="构建数据库连接URL"></a>构建数据库连接URL</h3><p>基本格式，即”JDBC协议+IP地址或域名+端口+数据库名称”。</p>
<p><strong><code>MySQL: &quot;jdbc:mysql://localhost:3306/db_database10&quot;;</code></strong></p>
<p><code>SQL Server: &quot;jdbc:sqlserver://localhost:1433;databaseName=db_database10&quot;;</code></p>
</li>
<li><h3 id="获取Connection对象"><a href="#获取Connection对象" class="headerlink" title="获取Connection对象"></a>获取Connection对象</h3><p>Connection对象是JDBC封装的数据库连接对象，语法：</p>
<p><strong><code>DriverManager.getConnection(url, username, password);</code></strong></p>
<p>Connection对象的获取需要用到DriverManager对象，DriverManager的getConnection( )</p>
</li>
</ol>
<p>方法通过数据库连接URL、数据库用户名及数据库密码创建Connection对象。</p>
<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line">   <span class="type">String</span> <span class="variable">Driver</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>; </span><br><span class="line">   Class.forName(Driver);<span class="comment">//加载数据库驱动，注册到驱动管理器</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db_database10&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;654321&quot;</span>;</span><br><span class="line">   <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(URL, userName, password);<span class="comment">//创建数据库连接</span></span><br><span class="line">   <span class="keyword">if</span>(conn != <span class="literal">null</span>) &#123;<span class="comment">//判断数据库连接是否为空</span></span><br><span class="line">   out.println(<span class="string">&quot;数据库连接成功!&quot;</span>);</span><br><span class="line">   conn.close()</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   out.println(<span class="string">&quot;数据库连接失败! &quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(ClassNotFoundException cn) &#123;</span><br><span class="line">  cn.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span>(SQLException se) &#123;</span><br><span class="line">se.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="Connection-接口"><a href="#Connection-接口" class="headerlink" title="Connection 接口"></a>Connection 接口</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Connection接口位于java.sql包中，是与特定数据库的连接会话，只有获得特定数据库的连接对象，才能访问数据库、v奥做数据库中的数据表、视图和存储过程等。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="void-close-throws-SQLException"><a href="#void-close-throws-SQLException" class="headerlink" title="void close( ) throws SQLException"></a>void close( ) throws SQLException</h5><p>立即释放此Connection对象的数据库连接占用的JDBC资源。在操作数据库后，应立即调用此方法。</p>
<h5 id="Statement-createStatement-throws-SQLException"><a href="#Statement-createStatement-throws-SQLException" class="headerlink" title="Statement createStatement( ) throws SQLException"></a>Statement createStatement( ) throws SQLException</h5><p>创建一个Statement对象来将SQL语句发送到数据库，此方法返回Statement对象。</p>
<h3 id="DriverManager-类"><a href="#DriverManager-类" class="headerlink" title="DriverManager 类"></a>DriverManager 类</h3><p>使用JDBC操作数据库，需要使用数据库厂商提供的驱动。该类主要作用于用户和驱动程序之间，管理数据库厂商提供的驱动程序，并建立应用程序与数据库之间的连接。<strong>此类的getConnection(String url, String user, String password) throws SQLException根据指定的数据库连接url等，建立数据库连接的Connection对象。</strong></p>
<h3 id="Statement接口"><a href="#Statement接口" class="headerlink" title="Statement接口"></a>Statement接口</h3><p>在创建了数据库连接之后，就可以通过程序来调用SQL语句对数据库进行操作，<strong>而该接口就提供了执行语句和获取查询结果的基本方法</strong>。</p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>boolean execute(String sql) throws SQLException执行指定的SQL语句，如果SQL语句返回结果，此方法返回true，否则返回false。</li>
<li>int executeQuery(String sql) throws SQLException执行SQL语句中的DML类型(insert\update\delete)的SQL语句，返回影响的行数。</li>
<li>ResultSet executeQuery(String sql) throws SQLException执行查询类型的SQL语句，返回查询所获取的结果集ResultSet对象。</li>
</ul>
<h3 id="PreparedStatement接口"><a href="#PreparedStatement接口" class="headerlink" title="PreparedStatement接口"></a>PreparedStatement接口</h3><p>继承于Statement接口，拥有Statement接口中的方法，而且针对带有参数的SQL语句的执行操作进行了拓展。</p>
<h4 id="与上区别"><a href="#与上区别" class="headerlink" title="与上区别"></a>与上区别</h4><ul>
<li><p><strong>应用于PreparedStatement接口中的SQL语句，可以使用占位符”?”来代替SQL语句中的参数，然后再对其进行赋值。</strong></p>
</li>
<li><p>会先初始化SQL，先把这个SQL提交到数据库进行预处理，多次使用可提高效率；createStatement不会初始化，没有预处理，每次都是从0开始执行SQL。</p>
</li>
<li>PreparedStatement是预编译的，对于批量处理可以大大提高效率，也叫JDBC存储过程。当在对数据库进行一次性存取的时候，用createStatement对象进行。</li>
</ul>
<h3 id="ResultSet接口"><a href="#ResultSet接口" class="headerlink" title="ResultSet接口"></a>ResultSet接口</h3><p>在JDBC中使用Resultset对象来接收查询结果集。<strong>ResultSet包含了符合SQL语句的所有行</strong>。zhenduiJava中的数据类型，提供了Getxxx的方法，可以获得每一行的数据。</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul>
<li><p><strong>==其中数据其实放在ResultSet结果集的中间部分，第一行和最后一行都是空的。==</strong></p>
</li>
<li><p><strong>默认情况下，ResultSet的光标位置在第一行数据之前，故在第一次获取数据时就需要移动光标位置。</strong></p>
</li>
</ul>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p><strong>INSERT语句</strong>，语句中的参数可以使用占位符“？”代替，然后通过PreparedStatement对其赋值并执行SQL</p>
<p><code>String sql=&quot;INSERT INTO tb_account(username, password) VALUES (?,?)&quot;;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Config config)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into category values(null,?,?)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DBUtil.getConnection();</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> c.prepareStatement(sql);</span><br><span class="line">            ps.setString(<span class="number">1</span>, config.key);</span><br><span class="line">            ps.setString(<span class="number">2</span>, config.value);</span><br><span class="line">            ps.execute();</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.getGeneratedKeys();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line">                config.id = id;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DBUtil.getConnection();</span><br><span class="line">            <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from category where id = &quot;</span> + id ;</span><br><span class="line">            s.execute(sql);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><em>在AddBook.jsp页面中，首先通过&lt; jsp:useBean &gt;实例化JavaBean对象Book，并通过&lt; jsp:setProperty &gt;对Book对象中的属性赋值，在构建了图书对象后通过JDBC技术，将其写入数据库。</em></p>
<p><strong>&lt; jsp:setProperty &gt;标签的property属性的值可以设置为”<em>“，它的作用是将与表单中同名称的属性值赋给JavaBean对象中的同名属性(\</em>为快速赋值)。</strong></p>
<p><strong>使用PreparedStatement对象给SQL语句的占位符参数赋值，==其参数的下标值不是0，而是1==，与数组的下标有所区别。</strong></p>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p><strong>SELECT语句</strong>，使用JDBC查询数据需要通过一个ResultSet对象来装载查询结果集，从数据表中所查询到的数据都放置在这个集合中。</p>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p><strong>Update语句</strong></p>
<h3 id="删除语句"><a href="#删除语句" class="headerlink" title="删除语句"></a>删除语句</h3><p><strong>DELETE语句</strong></p>
<h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>为了解决数据库频繁连接、关闭操作的问题，JDBC的批处理提供很好的解决方案，批量将SQL语句一次性发送到数据库中进行执行。</p>
<p>代码待补充……</p>
]]></content>
      <tags>
        <tag>Somthing of JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_Ending</title>
    <url>/2021/12/26/Java-Ending/</url>
    <content><![CDATA[<h1 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h1><p><img src="https://s2.loli.net/2021/12/26/AcuBF8l3NnZyqLT.png" alt="image-20211226201329697"></p>
<h2 id="部署的三种选择："><a href="#部署的三种选择：" class="headerlink" title="部署的三种选择："></a>部署的三种选择：</h2><h3 id="本机"><a href="#本机" class="headerlink" title="本机"></a>本机</h3><p>整个程序都在用户的计算机上以独立、可携的GUI执行，并以可执行的Jar来部署。</p>
<h4 id="把程序包进JAR"><a href="#把程序包进JAR" class="headerlink" title="把程序包进JAR"></a>把程序包进JAR</h4><p>JAR就是Java ARchive。这种文件是个pkzip格式的文件，能把一组类文件包装起来，所以交付时只需要一个用jar整理的JAR文件。</p>
<p>问题是用户拿JAR怎么办？</p>
<p>要创建出可执行的JAR！</p>
<p><strong>可执行的JAR代表用户不需要把文件抽出来就能运行。程序可以在类文件保存在JAR的情况下执行。秘诀在于创建出manifest文件，它会带有JAR的信息，告诉Java虚拟机那个类中含有main( )这个方法。</strong></p>
<p><img src="https://s2.loli.net/2021/12/26/k2BsEUqT91JSjAF.png" alt="image-20211226202235036"></p>
<p><img src="https://s2.loli.net/2021/12/26/sGPyLlScK4pIjZU.png" alt="image-20211226202446339"></p>
<p><img src="https://s2.loli.net/2021/12/26/iuhzUtRKg6Wwl32.png" alt="image-20211226202747131"></p>
<h4 id="防止包命名冲突"><a href="#防止包命名冲突" class="headerlink" title="防止包命名冲突"></a>防止包命名冲突</h4><p>Sun建议的命名规则能够大幅降低冲突的可能性——加上你所取得的域名称。即反向使用domain</p>
<p><img src="https://s2.loli.net/2021/12/26/Evz9lf7GkeOdiPZ.png" alt="image-20211226203047748"></p>
<p><img src="https://s2.loli.net/2021/12/26/LbZEgFcA3N1yj9D.png" alt="image-20211226203530158"></p>
<p><img src="https://s2.loli.net/2021/12/26/oxzSFOIr5aswMJ1.png" alt="image-20211226203551529"></p>
<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><p><img src="https://s2.loli.net/2021/12/26/VGsw5lEaxBMZOeK.png" alt="image-20211226203617583"></p>
<h3 id="两者的组合"><a href="#两者的组合" class="headerlink" title="两者的组合"></a>两者的组合</h3><p>应用程序被分散成用户本地系统运行的客户端，连接到执行应用程序服务的服务器部分。</p>
<h3 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h3><p>整个应用程序都在服务器端执行，客户端通过非Java形式，可能是浏览器的装置来存取。 </p>
]]></content>
      <tags>
        <tag>Here comes the end of Head First of Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Learing 2</title>
    <url>/2021/05/31/Java-Learing-2/</url>
    <content><![CDATA[<blockquote>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="一、关于Java中的数据类型"><a href="#一、关于Java中的数据类型" class="headerlink" title="一、关于Java中的数据类型:"></a>一、关于Java中的数据类型:</h2><h4 id="1-简单数据类型，即基本数据类型，有固定的存储长度"><a href="#1-简单数据类型，即基本数据类型，有固定的存储长度" class="headerlink" title="1.简单数据类型，即基本数据类型，有固定的存储长度"></a>1.简单数据类型，即基本数据类型，有固定的存储长度</h4><h6 id="包括整数类型，浮点类型，字符类型，布尔类型"><a href="#包括整数类型，浮点类型，字符类型，布尔类型" class="headerlink" title="包括整数类型，浮点类型，字符类型，布尔类型"></a>包括整数类型，浮点类型，字符类型，布尔类型</h6><h4 id="2-复杂数据类型，又名引用类型"><a href="#2-复杂数据类型，又名引用类型" class="headerlink" title="2.复杂数据类型，又名引用类型"></a>2.复杂数据类型，又名引用类型</h4><h6 id="包括数组，类，接口-interface-，其存储空间取决于组成内容-由几个基本数据类型，或几个复合数据类型组成"><a href="#包括数组，类，接口-interface-，其存储空间取决于组成内容-由几个基本数据类型，或几个复合数据类型组成" class="headerlink" title="包括数组，类，接口(interface)，其存储空间取决于组成内容(由几个基本数据类型，或几个复合数据类型组成)"></a>包括数组，类，接口(interface)，其存储空间取决于组成内容(由几个基本数据类型，或几个复合数据类型组成)</h6><hr>
<h2 id="二、数据类型之间的转换"><a href="#二、数据类型之间的转换" class="headerlink" title="二、数据类型之间的转换"></a>二、数据类型之间的转换</h2><h5 id="byte-1-→short-2-→char-2-→int-4-→long-8-→float-4-→double-8"><a href="#byte-1-→short-2-→char-2-→int-4-→long-8-→float-4-→double-8" class="headerlink" title="byte(1)→short(2)→char(2)→int(4)→long(8)→float(4)→double(8)"></a>byte(1)→short(2)→char(2)→int(4)→long(8)→float(4)→double(8)</h5><p><strong><em>特别注意，布尔类型(boolean)(只包括true,false)不与其他类型进行转换</em></strong></p>
<p><strong>在Java中，所有数据类型所占字节数量与平台无关。</strong></p>
<p><strong>此外，Java没有任何无符号的(unsigned)形式的int, long, short或byte类型。</strong></p>
</blockquote>
<hr>
<hr>
<blockquote>
<h1 id="amp-amp-输入输出"><a href="#amp-amp-输入输出" class="headerlink" title="&amp;&amp;输入输出"></a>&amp;&amp;输入输出</h1><h2 id="一、标准输入流输入数据"><a href="#一、标准输入流输入数据" class="headerlink" title="一、标准输入流输入数据:"></a>一、标准输入流输入数据:</h2><p>  <code>byte System.in.read()</code>(即所获取数据为字节类型)</p>
<p>字符串输入:</p>
</blockquote>
<p><code>BufferedReader in = new BufferedReader(new InputStreamReader(System.in))(经过对System.in的层层修饰)</code></p>
<p><code>String s = in.readLine();</code></p>
<blockquote>
<p>  常用:</p>
<p><code>Scanner  sc = new Scanner(System.in);</code></p>
</blockquote>
<p><code>String sr = sc.nextLine();</code></p>
<p><code>int a = sc.nextInt();</code></p>
<p><code>String s = sc.next();</code></p>
<blockquote>
<p>  <code>swing对话框:</code></p>
</blockquote>
<p><code>String s = JOptionPane.showInputDialog(Message)</code></p>
<p><code>int i = Integer.parseInt(s);</code></p>
<blockquote>
<h2 id="二、输出数据"><a href="#二、输出数据" class="headerlink" title="二、输出数据:"></a>二、输出数据:</h2></blockquote>
<ul>
<li><p><code>System.out.println(x);//输出后带换行</code></p>
</li>
<li><p><code>System.out.print(x);//输出后无换行</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（以上两者可用String.format(&quot;%.2f&quot;,x)替换x，以控制x输出格式）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>System.out.printf()(可加输出格式控制，类似C语言中printf)</code></li>
</ul>
]]></content>
      <tags>
        <tag>数据类型与输入输出</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Learning</title>
    <url>/2021/05/29/Java-Learing/</url>
    <content><![CDATA[<p>It’s time to begin the learning of Java!</p>
<blockquote>
<p>​    关于Java的命令行编译运行方式：</p>
<p>​        1.利用记事本/Notepad++建立一个文件，之后重命名为.java文件，<strong><em>Win + R</em></strong>，输入cmd，打开命令行窗口，转换至java文件储存的文件夹内。如：在E盘建立Test.java文件，则在命令行输入E:，转至E盘,转至子文件，则输入<em>cd 子文件名</em></p>
<p>​        2.输入<strong><em>javac Test.java</em>（中有空格，拓展名.java一定要加上）</strong>编译.java文件，此步会生成Test.class这个字节码文件（.java文件中类的数量决定了字节码文件的数量）</p>
<p>​        3.在命令行窗口输入<strong><em>java Test</em>（中有空格，注意不加拓展名.class)</strong>运行字节码文件，即可得运行结果。</p>
<p>​        <em>注：编译过程使用javac.exe（Java编译器），故而编译时要输入指令javac；运行过程使用java.exe（虚拟机）。</em></p>
<p>在Java中，所有数据类型所占字节数量与平台无关。</p>
<p>此外，Java没有任何无符号的(unsigned)形式的int, long, short或byte类型。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>plus</title>
    <url>/2021/10/08/Java-Learning-3%20plus/</url>
    <content><![CDATA[<h1 id="ArrayList与一般数组"><a href="#ArrayList与一般数组" class="headerlink" title="ArrayList与一般数组"></a>ArrayList与一般数组</h1><p>​        相同点：</p>
<ul>
<li><p>二者都为对象，都保存在堆上</p>
</li>
<li><p>二者都可保存数据引用和primitive主数据类型</p>
</li>
<li><p>创建时指定类型</p>
<p>不同点：</p>
<p>| 对比 | 一般数组                                       | ArrayList                                                    |<br>| —— | ——————————————————————— | —————————————————————————————— |<br>| 创建 | 需要指定大小                                   | 只需创建出该类型对象即可，无需指定大小（在增加或删除时，自行调整大小） |<br>| 方法 | 并无方法可调用，最多使用如length这样的实例变量 | 建立的是一个类对象，可以使用“.”运算符来调用其方法            |<br>| 存放 | 必须指定位置，若下标溢出，执行会抛出异常       | 无需指定索引值，可使用add方法，让其自行管理大小              |<br>| 语法 | 可使用特殊语法[ ]来调用数组元素                | 普通对象，不可使用[ ]这样的特殊语法                          |</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Java API extension</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Learning 3</title>
    <url>/2021/06/04/Java-Learning-3/</url>
    <content><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="常见集合"><a href="#常见集合" class="headerlink" title="常见集合"></a>常见集合</h2><p>ArrayList是最常用的API，但不是唯一的。</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p> 以有序的状态保持并可防止重复。</p>
<p>但是如果没有需要让清单保持有序的状态，TreeSet的成本会比想付出的还要多—-每当插入新项目，都要花时间找到合适的位置，而ArrayList只要把项目放在最后面就好。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>可用成对的name/value来保存与取出</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>针对经常插入或删除中间元素所涉及的高效率集合。（实际上ArrayList还是比较实用）</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>防止重复的集合，可快速地找寻相符的元素。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>类似HashMap，但可记住元素插入的顺序，也可以设定成按照元素上次存取的先后来排序。</p>
<p><img src="https://s2.loli.net/2021/12/26/RjgciyJoDFGkQIN.png" alt="image-20211226110456330"></p>
<h2 id="Perface"><a href="#Perface" class="headerlink" title="Perface"></a>Perface</h2><h3 id="Collections-sort"><a href="#Collections-sort" class="headerlink" title="Collections.sort( )"></a>Collections.sort( )</h3><p>鉴于ArrayList是最常用的集合，而且实现了List接口。恰巧，Collections这个类中存在sort( )方法，要用到List。所以多亏了多态机制，可以把ArrayList传给用到了List的方法。也就是说，可以使用Collections.sort( )方法来实现排序。</p>
<p>当歌曲的类型，由String变为Song时，可以明显发现编译器报错。也就是，ArrayList<String> 和 ArrayList<Song>之间的差异导致。</p>
<p><img src="https://s2.loli.net/2021/12/26/XJNW7FbSmytRw39.png" alt="image-20211226115014403"></p>
<h2 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h2><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><h4 id="泛型意味着更好的类型安全性。"><a href="#泛型意味着更好的类型安全性。" class="headerlink" title="泛型意味着更好的类型安全性。"></a>泛型意味着更好的类型安全性。</h4><p>几乎所有会以泛型写的程序都与处理集合有关。虽然泛型也可以用在其他地方，但它的<strong>主要目的还是让你能够写出有安全类型的集合</strong>。也就是，<strong>让编译器能够帮助防止把Dog加到一群Cat中。</strong></p>
<p>在泛型功能出现之前，编译器无法注意到加入集合中的东西是什么，因为所有的集合都写成处理Object类型，可以把任何东西放进ArrayList中，就类似于ArrayList<Object>。<strong>运用泛型，可以创建类型安全更好的集合</strong>，让问题尽可能在编译器就能抓到。</p>
<p><img src="https://s2.loli.net/2021/12/26/9Ph7AzNUo4eEMCm.png" alt="image-20211226120001237"></p>
<p><img src="https://s2.loli.net/2021/12/26/n6eZXf32TVu5sRK.png" alt="image-20211226120459538"></p>
<h4 id="泛型的本质为参数化类型，即程序中的数据类型被指定为一个参数E-Element-。"><a href="#泛型的本质为参数化类型，即程序中的数据类型被指定为一个参数E-Element-。" class="headerlink" title="泛型的本质为参数化类型，即程序中的数据类型被指定为一个参数E(Element)。"></a>泛型的本质为参数化类型，即程序中的数据类型被指定为一个参数E(Element)。</h4><p><strong>E代表用来创建与初始ArrayList的类型。</strong>在编译时，E会被指定的真正类型所取代(又称为类型参数)。这也是为何add( )这个方法无法加入与E所指定类型不兼容的引用的原因。若创建出ArrayList<Dog>, 则add( )会变成add(Dog o)。</p>
<p>其在定义时，不指明参数类型，在用时确定。</p>
<h3 id="运用泛型的方法"><a href="#运用泛型的方法" class="headerlink" title="运用泛型的方法"></a>运用泛型的方法</h3><p>泛型的类代表类的声明用到类型参数，泛型的方法代表方法的声明特征用到类型参数。</p>
<p>在方法中的类型参数有两种不同的运用方式。</p>
<h4 id="使用定义在类声明的类型参数"><a href="#使用定义在类声明的类型参数" class="headerlink" title="使用定义在类声明的类型参数"></a>使用定义在类声明的类型参数</h4><p><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;...&#123;</code></p>
<p><code>public boolean add(E o)</code> //只能在此使用E，因为已经被定义为类的一部分</p>
<p><code>&#125;</code></p>
<p><strong>当声明类的类型参数时，就可以把该类或接口类型用在任何地方。参数的类型声明基本上会以用来初始化类的类型来取代。</strong></p>
<h4 id="使用未定义在类声明的类型参数"><a href="#使用未定义在类声明的类型参数" class="headerlink" title="使用未定义在类声明的类型参数"></a>使用未定义在类声明的类型参数</h4><p><code>public &lt;T extends Animal&gt; void takeThing(ArrayList&lt;T&gt; list)</code></p>
<p><strong>如果类本身没有使用类型参数，可通过在一个不寻常但可行的位置上指定给方法—-在返回类型之前。这意味着T可以是”任何一种Animal”。</strong></p>
<p>附：</p>
<p><img src="https://s2.loli.net/2021/12/26/l7UROxS1a5siVTu.png" alt="image-20211226122852024"></p>
<h3 id="回到引出的那个问题："><a href="#回到引出的那个问题：" class="headerlink" title="回到引出的那个问题："></a>回到引出的那个问题：</h3><p><img src="https://s2.loli.net/2021/12/26/VPBtOAGQiLpyNm6.png" alt="image-20211226123237186"></p>
<p>也就是说，sort( )方法只能接受Comparable对象的list。而Song不是Comparable的子型，所以不能。</p>
<p>但是，根据String的说明：</p>
<p><code>public final class String extends Object implements Serializable, Comparable&lt;String&gt;, CharSequence...</code></p>
<p>也就是说，<strong>String没有继承过Comparable，只有实现，因为Comparable是个接口</strong>，那为什么会是extends？</p>
<h4 id="以泛型的观点来说，extend代表extend或implement。"><a href="#以泛型的观点来说，extend代表extend或implement。" class="headerlink" title="以泛型的观点来说，extend代表extend或implement。"></a>以泛型的观点来说，extend代表extend或implement。</h4><p><strong>对一个泛型而言，extends这个关键词代表“是一个……”，且不管接口或类都能使用。也就是说，适用于extends和implements。</strong></p>
<h4 id="SO"><a href="#SO" class="headerlink" title="SO"></a>SO</h4><p><strong>Song类必须实现Comparable！</strong></p>
<p>只有在这种情况下，才能把ArrayList<Song>传给sort( )方法，因为这个方法就是如此声明的。况且，也需要确定两个Song如何比较的大小。</p>
<p><img src="https://s2.loli.net/2021/12/26/sMv1TYhmF2oknrd.png" alt="image-20211226124605060"></p>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20211226124953490.png" alt="image-20211226124953490"></p>
<p>但是，如果想用多几种进行排序呢?</p>
<p>可以引出另一种sort( )方法—-取用Comparator参数。</p>
<h4 id="Another"><a href="#Another" class="headerlink" title="Another"></a>Another</h4><p>使用自制的Comparator，这是独立于所比较元素类型之外的——它是独立的类！因此，可以有各种不同的比较方法~~</p>
<p>取用Comparator版的sort( )方法会用Comparator而不是元素内置的CompareTo( )方法来比较顺序。也就是说，如果sort( )方法带有Comparator，就不会调用元素的CompareTo( )，而会去调用Comparator的Compare( )方法。</p>
<p><img src="https://s2.loli.net/2021/12/26/NHnioReGCWIEVJj.png" alt="image-20211226171420009"></p>
<h4 id="处理重复"><a href="#处理重复" class="headerlink" title="处理重复"></a>处理重复</h4><h5 id="LIST：对付顺序的好帮手"><a href="#LIST：对付顺序的好帮手" class="headerlink" title="LIST：对付顺序的好帮手"></a>LIST：对付顺序的好帮手</h5><p>一种知道索引位置的集合。</p>
<p>List直到某物在系列集合中的位置。可以有多个元素引用相同的对象。</p>
<h5 id="SET：注重独一无二的性质"><a href="#SET：注重独一无二的性质" class="headerlink" title="SET：注重独一无二的性质"></a>SET：注重独一无二的性质</h5><p>不允许重复的集合。</p>
<p>知道某物是否已经存在于集合中。不会有多个元素引用相同的对象。</p>
<h5 id="MAP：-用key来搜索的专家。"><a href="#MAP：-用key来搜索的专家。" class="headerlink" title="MAP： 用key来搜索的专家。"></a>MAP： 用key来搜索的专家。</h5><p>使用成对的键值和数据值。</p>
<p>Map会维护与key有关联的值。<strong>两个key可以引用相同的对象，但key不能重复</strong>，典型的key是String，但也可以是其他任何对象。</p>
<blockquote>
<p>泛型规则和限制：</p>
<ul>
<li>泛型的类型参数只能是类类型，不能是简单类型</li>
<li>泛型的参数类型可以有多个，如Map<K, V></li>
<li>泛型的参数类型可以使用extends语句，如<T extends M>，但此处的extends并非继承，而是类型限制，即在M范围内的T。</li>
<li>也可以使用通配符类型，即类似于&lt;? Extends M&gt;，是指在M范围内的某个类型，此处的?代表不定型。</li>
</ul>
</blockquote>
<h3 id="Collection-API"><a href="#Collection-API" class="headerlink" title="Collection API"></a>Collection API</h3><p><strong>接口Collection位于Collection API的最高层，定义了所有底层接口或类的公共方法。</strong></p>
<p><img src="https://s2.loli.net/2021/12/26/34MHN52sn7tSmUO.png" alt="image-20211226175620388"></p>
<p><img src="https://s2.loli.net/2021/12/26/4gLxYnumoHhwtPd.png" alt="image-20211226175744747"></p>
<p>所以，此处<strong>使用HashSet取代ArrayList</strong>。</p>
<h3 id="对象的相等"><a href="#对象的相等" class="headerlink" title="对象的相等"></a>对象的相等</h3><h4 id="引用相等性"><a href="#引用相等性" class="headerlink" title="引用相等性"></a>引用相等性</h4><p>堆上同一个对象的两个引用。</p>
<p>引用到堆上同一个对象的两个引用是相等的。如果对两个引用调用hashCode( )，会得到相同的结果。</p>
<blockquote>
<p>如果没有被覆盖的话，hashCode( )默认的行为会返回每个对象特有的序号(大部分Java版本是依据内存位置计算此序号，所以不会有相同的hashcode。)</p>
</blockquote>
<p><strong>要知道两个引用是否相等，可以使用==来比较变量上的字节组合</strong>。如果是相同的对象，字节组合也一样。</p>
<h4 id="对象相等性"><a href="#对象相等性" class="headerlink" title="对象相等性"></a>对象相等性</h4><p>堆上的不同两个对象在意义上是相同的。</p>
<p>如果你想要把两个不同的Song对象视为相等的,就必须覆盖过从Object继承下来的hashCode( )方法与equals()方法。就因为上面所说的内存计算问题, 所以你必须覆盖过hashCode( )才能确保两个对象有相同的hashcode, 也要确保以另一个对象为参数的equals( )调用会返回true。</p>
<p><img src="https://s2.loli.net/2021/12/26/rNl1MoT3asIdGPA.png" alt="image-20211226181219247"></p>
<p><img src="https://s2.loli.net/2021/12/26/ylYvh4RZu2q6CMI.png" alt="image-20211226181200357"></p>
<p><img src="https://s2.loli.net/2021/12/26/MFyzxri8KOEkcDW.png" alt="image-20211226181806418"></p>
<p><img src="https://s2.loli.net/2021/12/26/vMrlW1eN4mhXkwn.png" alt="image-20211226182244389"></p>
<p>API文件有对对象的状态制定出必须遵守的规则:</p>
<p>(1）如果两个对象相等,则hashcode必须也是相等的。</p>
<p>(2）如果两个对象相等, 对其中一个对象调用equals()必须返回true。也就是说,若a.equals(b).则b.equals(a).</p>
<p>(3）如果两个对象有相同的hashcode值, 它们也不一定是相等的。但若两个对象相等, 则hashcode值一定是相等的。</p>
<p>(4）若equals()被覆盖过，则hashCode()也必须被覆盖。</p>
<p>(5) hashCode()的默认行为是对在heap上的对象产生独特的值。如果你没有override过hashCode(),则该class的两个对象怎样都不会被认为是相同的。</p>
<p>(6)equals()的默认行为是执行==的比较。也就是说会去测试两个引用是否对上heap上同一个对象。如果equals()没有被覆盖过,两个对象永远都不会被视为相同的,因为不同的对象有不同的字节组合。</p>
<p><img src="https://s2.loli.net/2021/12/26/BSQdlC9kRIVxru1.png" alt="image-20211226182512343"></p>
<h4 id="Something-About-TreeSet"><a href="#Something-About-TreeSet" class="headerlink" title="Something About TreeSet"></a>Something About TreeSet</h4><p><img src="https://s2.loli.net/2021/12/26/gIQXAxSnyqZz5v2.png" alt="image-20211226182608504"></p>
<p><img src="https://s2.loli.net/2021/12/26/PkmZnsKwjTtXGaQ.png" alt="image-20211226185927531"></p>
<h4 id="1-Collection-接口"><a href="#1-Collection-接口" class="headerlink" title="1. Collection 接口"></a>1. Collection 接口</h4><h5 id="常用的方法："><a href="#常用的方法：" class="headerlink" title="常用的方法："></a>常用的方法：</h5><p>​    boolean add(E obj)</p>
<p>​    boolean isEmpty()</p>
<p>​    Iterator<E> iterator() : 获取手机的Iterator接口实例</p>
<p>​    Object[] toArray() : 将收集变为对象数组</p>
<h5 id="关于Iterator接口"><a href="#关于Iterator接口" class="headerlink" title="关于Iterator接口:"></a>关于Iterator接口:</h5><ol>
<li><p>boolean hasNext(): 是否存在下一个元素</p>
</li>
<li><p>Object next(): 返回要访问的下一个元素，若无，引发异常</p>
</li>
</ol>
<h4 id="2-Set-接口"><a href="#2-Set-接口" class="headerlink" title="2. Set 接口"></a>2. Set 接口</h4><p>特点：不含重复元素，且无序，其中的SortedSet接口用于描述按“自然顺序”组织元素的收集，即其中对象有序。</p>
<p>其判断集合中重复元素的标准为按对象值比较，即使用equals()方法。</p>
<p>迭代器：Iterator it = Set.iterator();</p>
<h4 id="3-List-接口"><a href="#3-List-接口" class="headerlink" title="3. List 接口"></a>3. List 接口</h4><p>特点：其中可含重复元素，且有序。包括ArrayList与LinkedList两个类。</p>
<p>常用方法：</p>
<p>​    void add(E e) : 在尾部添加元素</p>
<p>​    void add(int pos, E e) : 在指定位置添加元素</p>
<p>​    E get(int pos) : 返回指定位置的元素</p>
<p>​    E set(int pos, E e) : 更改指定位置的元素</p>
<p>​    E remove(int pos) : 删除指定位置的元素</p>
<p>ArrayList 与 LinkedList区别：</p>
<p>​    前者使用数组存储元素，可以实现快速访问元素；后者使用双向链表，可以实现快速插入，删除元素。</p>
<h4 id="4-Map-接口"><a href="#4-Map-接口" class="headerlink" title="4. Map 接口"></a>4. Map 接口</h4><h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><p>public Set<K> keySet(): 关键字的集合</p>
<p>public Collection<V> values() : 值的集合</p>
<p>public Set<Map.Entry<K, V> &gt;entrySet : 关键字和值的映射关系的集合</p>
<p>public V get(K key) : 获取关键字对应的值</p>
<p>public V put(K key, V val) : 加入新的映射；若已经存在，修改映射的值，返回原映射的值，否则，返回null</p>
<p>public V remove(Object key) : 删除关键字多对应的映射，返回值同上。</p>
<p>public boolean equals(Object obj) : 判断Map对象与参数对象是否等价，两个相同的Map，其映射关系集合应当一致</p>
<p>public boolean containsKey(Object key): 是否存在于关键值匹配的映射关系</p>
<p>public boolean containsValues(Object value) : 是否存在与键值匹配的映射关系</p>
<h6 id="另："><a href="#另：" class="headerlink" title="另："></a>另：</h6><p>​    <code>通过与Set接口的结合，可以实现由值取关键字。即首先将关键字通过keySet()提取出来进入Set s中，而后通过迭代器for(Iterator it = s.iterator();it.hasNext();),  匹配m.get(it.next()).equals(V value)或 for(T s : s) 遍历(T为Set中元素的数据类型），m.get(s).equals(V value)来查找值对应的关键字</code></p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在普通数组的情况下，Dogs[ ]可以调用Animals[ ]的方法，即可以将其作为参数传入以Animal为参数的方法中。</p>
<p>但在泛型中，这是不允许的。</p>
<p>吃个栗子：<img src="https://s2.loli.net/2021/12/26/MVXCheT5z6G8LQ3.png" alt="image-20211226192723304"></p>
<p>很显然的是，就普通数组而言，不可调用add方法，也就是说，不会出现这种添加情况，编译不会通过。但泛型中存在这种情况，如果允许Dogs[ ]传入，会导致在dog中混入一只cat，这显然不合理。</p>
<p>其实，数组也能进行相应的操作的哦。</p>
<p><strong>数组的类型是在运行期间检查的，但集合的类型检查只会发生在编译期间。</strong></p>
<p>这也就是为何数组这样操作，可以逃过编译(但运行的时候会出错)，而集合却不能。</p>
<p>如果把方法的参数设定为ArrayList<Animal>，那么Array<Cat>和Array<Dog>都不可用。</p>
<h3 id="万用字符"><a href="#万用字符" class="headerlink" title="万用字符"></a>万用字符</h3><p>这样设定方法的参数为ArrayList<Animal>时，就可以接收Animal子型参数了。</p>
<p><img src="https://s2.loli.net/2021/12/26/nwfPWjNJMEtukZ9.png" alt="image-20211226194114402"></p>
<p>但是，注意：</p>
<p><strong>在这种情况下，只能使用list中任何元素的方法，不能在list中新增元素!!!</strong></p>
<p>也就是说，可以操作集合元素，但不能新增集合元素。如此才能保障执行期间的安全性，因为编译器会阻止执行期的恐怖行动。</p>
<p><code>for(Animal a:animals) &#123;</code></p>
<p><code>a.eat();&#125; //可以的</code></p>
<p><code>for (Animal a:animals) &#123;</code> </p>
<p><code>a.add(new Cat());&#125;// 不可以！</code></p>
<p><img src="https://s2.loli.net/2021/12/26/HYxVAqajiUOR1cl.png" alt="image-20211226194715004"></p>
]]></content>
      <tags>
        <tag>Java Learning 3</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Learning-4</title>
    <url>/2021/08/27/Java-Learning-4/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">design</span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		EventQueue.invokeLater(() -&gt; <span class="comment">// 事件分派线程中的执行代码</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotHelloFrame</span>();</span><br><span class="line">			frame.setTitle(<span class="string">&quot;What you buy&quot;</span>);</span><br><span class="line">				frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">			frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotHelloFrame</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">NotHelloFrame</span><span class="params">()</span> &#123;</span><br><span class="line">		add(<span class="keyword">new</span> <span class="title class_">NotHelloComponent</span>());</span><br><span class="line">		pack();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotHelloComponent</span> <span class="keyword">extends</span> <span class="title class_">JComponent</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MESSAGE_X</span> <span class="operator">=</span> <span class="number">75</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MESSAGE_Y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_WIDTH</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_HEIGHT</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paintComponent</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">		g.drawString(<span class="string">&quot;What are you want?&quot;</span>, MESSAGE_X, MESSAGE_Y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Dimension <span class="title function_">getPreferredSize</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dimension</span>(DEFAULT_WIDTH, DEFAULT_HEIGHT);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>绘制图像框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Learning-5</title>
    <url>/2021/11/12/Java-Learning-5/</url>
    <content><![CDATA[<h1 id="Java中的继承"><a href="#Java中的继承" class="headerlink" title="Java中的继承"></a>Java中的继承</h1><h2 id="例：设计动物仿真程序的继承树"><a href="#例：设计动物仿真程序的继承树" class="headerlink" title="例：设计动物仿真程序的继承树"></a>例：设计动物仿真程序的继承树</h2><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li>找出具有共同属性和行为的对象</li>
<li>设计代表共同状态与行为的类</li>
<li>决定子列是否需要让某项行为(也就是方法的实现)有特定不同的运作方式</li>
<li>通过寻找使用共同行为的子类来找出更多抽象化的机会</li>
<li>完成类的继承层次</li>
</ol>
<h4 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h4><p>以Wolf类为例，其包括继承自Animal和Canine两类在内，一共四个方法。具体在调用对象引用的方法时，会调用到与该对象类型最接近的方法。换句话说，最低阶的会胜出！即，Java虚拟机会从继承树最底层(层次树的最下方)Wolf开始，若有符合Wolf版的方法，则直接进行调用。若无，则继续向上，去查找Animal中相应的方法，依此类推，直到找到为止。</p>
]]></content>
      <tags>
        <tag>Extends</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_Thread</title>
    <url>/2021/12/14/Java-Thread/</url>
    <content><![CDATA[<p>The beginning of thread.</p>
<p>Java 有多个线程但只有一种Thread类。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="Some-Basic-Concepts"><a href="#Some-Basic-Concepts" class="headerlink" title="Some Basic Concepts"></a>Some Basic Concepts</h2><p>线程是独立的线程，他代表独立的执行空间。</p>
<p>Thread是Java中用来表示线程的类，要建立线程就得创建Thread。</p>
<p>每一个Java应用程序会启动一个主线程—将main( )放在自己执行空间的最开始出。Java虚拟机会负责主线程的启动(如垃圾回收所需的系统用线程)。程序员要负责启动自己建立的线程。</p>
<h2 id="What-does-having-more-than-one-executing-space-symbolize"><a href="#What-does-having-more-than-one-executing-space-symbolize" class="headerlink" title="What does having more than one executing space symbolize?"></a>What does having more than one executing space symbolize?</h2><p>当有超过一个以上的执行空间时，看起来好像是有好几件事同时发生。但实际上，执行动作可以在执行空间中快速地来回切换。<strong>Java也只是个在底层操作系统上执行的进程</strong>。一旦轮到Java执行时，Java虚拟机会执行<strong>目前执行空间最上面的</strong>。</p>
<p>线程要记录的一项事务是<strong>目前线程执行空间做到哪里</strong>。</p>
<p>举个栗子：</p>
<p>Java虚拟机调用main( )主线程。</p>
<p>main( )中建立了一个Thread对象t，并启动了新线程t.start( )。则此时，堆上新增线程t.start( )，另起一执行空间，启动自建线程中的run( )，在新线程启动期间，main( )会暂停执行。</p>
<p>之后，会在主线程和用户自建线程之间来回切换，直到二者全部执行完毕。</p>
<h2 id="如何启动新的线程？"><a href="#如何启动新的线程？" class="headerlink" title="如何启动新的线程？"></a>如何启动新的线程？</h2><ol>
<li><p>建立Runnable对象(线程的任务)</p>
<p><code>Runnable threadJob = new MyRunnable();</code></p>
</li>
<li><p>建立Thread对象(执行工人)并赋值Runnable(任务)</p>
<p><code>Thread myThread = new Thread(threadJob);</code></p>
<p>把Runnable对象传给Thread的构造函数。这会告诉Thread对象要把那个方法放在执行空间区运行—Runnable的run( )方法。</p>
</li>
<li><p>启动Thread</p>
<p>myThread.start( );</p>
<p>在还没有调用Thread的start( )方法之前，什么也不会发生。当新的线程启动之后，它会把Runnable对象的方法摆到新的执行空间中。<img src="https://s2.loli.net/2021/12/21/sAT4lDncoZfyLRm.png" alt="image-20211221191525894"></p>
</li>
</ol>
<blockquote>
<p>对于Thread而言，它相当于一个工人，对于Runnable而言，它相当于这个工人要完成的工作。Runnable带有会放在执行空间的第一项的方法：run( )。</p>
</blockquote>
<p>Thread对象需要任务，任务是线程在启动时去执行的工作。<strong>run( )该任务是新线程空间上的第一个方法</strong>，且一点更要长得像下面这样:</p>
<p>public void run( ) {</p>
<p>​    //会被新线程执行的代码</p>
<p>}</p>
<p>Runnable定义了一个协约。因为Runnable是个接口，线程的任务可以被定义在任何实现Runnable的类上。线程只在乎传入给Thread的构造函数的参数是否为实现Runnable的类。当把Runnable传给Thread的构造函数时，实际上就是在给Thread取得run( )的方法，即给了Thread一项任务。Runnable接口只有run( )这一个方法。</p>
<blockquote>
<p>在调用start( )开始执行线程之前，对象只是个Thread实例，并不是真正的线程。</p>
</blockquote>
<p><img src="https://s2.loli.net/2021/12/21/7Tycos9U2SWEKnu.png" alt="image-20211221211338659"></p>
<h3 id="新建线程的三个状态"><a href="#新建线程的三个状态" class="headerlink" title="新建线程的三个状态"></a>新建线程的三个状态</h3><ol>
<li><h4 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h4><p>Thread t = new Thread(r);</p>
</li>
</ol>
<p>Thread的实例已经创建，但还没有启动。也就是说，有Thread对象，没有执行中的线程。</p>
<ol>
<li><h4 id="可执行"><a href="#可执行" class="headerlink" title="可执行"></a>可执行</h4><p>t.start( );</p>
</li>
</ol>
<p>当启动线程时，它会变成可执行的状态。这时，线程已经布置好执行空间。</p>
<ol>
<li><h4 id="执行中-线程的目标"><a href="#执行中-线程的目标" class="headerlink" title="执行中(线程的目标)"></a>执行中(线程的目标)</h4><p>轮到它执行</p>
</li>
</ol>
<p>所有的线程都在等待这一刻，成为正在执行中的那一个。这只能靠Java虚拟机的线程调度机制来决定。有时也能对Java虚拟机选择执行的线程给点意见，但无法强迫它把线程从可执行状态移动到执行中。</p>
<blockquote>
<p>一旦线程进入可执行状态，他会在可执行与执行中两种状态中来来去去，同时也有另一种状态：暂时不可执行(又称为被堵塞状态)。</p>
</blockquote>
<h4 id="典型的可执行-执行中循环："><a href="#典型的可执行-执行中循环：" class="headerlink" title="典型的可执行/执行中循环："></a>典型的可执行/执行中循环：</h4><p>通常线程会在可执行与执行中两种状态中来回交替。因为Java虚拟机的线程调度会把线程跳出来运行又把它踢回去以让其他线程有执行机会。</p>
<h4 id="线程有可能会暂时被挡住"><a href="#线程有可能会暂时被挡住" class="headerlink" title="线程有可能会暂时被挡住"></a>线程有可能会暂时被挡住</h4><p>调度器会因为某些原因把线程送进去关一阵子。例如线程执行到等待Socket输入串流的程序段，但没有数据可供读取。调度器会把线程移出可执行状态等。会导致线程暂时失能。</p>
<h2 id="无法掌控的线程调度器"><a href="#无法掌控的线程调度器" class="headerlink" title="无法掌控的线程调度器"></a>无法掌控的线程调度器</h2><p>无法控制调度，没有API可以可调用调度器。调度器在不同的虚拟机上有不同的行为。最重要的是，调度无法确定。</p>
<p>也就是说，同一个多线程的程序，在不同的主机上运行，会导致不同的结果。甚至于同一个程序在同一台主机上运行的结果也是不确定的。不能让程序依靠调度的特定行为来保持执行的正确性！</p>
<p>吃个栗子：</p>
<p><img src="https://s2.loli.net/2021/12/21/UYbLWgKlOd8PzcT.png" alt="image-20211221215408955"></p>
<blockquote>
<p>调度不能保证任何的执行时间和顺序，所以你不能期待他会完全地平均分配执行，最多只能影响sleep的最小保证时间。</p>
</blockquote>
<p><img src="https://s2.loli.net/2021/12/21/9ZMQnxvV1BYprqX.png" alt="image-20211221222504166"></p>
<p>想要确保其他线程有机会执行的话，就把线程放进睡眠状态。</p>
<p><img src="https://s2.loli.net/2021/12/21/Trw8pfKCkvhcVOL.png" alt="image-20211221223345949"></p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="Ryan和Monica的透支银行余额事件"><a href="#Ryan和Monica的透支银行余额事件" class="headerlink" title="Ryan和Monica的透支银行余额事件"></a>Ryan和Monica的透支银行余额事件</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p><img src="https://s2.loli.net/2021/12/23/CdDtVX8cL95JMjP.png" alt="image-20211223154931306"></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><img src="https://s2.loli.net/2021/12/23/x1CTGOcV2d6nUzN.png" alt="image-20211223154659753"></p>
<p>每个对象都有个锁。大部分时间都没有锁上。对象的锁只会在有同步化的方法上起作用。当对象有一个或多个同步化的方法时，线程只有在取得对象锁的钥匙时，才能进入同步化的方法。</p>
<p>锁不是配在方法上的，而是配在对象上。如果对象有两个同步化的方法，就表示两个线程无法进入同一个方法，也表示两个线程无法进入不同的方法。如果有多个方法可能会操作对象的实例变量，则这些方法都应该有同步化的保护。</p>
<p><strong>同步化的目标是要保护重要的数据。但要注意，锁住的不是数据，而是存取数据的方法。</strong></p>
<p>所以线程在开始执行并遇到同步化的方法时，会认知到他需要对象的钥匙才能进入方法。<strong>他会取得钥匙，这是由Java虚拟机来处理的，没有可以存取对象锁的API。那么此时，他会保护好这把钥匙，直到完成同步化方法。</strong>与此同时，其他线程不可以进入该对象的同步化方法，因为只有这一把钥匙。</p>
<blockquote>
<p>只有当对象具有同步化方法时，才会上锁。而且线程只有取得钥匙后，才能进入该方法。也就是说，线程只有在没有其他线程已经进入的情况下，才能进入。</p>
</blockquote>
<h3 id="“丢失更新”问题"><a href="#“丢失更新”问题" class="headerlink" title="“丢失更新”问题"></a>“丢失更新”问题</h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>这是另一个典型的并行性(concurrency)问题。丢失更新(lost update)有一种特定的过程。</p>
<p>吃个栗子：</p>
<ol>
<li>取得账户余额 <code>int i = balance;</code></li>
<li>将账户余额增加 <code>balance = i + 1;</code></li>
</ol>
<blockquote>
<p>正常情况下，都是直接balance++; 但怎么说呢，偶尔会因为表达式的复杂，只得使用以上方法。</p>
</blockquote>
<p>看上去，这样没什么问题。</p>
<p>那么，若此时有两个线程A和B在执行这个方法。</p>
<p>A：取余额0，增加1，变为1；</p>
<p>​    再取余额1，增加1，变为2；</p>
<p>B：取余额2，增加1，变为3；</p>
<p>​    取余额3，B睡了，此时未增加。</p>
<p>A：取余额3，增加1，变为4；</p>
<p>​    取余额4，增加1，变为5。</p>
<p>B：苏醒，将其的i=3，增加1，余额balance变为4…….</p>
<blockquote>
<p>很明显，B更改了A增加的值，丢失了A进行的更新。</p>
</blockquote>
<p>此时，就需要同步化机制来帮忙，将 <code>int i = balance; balance = i + 1;</code>锁成整体，变得不可分割。</p>
<p><img src="https://s2.loli.net/2021/12/23/VGYbOyUdQhtsCwz.png" alt="image-20211223162430700"></p>
<p><img src="https://s2.loli.net/2021/12/23/OPUaqB8yWInmF3R.png" alt="image-20211223162514844"></p>
<h3 id="死锁现象"><a href="#死锁现象" class="headerlink" title="死锁现象"></a>死锁现象</h3><p>死锁会发生是因为两个线程互相持有对方正在等待的东西。没有方法可以脱离这个情况。所以只好一直等，一直等。</p>
<p>Java中没有处理死锁的机制，甚至它都不知道死锁的发生，所以要小心设计程序。如果经常编写多线程的程序，去看看O’Reilly出版的“Java Thread”。</p>
<p><img src="https://s2.loli.net/2021/12/23/rcYB15efjhOKvI7.png" alt="image-20211223162828317"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Thread.sleep()这个静态方法可以强制线程进入等待状态到过了设定的时间为止。</li>
<li>sleep()方法可能会抛出InterruptedException异常，所以要包在try/catch块中，或者把他也声明出来。</li>
<li>可以用setName来给线程命名，通常是用来除错的。</li>
<li>如果两个或以上线程存取堆上相同的对象可能会出现严重的问题。</li>
<li>如果两个或以上的线程存取相同的对象可能会引发数据的损毁。</li>
<li>使用synchronized这个关键词修饰符，可以防止两个线程同时进入同一个对象的同一个方法。</li>
<li>对象就算是有多个同步化的方法，也还是只有一个锁。一旦某个线程进入该对象的同步化方法，其他线程就无法进入该对象上的任何同步化方法。</li>
<li>不只对象有锁，类本身也是有锁的。也就是说，假如有3个Dog对象，那么此时应该是有4个锁。</li>
<li>故而，对静态变量进行同步化，线程想要进入方法就需要先获得类的锁。</li>
<li>同步化的根本目的是为了防止步骤被分割，也就是指定某段工作要在不能分割的状态下执行。单独的操作并不重要，重要的是拥有多个步骤的一个方法。</li>
</ol>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.print.PrinterJobWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/12/23 16:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleChatClient</span> &#123;</span><br><span class="line">    JTextArea incoming;</span><br><span class="line">    JTextField outgoing;</span><br><span class="line">    BufferedReader reader;</span><br><span class="line">    PrintWriter writer;</span><br><span class="line"></span><br><span class="line">    Socket socket;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleChatClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleChatClient</span>();</span><br><span class="line">        client.go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;Ludicrously Simple Chat Client&quot;</span>);</span><br><span class="line">        <span class="type">JPanel</span> <span class="variable">panel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">        incoming = <span class="keyword">new</span> <span class="title class_">JTextArea</span>(<span class="number">15</span>, <span class="number">50</span>);</span><br><span class="line">        incoming.setLineWrap(<span class="literal">true</span>);</span><br><span class="line">        incoming.setWrapStyleWord(<span class="literal">true</span>);</span><br><span class="line">        incoming.setEditable(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">JScrollPane</span> <span class="variable">scrollPane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JScrollPane</span>(incoming);</span><br><span class="line">        scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);</span><br><span class="line">        scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);</span><br><span class="line">        outgoing = <span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">sendButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Send&quot;</span>);</span><br><span class="line">        sendButton.addActionListener(<span class="keyword">new</span> <span class="title class_">SendButtonActionListener</span>());</span><br><span class="line">        panel.add(scrollPane);</span><br><span class="line">        panel.add(outgoing);</span><br><span class="line">        panel.add(sendButton);</span><br><span class="line">        setUpNetworking();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">readerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">IncomingReader</span>());</span><br><span class="line">        readerThread.start();</span><br><span class="line"></span><br><span class="line">        frame.getContentPane().add(BorderLayout.CENTER, panel);</span><br><span class="line">        frame.setSize(<span class="number">400</span>, <span class="number">500</span>);</span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用socket取得输入/输出串流，进行输入/输出事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setUpNetworking</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(host, port);</span><br><span class="line">            <span class="type">InputStreamReader</span> <span class="variable">streamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream());</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(streamReader);</span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream());</span><br><span class="line">            System.out.println(<span class="string">&quot;networking established&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendButtonActionListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent actionEvent)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.println(outgoing.getText());</span><br><span class="line">                writer.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            outgoing.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            outgoing.requestFocus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IncomingReader</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            String message;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((message = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;read &quot;</span> + message);</span><br><span class="line">                    incoming.append(message + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/12/23 17:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleChatServer</span> &#123;</span><br><span class="line">    ArrayList clientOutputStreams;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        BufferedReader reader;</span><br><span class="line">        Socket socket;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ClientHandler</span><span class="params">(Socket clientSocket)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket = clientSocket;</span><br><span class="line">                <span class="type">InputStreamReader</span> <span class="variable">isReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream());</span><br><span class="line">                reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isReader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            String message;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((message = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;read &quot;</span>+ message);</span><br><span class="line">                    tellEveryone(message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SimpleChatServer</span>().go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        clientOutputStreams = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(clientSocket.getOutputStream());</span><br><span class="line">                clientOutputStreams.add(writer);</span><br><span class="line"></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ClientHandler</span>(clientSocket));</span><br><span class="line">                t.start();</span><br><span class="line">                System.out.println(<span class="string">&quot;got a connection&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tellEveryone</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> clientOutputStreams.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> (PrintWriter) it.next();</span><br><span class="line">                writer.println(message);</span><br><span class="line">                writer.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Something about Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb</title>
    <url>/2022/01/09/JavaWeb/</url>
    <content><![CDATA[<h1 id="JavaWeb基础"><a href="#JavaWeb基础" class="headerlink" title="JavaWeb基础"></a>JavaWeb基础</h1><h2 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>一个Java项目基本包括：</p>
<ul>
<li>引入的依赖包</li>
<li>项目的目录结构</li>
<li>配置的环境</li>
<li>等等</li>
</ul>
<p>虽难度不大，但琐碎且耗时，所以需要一个标准化的Java项目管理和构建工具。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Maven就是专门为Java打造的管理和构建工具。主要功能：</p>
<ul>
<li>提供了一套标准化的项目结构；</li>
<li>提供了一套标准化的构建流程（编译，测试，打包，发布……）；</li>
<li>提供了一套依赖管理机制。</li>
</ul>
<h3 id="Maven项目结构："><a href="#Maven项目结构：" class="headerlink" title="Maven项目结构："></a>Maven项目结构：</h3><p>一个使用Maven管理的普通的Java项目，它的目录结构默认如下：</p>
<p><img src="https://s2.loli.net/2022/01/14/B9xbAFmDVcwXrGQ.png" alt="image-20220114171600543"></p>
<p><img src="https://s2.loli.net/2022/01/14/gtv5HIKcRPqiFZd.png" alt="image-20220114191840406"></p>
<p>其中，groupId类似Java中的包名，通常是公司或组织名称，artifactId类似Java中的类名，通常是项目名称。再加上version，一个Maven工程就是由groupId、artifactId和version作为唯一标识的。在引用其他方类库时，也是通过这3个变量确定。例如，依赖<code>commons-logging</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>使用<code>&lt;dependency&gt;</code>声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。</p>
<p><img src="https://s2.loli.net/2022/01/14/qkvcp8RU9W7NO4G.png" alt="image-20220114194907705"></p>
<h2 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>在平时的开发当中，一个项目往往包含了大量的方法，可能有成千上万个。如何去保证这些方法产生的结果是我们想要的呢？当然了，最容易想到的一个方式，就是我们通过System.out来输出我们的结果，看看是不是满足我们的需求，但是项目中这些成千上万个方法，我们总不能在每一个方法中都去输出一遍嘛。</p>
<p>还有就是新建一个main()方法，然后编写测试代码。但若待测试的代码过多，就需要很多的main()方法，或者一个庞大的main()方法。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><strong>使用Junit可以帮助我们快速完成单元测试。</strong></p>
<p>其简化单元测试，写一点测一点，在编写以后的代码中，可以较快地追踪到问题的原因，减小回归错误的纠错难度。</p>
<p>junit如何解决这个问题的呢？答案在于内部提供了一个断言机制，他能够将我们预期的结果和实际的结果进行比对，判断出是否满足我们的期望。</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ol>
<li>每一个测试方法上使用@Test修饰</li>
<li>每一个测试方法必须使用public void进行修饰</li>
<li>每一个测试方法不能携带参数</li>
<li>测试代码和源代码在两个不同的项目路径下</li>
<li>测试类的包应该和被测试类保持一致</li>
<li>测试单元中的每个方法必须可以独立测试</li>
</ol>
<p>Junit也建议在每一个测试方法名加上test前缀，表明这是一个测试方法。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://s2.loli.net/2022/01/15/L4V2aGrQxMBjAkv.png" alt="image-20220115000228233"></p>
<p>如图所示：</p>
<p>assertEquals是一个断言的规则，第一个参数表明我们预期的值，第二个参数表明实际运行的值。</p>
<p>如果运行成功，编辑器的控制台不会出现错误信息，如果有就出现failure等信息。</p>
<p>引用：<a href="https://zhuanlan.zhihu.com/p/86624354">Java程序员必须要知道的单元测试框架Junit详解 - 知乎 (zhihu.com)</a></p>
<h2 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>xml是可拓展的标记性语言。</p>
<p>可拓展是说，xml文件中的标签可以自定义。如图：</p>
<p><img src="https://s2.loli.net/2022/01/09/mnxW4zLSDOrE1H3.png" alt="image-20220109202115434"></p>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>xml的主要作用：</p>
<ul>
<li>用来保存数据()，而且这些数据具有自我描述性</li>
<li>它还可以作为项目或模块的配置文件</li>
<li>可以作为网络传输数据的格式(但都是过去啦，现在都用JSON)</li>
</ul>
<h3 id="xml解析技术介绍"><a href="#xml解析技术介绍" class="headerlink" title="xml解析技术介绍"></a>xml解析技术介绍</h3><p>解析：将xml中的数据转换为程序需要的信息。</p>
<p>xml是可拓展的标记语言。不管是html还是xml，都是标记性文档，都可以使用w3c组织制定的dom技术来解析。</p>
<p><img src="https://s2.loli.net/2022/01/09/SlI8J4COk7PEyYx.png" alt="image-20220109211303542"></p>
<p>document对象表示的是整个文档(可以是html文档，也可以是xml文档)。</p>
<h3 id="xml语法"><a href="#xml语法" class="headerlink" title="xml语法"></a>xml语法</h3><ol>
<li>文档声明</li>
<li>元素(标签)</li>
<li>xml属性</li>
<li>xml注释</li>
<li>文本区域(CDATA区)</li>
</ol>
<h4 id="文档声明"><a href="#文档声明" class="headerlink" title="文档声明"></a>文档声明</h4><p>创建一个xml文件</p>
<p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&gt;   xml声明。</code></p>
<!-- xml声明， version是版本的意思，encoding是编码-->
<!-- 而且这个<?xml要连在一起，否则会报错。 -->
<h4 id="XML文档必须要有根元素"><a href="#XML文档必须要有根元素" class="headerlink" title="XML文档必须要有根元素"></a>XML文档必须要有根元素</h4><p>根元素就是顶级元素</p>
<p>没有父标签的元素，叫顶级元素。</p>
<p>根元素是没有父标签的顶级元素，而且是唯一一个才行。</p>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20220109220730784.png" alt="image-20220109220730784"></p>
<h4 id="XML中的特殊字符"><a href="#XML中的特殊字符" class="headerlink" title="XML中的特殊字符"></a>XML中的特殊字符</h4><p>转化成HTML中的字符。</p>
<p>如：“&gt;”特殊字符，&amp;gt； ；  “&lt;”特殊字符：&amp;lt；</p>
<h4 id="文本区域-CDATA区"><a href="#文本区域-CDATA区" class="headerlink" title="文本区域(CDATA区)"></a>文本区域(CDATA区)</h4><p>CDATA语法可以告诉xml解析器，我CDATA里的文本内容，只是纯文本，不需要xml语法解析</p>
<p>CDATA格式：</p>
<p><code>&lt;![CDATA[这里可以把你输入的字符原样显示，不会解析xml]]&gt;</code></p>
<p><img src="https://s2.loli.net/2022/01/09/iSHNrQ1sWvRT7hg.png" alt="image-20220109221640342"></p>
<p><img src="https://s2.loli.net/2022/01/09/PBAH4aKbRSjdCkn.png" alt="image-20220109221737442"></p>
<h3 id="配置servlet"><a href="#配置servlet" class="headerlink" title="配置servlet"></a>配置servlet</h3><p><img src="https://s2.loli.net/2022/01/09/VNK61QrMv3DCozT.png" alt="image-20220109223034886"></p>
<h3 id="什么是servlet"><a href="#什么是servlet" class="headerlink" title="什么是servlet"></a>什么是servlet</h3><ol>
<li>Servlet是JavaEE规范之一，规范也就是接口的意思。</li>
<li>Servlet是JavaWeb三大组件之一。三大组件分别是：Servlet程序、Filter过滤器、Listener监听器。</li>
<li>Servlet是运行在服务器上的一个java小程序，==它可以接收客户端发送过来的请求，并响应数据给客户端==。</li>
</ol>
<p>手动实现Servlet程序</p>
<ol>
<li>编写一个类去实现Servlet接口</li>
<li>实现service方法，处理请求，并响应数据</li>
<li>在web.xml中去配置Servlet程序的访问地址</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/14/7Ftk8B4l3uK6EwV.png" alt="image-20220114003516156"></p>
<p><img src="https://s2.loli.net/2022/01/14/6y4WUZlRdMNSvTx.png" alt="image-20220114004548054"></p>
<p><img src="https://s2.loli.net/2022/01/14/I7HKBhtumQecaX9.png" alt="image-20220114004704441"></p>
<p>base标签设置页面中所有相对路径工作时，参照的路径，即href属性。</p>
<base href="http://localhost:8080/07_servlet/a_b_c.html">

<p><img src="https://s2.loli.net/2022/01/15/GfJxmqCc2M3Q9rV.png" alt="image-20220115003150399"></p>
<h2 id="JavaEE三层架构"><a href="#JavaEE三层架构" class="headerlink" title="JavaEE三层架构"></a>JavaEE三层架构</h2><p><img src="https://s2.loli.net/2022/01/15/6aWORlNcSgE9bmx.png" alt="image-20220115004626889"></p>
<h3 id="Jdbc-Utils"><a href="#Jdbc-Utils" class="headerlink" title="Jdbc_Utils"></a>Jdbc_Utils</h3><p><img src="https://s2.loli.net/2022/01/15/Rl8OFxPgK4sZJ5I.png" alt="image-20220115010008104"></p>
<p><img src="https://s2.loli.net/2022/01/15/toPDzuvSKcFkCgQ.png" alt="image-20220115010937146"></p>
<p><img src="https://s2.loli.net/2022/01/15/UPxErg1WGwaNLzR.png" alt="image-20220115011020984"></p>
<p><img src="https://s2.loli.net/2022/01/15/RJ8adT4rNfuzm2D.png" alt="image-20220115011610686"></p>
<p><img src="https://s2.loli.net/2022/01/15/uDHnOW2qNFyXESK.png" alt="image-20220115011739243"></p>
<h3 id="专门来复用的Dao抽象类"><a href="#专门来复用的Dao抽象类" class="headerlink" title="专门来复用的Dao抽象类"></a>专门来复用的Dao抽象类</h3><h4 id="选取代码"><a href="#选取代码" class="headerlink" title="选取代码"></a>选取代码</h4><p><img src="https://s2.loli.net/2022/01/15/RMO8Q7DZyKwfL9P.png" alt="image-20220115012311409"></p>
<p><strong>Object … args : 可变长参数</strong>，用来表示sql语句中的作为占位符的？的参数的实际值。</p>
<p>记得增加finally</p>
<h4 id="查询一个："><a href="#查询一个：" class="headerlink" title="查询一个："></a>查询一个：</h4><p><img src="https://s2.loli.net/2022/01/15/vB2mqZOgEAFXCnQ.png" alt="image-20220115012703423"></p>
<h4 id="参数解释及finally"><a href="#参数解释及finally" class="headerlink" title="参数解释及finally"></a>参数解释及finally</h4><p>连接用了之后要及时关闭，不然会占用连接资源，因为sql里边就那几个可用的连接</p>
<p><img src="https://s2.loli.net/2022/01/15/meTfsX4aMkE15b8.png" alt="image-20220115012950145"></p>
<h4 id="查询多个"><a href="#查询多个" class="headerlink" title="查询多个"></a>查询多个</h4><p><img src="https://s2.loli.net/2022/01/15/eWDNHuIlTh7FB9Y.png" alt="image-20220115013250380"></p>
<h4 id="查询一列"><a href="#查询一列" class="headerlink" title="查询一列"></a>查询一列</h4><p><img src="https://s2.loli.net/2022/01/15/MWq3SU6eNI1GP5u.png" alt="image-20220115013448414"></p>
<h3 id="UserDao接口以及其实现类"><a href="#UserDao接口以及其实现类" class="headerlink" title="UserDao接口以及其实现类"></a>UserDao接口以及其实现类</h3><p><img src="https://s2.loli.net/2022/01/15/QNASR3rtDfjzheU.png" alt="image-20220115014005397"></p>
<p><img src="https://s2.loli.net/2022/01/15/nxqjN6HkwLcgzRV.png" alt="image-20220115013925082"></p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/2022/02/01/Maven/</url>
    <content><![CDATA[<h1 id="Maven：自动化构建工具"><a href="#Maven：自动化构建工具" class="headerlink" title="Maven：自动化构建工具"></a>Maven：自动化构建工具</h1>]]></content>
      <tags>
        <tag>Begin！</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-触发器</title>
    <url>/2021/11/29/MySQL-%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    <content><![CDATA[<h1 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h1><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>MySQL的语句在需要时被执行，包括存储过程也是如此。但是，经常会出现想要某条语句(或某些语句)在事件发生时自动执行的情况。此时，便需要触发器的作用。</p>
<p><strong>触发器</strong> 是MySQL响应以下任意语句而自动执行的一条MySQL语句(或位于BEGIN和END语句之间的一组语句)：<strong>DELETE、UPDATE、INSERT</strong>。其余MySQL语句不支持触发器。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>在创建触发器时，需要给出4条信息：</p>
<ul>
<li><p>唯一的触发器名(每个表唯一，但最好保证整个数据库中唯一)</p>
</li>
<li><p>触发器关联的表</p>
</li>
<li><p>触发器因该相响应的活动(DELETE、INSERT或UPDATE)；</p>
</li>
<li><p>触发器该何时执行(处理之前或之后)。</p>
<p>注意，在触发器中返回结果集是低版本MySQL的做法，书上的代码，不允许触发器返回任何结果，因此使用INTO @变量名，将结果赋值到变量中，用SELECT调用即可。</p>
<p>修改为：</p>
<p>CREATE TRIGGER newp AFTER INSERT ON tb_product</p>
<p>FOR EACH ROW SELECT ‘Product added’ INTO @asd;</p>
<p>可用SELECT @asd；输出变量中结果。</p>
</li>
</ul>
<blockquote>
<p>tips：</p>
<p>触发器按照每个表每个事件定义，单一触发器不能与多个事件或多个表关联。所以，如果你需要一个对INDERT和UPDATE操作执行的触发器，就应该定义两个。</p>
</blockquote>
]]></content>
      <tags>
        <tag>触发器</tag>
      </tags>
  </entry>
  <entry>
    <title>Serializable</title>
    <url>/2021/12/11/Serializable/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Java储存对象"><a href="#Java储存对象" class="headerlink" title="Java储存对象"></a>Java储存对象</h2><h3 id="只有自己写的Java程序会用到"><a href="#只有自己写的Java程序会用到" class="headerlink" title="只有自己写的Java程序会用到"></a>只有自己写的Java程序会用到</h3><ol>
<li><h4 id="用序列化-Serialization"><a href="#用序列化-Serialization" class="headerlink" title="用序列化(Serialization)"></a>用序列化(Serialization)</h4></li>
</ol>
<p>将被序列化的对象写到文件中。然后让程序取文件中读取序列化的对象并展开为原来状态</p>
<p>数据需要被其他程序引用</p>
<ol>
<li><h4 id="放文本文件中。"><a href="#放文本文件中。" class="headerlink" title="放文本文件中。"></a>放文本文件中。</h4></li>
</ol>
<p>用其他程序可以解析的特殊字符写到文件中。</p>
<p>将序列化对象</p>
<h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><h2 id="将序列化对象写入文件"><a href="#将序列化对象写入文件" class="headerlink" title="将序列化对象写入文件"></a>将序列化对象写入文件</h2><h3 id="方法步骤"><a href="#方法步骤" class="headerlink" title="方法步骤"></a>方法步骤</h3><ol>
<li><code>创建出FileOutputStream fileStream = new FileOutputStream(&quot;Mygame.txt&quot;);</code> </li>
<li><code>创建出ObjectOutputStream os = new ObjectOutputStream(fileStream);</code> </li>
<li><code>写入对象os.writeObject(characterOne);</code></li>
<li><code>os.close();</code></li>
</ol>
<p>Java的输入/输出API带有连接类型的串流，他代表来源于目的地之间的连接。连接串流将串流与其他串流连接起来。一般来说，串流要两两连接才能做出有意义的事情—其中一个表示连接，另一个则是要被调用方法的。以FileOutputStream为例。它可以由写入字节的方法，但我们通常不会写入字节，而是以对象层次的观点来写入，所以需要高层的连接串流。<img src="https://s2.loli.net/2021/12/22/oEXO6W9umf7NpTl.png" alt="image-20211211160857891-16392102017261"></p>
<h3 id="对象被序列化"><a href="#对象被序列化" class="headerlink" title="对象被序列化"></a>对象被序列化</h3><ol>
<li>在堆上的对象</li>
</ol>
<p>在堆上的对象有状态——实例变量的值。这些值让同一类的不通事理有了不同的意义。</p>
<ol>
<li>被序列化的对象</li>
</ol>
<p>序列化的对象保存了实例变量的值，因此之后可以在堆上带回一模一样的实例。</p>
<p>如，带有两个primitive主数据类型实例变量(高度、宽度)的对象，会将宽度与高度的实例变量值(二进制格式)与Java虚拟机所需的信息(像是类的名称)被保存在foo.ser文件中。</p>
<p><code>Foo myFoo = new Foo();</code></p>
<p><code>myFoo.setWidth(37);</code></p>
<p><code>myFoo.setHeight(70);</code></p>
<p><code>FileOutputStream fs = new FileOutputStream(&quot;foo.ser&quot;);</code></p>
<p><code>ObjectOutputStream os = new ObjectOutputStream(fs);</code></p>
<p><code>os.writeObject(myFoo);</code></p>
<p>当对象被序列化时，被该对象引用的实例变量也会被序列化。即序列化程序会将对象版图上的所有东西存储起来。被对象的实例变量所引用的所有对象都会被序列化。</p>
<h3 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h3><p>如果想让类能够被序列化，就实现Serializable接口。</p>
<p>其又被称为marker或tag接口，因为此接口并没有任何方法需要实现。使用它唯一的目的就是，实现它的类是可以被序列化的。如果某类可以序列化，那么它的子类也自动地可以序列化。</p>
<p>为了保证正确的序列化，整个对象版图中，<strong>所有牵扯到的类都必须实现Serializable接口</strong>。</p>
<p>若是比较特殊的，比如忘记实现序列化，或者动态数据只有在运行的时候求出，不能或不必保存，那么需要标记为transient(瞬时)的。虽然Java函数库中大部分类可以被序列化，你还是无法将网络联机之类的东西保存下来，他得要在执行期当场创建才有意义。</p>
<h2 id="解序列化"><a href="#解序列化" class="headerlink" title="解序列化"></a>解序列化</h2><h3 id="方法步骤-1"><a href="#方法步骤-1" class="headerlink" title="方法步骤"></a>方法步骤</h3><p><code>1. 创建出FileInputStream fileStream = new FileInputStream(&quot;MyGame.txt&quot;);</code></p>
<p><code>2. 创建出ObjectInputStream os = new ObjectInputStream(fileStream);</code></p>
<p><code>3. 读取对象 Object one = os.readObject();</code></p>
<p><code>4. 转换对象类型 characterOne = (MyGame)one;</code></p>
<p><code>5. 关闭ObjectInputStream os.close();</code>  </p>
<h3 id="对象解序列化时"><a href="#对象解序列化时" class="headerlink" title="对象解序列化时"></a>对象解序列化时</h3><p>当对象被解序列化时，Java虚拟机会通过尝试在堆上创建新的对象，让它维持与被序列化时有相同的状态来恢复对象的原状。但这当然不包括transient的变量，它们不是null(对对象引用而言)就是primitive主数据类型的默认值。<img src="https://s2.loli.net/2021/12/22/QNgyWML1BupCnxS.png" alt="image-0918"></p>
<p>新的对象会被分配到堆上，但构造函数不会执行！很显然，我们只是需要对象回到存储时的状态，而不是要一个全新的对象。</p>
<p>如果该对象在继承树上有一个不可序列化的祖先类，则<strong>该不可序列化类以及在它之上的类的构造函数(就算其上的类是可序列化的也一样)就会执行</strong>。一旦构造函数启动之后将无法停止，也就是说，<strong>从第一个不可序列化的父类开始，全部都会重新初始状态</strong>。</p>
<h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ol>
<li>可以通过序列化来存储对象的状态。</li>
<li>使用ObjectOutputStream来序列化对象</li>
<li>Stream是连接串流或是链接用的串流</li>
<li>连接串流用来表示源或目的地、文件、网络套接字连接。</li>
<li>对象必须实现序列化这个接口，才能被序列化。如果父类实现序列化，则子类也就自动地有实现，不管是否有明确的声明。</li>
<li>当对象被序列化时，整个对象版图都会被序列化。这代表他的实例变量引用的对象也会被序列化。</li>
<li>在解序列化时(deserialization)，所有的类必须都能让虚拟机找到。</li>
<li>若该实例变量被标记为transient，则该变量在还原的时候会被赋予null或primitive主数据类型的默认值。</li>
<li>读取对象的顺序必须与写入的顺序相同。</li>
<li>readObject( )的返回类型是Object</li>
<li>静态变量不会被序列化，因为它属于整个类，而不是一个对象。</li>
</ol>
<h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><h3 id="java-io-File-class"><a href="#java-io-File-class" class="headerlink" title="java.io.File  class"></a>java.io.File  class</h3><p>File这个类代表磁盘上的文件，但并不是文件中的内容分。就似乎可以把File对象想象成文件的路径，而不是文件本身。例如。File并没有读写文件的方法。关于File有个很有用的功能就是就是它提供一种比使用字符串文件名来表示文件更安全的方式。举例来说，在构造函数中，可以用File对象来代替字符串表示的文件名，便于检查路径是否合法，之后再将其作为参数传给FileWriter或FileOutputStream等。</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>缓冲区能让你暂时摆一堆东西一直到满为止。用了缓冲区就可以省下好几趟来回。</p>
<p><code>BufferedWriter writer = new BufferedWriter(new FileWriter(file));</code></p>
<p>缓冲区的奥妙之处在于，可以比没有使用缓冲区的效率更好。也可以直接使用FileWriter的write( )，但他每次都直接写进磁盘，而每趟磁盘操作会比内存操作花费更多的时间。通过BufferedWriter和FileWriter的链接，BufferedWriter可以暂存一堆数据，然后到满的时候再实际写入磁盘，可以减少对磁盘操作的次数。flush().</p>
]]></content>
  </entry>
  <entry>
    <title>Spring-5</title>
    <url>/2022/01/02/Spring-5/</url>
    <content><![CDATA[<h1 id="Spring5-框架"><a href="#Spring5-框架" class="headerlink" title="Spring5 框架"></a>Spring5 框架</h1><h2 id="Spring-概念"><a href="#Spring-概念" class="headerlink" title="Spring 概念"></a>Spring 概念</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>Spring 是轻量级的开源的JavaEE框架(bean生命周期)</li>
<li>Spring可以解决企业应用开发的复杂性</li>
<li>Spring有两个核心部分: IOC和Aop</li>
</ol>
<h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><h3 id="IOC基本概念"><a href="#IOC基本概念" class="headerlink" title="IOC基本概念"></a>IOC基本概念</h3><h4 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h4><p>控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理</p>
<p>使用目的：为了降低耦合度到最低。</p>
<p>做入门案例就是IOC的一种实现。</p>
<h3 id="IOC底层原理"><a href="#IOC底层原理" class="headerlink" title="IOC底层原理"></a>IOC底层原理</h3><ol>
<li>xml解析、工厂模式、反射</li>
<li>画图说明</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/18/s2huD6PySiATa7d.png" alt="image-20220118215648859"></p>
<p>一种降低耦合度的方法：</p>
<p><img src="https://s2.loli.net/2022/01/18/C7Uh3JMa1VXEAw9.png" alt="image-20220118220558909"></p>
<h3 id="IOC过程："><a href="#IOC过程：" class="headerlink" title="IOC过程："></a>IOC过程：</h3><h4 id="第一步-xml配置文件，配置创建的对象"><a href="#第一步-xml配置文件，配置创建的对象" class="headerlink" title="第一步 xml配置文件，配置创建的对象"></a>第一步 xml配置文件，配置创建的对象</h4><bean id="dao" class="com.example.UserDao"></bean>

<h4 id="第二步-有service类和dao类，创建工厂类"><a href="#第二步-有service类和dao类，创建工厂类" class="headerlink" title="第二步 有service类和dao类，创建工厂类"></a>第二步 有service类和dao类，创建工厂类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title function_">getDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">classValue</span> <span class="operator">=</span> class属性值; <span class="comment">// 1. xml解析,com.example.UserDao</span></span><br><span class="line">        <span class="comment">// 2. 通过反射创建对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(classValue); <span class="comment">// 获取类的Class对象</span></span><br><span class="line">        <span class="keyword">return</span> (UserDao)clazz.newInstance(); <span class="comment">// 创建对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步降低耦合度</p>
<h3 id="IOC接口-BeanFactory"><a href="#IOC接口-BeanFactory" class="headerlink" title="IOC接口(BeanFactory)"></a>IOC接口(BeanFactory)</h3><ol>
<li><p>IOC思想基于IOC容器完成，IOC容器底层就是对象工厂</p>
</li>
<li><p>Spring提供IOC容器两种实现方式(两个接口):</p>
<ol>
<li><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory:"></a>BeanFactory:</h4><p>IOC容器基本实现，是Spring内部的使用接口，一般不提供开发人员使用</p>
<p>==<strong>加载配置文件时，不会创建对象，在获取/使用对象时，才会创建对象。</strong>==</p>
<p><img src="https://s2.loli.net/2022/01/19/4sZySd1oKvAmn7i.png" alt="image-20220119004715201"></p>
</li>
<li><h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext:"></a>ApplicationContext:</h4><p>BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员使用</p>
<p><strong>==加载配置文件时，就会把在配置文件中的对象进行创建。==</strong>只要做了bean配置(有bean标签)</p>
<p><img src="https://s2.loli.net/2022/01/19/QhRVEzCJqPykFAi.png" alt="image-20220119005217032"></p>
</li>
</ol>
</li>
</ol>
<h4 id="哪个好？"><a href="#哪个好？" class="headerlink" title="哪个好？"></a>哪个好？</h4><p>第一种虽然可以节约资源，因为用的时候才创建。但因为用的Spring框架，要结合web项目进行使用，即要使用tomcat将服务器启动，则把创建对象这种耗时耗资源的操作，都在项目启动时进行处理。服务器启动过程中，就去创建这个对象，而不是之后操作中才创建。</p>
<h5 id="所以，一般使用第二种！"><a href="#所以，一般使用第二种！" class="headerlink" title="所以，一般使用第二种！"></a>所以，一般使用第二种！</h5><h4 id="ApplicationContext的实现类"><a href="#ApplicationContext的实现类" class="headerlink" title="ApplicationContext的实现类"></a>ApplicationContext的实现类</h4><p>两个主要的：</p>
<p><img src="https://s2.loli.net/2022/01/19/81wFyGMP3BV4WOU.png" alt="image-20220119010458141"></p>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p><strong>1中是加盘符(如E盘)的完整文件路径</strong></p>
<p><strong>2中是文件在类中的路径(相当于相对路径)</strong></p>
<h3 id="什么是Bean管理"><a href="#什么是Bean管理" class="headerlink" title="什么是Bean管理"></a>什么是Bean管理</h3><ol>
<li><p>Bean管理指的是两个操作</p>
</li>
<li><p>Spring创建对象</p>
</li>
<li>Spring注入属性</li>
</ol>
<h4 id="Bean管理操作有两种方式"><a href="#Bean管理操作有两种方式" class="headerlink" title="Bean管理操作有两种方式"></a>Bean管理操作有两种方式</h4><ol>
<li>基于xml配置文件方式实现</li>
<li>基于注解方式实现</li>
</ol>
<h4 id="IOC操作Bean管理-基于xml"><a href="#IOC操作Bean管理-基于xml" class="headerlink" title="IOC操作Bean管理(基于xml)"></a>IOC操作Bean管理(基于xml)</h4><ol>
<li><h5 id="基于xml方式创建对象"><a href="#基于xml方式创建对象" class="headerlink" title="基于xml方式创建对象"></a>基于xml方式创建对象</h5><ol>
<li>在spring配置文件中，使用bean标签，标签里面添加对应属性，就可以实现对象创建</li>
<li><p>在bean标签中，有很多属性</p>
<ul>
<li>id属性：给要获取的对象取的唯一标识</li>
<li>class属性：类全路径(包名.类)</li>
</ul>
</li>
<li><p>构建对象时，默认使用的是无参构造方法</p>
</li>
</ol>
</li>
</ol>
<p>如：</p>
<p><img src="https://s2.loli.net/2022/01/28/pTfkvWKjF9aLJRY.png" alt="image-20220122003902640"></p>
<ol>
<li><h5 id="基于xml方式注入属性"><a href="#基于xml方式注入属性" class="headerlink" title="基于xml方式注入属性"></a>基于xml方式注入属性</h5><p>​    DI：依赖注入，就是注入属性(在创建对象的基础上，进行属性注入)</p>
<ol>
<li><p>第一种注入方式：使用set方法进行注入</p>
<ol>
<li>创建类：定义属性和对应的set方法</li>
<li>在spring配置文件中配置文件创建，配置属性注入</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/98xAQVJtg3IMSdv.png" alt="image-20220123010021903"></p>
</li>
<li><p>第二种注入方式：使用有参构造进行注入</p>
<ol>
<li>创建类，定义属性，创建属性对应的有参构造方法</li>
<li>在spring配置文件中，进行配置</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/JmbNAV1xwlKCyvi.png" alt="image-20220123005934953"></p>
</li>
</ol>
</li>
<li><h5 id="xml注入其他类型属性"><a href="#xml注入其他类型属性" class="headerlink" title="xml注入其他类型属性"></a>xml注入其他类型属性</h5><ol>
<li><h6 id="注入属性—字面量：设置的固定的内容，如属性的值等。"><a href="#注入属性—字面量：设置的固定的内容，如属性的值等。" class="headerlink" title="注入属性—字面量：设置的固定的内容，如属性的值等。"></a>注入属性—字面量：设置的固定的内容，如属性的值等。</h6><ol>
<li>null</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/Sgy4eP7LBfJlpNz.png" alt="image-20220123011606184"></p>
<ol>
<li>设置的属性值中包含特殊符号</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/gKelrsx61DImE4i.png" alt="image-20220123012202077"></p>
</li>
<li><h6 id="注入属性—外部bean-ref，即为注入外部bean的标志"><a href="#注入属性—外部bean-ref，即为注入外部bean的标志" class="headerlink" title="注入属性—外部bean (ref，即为注入外部bean的标志)"></a><strong>注入属性—外部bean (ref，即为注入外部bean的标志)</strong></h6><ol>
<li>创建两个类service类和dao类</li>
<li>在service调用dao里面的方法</li>
<li>在spring配置文件中进行配置</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/F5JRBr8alThvkMn.png" alt="image-20220123015718866"></p>
<p>结果：</p>
<p><img src="https://s2.loli.net/2022/01/23/ewng6kGF4Sm1pVl.png" alt="image-20220123020139091"></p>
</li>
<li><h6 id="注入属性—内部bean和级联赋值"><a href="#注入属性—内部bean和级联赋值" class="headerlink" title="注入属性—内部bean和级联赋值"></a>注入属性—内部bean和级联赋值</h6><p><strong>内部bean：</strong></p>
<ol>
<li>选取1对多的关系：如，部门和员工</li>
<li>表示1对多的关系</li>
<li>在spring配置文件中进行配置</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/z1ImZonDvYBfSjH.png" alt="image-20220123184748289"></p>
<p><strong>级联赋值：</strong>(给emp赋值的同时，给deptName赋值)</p>
<p>给有关联的类的属性同时进行赋值</p>
<p><strong>法1</strong></p>
<p><img src="https://s2.loli.net/2022/01/23/LoQyAkdTpYqIjwg.png" alt="image-20220123192012953"></p>
<p>即，通过外部bean实现属性注入，从而进行级联赋值。</p>
<p><strong>法2</strong></p>
<p><img src="https://s2.loli.net/2022/01/23/2Co6iT19ygu4prM.png" alt="image-20220123193506941"></p>
</li>
<li><h6 id="注入属性—集合类型"><a href="#注入属性—集合类型" class="headerlink" title="注入属性—集合类型"></a>注入属性—集合类型</h6><ol>
<li>数组类型</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/W4Nsgnj7ZpOd1VD.png" alt="image-20220123211318723"></p>
<ol>
<li>list类型</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/OxIYSimJdCk67QN.png" alt="image-20220123211406730"></p>
<ol>
<li>map类型</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/8DFTL6gwMn4tpbA.png" alt="image-20220123211510255"></p>
<ol>
<li>set类型</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/23/SAfhra5Yb8duELU.png" alt="image-20220123211605712"></p>
<h6 id="7-两个点："><a href="#7-两个点：" class="headerlink" title="7. 两个点："></a>7. 两个点：</h6><p><img src="https://s2.loli.net/2022/01/23/CUKPr67I58MNXoL.png" alt="image-20220123232903521"></p>
<p><img src="https://s2.loli.net/2022/01/24/bcjpBuQ4d3hS7vP.png" alt="image-20220123232809036"></p>
<p><strong>抽取出来，成为公共部分</strong></p>
<p><img src="https://s2.loli.net/2022/01/23/E4XJQ35H2VKDZBp.png" alt="image-20220123233956654"></p>
<p><img src="https://s2.loli.net/2022/01/23/qCKp6bVWUcuYhaO.png" alt="image-20220123233910031"></p>
<p><img src="https://s2.loli.net/2022/01/23/gt3VoPYKT92D5MR.png" alt="image-20220123234546772"></p>
</li>
</ol>
</li>
</ol>
<h4 id="IOC操作Bean管理-FactoryBean"><a href="#IOC操作Bean管理-FactoryBean" class="headerlink" title="IOC操作Bean管理(FactoryBean)"></a>IOC操作Bean管理(FactoryBean)</h4><ol>
<li><p>Spring有两种类型bean，一种普通bean，另一种工厂bean(FactoryBean)</p>
</li>
<li><p>普通bean：在配置文件中定义的bean类型就是返回的类型</p>
</li>
<li><p>工厂bean：在配置文件中定义的bean类型可以和返回的类型不一样</p>
<ol>
<li><p>第一步：创建类，让这个类作为工厂bean，实现接口FactoryBean</p>
</li>
<li><p><img src="https://s2.loli.net/2022/01/24/o9YFxJhQ3tGOg56.png" alt="image-20220124004258839"></p>
</li>
<li><p>第二步：实现接口里面的方法，在实现的方法中定义返回的bean类型</p>
<p><img src="https://s2.loli.net/2022/01/24/c57daHVtYyPGfCz.png" alt="image-20220124004231461"></p>
<h6 id="定义的返回类型是MyBean："><a href="#定义的返回类型是MyBean：" class="headerlink" title="定义的返回类型是MyBean："></a>定义的返回类型是MyBean：</h6><p><img src="https://s2.loli.net/2022/01/24/CKO29r6oQvNWjGY.png" alt="image-20220124004757107"></p>
<h6 id="实际的返回类型是Book："><a href="#实际的返回类型是Book：" class="headerlink" title="实际的返回类型是Book："></a>实际的返回类型是Book：</h6><p><img src="https://s2.loli.net/2022/01/24/EKyx6NGDQwrmUI2.png" alt="image-20220124004417185"></p>
</li>
</ol>
</li>
</ol>
<h4 id="IOC操作Bean管理-Bean作用域"><a href="#IOC操作Bean管理-Bean作用域" class="headerlink" title="IOC操作Bean管理(Bean作用域)"></a>IOC操作Bean管理(Bean作用域)</h4><ol>
<li>在spring里面，设置创建的bean实例是单实例还是多实例。</li>
<li>在spring里面，默认情况下，bean是单实例对象。</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/24/yJIFapERiM9wTbP.png" alt="image-20220124182142662"></p>
<p>也就是说，虽然生成了两个实例，但指的是同一个对象空间，即地址相同。</p>
<ol>
<li><p>设置单实例还是多实例的方法</p>
<ol>
<li><p>在spring中，bean标签里面有scope属性进行设置</p>
</li>
<li><p>scope常用属性值：singleton和prototype</p>
<ol>
<li>singleton：默认值，表示是单实例对象</li>
<li>prototype: 表示是多实例对象</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/24/LWXmsGUIl3afxw7.png" alt="image-20220124185403859"></p>
<p>二者区别：</p>
<pre><code>1. **设置为singleton，在加载spring配置文件时，就会默认进行创建单实例对象**
2. **设置为prototype，在调用getBean方法时，才去创建多实例对象**
</code></pre></li>
</ol>
</li>
</ol>
<h4 id="IOC操作Bean管理-Bean生命周期"><a href="#IOC操作Bean管理-Bean生命周期" class="headerlink" title="IOC操作Bean管理(Bean生命周期)"></a>IOC操作Bean管理(Bean生命周期)</h4><ol>
<li><p>生命周期</p>
<p>对象从创建到销毁的过程</p>
</li>
<li><p>bean生命周期</p>
<ol>
<li>通过构造器创建bean实例(无参数构造)</li>
<li>为bean的属性设置值和对其他bean的引用(调用set方法)</li>
<li>调用bean的初始化方法(需要进行配置)</li>
<li>bean可以使用(获取到对象)</li>
<li>当容器关闭时，调用bean的销毁方法(需要进行配置)</li>
</ol>
</li>
<li><p>代码: </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span>&#123;</span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Orders</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一步 执行无参构造创建bean实例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String oname;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOname</span><span class="params">(String oname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.oname = oname;</span><br><span class="line">        System.out.println(<span class="string">&quot;第二步 调用set方法设置属性值&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建执行的初始化的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第三步 执行初始化的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建执行的销毁的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第五步 执行销毁的方法&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;orders&quot;</span> class=<span class="string">&quot;com.test.spring5.bean.Orders&quot;</span> init-method=<span class="string">&quot;initMethod&quot;</span> destroy-method=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;oname&quot;</span> value=<span class="string">&quot;手机&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBean</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean4.xml&quot;</span>);</span><br><span class="line">    <span class="type">Orders</span> <span class="variable">orders</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;orders&quot;</span>, Orders.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;第四步 获取创建bean实例对象&quot;</span>);</span><br><span class="line">    context.close();</span><br><span class="line">    <span class="comment">/* 或</span></span><br><span class="line"><span class="comment">    ApplicationContext context = </span></span><br><span class="line"><span class="comment">    	new ClassPathXmlApplicationContxt(&quot;bean4.xml&quot;);</span></span><br><span class="line"><span class="comment">    (ClassPathXmlApplicationContext)context.close();</span></span><br><span class="line"><span class="comment">    因为ApplicationContext这个接口没有close方法，所以只能用实现该接口的类的close方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ol>
<li><p>bean的后置处理器，此时bean生命周期有七步：</p>
<ol>
<li>通过构造器创建bean实例(无参数构造)</li>
<li>为bean的属性设置值和对其他bean的引用(调用set方法)</li>
<li>把bean实例传递bean后置处理器的方法</li>
<li>调用bean的初始化方法(需要进行配置)</li>
<li>把bean实例传递bean后置处理器的方法</li>
<li>bean可以使用(获取到对象)</li>
<li>当容器关闭时，调用bean的销毁方法(需要进行配置)</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/25/ue9RpQPyAY1omWn.png" alt="image-20220125001452518"></p>
<p>给其上所有的bean配置都加上后置处理器。</p>
<p><img src="https://s2.loli.net/2022/01/28/8NUhvqbkLtI1XBa.png" alt="image-20220125001800193"></p>
<p><img src="https://s2.loli.net/2022/01/25/hqonRZM74U82T9p.png" alt="image-20220125001607128"></p>
</li>
</ol>
<h4 id="IOC操作Bean管理-xml自动装配"><a href="#IOC操作Bean管理-xml自动装配" class="headerlink" title="IOC操作Bean管理(xml自动装配)"></a>IOC操作Bean管理(xml自动装配)</h4><p>(该方法不常用，一般使用注解方式)</p>
<ol>
<li><h5 id="什么是自动装配"><a href="#什么是自动装配" class="headerlink" title="什么是自动装配"></a>什么是自动装配</h5><ol>
<li>根据指定装配规则(属性名称或属性类型)，Spring自动将匹配的属性进行注入</li>
</ol>
</li>
<li><h5 id="两种方法"><a href="#两种方法" class="headerlink" title="两种方法"></a>两种方法</h5><ol>
<li><h5 id="byName：此时要求，注入的bean名和类中的属性的实例名一样"><a href="#byName：此时要求，注入的bean名和类中的属性的实例名一样" class="headerlink" title="byName：此时要求，注入的bean名和类中的属性的实例名一样"></a>byName：此时要求，注入的bean名和类中的属性的实例名一样</h5><p>即，此处的外部bean中id=”dept”，Emp类中要有一个Dept dept; 这样才可以装配成功</p>
<p><img src="https://s2.loli.net/2022/01/25/KtQqgwumLMJnp5H.png" alt="image-20220125135601553"></p>
</li>
<li><h5 id="byType：此时要求，注入的bean，只能有一个Dept类型的"><a href="#byType：此时要求，注入的bean，只能有一个Dept类型的" class="headerlink" title="byType：此时要求，注入的bean，只能有一个Dept类型的"></a>byType：此时要求，注入的bean，只能有一个Dept类型的</h5><p>否则，不知道对应哪个。</p>
<p><img src="https://s2.loli.net/2022/01/25/uNF9nmZrWvSaphB.png" alt="image-20220125140733132"></p>
</li>
</ol>
</li>
</ol>
<h4 id="IOC操作Bean管理-外部属性文件"><a href="#IOC操作Bean管理-外部属性文件" class="headerlink" title="IOC操作Bean管理(外部属性文件)"></a>IOC操作Bean管理(外部属性文件)</h4><h5 id="将不变的定值部分提取出来，常用于数据库中配置"><a href="#将不变的定值部分提取出来，常用于数据库中配置" class="headerlink" title="将不变的定值部分提取出来，常用于数据库中配置"></a><strong>将不变的定值部分提取出来，常用于数据库中配置</strong></h5><h5 id="两种方式："><a href="#两种方式：" class="headerlink" title="两种方式："></a>两种方式：</h5><ol>
<li><p>直接配置数据库信息</p>
<ol>
<li><p>配置druid连接池</p>
</li>
<li><p>引入druid连接池依赖jar包</p>
<p><img src="https://s2.loli.net/2022/01/25/c8IMAxRjWLwQVqD.png" alt="image-20220125223504046"></p>
<p><img src="https://s2.loli.net/2022/01/25/iuMGlxVDrb5c8kj.png" alt="image-20220125223719398"></p>
</li>
</ol>
</li>
<li><p>引入外部属性文件配置数据库连接池</p>
<ol>
<li><p>创建外部属性文件，.properties格式，写数据库信息</p>
<p><img src="https://s2.loli.net/2022/01/25/RNCoVimge8Wx4sb.png" alt="image-20220125224447186"></p>
</li>
<li><p>把外部properties属性文件引入到spring配置文件中</p>
<ol>
<li><p>引入context命名空间</p>
<p><img src="https://s2.loli.net/2022/01/25/eA57xk84TUygYtr.png" alt="image-20220125224703623"></p>
<p>画横线的上边，所有的beans都改为context即可</p>
</li>
<li><p>在spring配置文件中，使用标签引入外部属性文件</p>
<p><img src="https://s2.loli.net/2022/01/25/7US6JkdrCy3gvcZ.png" alt="image-20220125225142909"></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="IOC操作Bean管理-基于注解"><a href="#IOC操作Bean管理-基于注解" class="headerlink" title="IOC操作Bean管理(基于注解)"></a>IOC操作Bean管理(基于注解)</h4><h5 id="注解的概念"><a href="#注解的概念" class="headerlink" title="注解的概念"></a>注解的概念</h5><ol>
<li>注解是代码特殊标记，格式：@注解名称(属性名称=属性值，…)</li>
<li>注解的位置：可以放在类上面、属性上面、方法上面</li>
<li>使用注解的目的：简化xml配置</li>
</ol>
<h5 id="Spring针对bean管理中的创建对象的注解"><a href="#Spring针对bean管理中的创建对象的注解" class="headerlink" title="Spring针对bean管理中的创建对象的注解"></a>Spring针对bean管理中的创建对象的注解</h5><ol>
<li>@Component(各种都可)</li>
<li>@Service(Service层)</li>
<li>@Controller(Web层)</li>
<li>@Repository(Dao层)</li>
</ol>
<p>功能一样，都可以用来创建bean实例，但为了使代码整体结构明了，常用于不同的层中</p>
<h5 id="基于注解方式实现对象创建"><a href="#基于注解方式实现对象创建" class="headerlink" title="基于注解方式实现对象创建"></a>基于注解方式实现对象创建</h5><ol>
<li><p>引入依赖包</p>
<p><img src="https://s2.loli.net/2022/01/27/lPhf37YjZtLqCN6.png" alt="image-20220127230046239"></p>
</li>
<li><p>开启组件扫描</p>
</li>
<li><p>过程</p>
<p><img src="https://s2.loli.net/2022/01/26/TRegU3IoNQxsSHV.png" alt="image-20220126170012555"></p>
<p><img src="https://s2.loli.net/2022/01/26/OvQacp6xbD25yWn.png" alt="image-20220126170249846"></p>
</li>
</ol>
<p>首先加载配置文件bean1.xml，之后开始进行组件扫描，扫描给定的包中的文件，按照所给注解创建对象，再调用方法输出内容。</p>
<h4 id="IOC操作Bean管理-组件扫描配置"><a href="#IOC操作Bean管理-组件扫描配置" class="headerlink" title="IOC操作Bean管理(组件扫描配置)"></a>IOC操作Bean管理(组件扫描配置)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> &lt;!--这种情况下，会扫描所给包下的所有文件的所有注解--&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.test.spring5&quot;</span>&gt;&lt;/context:component-scan&gt;</span><br><span class="line">    </span><br><span class="line"> &lt;!--示例<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    use-<span class="keyword">default</span>-filters=<span class="string">&quot;false&quot;</span> 表示现在不使用默认filters，自己进行配置</span><br><span class="line">    context:include-filter,设置扫描哪些内容</span><br><span class="line">    也就是说，此时只扫描所给包下，所有的有Controller注解的类</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.test.spring5&quot;</span> use-<span class="keyword">default</span>-filters=<span class="string">&quot;false&quot;</span>&gt;</span><br><span class="line">	&lt;context:include-filter type=<span class="string">&quot;annotation&quot;</span></span><br><span class="line">        					expression=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;    </span><br><span class="line">&lt;/context:component-scan&gt;</span><br><span class="line">    </span><br><span class="line">&lt;!--示例<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    context:exclude-filter, 设置不扫描哪些内容</span><br><span class="line">--&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.test.spring5&quot;</span>&gt;</span><br><span class="line">    &lt;context:exclude-filter type=<span class="string">&quot;annotation&quot;</span></span><br><span class="line">        					expression-<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>
<h4 id="基于注解方式实现属性注入"><a href="#基于注解方式实现属性注入" class="headerlink" title="基于注解方式实现属性注入"></a>基于注解方式实现属性注入</h4><h5 id="AutoWired"><a href="#AutoWired" class="headerlink" title="@AutoWired"></a>@AutoWired</h5><h6 id="根据属性类型进行自动装配"><a href="#根据属性类型进行自动装配" class="headerlink" title="根据属性类型进行自动装配"></a>根据属性类型进行自动装配</h6><p><img src="https://s2.loli.net/2022/01/26/lKsOVnNEo21YXMG.png" alt="image-20220126190154264"></p>
<p><img src="https://s2.loli.net/2022/01/26/cyiwDjpYNbxKPtm.png" alt="image-20220126190223331"></p>
<p><strong>实现类 要有 创建对象 的注解</strong></p>
<p><img src="https://s2.loli.net/2022/01/26/e5bzmya76si1qpc.png" alt="image-20220126190102415"></p>
<h5 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h5><h6 id="根据属性名称进行注入"><a href="#根据属性名称进行注入" class="headerlink" title="根据属性名称进行注入"></a>根据属性名称进行注入</h6><p> 常常放在@AutoWired下面，二者一起使用(当一个接口有多个实现类时，通过实现类名称确定使用哪个)</p>
<p>其值value要与实现类的创建注解中的value一致</p>
<p><img src="https://s2.loli.net/2022/01/28/ciDAnByEufeVLSh.png" alt="image-20220126210553992"></p>
<p><img src="https://s2.loli.net/2022/01/26/uMkRmvZlOb3Exr6.png" alt="image-20220126210420160"></p>
<h5 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h5><h6 id="可以根据类型注入，也可以根据名称注入"><a href="#可以根据类型注入，也可以根据名称注入" class="headerlink" title="可以根据类型注入，也可以根据名称注入"></a>可以根据类型注入，也可以根据名称注入</h6><p>根据类型注入时，直接@Resource即可</p>
<p>根据名称注入：</p>
<p><img src="https://s2.loli.net/2022/01/26/A7mdRxOcqfjSCLi.png" alt="image-20220126211243420"></p>
<blockquote>
<p>因为Resource实质上并不属于Spring，而是属于javax包，故而，Spring官方建议使用前两种。</p>
</blockquote>
<h5 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h5><h6 id="注入普通类型的属性值"><a href="#注入普通类型的属性值" class="headerlink" title="注入普通类型的属性值"></a>注入普通类型的属性值</h6><p><img src="https://s2.loli.net/2022/01/26/p5o2zIWXDc6PCSb.png" alt="image-20220126212117946"></p>
<p><img src="https://s2.loli.net/2022/01/26/DPcTgbeuK7LBXQh.png" alt="image-20220126212143138"></p>
<h4 id="IOC操作Bean管理-完全注解开发"><a href="#IOC操作Bean管理-完全注解开发" class="headerlink" title="IOC操作Bean管理(完全注解开发)"></a>IOC操作Bean管理(完全注解开发)</h4><h5 id="创建配置类，替代xml文件"><a href="#创建配置类，替代xml文件" class="headerlink" title="创建配置类，替代xml文件"></a>创建配置类，替代xml文件</h5><p>注意配置注解@Configuration和组件扫描注解@ComponentScan</p>
<p><img src="https://s2.loli.net/2022/01/26/YNfmIMoj8viDxQ5.png" alt="image-20220126215512250"></p>
<h5 id="创建测试类"><a href="#创建测试类" class="headerlink" title="创建测试类"></a>创建测试类</h5><p><img src="https://s2.loli.net/2022/01/26/iaI2TxNmkyFwQAH.png" alt="image-20220126215751386"></p>
<h2 id="Aop"><a href="#Aop" class="headerlink" title="Aop"></a>Aop</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>面向切面(方面)编程</p>
<ol>
<li><p>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率</p>
</li>
<li><p>即，不修改原本的源代码，在原有的主干功能的基础上，(通过增加模块的方式)增添新的功能</p>
</li>
<li><p>例子：</p>
<p><img src="https://s2.loli.net/2022/01/26/VynzSlPpexdoKUG.png" alt="image-20220126221631626"></p>
</li>
</ol>
<h3 id="AOP底层原理"><a href="#AOP底层原理" class="headerlink" title="AOP底层原理"></a>AOP底层原理</h3><h4 id="AOP底层使用动态代理"><a href="#AOP底层使用动态代理" class="headerlink" title="AOP底层使用动态代理"></a>AOP底层使用动态代理</h4><h5 id="有接口，使用JDK动态代理"><a href="#有接口，使用JDK动态代理" class="headerlink" title="有接口，使用JDK动态代理"></a>有接口，使用JDK动态代理</h5><p>创建接口的实现类代理对象，增强类的方法</p>
<p><img src="https://s2.loli.net/2022/01/26/Zur8WcIRMFXGy3f.png" alt="image-20220126224949978"></p>
<h5 id="无接口，使用CGLIB动态代理"><a href="#无接口，使用CGLIB动态代理" class="headerlink" title="无接口，使用CGLIB动态代理"></a>无接口，使用CGLIB动态代理</h5><p>   创建当前类的子类代理对象，增强类的方法</p>
<p><img src="https://s2.loli.net/2022/01/27/QIh9i6l3tpAdv5U.png" alt="image-20220126225018496"></p>
<h4 id="动态代理实现"><a href="#动态代理实现" class="headerlink" title="动态代理实现"></a>动态代理实现</h4><h5 id="Proxy类"><a href="#Proxy类" class="headerlink" title="Proxy类"></a>Proxy类</h5><h6 id="创建代理对象的方法"><a href="#创建代理对象的方法" class="headerlink" title="创建代理对象的方法"></a>创建代理对象的方法</h6><p><img src="https://s2.loli.net/2022/01/27/gM5ZpkOuAvnWqbG.png" alt="image-20220127160252028"></p>
<p><img src="https://s2.loli.net/2022/01/27/6UrZuQHcXgLktaG.png" alt="image-20220127160608351"></p>
<p>三个参数：</p>
<ul>
<li>类加载器</li>
<li>增强方法所在的类，其实现的接口，支持多个接口</li>
<li>实现InvocationHandler接口，创建代理对象，其中写增强的方法</li>
</ul>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><ol>
<li><p>创建接口和接口实现类</p>
<p><img src="https://s2.loli.net/2022/01/27/u46MYRbWSfxOHFJ.png" alt="image-20220127191831981"></p>
<p><img src="https://s2.loli.net/2022/01/27/uI6AHgsoXvRqSi1.png" alt="image-20220127191811419"></p>
</li>
<li><p>使用Proxy类创建接口的动态代理</p>
<p>使用newProxyInstance( )方法创建代理类UserDao的实例时，第一个参数是当前类的加载器，第二个参数是待创建代理的接口的Class对象，第三个是 将原有方法进行增强的 代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建接口实现类代理对象</span></span><br><span class="line">        Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line">        <span class="type">UserDaoImpl</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">dao</span> <span class="operator">=</span> (UserDao)Proxy.newProxyInstance(JdkProxy.class.getClassLoader(), interfaces, <span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> dao.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 执行下方invoke方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result: &quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 创建代理对象代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/1/27 18:07:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造传递 需要代理对象的类</span></span><br><span class="line">    <span class="comment">// 此处是为了类型的广泛兼容，将UserDao扩展为Object</span></span><br><span class="line">    <span class="comment">// 因为是在之前的方法的基础上进行增强，故而需要获取之前的方法，便于执行</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Desc // 进行方法增强</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@date</span> 2022/1/27 18:45</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Object&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之前执行 &quot;</span> + method.getName());</span><br><span class="line">        <span class="comment">// 此处执行增强前的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;方法之后执行 &quot;</span> + obj);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/27/Jv5yNefrbEdSgPQ.png" alt="image-20220127200058512"></p>
<h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><h4 id="连接点"><a href="#连接点" class="headerlink" title="连接点"></a>连接点</h4><p>类中可以被增强的方法</p>
<h4 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a>切入点</h4><p>类中实际被增强的方法</p>
<h4 id="通知-增强"><a href="#通知-增强" class="headerlink" title="通知(增强)"></a>通知(增强)</h4><p>增强(加)的逻辑部分</p>
<h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><ul>
<li>前置通知：方法之前 执行</li>
<li>后置通知：方法之后 执行</li>
<li>环绕通知：方法之前和之后都有执行，类似上面的代码</li>
<li>异常通知：当方法抛出异常时 执行</li>
<li>最终通知：类似于try/catch块中的finally部分，不管是否抛出异常都会执行，但二者不同</li>
</ul>
<h4 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h4><p>是动作，将通知应用到切入点的过程，比如将权限判断应用到登录中这一过程</p>
<h3 id="AOP操作"><a href="#AOP操作" class="headerlink" title="AOP操作"></a>AOP操作</h3><p><strong>Spring框架一般都是基于AspectJ实现AOP操作</strong></p>
<h4 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h4><p>本来是一个独立的AOP框架，为了开发时方便，一般将其和Spring框架一起使用，进行AOP操作。</p>
<h4 id="基于AspectJ实现AOP操作"><a href="#基于AspectJ实现AOP操作" class="headerlink" title="基于AspectJ实现AOP操作"></a>基于AspectJ实现AOP操作</h4><h5 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h5><p>基于xml配置文件实现</p>
<p>基于注解方式实现(常用)</p>
<h4 id="引入四个依赖包"><a href="#引入四个依赖包" class="headerlink" title="引入四个依赖包"></a>引入四个依赖包</h4><p><img src="https://s2.loli.net/2022/01/27/dFu94iEQP3IRl8b.png" alt="image-20220127225753665"></p>
<h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h4><h5 id="标识-增强的是哪个类中的哪个方法"><a href="#标识-增强的是哪个类中的哪个方法" class="headerlink" title="标识 增强的是哪个类中的哪个方法"></a>标识 增强的是哪个类中的哪个方法</h5><h5 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h5><p>execution({权限修饰符}{返回类型}{类全路径}{方法名称}({参数列表}) )</p>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><ol>
<li>对com.test.spring5.UserDao中的add方法进行增强</li>
</ol>
<p>execution(<em> com.test.spring5.UserDao.add(..)) // 其中</em>表示任一权限，返回类型省略</p>
<ol>
<li>对com.test.spring5.UserDao中的所有方法进行增强</li>
</ol>
<p>execution(<em> com.test.spring5.UserDao.</em>(..))</p>
<ol>
<li>对com.test.spring5中的所有类的所有方法进行增强</li>
</ol>
<p>execution(<em> com.test.spring5.</em>.*(..))</p>
<h4 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h4><ol>
<li><p>创建待增强类和增强类</p>
<p><img src="https://s2.loli.net/2022/01/27/ftL7Z1r6mojARJ5.png" alt="image-20220127222936095"></p>
</li>
<li><p>引入context和aop命名空间，开启注解扫描</p>
<p><img src="https://s2.loli.net/2022/01/27/N32FiG9kyPatj85.png" alt="image-20220127223052786"></p>
</li>
<li><p>用注解的方式@Component生成两个类的实例，并用@Aspect注解标记增强类</p>
<p><img src="https://s2.loli.net/2022/01/27/oUV2Fv9HKlES3ck.png" alt="image-20220127223113029"></p>
<p><img src="https://s2.loli.net/2022/01/27/QlyYEcHOxd5uaCg.png" alt="image-20220127223227676"></p>
</li>
<li><p>创建五种类型的通知，并用注解进行标记</p>
<p>加什么注解，增强后的方法就有什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前置通知</span></span><br><span class="line"><span class="meta">@Before(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终通知</span></span><br><span class="line"><span class="meta">@After(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;After...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置/返回通知</span></span><br><span class="line"><span class="meta">@AfterReturning(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;After returning...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常通知</span></span><br><span class="line"><span class="meta">@AfterThrowing(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrow</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;After throwing...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 环绕通知</span></span><br><span class="line"><span class="meta">@Around(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Before enhancing...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用未增强的方法</span></span><br><span class="line">    proceedingJoinPoint.proceed();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;After enhancing...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<p><img src="https://s2.loli.net/2022/01/27/TNPsru12XWwGRZ3.png" alt="image-20220127223659348"></p>
</li>
<li><p>结果</p>
<p><img src="https://s2.loli.net/2022/01/27/m98c3SVvRnBJFtq.png" alt="image-20220127223625592"></p>
<p>首先执行环绕通知的前部分，然后执行方法的前置通知，原方法执行后，执行环绕通知后半部分，接着是最终通知，而后是后置/返回通知。<strong>若抛出异常，则会执行异常通知，此时其后置通知不会再执行(抛出异常后，其下语句不再执行)，但最终通知执行。</strong></p>
<p><img src="https://s2.loli.net/2022/01/27/QRHOAfT6PdlVSbD.png" alt="image-20220127224220929"></p>
</li>
</ol>
<h4 id="另外两个"><a href="#另外两个" class="headerlink" title="另外两个"></a>另外两个</h4><h5 id="提取出相同的切入点"><a href="#提取出相同的切入点" class="headerlink" title="提取出相同的切入点"></a>提取出相同的切入点</h5><p>比如上边的五个通知，注解中的value是一样的，就可以放在一起。则将来修改时，只用修改一处，也更加方便。</p>
<p>只需增加一个@Pointcut注解</p>
<p><img src="https://s2.loli.net/2022/01/27/bkypg5FzvJB2jn7.png" alt="image-20220127224853590"></p>
<h5 id="设置增强类的执行优先级"><a href="#设置增强类的执行优先级" class="headerlink" title="设置增强类的执行优先级"></a>设置增强类的执行优先级</h5><p>若一个类有多个增强类，那么可以设置各个增强类执行的优先级</p>
<p>增加@Order(数字类型)：数字越小，优先级越高</p>
<p><img src="https://s2.loli.net/2022/01/27/ihZAMfEstm1kv2w.png" alt="image-20220127225050893"></p>
<h2 id="JDBCTemplate"><a href="#JDBCTemplate" class="headerlink" title="JDBCTemplate"></a>JDBCTemplate</h2><h3 id="JdbcTemplate概述"><a href="#JdbcTemplate概述" class="headerlink" title="JdbcTemplate概述"></a>JdbcTemplate概述</h3><p>Spring框架对JDBC进行封装，使用JdbcTemplate方便实现对数据库操作</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="引入相关的依赖"><a href="#引入相关的依赖" class="headerlink" title="引入相关的依赖"></a>引入相关的依赖</h4><p><img src="https://s2.loli.net/2022/01/27/GbmpaTrwkJNQV3B.png" alt="image-20220127231141941"></p>
<h4 id="配置数据库连接池"><a href="#配置数据库连接池" class="headerlink" title="配置数据库连接池"></a>配置数据库连接池</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--配置数据库连接池--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;dataSource&quot;</span> class=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span><br><span class="line">      destroy-method=<span class="string">&quot;close&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;jdbc:mysql://localhost:3306/db_database10&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;654321&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="配置JdbcTemplate对象，注入DataSource"><a href="#配置JdbcTemplate对象，注入DataSource" class="headerlink" title="配置JdbcTemplate对象，注入DataSource"></a>配置JdbcTemplate对象，注入DataSource</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--JdbcTemplate对象--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;jdbcTemplate&quot;</span> class=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span><br><span class="line">    &lt;!--注入DataSource--&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="创建service类和dao类，在dao中注入jdbcTemplate对象"><a href="#创建service类和dao类，在dao中注入jdbcTemplate对象" class="headerlink" title="创建service类和dao类，在dao中注入jdbcTemplate对象"></a>创建service类和dao类，在dao中注入jdbcTemplate对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdcTemplate;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JdbcTemplate操作数据库-添加功能"><a href="#JdbcTemplate操作数据库-添加功能" class="headerlink" title="JdbcTemplate操作数据库(添加功能)"></a>JdbcTemplate操作数据库(添加功能)</h3><h4 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h4><p>创建用户类，以数据表tb_user中的属性值为实例域，并生成getter和setter方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String userStatus;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在类中新增方法"><a href="#在类中新增方法" class="headerlink" title="在类中新增方法"></a>在类中新增方法</h4><h5 id="UserService类中新增addUser方法"><a href="#UserService类中新增addUser方法" class="headerlink" title="UserService类中新增addUser方法"></a>UserService类中新增addUser方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userDao.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="UserDao类中新增add方法"><a href="#UserDao类中新增add方法" class="headerlink" title="UserDao类中新增add方法"></a>UserDao类中新增add方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="UserDaoImpl中实现add方法"><a href="#UserDaoImpl中实现add方法" class="headerlink" title="UserDaoImpl中实现add方法"></a>UserDaoImpl中实现add方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(User user)</span> &#123;</span><br><span class="line">		<span class="comment">// 主要使用JdbcTemplate中的update方法进行新增</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO tb_user VALUES(?,?,?)&quot;</span>;</span><br><span class="line">        Object[] args = &#123; user.getUserId(), user.getUserName(), user.getUserStatus() &#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">addNumber</span> <span class="operator">=</span> jdbcTemplate.update(sql, args);</span><br><span class="line">        System.out.println(addNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE tb_user SET user_id=?, user_name=?, user_status=? WHERE user_id=?&quot;</span>;</span><br><span class="line">        Object[] args = &#123; user.getUserId(), user.getUserName(), user.getUserStatus(), user.getUserId() &#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;DELETE FROM tb_user WHERE user_id = ?&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, id);</span><br><span class="line">        System.out.println(update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT COUNT(*) FROM tb_user&quot;</span>;</span><br><span class="line">        <span class="comment">// 方法的第二个参数为返回值的类类型</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> count;</span><br><span class="line">        <span class="keyword">return</span> count1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserId(<span class="string">&quot;002&quot;</span>);</span><br><span class="line">        user.setUserName(<span class="string">&quot;张四&quot;</span>);</span><br><span class="line">        user.setUserStatus(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        userService.addUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/01/28/xB7mg9XWj5wq8ru.png" alt="image-20220128165149416"></p>
<h3 id="JdbcTemplate操作数据库-查询返回对象"><a href="#JdbcTemplate操作数据库-查询返回对象" class="headerlink" title="JdbcTemplate操作数据库(查询返回对象)"></a>JdbcTemplate操作数据库(查询返回对象)</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><code>T t = queryForObject(String sql, RowMapper&lt;T&gt; rowMapper, Object... args)</code></p>
<h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><h5 id="第一个参数：sql语句"><a href="#第一个参数：sql语句" class="headerlink" title="第一个参数：sql语句"></a>第一个参数：sql语句</h5><h5 id="第二个参数：RowMapper接口"><a href="#第二个参数：RowMapper接口" class="headerlink" title="第二个参数：RowMapper接口"></a>第二个参数：RowMapper接口</h5><p>针对不同返回类型，使用这个接口的实现类完成对数据的封装。泛型具体化为 什么类型，返回时，数据就被封装为 什么类型。</p>
<h5 id="第三个参数：占位符代表的值"><a href="#第三个参数：占位符代表的值" class="headerlink" title="第三个参数：占位符代表的值"></a>第三个参数：占位符代表的值</h5><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><img src="https://s2.loli.net/2022/01/28/Ysbt1yTzgulfwVG.png" alt="image-20220128210514151"></p>
<h3 id="查询返回集合"><a href="#查询返回集合" class="headerlink" title="查询返回集合"></a>查询返回集合</h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p><code>List&lt;T&gt; t = jdbcTemplate.query(sql, RowMapper&lt;T&gt; rowMapper, Object... obj)</code></p>
<p>三个参数同上，最后一个参数可以没有。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAllUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM tb_user&quot;</span>;</span><br><span class="line">    <span class="comment">// 这个方法重要，返回的是集合</span></span><br><span class="line">    List&lt;User&gt; userList = jdbcTemplate.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;User&gt;(User.class));</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="批量增加"><a href="#批量增加" class="headerlink" title="批量增加"></a>批量增加</h3><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><p><code>int[] ints = jdbcTemplate.batchUpdate(sql, List&lt;Object&gt; batchArgs)</code> </p>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><h5 id="第一个参数：sql语句-1"><a href="#第一个参数：sql语句-1" class="headerlink" title="第一个参数：sql语句"></a>第一个参数：sql语句</h5><h5 id="第二个参数：List集合，添加多条记录"><a href="#第二个参数：List集合，添加多条记录" class="headerlink" title="第二个参数：List集合，添加多条记录"></a>第二个参数：List集合，添加多条记录</h5><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p><img src="https://s2.loli.net/2022/01/28/hoScOvU8rME5x63.png" alt="image-20220128213901809"></p>
<p><img src="https://s2.loli.net/2022/01/28/oE4M7xipeT1N5lK.png" alt="image-20220128214324252"></p>
<h3 id="批量删除和修改"><a href="#批量删除和修改" class="headerlink" title="批量删除和修改"></a>批量删除和修改</h3><h4 id="方法一样。"><a href="#方法一样。" class="headerlink" title="方法一样。"></a>方法一样。</h4><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><h5 id="修改和增加的参数差不多"><a href="#修改和增加的参数差不多" class="headerlink" title="修改和增加的参数差不多"></a>修改和增加的参数差不多</h5><h5 id="删除的参数如下："><a href="#删除的参数如下：" class="headerlink" title="删除的参数如下："></a>删除的参数如下：</h5><p><img src="https://s2.loli.net/2022/01/28/3ous86klgJNdOZr.png" alt="image-20220128215811316"></p>
<h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><h3 id="事务基本概念"><a href="#事务基本概念" class="headerlink" title="事务基本概念"></a>事务基本概念</h3><p>事务是数据库操作的最基本单元，逻辑上，一组操作要么都成功，要么都失败。</p>
<h3 id="事务的四个特性-ACID"><a href="#事务的四个特性-ACID" class="headerlink" title="事务的四个特性(ACID)"></a>事务的四个特性(ACID)</h3><ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>永久性</li>
</ul>
<h3 id="事务操作的环境"><a href="#事务操作的环境" class="headerlink" title="事务操作的环境"></a>事务操作的环境</h3><p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20220128221411247.png" alt="image-20220128221411247"></p>
<h4 id="创建数据表，添加记录"><a href="#创建数据表，添加记录" class="headerlink" title="创建数据表，添加记录"></a>创建数据表，添加记录</h4><p><img src="https://s2.loli.net/2022/01/28/SjkdGthBaTyRw8r.png" alt="image-20220128222344884"></p>
<h4 id="创建service，搭建dao，完成对象创建和注入"><a href="#创建service，搭建dao，完成对象创建和注入" class="headerlink" title="创建service，搭建dao，完成对象创建和注入"></a>创建service，搭建dao，完成对象创建和注入</h4><p>同之前一样</p>
<h4 id="事务引入"><a href="#事务引入" class="headerlink" title="事务引入"></a>事务引入</h4><p><img src="https://s2.loli.net/2022/01/28/5KTNFwh6AXa49nS.png" alt="image-20220128224344901"></p>
<h3 id="Spring中事务管理"><a href="#Spring中事务管理" class="headerlink" title="Spring中事务管理"></a>Spring中事务管理</h3><h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>事务添加到JavaEE三层结构里面Service层(业务逻辑层)</p>
<h4 id="在Spring中进行事务管理操作"><a href="#在Spring中进行事务管理操作" class="headerlink" title="在Spring中进行事务管理操作"></a>在Spring中进行事务管理操作</h4><p><strong>有两种方式：编程式事务管理(不常用)和声明式事务管理(常用)</strong></p>
<p>编程式即，将上述过程，全用代码实现，复杂且庞大，故而一般不使用</p>
<p>声明式即，将上述过程，通过配置的方式，进行实现。</p>
<h4 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h4><h5 id="基于注解方式-常用"><a href="#基于注解方式-常用" class="headerlink" title="基于注解方式(常用)"></a>基于注解方式(常用)</h5><h5 id="基于xml文件方式"><a href="#基于xml文件方式" class="headerlink" title="基于xml文件方式"></a>基于xml文件方式</h5><h4 id="底层使用AOP原理"><a href="#底层使用AOP原理" class="headerlink" title="底层使用AOP原理"></a>底层使用AOP原理</h4><h4 id="事务管理API"><a href="#事务管理API" class="headerlink" title="事务管理API"></a>事务管理API</h4><p>提供一个接口，其针对不同的框架，提供了不同的实现类</p>
<p>使用JdbcTemplate(和Mybatis)时</p>
<p><img src="https://s2.loli.net/2022/01/29/3MjaGenVJsqog6Z.png" alt="image-20220129134645032"></p>
<h3 id="声明式事务管理：注解"><a href="#声明式事务管理：注解" class="headerlink" title="声明式事务管理：注解"></a>声明式事务管理：注解</h3><h4 id="配置事务管理器"><a href="#配置事务管理器" class="headerlink" title="配置事务管理器"></a>配置事务管理器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--创建事务管理器--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;transactionManager&quot;</span> class=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br><span class="line">    &lt;!--注入数据源--&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="开启事务注解"><a href="#开启事务注解" class="headerlink" title="开启事务注解"></a>开启事务注解</h4><h5 id="引入名称空间tx"><a href="#引入名称空间tx" class="headerlink" title="引入名称空间tx"></a>引入名称空间tx</h5><p><img src="https://s2.loli.net/2022/01/29/4eMxkqtn72JjPiy.png" alt="image-20220129143603753"></p>
<h5 id="开启事务注解-1"><a href="#开启事务注解-1" class="headerlink" title="开启事务注解"></a>开启事务注解</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;tx:annotation-driven transaction-manager=<span class="string">&quot;transactionManager&quot;</span>&gt;&lt;/tx:annotation-driven&gt;</span><br></pre></td></tr></table></figure>
<h5 id="在service类-或类中方法-上添加事务注解"><a href="#在service类-或类中方法-上添加事务注解" class="headerlink" title="在service类(或类中方法)上添加事务注解"></a>在service类(或类中方法)上添加事务注解</h5><p><img src="https://s2.loli.net/2022/01/29/i9OvuRpnSEFdgW2.png" alt="image-20220129162034905"></p>
<p>可以在类上加该注解，也可以在方法上加。</p>
<p>在类上加时，表示整个类中所有的方法，都具有事务属性</p>
<p>在方法上加，只表示这个方法，是事务，具有事务属性。</p>
<h4 id="管理事务的参数配置"><a href="#管理事务的参数配置" class="headerlink" title="管理事务的参数配置"></a>管理事务的参数配置</h4><p>在service类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数</p>
<h5 id="propagation：事务传播行为"><a href="#propagation：事务传播行为" class="headerlink" title="propagation：事务传播行为"></a>propagation：事务传播行为</h5><p>多个事务方法之间进行调用，这个过程中，事务是如何管理的。(就是，有事务方法调用没有事务方法，没有事务方法调用有事务方法，或者两个有事务方法之间调用之类的。)</p>
<p>事务方法：对数据库表中数据进行变化的操作(查询行为就不是，因为数据未变化)</p>
<h6 id="Spring框架事务传播行为有7种："><a href="#Spring框架事务传播行为有7种：" class="headerlink" title="Spring框架事务传播行为有7种："></a>Spring框架事务传播行为有7种：</h6><p>常用的两个：</p>
<p>REQUIRED: 如果调用方法本身有事务，被调用方法使用当前方法里面的事务；如果调用方法本身没有事务，被调用方法，创建新的事务。(默认是这个)</p>
<p>REQUIRED_NEW：不管调用方法本身有没有事务，被调用方法，都创建新的事务。</p>
<p>@Transactional(propagation=REQUIRED_NEW)</p>
<h5 id="isolation：事务隔离级别"><a href="#isolation：事务隔离级别" class="headerlink" title="isolation：事务隔离级别"></a>isolation：事务隔离级别</h5><p>多事务操作之间不会产生影响。不考虑隔离性会产生很多问题。</p>
<h6 id="三个读问题"><a href="#三个读问题" class="headerlink" title="三个读问题"></a>三个读问题</h6><h6 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h6><p>一个未提交事务读取到另一个未提交事务</p>
<h6 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h6><p>一个未提交事务读取到另一个已提交事务修改的数据</p>
<h6 id="虚-幻读"><a href="#虚-幻读" class="headerlink" title="虚/幻读"></a>虚/幻读</h6><p>一个未提交事务读取到另一个已提交事务增加的数据</p>
<h6 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h6><p>通过设置隔离级别，解决以上三个问题。</p>
<p>默认是REPEATABLE_READ。</p>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20220129235129910.png" alt="image-20220129235129910"></p>
<h5 id="timeout：超时时间"><a href="#timeout：超时时间" class="headerlink" title="timeout：超时时间"></a>timeout：超时时间</h5><p>事务需要在一定时间内提交，超时则进行回滚。</p>
<p>默认值是-1(即，不超时)，设置时间以秒为单位进行计算。</p>
<h5 id="readOnly：是否只读"><a href="#readOnly：是否只读" class="headerlink" title="readOnly：是否只读"></a>readOnly：是否只读</h5><p>读：查询操作；写：添加、修改、删除操作</p>
<p>默认值为false，即可以查询，也可以修改、删除、添加等</p>
<p>设置为true时，即为只能查询。</p>
<h5 id="rollbackFor：回滚"><a href="#rollbackFor：回滚" class="headerlink" title="rollbackFor：回滚"></a>rollbackFor：回滚</h5><p>设置出现哪些异常进行事务回滚</p>
<h5 id="noRollbackFor：不回滚"><a href="#noRollbackFor：不回滚" class="headerlink" title="noRollbackFor：不回滚"></a>noRollbackFor：不回滚</h5><p>设置出现哪些异常不进行事务回滚</p>
<h3 id="完全注解方式"><a href="#完全注解方式" class="headerlink" title="完全注解方式"></a>完全注解方式</h3><h4 id="建立一个配置类"><a href="#建立一个配置类" class="headerlink" title="建立一个配置类"></a>建立一个配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc 配置类注解，组件扫描注解，开启事务注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages =&quot;com.test.spring5&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc 创建一个druid连接池的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/1/30 21:40</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> DruidDataSource&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">getDruidDataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/db_database10&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;654321&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc 创建JdbcTemplate对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/1/30 21:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> JdbcTemplate&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">getJdbcTemplate</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="comment">// 在IOC容器中，已经存在这样一个对象，到IOC容器中，根据类型获取对象</span></span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        jdbcTemplate.setDataSource(getDruidDataSource());</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc 创建事务管理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/1/30 21:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> DataSourceTransactionManager&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">getDataTransactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAccount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(TxConfig.class);</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    userService.accountMoney();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring5-新特性"><a href="#Spring5-新特性" class="headerlink" title="Spring5 新特性"></a>Spring5 新特性</h2><ol>
<li>整个Spring5框架的代码基于Java8，运行时兼容JDK9，许多不建议使用的类和方法在代码库中删除。</li>
<li><p>Spring5自带了通用的日志封装</p>
<ol>
<li><p>Spring5已经移除了Log4jConfigListener，官方建议使用Log4j2</p>
</li>
<li><p>Spring5框架整合Log4j2</p>
<ol>
<li><p>引入jar包</p>
<p><img src="https://s2.loli.net/2022/01/31/yW4GiDsE5ISPOMZ.png" alt="image-20220131203938791"></p>
</li>
<li><p>创建log4j2.xml配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;!--日志级别以及优先级排序：OFF&gt;FATAL&gt;ERROR&gt;WARN&gt;INFO&gt;DEBUG&gt;TRACE&gt;ALL--&gt;</span><br><span class="line">&lt;!--越往右，优先级越高，显示的内容越多--&gt;</span><br><span class="line">&lt;!--Configuration后面的status用于设置log4j2自身内部的信息输出，可以不设置，当设置为trace时，可以看到其内部的各种详细输出--&gt;</span><br><span class="line">&lt;configuration status=<span class="string">&quot;INFO&quot;</span>&gt;</span><br><span class="line">    &lt;appenders&gt;</span><br><span class="line">        &lt;!--输出日志信息到控制台--&gt;</span><br><span class="line">        &lt;console name=<span class="string">&quot;Console&quot;</span> target=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br><span class="line">            &lt;!--控制日志输出的格式--&gt;</span><br><span class="line">            &lt;PatternLayout pattern=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br><span class="line">        &lt;/console&gt;</span><br><span class="line">    &lt;/appenders&gt;</span><br><span class="line">    &lt;!--定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;</span><br><span class="line">    &lt;loggers&gt;</span><br><span class="line">        &lt;!--指定项目的根日志，如果没有单独指定Logger，则会使用root作为默认的日志输出--&gt;</span><br><span class="line">        &lt;root level=<span class="string">&quot;info&quot;</span>&gt;</span><br><span class="line">            &lt;appender-ref ref=<span class="string">&quot;Console&quot;</span>/&gt;</span><br><span class="line">        &lt;/root&gt;</span><br><span class="line">    &lt;/loggers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Nullable注解"><a href="#Nullable注解" class="headerlink" title="@Nullable注解"></a>@Nullable注解</h3><ol>
<li><p>Spring5框架核心容器支持@Nullable注解</p>
</li>
<li><p>@Nullable注解可以使用在方法上面、属性上面、参数上面，表示方法返回可以为空，属性值可以为空，参数值可以为空。</p>
</li>
</ol>
<h3 id="支持函数式风格GenericApplicationContext"><a href="#支持函数式风格GenericApplicationContext" class="headerlink" title="支持函数式风格GenericApplicationContext"></a>支持函数式风格GenericApplicationContext</h3><p>Spring5框架核心容器支持函数式风格。</p>
<p>利用lamda表达式，将手动创建的对象，在spring中，做个注册</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 函数式风格创建对象，交给Spring进行管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">GenericApplicationContextTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建GenericApplicationContext对象</span></span><br><span class="line">	<span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    <span class="comment">// 2. 调用context的方法对象注册</span></span><br><span class="line">    context.refresh();</span><br><span class="line">    context.registerBean(<span class="string">&quot;user1&quot;</span>, User.class,()-&gt;<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">    <span class="comment">// 3. 获取在Spring注册的对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)context.getBean(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整合JUnit5"><a href="#整合JUnit5" class="headerlink" title="整合JUnit5"></a>整合JUnit5</h3><h4 id="整合JUnit4"><a href="#整合JUnit4" class="headerlink" title="整合JUnit4"></a>整合JUnit4</h4><p>先，引入依赖spring-test-5.2.6.RELEASE.jar和JUnit4的library</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:bean1.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Junit4Test</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        userService.selectCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="整合JUnit5-1"><a href="#整合JUnit5-1" class="headerlink" title="整合JUnit5"></a>整合JUnit5</h4><ol>
<li>引入JUnit的jar包</li>
</ol>
<p><img src="https://s2.loli.net/2022/02/01/1EW3SpFRPk9NtaT.png" alt="image-20220201144000598"></p>
<p><img src="https://s2.loli.net/2022/02/01/OVx864NISmwgZly.png" alt="image-20220201144107119"></p>
<p>加上这个导入语句后，就可以选择引入</p>
<ol>
<li><p>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:bean1.xml&quot;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>符合注解，替代两个注解</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(locations=&quot;classpath:bean1.xml&quot;)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/01/01/The-core-of-Java/</url>
    <content><![CDATA[<p>title: The-core-of-Java<br>date: 2022-01-01 15:57:57<br>tags: 核心卷一</p>
<h1 id="第四章-对象与类"><a href="#第四章-对象与类" class="headerlink" title="第四章 对象与类"></a>第四章 对象与类</h1><h2 id="第一节-面向对象程序设计概述"><a href="#第一节-面向对象程序设计概述" class="headerlink" title="第一节 面向对象程序设计概述"></a>第一节 面向对象程序设计概述</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类使构造对象的模板或蓝图。可以将类想象成制作小甜饼的切割机，将对象想象为小甜饼。由类构造对象的过程称为创建类的实例。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>(有时称为数据隐藏)是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在一个包里，并对对象的使用者隐藏了数据的实现方式。对象中的数据称为实例域，操纵数据的过程成为方法。对每个特定的类实例(对象)都有一组特定的实例域值。这些值的集合就是这个对象的当前状态。不管何时，只要向对象发送一个消息，他的状态就有可能发生改变。</p>
<p><strong>实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。</strong></p>
<p>这意味着一个类可以全面地改变存储数据的方式，只要仍然使用同样的方法操作数据，其他对象就不会知道或介意所发生的变化。</p>
<p>OOP的另一个原则会让用户自定义Java类变得轻而易举，这就是：可以通过扩展一个类来建立另一个新的类。事实上，在Java中，所有的类都源自于一个“超类”，他就是Object。</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="对象的三个主要特性："><a href="#对象的三个主要特性：" class="headerlink" title="对象的三个主要特性："></a>对象的三个主要特性：</h4><ul>
<li>对象的行为(behavior) —— 可以对对象施加哪些操作，或可以对对象施法哪些方法？</li>
<li>对象的状态(state) —— 当施加那些方法时，对象如何响应？</li>
<li>对象标识(identity) —— 如何辨别具有相同行为与状态的不同对象？</li>
</ul>
<p>同一个类的所有对象实例，由于支持相同的行为而具有家族式的相似性。对象的行为是用可调用的方法定义的。</p>
<p>此外，每个对象都保存着描述当前特征的信息。这就是对象的装填。对象状态的改变必须通过调用方法实现(如果不经过方法调用就可以改变对象的状态，只能说明封装性遭到了破坏)。</p>
<p>但是，对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份(identity)。也就是说，作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。</p>
<h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>在类之间，最常见的关系有</p>
<ul>
<li>依赖(“uses-a”)</li>
<li>聚合(“has-a”)</li>
<li>继承(“is-a”)</li>
</ul>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>即”uses-a”关系，是一种最明显的、最常见的关系。例如，Order(订单)类使用Account(账户)类是因为Order对象需要访问Account对象查看信用状态。但是Item类不依赖于Account类，这是因为Item对象与客户账户无关。因此，如果一个类的方法操纵另一个类的对象，就说一个类依赖于另一个类。</p>
<p>应该尽可能地将相互依赖的类减至最少。就是让类之间的耦合度最小。</p>
<h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>即”has-a”关系，是一种具体且易于理解的关系。例如，一个Order对象包含一些Item(商品)类。</p>
<p>聚合关系意味着类A的对象包含类B的对象。</p>
<blockquote>
<p>有些方法学家，会更喜欢使用“关联”这个术语，而不喜欢聚合这个概念。</p>
</blockquote>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>即“is-a”关系，是一种用于表示特殊与一般关系的。例如，RushOrder类由Order类继承而来。在具有特殊性的RushOrder类中包含了一些用于优先处理的特殊方法，以及一个计算运费的不同方法。</p>
<h2 id="第二讲-使用预定义类"><a href="#第二讲-使用预定义类" class="headerlink" title="第二讲 使用预定义类"></a>第二讲 使用预定义类</h2><h3 id="更改器方法与访问器方法"><a href="#更改器方法与访问器方法" class="headerlink" title="更改器方法与访问器方法"></a>更改器方法与访问器方法</h3><p><code>LocalDate aThousandDaysLater = newYearsEve.plusDays(1000);</code></p>
<p>这个调用之后newYearsEve会有什么变化？他会改为1000天之后的日期吗？事实上，并没有。plusDays方法会生成一个新的LocalDate对象，然后把这个新对象赋给aThousandDaysLater变量。原来的对象不做任何改动。也就是说plusDays方法没有更改调用这个方法的对象。</p>
<p>则称，只访问对象而不修改对象的方法为<strong>访问器方法</strong>(accessor method)。</p>
<p><strong>更改器方法</strong>(mutator method)调用后，对象的状态会发生改变。</p>
<h2 id="第三讲-用户自定义类"><a href="#第三讲-用户自定义类" class="headerlink" title="第三讲 用户自定义类"></a>第三讲 用户自定义类</h2><h3 id="隐式参数与显式参数"><a href="#隐式参数与显式参数" class="headerlink" title="隐式参数与显式参数"></a>隐式参数与显式参数</h3><p>方法用于操作对象以及存取它们的实例域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">raiseSalary</span> <span class="params">(<span class="type">double</span> byPercent)</span> &#123;</span><br><span class="line">	<span class="type">double</span> <span class="variable">raise</span> <span class="operator">=</span> salary * byPercent/ <span class="number">100</span>;</span><br><span class="line">    salary = raise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有两个参数。第一个参数称为隐式(implicit)参数，是出现在方法名前面Employee对象。第二个参数是位于方法名后面括号中的数值，这是一个显式(explicit)参数。(隐式参数也就是方法调用的目标或接收者)</p>
<h3 id="封装的优点"><a href="#封装的优点" class="headerlink" title="封装的优点"></a>封装的优点</h3><p><code>public double getSalary() &#123;return salary;&#125;</code></p>
<p>如上是典型的访问器方法。由于它们只返回实例域值，因此又称为域访问器。</p>
<p>那将salary域标记为public，以此来取代独立的访问器方法呢？</p>
<p>假如salary是一个只读域，那么一旦在构造器中设置完毕，就没有任何一个方法可以对它进行修改，这样来确保salary域不会受到外界的破坏。</p>
<p>不过，虽然salary不是只读域，但是它只能用raiseSalary方法修改。特别是一旦这个域值出现了错误，只要调试这个方法就可以了。如果salary域是public的，破坏这个域值的捣乱者有可能会出没在任何地方。</p>
<p>在有些时候，需要获得或设置实例域的值。因此，应该提供下面三项内容：</p>
<ul>
<li>一个私有的数据域；</li>
<li>一个公有的域访问器方法；</li>
<li>一个公有的域更改器方法。</li>
</ul>
<p>这样做要比提供一个简单的公有数据域复杂些。但是却有着下列明显的好处：</p>
<p>首先，可以改变内部实现，除了该类的方法之外，不会影响其他代码。</p>
<p>其次，更改器可以进行错误检查，防止一些不合理的赋值。</p>
<h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><p>尽管大多数方法都被设计为公有的，但在某些特殊的情况下，也可能将它们设定为私有的。有时，可能希望将一个计算代码划分成若干独立的辅助方法。通常，这些辅助方法不应该成为公有方法的一部分，这是由于它们往往与当前的实现机制非常紧密，或者需要一个特别的协议以及一个特别的调用次序，最好将这样的方法设计为private的。</p>
<p>对于私有方法，如果改用其它方法实现相应的操作，则不必保留原有方法。如果数据的表达方式发生了变化，这个方法可能就变得难以实现，或者不再需要。然而，只要方法是private，类的设计者就可以确认，<strong>它不会被外部的其他类操作调用，可以将其删除。</strong></p>
<h3 id="final实例域"><a href="#final实例域" class="headerlink" title="final实例域"></a>final实例域</h3><p>可以将一个实例域定义为final，构建对象时，必须初始化这样的域。也就是说，必须在确保一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。</p>
<p>final修饰符大都应用于基本(primitive)类型域，或不可变(immutable)类的域(如果类中的每个方法都不会改变其对象，这种类就是不可变的类。)。</p>
<p>如果final修饰的是类的话，也就表示，该引用变量不能再指向其他对象，但对象的值可以发生改变。</p>
<h2 id="第四讲-静态域与静态方法"><a href="#第四讲-静态域与静态方法" class="headerlink" title="第四讲 静态域与静态方法"></a>第四讲 静态域与静态方法</h2><h3 id="静态域-类域"><a href="#静态域-类域" class="headerlink" title="静态域(类域)"></a>静态域(类域)</h3><p>如果将域定义为static，每个类中只有一个这样的域。它属于类，而不属于任何一个独立的对象。</p>
<p>每个对象对于类的实例域都有自己的一份拷贝。如，100个对象，会有100个实例域，但只有1个静态域。</p>
<h3 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h3><p>静态变量用的比较少，但静态常量却用的多。例如：</p>
<p><img src="https://s2.loli.net/2022/01/03/A5zFJnPmtY7h64w.png" alt="image-20220103161658620"></p>
<p>一般来说，由于任何对象都可以对公有域进行修改，所以，最好不要将域设计为public，但公有常量(final域)却没有关系，因为此时，不允许再赋其他值给它。</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><strong>静态方法是一种不能向对象实施的方法</strong>。例如，Math类中的pow：<code>Math.pow(x,a)</code>，在运算时，不使用任何的Math对象。换句话说，没有隐式的参数。</p>
<h3 id="使用静态方法"><a href="#使用静态方法" class="headerlink" title="使用静态方法"></a>使用静态方法</h3><p>在下面两种情况下使用静态方法：</p>
<ul>
<li>一个方法不需要访问对象状态，其所需的参数都是通过显示参数提供的</li>
<li>一个方法只需要访问类的静态域</li>
</ul>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>静态方法还有另一个用途，类似LocalDate和NumberFormat的类使用静态工厂方法(factory method)来构造对象。如下所示，生成不同风格的格式化对象：</p>
<p><img src="https://s2.loli.net/2022/01/03/YHGeydBEaxTtRFn.png" alt="image-20220103163937139"></p>
<p>为什么不使用构造器？</p>
<ul>
<li>无法命名构造器。构造器的名字必须和类名相同。但是，这里希望将得到的货币实例和百分比实例采用不同的名字。</li>
<li>当使用构造器时，无法改变所构造的对象类型。而Factory方法将返回一个DecimalFormat类对象，这是NumberFormat的子类。</li>
</ul>
<h2 id="第五讲-方法参数"><a href="#第五讲-方法参数" class="headerlink" title="第五讲 方法参数"></a>第五讲 方法参数</h2><p>方法参数一共有两种类型：</p>
<ul>
<li>基本数据类型</li>
<li>对象引用</li>
</ul>
<p>对于Java而言，总是采用按值调用。</p>
<p>也就是说，一个方法不可能修改一个基本数据类型的参数。</p>
<p><img src="https://s2.loli.net/2022/01/03/py5Tt4QFhe6kUr3.png" alt="image-20220103165356193"></p>
<p>而对象引用作为参数就不同了。</p>
<p><img src="https://s2.loli.net/2022/01/03/gh1LAIFiPGyxBTu.png" alt="image-20220103165431987"></p>
<p>因为对象的空间是固定的，拷贝的是引用，二者同时引用同一个对象，即指向一个固定的堆空间。</p>
<p>但要记住，Java程序设计语言总是采用<strong>按值调用</strong>，不是类似C++中的引用。也就是说，传递的不是地址！若是直接将两个对象引用作为参数进行交换操作，并不能实现对象指向的交换。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>一个方法不能修改一个基本数据类型的参数(数值型或布尔型)</li>
<li>一个方法可以改变一个对象参数的状态</li>
<li>一个方法不能让对象参数引用一个新的对象</li>
</ul>
<h2 id="第六讲-对象构造"><a href="#第六讲-对象构造" class="headerlink" title="第六讲 对象构造"></a>第六讲 对象构造</h2><h3 id="显式域初始化"><a href="#显式域初始化" class="headerlink" title="显式域初始化"></a>显式域初始化</h3><p>通过重载类的构造器方法，可以采用多种形式设置类的实例域的初始状态。确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值，这是一种很好的设计习惯。</p>
<h3 id="调用另一个构造器"><a href="#调用另一个构造器" class="headerlink" title="调用另一个构造器"></a>调用另一个构造器</h3><p>关键字this引用方法的隐式参数。不过这个关键字还有另一个含义。</p>
<p>如果构造器的第一个语句形如this(…)，这个构造器将调用同一个类的另一个构造器。</p>
<p><img src="https://s2.loli.net/2022/01/03/INWmxkURs9B2tCY.png" alt="image-20220103202413693"></p>
<p>在调用这个方法时，该方法将去调用Employee(String, double)构造器。</p>
<p>这种方式使用this关键字非常有用，这样对公共的构造器代码部分只编写一次即可。</p>
<blockquote>
<p>但C++中，一个构造器不能调用另一个构造器。</p>
</blockquote>
<h3 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h3><h4 id="初始化数据域的方法"><a href="#初始化数据域的方法" class="headerlink" title="初始化数据域的方法"></a>初始化数据域的方法</h4><ul>
<li>在构造器中设置值</li>
<li>在声明中赋值</li>
<li>初始化块</li>
</ul>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。</p>
<p><img src="https://s2.loli.net/2022/01/03/7qXQc8sgJHDrL2w.png" alt="image-20220103203502225"></p>
<p>这种机制不是必需的，也不常见。通常会直接将初始化代码放在构造器中。</p>
<p><img src="https://s2.loli.net/2022/01/03/vYbOosAtuxQDmaX.png" alt="image-20220103204013531"></p>
<p>当然，应该精心地组织好初始化代码。</p>
<h3 id="静态域初始化"><a href="#静态域初始化" class="headerlink" title="静态域初始化"></a>静态域初始化</h3><ul>
<li>提供一个初始化值</li>
</ul>
<p><code>private static int nextId = 1;</code></p>
<ul>
<li>使用静态的初始化块</li>
</ul>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20220104011743662.png" alt="image-20220104011743662"></p>
<h3 id="对象析构与finalize方法"><a href="#对象析构与finalize方法" class="headerlink" title="对象析构与finalize方法"></a>对象析构与finalize方法</h3><p>在析构器中，最常见的操作是回收分配给对象的存储空间。由于Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器。</p>
<p>当然，某些对象使用了内存之外的其他资源，例如，文件或使用了系统资源的另一个对象的句柄。在这种情况下，当资源不再需要时，将其回收和再利用将显得十分重要。</p>
<p>可以为类添加一个finalize方法。finalize方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用finalize方法回收任何短缺资源，这是因为很难直到这个方法什么时候才能够调用。</p>
<p><strong>如果某个资源需要在使用完毕后立刻被关闭，那么就需要由人工来管理。对象用完时，可以应用一个close方法来完成相应的清理操作。</strong></p>
<h2 id="第七讲-包"><a href="#第七讲-包" class="headerlink" title="第七讲 包"></a>第七讲 包</h2><h3 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h3><p>Java允许将包(package)将类组织起来。</p>
<p>使用包的主要原因时去确保类名的唯一性。</p>
<p>在包中定位类是编译器(compiler)的工作。类文件中的字节码肯定使用完整的包名来引用其他类。</p>
<blockquote>
<p>关于C++中import和#include弄混。</p>
<p>实际上，这两者之间并没有共同之处。在C++中，必须使用#include将外部特性的声明加载进来，这是因为C++编译器无法查看任何文件的内部，除了正在编译的文件以及在头文件中明确包含的文件。Java编译器可以查看其他文件的内容，只要告诉它到哪里去查看就可以了。</p>
<p>在C++中，与包机制类似的是命名空间(namespace)。在Java中。package与import语句类似于C++中的namespace和using指令。</p>
</blockquote>
<h3 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h3><p>前面已经接触过访问修饰符public和private。标记为public的部分可以被任意的类使用，标记为private的部分只能被定义它们的类使用。</p>
<p><strong>如果没有指定public或private，这个部分(类、方法或变量)可以被同一个包的所有方法访问。</strong></p>
<h3 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1）把类放到一个目录中，例如/home/user/classdir。</p>
<p>需要注意，这个目录是包树状结构的基目录。如果希望将com.horstmann.corejava.Employee类添加到其中，这个Employee.class类文件就必须位于子目录/home/user/classdir/com/horstmann/corejava中。</p>
<p>2）将JAR文件放在一个目录中，例如：/home/user/archives。</p>
<p>3）设置类路径（class path）。类路径是所有包含类文件的路径的集合。</p>
<p>在UNIX环境中，类路径中的不同项目之间采用冒号（:)分隔：</p>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20220105154939555.png" alt="image-20220105154939555"></p>
<p>在上述两种情况中，句点（.）表示当前目录。</p>
<p>类路径包括：</p>
<p>●  基目录/home/user/classdir或c:\classes；</p>
<p>●  当前目录(.)；</p>
<p>●  JAR文件/home/user/archives/archive.jar或c:\archives\archive.jar。</p>
<h2 id="第九讲-文档注释"><a href="#第九讲-文档注释" class="headerlink" title="第九讲 文档注释"></a>第九讲 文档注释</h2><h3 id="1-方法注释"><a href="#1-方法注释" class="headerlink" title="1. 方法注释"></a>1. 方法注释</h3><p>每个方法注释必须放在所描述的方法之前。</p>
<p>除了通用标记之外，还可以使用下面的标记：</p>
<ul>
<li>@param 变量描述</li>
</ul>
<p>这个标记将对当前方法的“param”(参数)部分参加一个条目。这个描述可以占据多行，并可以使用HTML标记。一个方法的所有的@param标记必须放在一起。</p>
<ul>
<li>@return 描述</li>
</ul>
<p>这个标记将对当前添加”return”(返回)部分。这个描述可以跨越多行，并可以使用HTML标记。</p>
<ul>
<li>@throws 类描述</li>
</ul>
<p>这个标记将添加一个注释，用于表示这个方法可能抛出异常。</p>
<p><img src="https://s2.loli.net/2022/01/05/jDElf7oyhQ3ZTrv.png" alt="image-20220105160743393"></p>
<p><img src="https://s2.loli.net/2022/01/05/we6qAjmNELdGviu.png" alt="image-20220105161216316"></p>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20220105161131526.png" alt="image-20220105161131526"></p>
<h3 id="2-域注释"><a href="#2-域注释" class="headerlink" title="2. 域注释"></a>2. 域注释</h3><p><img src="https://s2.loli.net/2022/01/05/dGbf7SkvEDAqYpJ.png" alt="image-20220105161654770"></p>
<h3 id="3-通用注释"><a href="#3-通用注释" class="headerlink" title="3. 通用注释"></a>3. 通用注释</h3><ul>
<li>@author 姓名</li>
</ul>
<p>这个标记将产生一个”author”(作者)条目。可以使用多个@author标记，每个@author标记对应一个作者。</p>
<ul>
<li>@version 文本</li>
</ul>
<p>这个标记将产生一个“version”(版本)条目。这里的文本可以是对当前版本的任何描述。</p>
<h4 id="4-下面的标记可以用于所有的文档注释"><a href="#4-下面的标记可以用于所有的文档注释" class="headerlink" title="4. 下面的标记可以用于所有的文档注释"></a>4. 下面的标记可以用于所有的文档注释</h4><ul>
<li>@since 文本</li>
</ul>
<p>这个标记将产生一个“since”(始于)条目。这里的text可以是对引入特性的版本描述。例如，@since version 1.7.1。</p>
<ul>
<li>@deprecated文本</li>
</ul>
<p>这个标记将对类、方法或变量天机一个不再使用的注释。文本中给出了取代的建议。</p>
<p><img src="https://s2.loli.net/2022/01/05/kG4KaUy9HYEJdMR.png" alt="image-20220105162315965"></p>
<p><img src="https://s2.loli.net/2022/01/05/X3oF6BbLTYkrGgQ.png" alt="image-20220105162409646"></p>
<h2 id="类设计的技巧"><a href="#类设计的技巧" class="headerlink" title="类设计的技巧"></a>类设计的技巧</h2><h3 id="1-一定要保证数据私有"><a href="#1-一定要保证数据私有" class="headerlink" title="1. 一定要保证数据私有"></a>1. 一定要保证数据私有</h3><p>这是最重要的！</p>
<p><strong>绝对不要破坏封装性。有时候，需要编写一个访问器方法或更改器方法，但是最好还是保持实例域的私有性。</strong></p>
<p>很多惨痛的经验告诉我们，数据的表示形式很可能会改变，但他们的使用方式却不会经常发生变化。</p>
<p>当数据保持私有时，他们的表示形式的变化不会对类的使用者产生影响，即使出现bug也易于检测。</p>
<h3 id="2-一定要对数据初始化"><a href="#2-一定要对数据初始化" class="headerlink" title="2. 一定要对数据初始化"></a>2. 一定要对数据初始化</h3><p>Java不对局部变量进行初始化，但是会对对象的实力域进行初始化。最好不要依赖于系统的默认值，而是应该显式地初始化所有的数据。</p>
<p>具体的初始化方式可以是提供默认值，也可以是在所有构造器中设置默认值。</p>
<h3 id="3-不要在类中使用过多的基本类型"><a href="#3-不要在类中使用过多的基本类型" class="headerlink" title="3. 不要在类中使用过多的基本类型"></a>3. 不要在类中使用过多的基本类型</h3><p>就是说，用其他的类代替多个相关的基本类型的使用。</p>
<p>这样会使类更加易于理解且易于修改。</p>
<p><img src="https://s2.loli.net/2022/01/05/J4oiebVBCzvHKFk.png" alt="image-20220105163502555"></p>
<h3 id="4-不是所有的域都需要独立的域访问器和域更改器"><a href="#4-不是所有的域都需要独立的域访问器和域更改器" class="headerlink" title="4. 不是所有的域都需要独立的域访问器和域更改器"></a>4. 不是所有的域都需要独立的域访问器和域更改器</h3><p>或许，需要获得或设置雇员的薪金。而一旦构造了雇员对象，就应该禁止更改雇佣日期，并且在对象中，常常包含一些不希望别人获得或设置的实例域。</p>
<h3 id="5-将职责过多的类进行分解"><a href="#5-将职责过多的类进行分解" class="headerlink" title="5. 将职责过多的类进行分解"></a>5. 将职责过多的类进行分解</h3><p>这样说似乎有点含糊不清。</p>
<p>但是，如果明显地可以将一个复杂的类分解成两个更为简单的类，就应该将其分解。</p>
<h3 id="6-类名和方法名要能够体现它们的职责"><a href="#6-类名和方法名要能够体现它们的职责" class="headerlink" title="6. 类名和方法名要能够体现它们的职责"></a>6. 类名和方法名要能够体现它们的职责</h3><p>与变量应该有一个能够反映其含义的名字一样，类也能如此。</p>
<p>命名类名的良好习惯是采用一个名词(Order)、前面有形容词修饰的名词(RushOrder)或动名词(有“-ing”后缀)修饰名词(例如，BillingAddress)。</p>
<p>对于方法来说，习惯是访问器方法用小写get开头(getSalary)，更改器方法用小写的set开头(setSalary)。</p>
<h3 id="7-优先使用不可变的类"><a href="#7-优先使用不可变的类" class="headerlink" title="7. 优先使用不可变的类"></a>7. 优先使用不可变的类</h3><p>LocalDate类以及java.time包中的其他类是不可变的——没有方法能修改对象的状态。类似plusDays的方法并不是更改对象，而是返回状态已修改的新对象。</p>
<p>更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改。</p>
<p>其结果是不可预料的。如果类是不可变的，就可以安全地在多个线程间共享其对象。</p>
<p>因此，要尽可能让类是不可变的，这是一个很好的想法。对于表示值的类，如一个字符串或一个时间点，这尤其容易。计算会生成新值，而不是更新原来的值。</p>
<p>当然，并不是所有类都应当是不可变的。如果员工加薪时让raiseSalary方法返回一个新的Employee对象，这会很奇怪。</p>
<h1 id="第五章-继承"><a href="#第五章-继承" class="headerlink" title="第五章 继承"></a>第五章 继承</h1><h2 id="第一讲-类、超类和子类"><a href="#第一讲-类、超类和子类" class="headerlink" title="第一讲  类、超类和子类"></a>第一讲  类、超类和子类</h2><p>关键字extends表明正在构造的新类派生于一个已存在的类。</p>
<p><img src="https://s2.loli.net/2022/01/06/w4toM6dX5z7RUcm.png" alt="image-20220106213143904"></p>
<p>然而，这个方法并不能运行。这是因为Manager类的getSalary方法不能直接地访问超类的私有域。也就是说，尽管每个Manager对象都拥有一个名为salary的域，但在Manager类的getSalary方法中并不能够直接地访问salary域。只有Employee类的方法才能够访问私有部分。如果Manager类的方法一定要访问私有域，就必须借助于公有的接口，Employee类的公有方法getSalary正是这样一个接口。</p>
<p>这里需要指出：我们希望调用超类Employee的getSalary方法，而不是当前类的这个方法。为此，可以使用特定的关键字super解决这个问题：</p>
<p><img src="https://s2.loli.net/2022/01/06/qjSvxMA6JmKkXZi.png" alt="image-20220106213904248"></p>
<blockquote>
<h3 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h3><p>有些人认为super与this引用是类似的概念，实际上：</p>
<p><strong>super并不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。</strong></p>
<p>this两个用途：</p>
<ul>
<li>引用隐式参数</li>
<li>调用该类的其他的构造器(第一条语句)</li>
</ul>
<p>super两个用途：</p>
<ul>
<li>调用超类的方法</li>
<li>调用超类的构造器(第一条语句)</li>
</ul>
</blockquote>
<p><img src="https://s2.loli.net/2022/01/06/584HmLGXJPiYanW.png" alt="image-20220106214721586"></p>
<p>当e引用Employee对象时，e.getSalary( )调用的是Employee类中的getSalary方法；当e引用Manager对象时，e.getSalary( )调用的是Manager类中的getSalary方法。</p>
<p>虚拟机知道e实际引用的对象类型，因此能够正确地调用相应的方法。</p>
<p>一个对象变量（例如，变量e）可以指示多种实际类型的现象被称为<strong>多态</strong>（polymorphism）。</p>
<p>在运行时能够自动地选择调用哪个方法的现象称为<strong>动态绑定</strong>（dynamic binding）。</p>
<h3 id="第五节-多态"><a href="#第五节-多态" class="headerlink" title="第五节 多态"></a>第五节 多态</h3><p>在Java程序设计语言里，<strong>对象变量是多态的</strong>。一个Employee变量既可以引用一个Employee类的对象，也可以引用一个Employee类的任何一个子类的对象，如Manager对象。</p>
<p><img src="https://s2.loli.net/2022/01/06/GIFhMEeC9s247LB.png" alt="image-20220106215805539"></p>
<p><img src="https://s2.loli.net/2022/01/06/yJeQb6hGTlD2sfV.png" alt="image-20220106215854899"></p>
<p>因为，staff[0]声明的类型是Employee，而setBonus不是Employee类的方法。</p>
<p><img src="https://s2.loli.net/2022/01/06/8ytxkeBmWQTjna1.png" alt="image-20220106220145915"></p>
<p>在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。</p>
<p><img src="https://s2.loli.net/2022/01/06/GXA2CRPaQkOjech.png" alt="image-20220106220331459"></p>
<p>使用new Manager[10]创建的数组是一个经理数组，如果试图存储一个Employee类型的引用就会引发ArrayStoreException异常。</p>
<h3 id="第六节-理解方法调用"><a href="#第六节-理解方法调用" class="headerlink" title="第六节 理解方法调用"></a>第六节 理解方法调用</h3><p>弄清楚如何在对象上应用方法调用非常重要。</p>
<p>下面假设要调用x.f(args)，隐式参数x声明为类C的一个对象。</p>
<h4 id="1-下面是调用过程的详细描述："><a href="#1-下面是调用过程的详细描述：" class="headerlink" title="1. 下面是调用过程的详细描述："></a>1. 下面是调用过程的详细描述：</h4><p><strong>1）编译器查看对象的声明类型和方法名。</strong></p>
<p>假设调用x.f(param)，且隐式参数x声明为C类的对象。需要注意的是：有可能存在多个名字为f，但参数类型不一样的方法。例如，可能存在方法f(int)和方法f(String)。编译器将会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法（超类的私有方法不可访问）。至此，编译器已获得所有可能被调用的候选方法。</p>
<p><strong>2）接下来，编译器将查看调用方法时提供的参数类型。</strong></p>
<p>如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为重载解析（overloading resolution）。例如，对于调用x.f(“Hello”)来说，编译器将会挑选f(String)，而不是f(int)。由于允许类型转换（int可以转换成double, Manager可以转换成Employee，等等），所以这个过程可能很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。</p>
<p>至此，编译器已获得需要调用的方法名字和参数类型。</p>
<blockquote>
<h4 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h4><p>前面曾经说过，<strong>方法的名字和参数列表称为方法的签名。</strong></p>
<p>例如，f(int)和f(String)是两个具有相同名字，不同签名的方法。如果在子类中定义了一个与超类签名相同的方法，那么子类中的这个方法就覆盖了超类中的这个相同签名的方法。</p>
<p>不过，返回类型不是签名的一部分，因此，在覆盖方法时，一定要保证返回类型的兼容性。</p>
<p>允许子类将覆盖方法的返回类型定义为原返回类型的子类型</p>
</blockquote>
<p><strong>3）如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为静态绑定（static binding）。</strong></p>
<p>与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。在我们列举的示例中，编译器采用动态绑定的方式生成一条调用f (String)的指令。</p>
<p><strong>4）当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。</strong></p>
<p>假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就直接调用它；否则，将在D类的超类中寻找f(String)，以此类推。</p>
<h4 id="2-方法表"><a href="#2-方法表" class="headerlink" title="2. 方法表"></a>2. 方法表</h4><p>每次调用方法都要进行搜索，时间开销相当大。</p>
<p>因此，虚拟机预先为每个类创建了一个<strong>方法表（method table）</strong>，其中列出了所有方法的签名和实际调用的方法。</p>
<p>这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。</p>
<p>在前面的例子中，虚拟机搜索D类的方法表，以便寻找与调用f(Sting)相匹配的方法。这个方法既有可能是D.f(String)，也有可能是X.f(String)，这里的X是D的超类。这里需要提醒一点，如果调用super.f(param)，编译器将对隐式参数超类的方法表进行搜索。</p>
<p><img src="https://s2.loli.net/2022/01/06/vgGCnimSphPfyWJ.png" alt="image-20220106222122309"></p>
<p>动态绑定有个非常重要的特性：</p>
<p>无需对现存的代码进行修改，就可以对程序进行拓展。假设增加一个新类Executive，并且变量e有可能引用这个类的对象，我们不需要对包含调用e.getSalary()的代码进行重新编译。如果e恰好引用一个Executive类的对象，就会自动地调用Executive.getSalary()方法。</p>
<h3 id="第八讲-强制类型转换"><a href="#第八讲-强制类型转换" class="headerlink" title="第八讲 强制类型转换"></a>第八讲 强制类型转换</h3><p><img src="https://s2.loli.net/2022/01/06/HyVSjae4CBIZvrg.png" alt="image-20220106222959327"></p>
<h4 id="进行的唯一原因"><a href="#进行的唯一原因" class="headerlink" title="进行的唯一原因"></a>进行的唯一原因</h4><p>在暂时忽视对象的实际类型之后，使用对象的全部功能。</p>
<p>例如，我们需要将数组中引用经理的元素复原成Manager类，以便能够访问新增加的所有变量。</p>
<p><strong>将一个值存入变量时，编译器将检查是否允许该操作。</strong></p>
<p><strong>将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检查。</strong></p>
<h4 id="因此"><a href="#因此" class="headerlink" title="因此"></a>因此</h4><p>应该养成这样一个良好的程序设计习惯：</p>
<p>在进行类型转换之前，先查看一下是否能够成功地转换。这个过程简单地使用instanceof操作符就可以实现。</p>
<p><img src="https://s2.loli.net/2022/01/06/P6xaWHNV2iBznck.png" alt="image-20220106223351872"></p>
<p>在一般情况下，应当尽量少用强制类型转换和instanceof。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>只能在继承层次内进行类型转换。</li>
<li>再将超类转换成子类之前，应该使用instanceof进行检查。</li>
</ul>
<h3 id="第九节-抽象类"><a href="#第九节-抽象类" class="headerlink" title="第九节 抽象类"></a>第九节 抽象类</h3><p><img src="https://s2.loli.net/2022/01/06/n57lrmIu4kg2Q9C.png" alt="image-20220106223848993"></p>
<p>在Person中，</p>
<p><img src="https://s2.loli.net/2022/01/06/k9eO1AjQcEUxDNn.png" alt="image-20220106224101130"></p>
<p><strong>许多程序员认为，在抽象类中不能包含具体方法。建议尽量将通用的域和方法（不管是否是抽象的）放在超类（不管是否是抽象类）中。</strong></p>
<p>抽象方法充当着占位的角色，它们的具体实现在子类中。</p>
<h4 id="1-扩展抽象类可以有两种选择。"><a href="#1-扩展抽象类可以有两种选择。" class="headerlink" title="1. 扩展抽象类可以有两种选择。"></a>1. 扩展抽象类可以有两种选择。</h4><ul>
<li><p>一种是在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类；</p>
</li>
<li><p>另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。</p>
</li>
</ul>
<p>例如，通过扩展抽象Person类，并实现getDescription方法来定义Student类。由于在Student类中不再含有抽象方法，所以不必将这个类声明为抽象的。类即使不含抽象方法，也可以将类声明为抽象类。</p>
<h4 id="2-抽象类不能被实例化。"><a href="#2-抽象类不能被实例化。" class="headerlink" title="2. 抽象类不能被实例化。"></a>2. 抽象类不能被实例化。</h4><p>也就是说，如果将一个类声明为abstract，就不能创建这个类的对象。</p>
<p><strong>需要注意，可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。</strong>例如，</p>
<p><img src="https://s2.loli.net/2022/01/06/pZyfraxLwRIiOUE.png" alt="image-20220106224627968"></p>
<p>这里的p是一个抽象类Person的变量，Person引用了一个非抽象子类Student的实例。</p>
<h3 id="Java用于控制可见性的4个访问修饰符："><a href="#Java用于控制可见性的4个访问修饰符：" class="headerlink" title="Java用于控制可见性的4个访问修饰符："></a>Java用于控制可见性的4个访问修饰符：</h3><ul>
<li>仅对本类可见——private。</li>
<li>对所有类可见——public。</li>
<li>对本包和所有子类可见——protected。</li>
<li>对本包可见——默认（很遗憾），不需要修饰符。</li>
</ul>
<h2 id="第二讲-Object：所有类的超类"><a href="#第二讲-Object：所有类的超类" class="headerlink" title="第二讲 Object：所有类的超类"></a>第二讲 Object：所有类的超类</h2><p>在Java中，只有基本类型不是对象。</p>
<h3 id="第一节-equals-方法"><a href="#第一节-equals-方法" class="headerlink" title="第一节 equals 方法"></a>第一节 equals 方法</h3><p><img src="https://s2.loli.net/2022/01/17/zDTi9tMsyOCfbPg.png" alt="image-20220117213943571"></p>
<blockquote>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p><strong>为了防备name或hireDay可能为null的情况，需要使用Objects.equals方法。</strong></p>
<p>如果两个参数都为null, Objects.equals(a, b)调用将返回true；如果其中一个参数为null，则返回false；否则，如果两个参数都不为null，则调用a.equals(b)。利用这个方法，Employee.equals方法的最后一条语句要改写为：</p>
<p><img src="https://s2.loli.net/2022/01/17/VuKSeBdMj5lN2zc.png" alt="image-20220117225732398"></p>
</blockquote>
<p>在子类中定义equals方法时，首先调用超类的equals。如果检测失败，对象就不可能相等。如果超类中的域都相等，就需要比较子类中的实例域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object otherObject)</span> &#123;</span><br><span class="line">        <span class="comment">// super.equals checked that this and otherObject belong to the same class</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">super</span>.equals(otherObject))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">other</span> <span class="operator">=</span> (Manager) otherObject;</span><br><span class="line">        <span class="type">return</span> <span class="variable">bonus</span> <span class="operator">=</span>= other.bonus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java语言规范要求equals方法具有下列特性：</p>
<ol>
<li><strong>自反性</strong>：对于任何非空引用x,  x.equals(x)应该返回true。</li>
<li><strong>对称性</strong>：对于任何引用x和y，当且仅当y.equals(x)返回true， x.equals(y)也应该返回true。</li>
<li><strong>传递性</strong>：对于任何引用x、y和z，如果x.equals(y)返回true， y.equals(z)返回true， x.equals(z)也应该返回true。</li>
<li><strong>一致性</strong>：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果。</li>
<li><strong>对于任意非空引用x， x.equals(null)应该返回false。</strong></li>
</ol>
<p><img src="https://s2.loli.net/2022/01/17/2pbVS14yPh8EQfC.png" alt="image-20220117232952358"></p>
<h4 id="下面给出编写一个完美的equals方法的建议："><a href="#下面给出编写一个完美的equals方法的建议：" class="headerlink" title="下面给出编写一个完美的equals方法的建议："></a>下面给出编写一个完美的equals方法的建议：</h4><p>1）显式参数命名为otherObject，稍后需要将它转换成另一个叫做other的变量。</p>
<p>2）检测this与otherObject是否引用同一个对象：</p>
<p><code>if (this == otherObject) return true;</code></p>
<p>这条语句只是一个优化。实际上，这是一种经常采用的形式。</p>
<p><strong>因为计算这个等式要比一个一个地比较类中的域所付出的代价小得多。</strong></p>
<p>3）检测otherObject是否为null，如果为null，返回false。这项检测是很必要的。</p>
<p><code>if (otherObject == null) return false;</code></p>
<p>4）比较this与otherObject是否属于同一类。如果equals的语义在每个子类中有所改变，就使用getClass检测：</p>
<p><code>if (getClass() != otherObject.getClass()) return false;</code></p>
<p>如果所有的子类都拥有统一的语义，就使用instanceof检测：</p>
<p><code>if (!(otherObject instanceof ClassName)) return false;</code></p>
<p>5）将otherObject转换为相应的类类型变量：</p>
<p><code>ClassName other = (ClassName) otherObject</code></p>
<p>6）现在开始对所有需要比较的域进行比较了。使用==比较基本类型域，使用equals比较对象域。如果所有的域都匹配，就返回true；否则返回false。</p>
<p><code>return field1 == other.field1 &amp;&amp; Objects.equals(field2, other.fields) &amp;&amp; ...;</code></p>
<p>如果在子类中重新定义equals，就要在其中包含调用super.equals(other)。</p>
<blockquote>
<p>对于数组类型的域，可以使用静态的Arrays.equals方法检测相应的数组元素是否相等。</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/01/18/f19UtvBs7MEOdCH.png" alt="image-20220118001450380"></p>
<h3 id="第二节-hashcode方法"><a href="#第二节-hashcode方法" class="headerlink" title="第二节 hashcode方法"></a>第二节 hashcode方法</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><p>散列码(hashcode)是由对象导出的一个整型值。散列码是没有规律的。如果x和y是两个不同的对象，x.hashCode( )与y.hashCode( )基本上不会相同。</p>
<p><img src="https://s2.loli.net/2022/01/18/KBXh3gSZmtCG4Mx.png" alt="image-20220118003233455"></p>
<p><img src="https://s2.loli.net/2022/01/18/rRsCczkHXWQvZ5d.png" alt="image-20220118003328447"></p>
<h4 id="2-为什么要有hashCode"><a href="#2-为什么要有hashCode" class="headerlink" title="2. 为什么要有hashCode"></a>2. 为什么要有hashCode</h4><p>当你把对象加入HashSet时，HashSet会先计算对象的hashCode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashCode值作比较，如果没有相符的hashCode，HashSet会假设对象没有重复出现。</p>
<p>但是如果发现有相同hashCode值的对象，这是会调用equals( )方法来检查hashCode相等的对象是否真的相同。</p>
<p>若两者相同，HashSet就不会让其加入成功，如果不同的话，就会重新散列到不同的位置。这样就减少了调用equals( )方法的次数，提高了执行速度。</p>
<h4 id="3-equals-和hashCode"><a href="#3-equals-和hashCode" class="headerlink" title="3. equals( )和hashCode( )"></a>3. equals( )和hashCode( )</h4><p>其实，hashCode( )和equals( )都是用于比较两个对象是否相等。</p>
<h5 id="1-同时提供"><a href="#1-同时提供" class="headerlink" title="1. 同时提供"></a>1. 同时提供</h5><p>因为在一些容器中(如HashMap、HashSet)中，有hashCode( )之后，判断元素是否在对应容器中的效率会更高。</p>
<p>当然，如果获得的hashCode( )相同，会使用equals( )判断是否真的相同。</p>
<p>同时，因为hashCode( )所使用的哈希算法，也许刚好会让多个对象传回相同的哈希值(越糟糕的哈希算法越容易碰撞，不过这也与数据值域分布放入特性有关)，这也导致了<strong>两个对象的hashCode值相等，并不代表两个对象就相等</strong>。</p>
<h5 id="2-所以"><a href="#2-所以" class="headerlink" title="2. 所以"></a>2. 所以</h5><ol>
<li>如果两个对象的hashCode值不相等，那么两个对象直接可以认为是不相等的。</li>
<li>如果两个对象的hashCode值相等，那么两个对象也不一定相等(哈希碰撞)。</li>
<li>如果两个对象的hashCode值相等且equals( )方法的返回值为true，则可以认为这两个对象相等。</li>
</ol>
<h5 id="3-重写equals-必须重写hashCode"><a href="#3-重写equals-必须重写hashCode" class="headerlink" title="3. 重写equals()必须重写hashCode()"></a>3. 重写equals()必须重写hashCode()</h5><p><strong>因为两个相等对象的hashCode值必须是相等的。也就是说，如果equals( )方法判断两个对象是相等的，那么这两个对象的hashCode值也要相等。</strong></p>
<p>如果重写equals( )方法时，没有重写hashCode( )方法的话，就可能会导致equals方法判断是相等的两个对象，hashCode值却不相等。 </p>
<h5 id="4-其他佐证"><a href="#4-其他佐证" class="headerlink" title="4. 其他佐证"></a>4. 其他佐证</h5><p><img src="https://s2.loli.net/2022/02/21/xz6jTLfG4s31B5R.png" alt="image-20220221235707389"></p>
<p><img src="https://s2.loli.net/2022/02/21/jGTsLIKUr3Z2QN8.png" alt="image-20220221235746077"></p>
<h4 id="4-重写hashCode方法"><a href="#4-重写hashCode方法" class="headerlink" title="4. 重写hashCode方法"></a>4. 重写hashCode方法</h4><p>hashCode方法应该返回一个整型数值(可以是负数)，并合理地组合实例域的散列码，以便能够让不同的对象产生散列码更加均匀。</p>
<p>首先，最好使用null安全的Objects.hashCode。如果其参数为null，会返回0，否则返回对参数调用hashCode方法的结果。</p>
<p>另外，对double类型的对象，调用静态方法Double.hashCode方法来避免创建Double对象：</p>
<p><img src="https://s2.loli.net/2022/02/22/KMOxUAc7DV4uXbG.png" alt="image-20220222000820113"></p>
<p>同时，需要组合多个散列值时，可以调用Objects.hash并提供多个参数。这个方法会对各个参数调用Objects.hashCode，并组合这些散列值。</p>
<p><img src="https://s2.loli.net/2022/02/22/ln71gMSFscJN6Pv.png" alt="image-20220222000939436"></p>
<h2 id="第三讲-泛型数组列表"><a href="#第三讲-泛型数组列表" class="headerlink" title="第三讲 泛型数组列表"></a>第三讲 泛型数组列表</h2><p>在Java中，允许在运行时确定数组的大小，但并不能在运行时动态更改数组。所以，ArrayList得以广泛应用。</p>
<h3 id="引子-菱形语法"><a href="#引子-菱形语法" class="headerlink" title="引子 菱形语法"></a>引子 菱形语法</h3><p>ArrayList是个采用类型参数(type parameter)的泛型类(generic class)。为了指定数组列表保存的元素对象类型，需要用一堆尖括号将类名括起来加在后面。如：</p>
<p><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(); // 省略了右边的类型参数</code></p>
<p>这被称为菱形语法，因为空尖括号&lt;&gt;就像一个菱形。可以结合new操作符使用菱形语法。编译器会检查新值是什么。如果赋值给一个变量，或传递到某个方法，或者从这个方法返回，编译器会检查这个变量、参数或方法的泛型类型，然后将这个类型放在&lt;&gt;中。在这个例子中，new ArrayList&lt;&gt;()将赋至一个类型为ArrayList<Employee>的变量，所以泛型类型为Employee。</p>
<h3 id="第一节-方法"><a href="#第一节-方法" class="headerlink" title="第一节 方法"></a>第一节 方法</h3><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>在数组列表中，如果调用add并且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。</p>
<h4 id="capacity-和-size"><a href="#capacity-和-size" class="headerlink" title="capacity 和 size"></a>capacity 和 size</h4><p>数组的大小和数组列表的容量有一个非常重要的区别。</p>
<p>如果为数组分配100个元素的存储空间，数组就有100个空位置可以使用。</p>
<p>而容量为100个元素的数组列表只是拥有保存100个元素的潜力。但是在最初，甚至完成了初始化构造之后，数组列表根本就不含有任何元素。</p>
<p>一旦能够确认数组列表的长度不再变化，可以使用trimToSize的方法。这个方法将存储区域的大小调整为当前元素数量所需的存储空间变化。垃圾回收器将回收多余的空间。(此时再添加新元素就需要花时间再次移动存储块，所以应该再确认不会添加任何元素的情况下，再调用trimToSize。)</p>
<h3 id="第二节-访问数组列表元素"><a href="#第二节-访问数组列表元素" class="headerlink" title="第二节 访问数组列表元素"></a>第二节 访问数组列表元素</h3><p>不能使用[ ]语法格式，只能使用set或get方法来实现访问或改变数组元素的操作。</p>
<h5 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h5><p>只有i小于等于数组列表的大小时，才能使用 list.set(i, x) 方法。例如，下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">list.set(<span class="number">0</span>, x); <span class="comment">//no element 0 yet</span></span><br></pre></td></tr></table></figure>
<p>使用add方法添加元素，使用set方法只能改变已有元素的值，不能添加。</p>
<h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><p><code>Employee a = staff.get(i);</code></p>
<h5 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h5><p>可以先使用数组列表创建并添加元素，之后使用.toArray( )方法将其转化为数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee[] x = <span class="keyword">new</span> <span class="title class_">Employee</span>[list.size()];</span><br><span class="line">list.toArray(x);</span><br></pre></td></tr></table></figure>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E object)</span>;</span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E object)</span>; <span class="comment">// 可以不用加index</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>; <span class="comment">// 删除一个元素，并将其后的元素向前移动，被删除的元素由返回值返回。</span></span><br></pre></td></tr></table></figure>
<h3 id="第三节-类型化与原始数组列表的兼容性"><a href="#第三节-类型化与原始数组列表的兼容性" class="headerlink" title="第三节 类型化与原始数组列表的兼容性"></a>第三节 类型化与原始数组列表的兼容性</h3><p>与没有使用类型参数的遗留代码交互操作。</p>
<ol>
<li><p>可以将一个类型化的数组列表作为函数的参数赋值给原始的ArrayList对象，如：</p>
<p> ArrayList<Employee> staff 可以作为参数赋值给ArrayList list，且不需要任何的类型转换。</p>
</li>
<li><p>但是将一个原始的ArrayList赋给一个类型化的ArrayList会得到一个警告信息。如</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> ArrayList <span class="title function_">find</span><span class="params">(String query)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Employee&gt; list = find(query); <span class="comment">// yields warning</span></span><br><span class="line"><span class="comment">// 使用类型转化也无用</span></span><br><span class="line">ArrayList&lt;Employee&gt; list = (ArrayList&lt;Employee&gt;)find(query); <span class="comment">// 指出类型转换有误</span></span><br></pre></td></tr></table></figure>
<p> 这就是Java中不尽如人意的参数化类型的限制所带来的结果。</p>
<p> 鉴于兼容性的考虑，编译器在对类型转换进行检查之后，如果没有发现违反规则的现象，就将所有的类型化类数组列表转换成原始ArrayList对象。</p>
<p> 即，在程序运行时，所有的数组列表都是一样的，没有虚拟机中的类型参数。</p>
</li>
</ol>
<h2 id="第四讲-对象包装器与自动装箱"><a href="#第四讲-对象包装器与自动装箱" class="headerlink" title="第四讲 对象包装器与自动装箱"></a>第四讲 对象包装器与自动装箱</h2><p>&lt; &gt;中的类型参数不允许是基本类型。</p>
<h3 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">3</span>); <span class="comment">// 会自动将其变换成list.add(Integer.valueOf(3));</span></span><br></pre></td></tr></table></figure>
<h3 id="自动拆箱"><a href="#自动拆箱" class="headerlink" title="自动拆箱"></a>自动拆箱</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.get(i); <span class="comment">// 自动变换成list.get(i).intValue();</span></span><br></pre></td></tr></table></figure>
<h2 id="第五讲-参数数量可变的方法"><a href="#第五讲-参数数量可变的方法" class="headerlink" title="第五讲 参数数量可变的方法"></a>第五讲 参数数量可变的方法</h2><p>printf方法是这样定义的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(String fmt, Object... args)</span> &#123; <span class="keyword">return</span> format(fmt, args); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的…是Java代码的一部分，表示可以接收任意数目的变量。</p>
<p>其实，printf方法接收两个参数，一个是格式化字符串，一个是Object[ ]数组。</p>
<p><strong>但是只允许其作为最后一个参数。</strong></p>
<h2 id="第六讲-枚举类"><a href="#第六讲-枚举类" class="headerlink" title="第六讲 枚举类"></a>第六讲 枚举类</h2><p>举个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> enmu Size &#123; SMALL, MEDIUM, LARGE, EXTRA_LARGE &#125;;</span><br></pre></td></tr></table></figure>
<p>这个声明定义的类型是一个类，它刚好有4个实例，在此尽量不要构造新对象。</p>
<p>因此，在比较两个枚举类型的值时，永远不需要调用equels方法，而直接使用”==”即可。</p>
<p>可以添加一些构造器、方法和域。构造器只是在构造枚举常量的时候被调用。</p>
<p><img src="https://s2.loli.net/2022/03/06/zroXSF2fg3sjTp8.png" alt="image-20220306103631328"></p>
<p>所有的枚举类型都是Enum类的子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Size.SMALL.toString() <span class="comment">// 返回&quot;SMALL&quot;</span></span><br><span class="line"><span class="type">Size</span> <span class="variable">s</span> <span class="operator">=</span> Eunm.valueOf(Size.class, <span class="string">&quot;SMALL&quot;</span>); <span class="comment">// 设置Size为Size.SMALL</span></span><br><span class="line"><span class="keyword">static</span> Enum <span class="title function_">valueOf</span><span class="params">(Class enumClass, String name)</span> <span class="comment">// 返回指定名字、给定类的枚举常量</span></span><br><span class="line">Size[] values = Size.values(); <span class="comment">// 返回包含全部枚举值的数组</span></span><br><span class="line">Size.SMALL.ordinal() <span class="comment">// 返回enum声明中枚举常量的位置，从0开始计数，返回0.</span></span><br></pre></td></tr></table></figure>
<h2 id="第七讲-反射"><a href="#第七讲-反射" class="headerlink" title="第七讲 反射"></a>第七讲 反射</h2><h3 id="第0节-概述"><a href="#第0节-概述" class="headerlink" title="第0节 概述"></a>第0节 概述</h3><p>能够分析类能力的程序称为反射(reflective)。</p>
<p>反射机制可以用来：</p>
<ul>
<li>在运行时分析类的能力</li>
<li>在运行时查看对象</li>
<li>实现通用的数组操作代码</li>
<li>利用Method对象，类似C++中的函数指针</li>
</ul>
<h3 id="第一节-Class类"><a href="#第一节-Class类" class="headerlink" title="第一节 Class类"></a>第一节 Class类</h3><p>在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。</p>
<p>这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。</p>
<p>可以通过专门的Java类访问这些信息。保存这些信息的类被称为Class。</p>
<p><strong>Object类中的getClass()将返回一个Class类型的实例。</strong></p>
<p><strong>一个Class对象将表示一个特定类的属性。</strong></p>
<p>最常用的是getName( )方法，这个方法将返回类的名字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> generator.getClass();</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> c1.getName(); <span class="comment">// name is &quot;java.util.Random&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="获取Class对象的方法"><a href="#获取Class对象的方法" class="headerlink" title="获取Class对象的方法"></a>获取Class对象的方法</h4><ul>
<li>对象.getClass( );</li>
<li>类名.class;</li>
<li>Class.forName(全类名);</li>
</ul>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法一：</span></span><br><span class="line"><span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> e.getClass();</span><br><span class="line"><span class="comment">// 法二：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;java.util.Random&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"><span class="comment">// 法三：</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Random.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="type">int</span>.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> Double[].class;</span><br></pre></td></tr></table></figure>
<p>法二：如果类名保存在字符串里，并可在运行中改变，就可以使用这个方法。</p>
<p>当然，这个方法只有在className中保存的是类名或接口名时才能够执行。</p>
<p>注意：一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类。如int不是类，但是int.class表示的是一个Class类型的对象。</p>
<h4 id="其他特点"><a href="#其他特点" class="headerlink" title="其他特点"></a>其他特点</h4><h5 id=""><a href="#" class="headerlink" title="=="></a>==</h5><p>虚拟机为每个类型管理一个Class对象，可以利用==来实现两个类对象比较的操作。</p>
<p><code>if (e.getClass() == Employee.class)&#123;...&#125;</code></p>
<h5 id="newInstance"><a href="#newInstance" class="headerlink" title="newInstance( )"></a>newInstance( )</h5><p>可以用来动态的创建一个类的实例</p>
<p><code>Object m = e.getClass().newInstance();</code></p>
<p>或</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;java.util.Random&quot;</span>;</span><br><span class="line"><span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> Class.forName(className).newInstance();</span><br></pre></td></tr></table></figure>
<p>创建了一个和e同类型的实例。newInstance()方法调用默认的构造器(没有参数的构造器)来初始化新创建的对象，如果这个类没有默认的构造器，就会抛出一个异常。</p>
<h3 id="第二节-捕获异常"><a href="#第二节-捕获异常" class="headerlink" title="第二节 捕获异常"></a>第二节 捕获异常</h3><p>异常有两种类型：未检查异常和已检查异常。</p>
<p>对于已检查异常，编译器将会检查是否提供了处理器。</p>
<p>有很多常见的异常，如，访问null引用，都属于未检查移仓。编译器不会查看是否为这些错误提供了处理器。毕竟，应该精心编写代码来避免这些错误的发生，而不要将精力花在编写异常处理器上。</p>
<p>将可能抛出已检查异常的代码放置在try块中，然后在catch子句中提供处理器代码。</p>
<p>如果抛出异常，就会跳过try块中的剩余代码，去执行catch子句(利用Throwable类的printStackTrace方法打印出栈的轨迹。Throwable是Exception类的超类)。如果没有抛出异常，就会跳过catch中的处理器代码。</p>
<p><code>void printStackTrace() // 将Throwable对象和栈的轨迹输出到标准错误流。</code></p>
<h3 id="第三节-利用反射分析类"><a href="#第三节-利用反射分析类" class="headerlink" title="第三节 利用反射分析类"></a>第三节 利用反射分析类</h3><h4 id="三个类"><a href="#三个类" class="headerlink" title="三个类"></a>三个类</h4><p>反射机制最重要的内容—检查类的结构。</p>
<p>在java.lang.reflect包中有三个类：Field、Method和Constructor，分别用于描述类的域、方法和构造器。 </p>
<ul>
<li>getName方法：返回项目的名称</li>
<li>getModifiers方法：返回一个整型数值，用不同的位开关描述public和static这样的修饰符使用状况。(可以使用Modifier类的静态方法来分析返回的整型数值。)</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>Class类中的getFields、getMethods、getConstructors方法将分别返回类提供的public域、方法和构造器数组，其中包括超类的公有成员。</p>
<p>Class类中的getDeclareFields、getDeclareMethods和getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器，其中包括私有成员和受保护成员，但不包括超类中的成员。</p>
<h3 id="第四节-运行时使用反射分析对象"><a href="#第四节-运行时使用反射分析对象" class="headerlink" title="第四节 运行时使用反射分析对象"></a>第四节 运行时使用反射分析对象</h3><p>进一步查看数据域的实际内容。</p>
<p>查看对象域的关键方法是Field类中的get方法。如例所示：</p>
<p><img src="https://s2.loli.net/2022/03/09/JeguiE7tO1Fnmyw.png" alt="image-20220309175410048"></p>
<p>实际上，由于name是个私有域，所以get方法将会抛出一个IllegalAccessException。只有利用get方法才能得到可访问域的值。除非拥有访问权限，否则Java安全机制只允许查看任意对象有哪些域，而不允许读取它们的值。</p>
<p>反射机制的默认行为受限于Java的访问控制。然而，如果一个Java程序没有受到安全管理器的控制，就可以覆盖访问控制。为了达到这个目的，需要调用Field、Method或Constructor对象的setAccessible方法。</p>
<p><img src="https://s2.loli.net/2022/03/09/xGJ91tVPBIga82p.png" alt="image-20220309180116987"></p>
<p>setAccessible方法是AccessibleObject类中的一个方法，它是Field、Method和Constructor类的公共超类。这个特性是为调试、持久存储和相似机制提供的。</p>
<h3 id="第五节-使用反射编写泛型数组代码"><a href="#第五节-使用反射编写泛型数组代码" class="headerlink" title="第五节 使用反射编写泛型数组代码"></a>第五节 使用反射编写泛型数组代码</h3><p>java.lang.reflect包中的Array类允许动态地创建数组。编写一个Array类中的copyOf方法实现中，如：</p>
<p><img src="https://s2.loli.net/2022/03/09/KwuPQ8AYZTFCbRa.png" alt="image-20220309182346217"></p>
<p>Java数组会记住每个元素的类型，即创建数组时new表达式中使用的元素类型。</p>
<p>将一个Employee[ ]临时地转换成Object[ ]数组，然后再把它转换回来是可以的，但一个从开始就是Object[ ]的数组，永远不能转换成Employee[ ]数组。</p>
<p>为了编写这类通用的数组代码，需要能够创建与原数组类型相同的新数组。为此需要调用Array类中的静态方法newInstance，它能够构造新数组。在调用它时必须提供两个参数，一个是数组的元素类型，一个是数组的长度。</p>
<p><code>Object newArray = Array.newInstance(componentType, newLength);</code></p>
<p>可以通过调用Array.getLength(a)获得数组的长度，也可以通过Array类的静态getLength方法的返回值得到任意数组的长度，而要获得新数组元素类型，就需要进行以下工作：</p>
<ol>
<li>首先获得a数组的类对象</li>
<li>确认它是一个数组</li>
<li>使用Class类(只能定义表示数组的类对象)的getComponentType方法确定数组对应的类型。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">goodCopyOf</span><span class="params">(Object a, <span class="type">int</span> newLength)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> a.getClass();</span><br><span class="line">    <span class="keyword">if</span> (!a.isArray())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">componentType</span> <span class="operator">=</span> c1.getComponentType();</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> Array.getLength(a);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">newArray</span> <span class="operator">=</span> Array.newInstance(componentType, newLength);</span><br><span class="line">    <span class="comment">// 原数组、原数组复制的起始索引、目标数组、复制的起始索引、复制长度</span></span><br><span class="line">    <span class="comment">// 原数组复制的起始索引+复制长度&lt;=原数组长度</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, newArray, <span class="number">0</span>, Math,min(length, newLength));</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这arraycopy()都是小写。</p>
<p>请注意，这个CopyOf方法可以用来扩展任意类型的数组，而不仅是对象数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] a = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">a = (int[]) goodCopyOf(a, 10);</span><br></pre></td></tr></table></figure>
<p>为了能够实现上述操作，应该将goodCopyOf的参数声明为Object类型，而不要声明为对象型数组(Object[ ])。整数型数组类型int[ ]可以被转换成Object，但不能转换成对象数组。</p>
<h3 id="第六节-调用任意方法"><a href="#第六节-调用任意方法" class="headerlink" title="第六节 调用任意方法"></a>第六节 调用任意方法</h3><p>反射机制允许你调用任意方法。</p>
<p>在Method类中，有一个invoke方法，它允许调用包装在当前Method对象中的方法。invoke方法的签名是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span></span><br></pre></td></tr></table></figure>
<p>第一个参数是隐式参数，其余的对象提供了显示参数。</p>
<p>对于静态方法，第一个参数可以被忽略，即可以将它设置为null。</p>
<p>如果返回类型是基本类型，invoke方法会返回其包装器类型。例如，假设m2表示Employee类的getSalary方法，那么返回的对象实际上Double，必须相应地完成类型转换。可以使用自动拆箱将它转换为一个double：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">s</span> <span class="operator">=</span> (Double)m2.invoke(harry);</span><br></pre></td></tr></table></figure>
<h4 id="得到Method对象"><a href="#得到Method对象" class="headerlink" title="得到Method对象"></a>得到Method对象</h4><ol>
<li><p>可以通过调用getDeclareMethods方法，然后对返回的Method对象数组进行查找，直到发现想要的方法为止。</p>
</li>
<li><p>通过调用Class类中的getMethod方法得到想要的方法。</p>
<p> 然而，有可能存在若干个相同名字的方法，<strong>因为还必须提供想要的方法的参数类型</strong>。getMethod的签名是：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method <span class="title function_">getMethod</span><span class="params">(String name, Class... paramterTypes)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 举个例子，获得Employee类的getName方法和raiseSalary方法的方法指针</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> Employee.class.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> Employee.class.getMethod(<span class="string">&quot;raiseSalary&quot;</span>, <span class="type">double</span>.class);</span><br></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>invoke的参数和返回值必须是Object类型的。这就意味着必须进行多次的类型转换，这样做将会使编译器错过检查代码的机会。</p>
<p>不仅如此，使用反射获得方法指针的代码要比仅仅直接调用方法明显慢一点。</p>
<p><strong>建议仅在必要的时候才使用Method对象，而最好使用接口以及Java SE 8中的lambda表达式。</strong></p>
<h2 id="第八讲-继承的设计技巧"><a href="#第八讲-继承的设计技巧" class="headerlink" title="第八讲 继承的设计技巧"></a>第八讲 继承的设计技巧</h2><ol>
<li>将公共操作和域放在超类</li>
<li><p>不要使用受保护的域<img src="https://s2.loli.net/2022/03/09/CxbLDo4du6H7gw5.png" alt="image-20220309214543431"></p>
</li>
<li><p>使用继承实现”is-a”关系</p>
</li>
</ol>
<p>钟点工与雇员之间不属于”is-a”关系。因为钟点工不是特殊的雇员。</p>
<ol>
<li>除非所有继承的方法都有意义，否则不要使用继承</li>
<li>在覆盖方法时，不要改变预期的行为</li>
</ol>
<p>置换原则不仅应用于语法，而且也可以应用于行为，这似乎更加重要。在覆盖一个方法时，不应该毫无缘由地改变行为的内涵。  在覆盖子类中的方法时，不要偏离最初的设计想法。</p>
<p>(置换原则：继承必须确保超类所拥有的性质在子类中仍然成立。</p>
<p>表明程序中出现超类对象的任何地方，都可以用子类对象替换。)</p>
<ol>
<li>使用多态，而非类型信息</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/09/tNFMPLA76iCyDzE.png" alt="image-20220309222613601"></p>
<p>类似这种，都应该考虑多态性。定义一个方法，将其放置在两个类的超类或接口中，然后调用x.action( );</p>
<p>使用多态方法或接口编写的代码比使用对多种类型进行检测的代码更加易于维护和扩展。</p>
<ol>
<li>不要过多地使用反射</li>
</ol>
<p>反射机制使得人们可以通过在运行时查看域或方法，但这种功能不适用于编写应用程序。反射是很脆弱的，即编译器很难帮助人们发现程序中的错误。</p>
<h1 id="第六章-接口、lambda表达式与内部类"><a href="#第六章-接口、lambda表达式与内部类" class="headerlink" title="第六章 接口、lambda表达式与内部类"></a>第六章 接口、lambda表达式与内部类</h1><h2 id="第一讲-接口"><a href="#第一讲-接口" class="headerlink" title="第一讲 接口"></a>第一讲 接口</h2><p>主要用来描述类具有什么功能，而并不给出每个功能的具体实现。</p>
<p>接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。</p>
<h3 id="第一节-接口的概念"><a href="#第一节-接口的概念" class="headerlink" title="第一节 接口的概念"></a>第一节 接口的概念</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>Arrays类中的sort方法承诺可以对对象数组进行排序，但要满足下列前提：对象所属的类必须实现了Comparable接口。下面是Comparable接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object other)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何实现Comparable接口的类都需要包含compareTo方法，并且这个方法的参数必须是一个Object对象，返回一个整型数值。</p>
<h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span>; <span class="comment">// paramter has type T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口中的所有方法自动地属于public。因此，在接口中声明方法时，不必提供关键字public。</p>
<p>在调用x.compareTo(y)的时候，这个compareTo方法必须确实比较两个对象的内容，并返回比较的结果。当x小于y时，返回一个负数；当x等于y时，返回0；否则返回一个正数。</p>
<p>在接口中还可以定义常量。然而，更为重要的是，要知道接口不能提供哪些功能。接口绝不能含有实例域。</p>
<h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><ol>
<li>将类声明为实现给定的接口</li>
<li>实现接口中所有的方法(default方法可以不用实现)</li>
</ol>
<h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h5><p>实现接口时，必须把方法声明为public；否则，编译器将认为这个方法的访问属性是包可见性，即类的默认访问属性，之后编译器就会给出试图提供更严格的访问权限的警告信息。</p>
<h3 id="第二节-接口的特性"><a href="#第二节-接口的特性" class="headerlink" title="第二节 接口的特性"></a>第二节 接口的特性</h3><p>可以使用instance检查一个对象是否实现了某个特定的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> Comparable) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>尽管每个类都只能拥有一个超类，但却可以实现多个接口。Java程序设计语言中有一个非常重要的内置接口，称为Cloneable。如果某个类实现了这个Cloneable接口，Object类中的clone方法就可以创建类对象的一个拷贝。则如果希望自己设计的类可以克隆和比较的能力，就</p>
<p><code>class Employee implements Cloneable, Comparable</code></p>
<h3 id="第三节-接口与抽象类"><a href="#第三节-接口与抽象类" class="headerlink" title="第三节 接口与抽象类"></a>第三节 接口与抽象类</h3><p>使用抽象类表示通用属性存在一个问题：每个类只能扩展于一个类。</p>
<p>接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。</p>
<h3 id="第四节-静态方法"><a href="#第四节-静态方法" class="headerlink" title="第四节 静态方法"></a>第四节 静态方法</h3><p>在Java SE 8中，允许在接口中增加静态方法。</p>
<p>没有任何理由认为这是不合法的。只是这有违将接口作为抽象规范的初衷。</p>
<p>通常的做法都是将静态方法放在伴随类中。在标准库中，可以看到成对出现的接口和实用工具类，如Collection / Collections或Path / Paths。</p>
<p><img src="https://s2.loli.net/2022/03/10/YLAf6lMEXhdgQiB.png" alt="image-20220310001936145"></p>
<h3 id="第五节-默认方法"><a href="#第五节-默认方法" class="headerlink" title="第五节 默认方法"></a>第五节 默认方法</h3><p>可以为接口方法提供一个默认实现。必须用default修饰符标记这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，实现这个接口的程序员只需要为他们真正关心的事件覆盖方法。</p>
<h4 id="接口演化"><a href="#接口演化" class="headerlink" title="接口演化"></a>接口演化</h4><p>假如有一个类实现了Comparable接口，但是Java 8为该接口增加了一个新的方法stream，而且这个方法不是默认方法，那么这个类将由于没有实现这个方法，无法通过编译。</p>
<p>为接口增加一个非默认方法不能保证”源代码兼容(source compatible)”。</p>
<p>如果不重新编译，使用原先的一个包含该类的JAR文件。这个类仍能正常加载，正常构造实例，即可以保证”二进制兼容”，但是如果在该类上调用该方法，将会出现AbstractMethodError。</p>
<p>而将方法实现为一个默认方法，就可以使该类能够正常编译。而且如果没有重新编译而直接加载这个类，就可以直接Comparable.stream方法来调用。</p>
<h3 id="第六节-解决默认方法冲突"><a href="#第六节-解决默认方法冲突" class="headerlink" title="第六节 解决默认方法冲突"></a>第六节 解决默认方法冲突</h3><p>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法：</p>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ol>
<li>超类优先。如果超类提供了一个具体的方法，同名并且有相同参数类型的默认方法会被忽略。</li>
<li>接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型(不论是否是默认参数)相同的方法，必须覆盖这个方法来解决冲突。</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/10/Ur7D6TWkd4tmyAv.png" alt="image-20220310003432885"></p>
<p>两个接口如何冲突并不重要。如果至少有一个接口提供了一个实现，编译器就会报告错误，而程序员就必须解决这个二义性。</p>
<h4 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h4><p>千万不要让一个默认方法重新定义Object类中的某个方法，因为类优先。</p>
<h2 id="第二讲-接口示例"><a href="#第二讲-接口示例" class="headerlink" title="第二讲 接口示例"></a>第二讲 接口示例</h2><h3 id="第一节-接口与回调"><a href="#第一节-接口与回调" class="headerlink" title="第一节 接口与回调"></a>第一节 接口与回调</h3><p>回调（callback）是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。</p>
<h3 id="第二节-Comparator接口"><a href="#第二节-Comparator接口" class="headerlink" title="第二节 Comparator接口"></a>第二节 Comparator接口</h3><p>现在假设我们希望按长度递增的顺序对字符串进行排序，而不是按字典顺序进行排序。肯定不能让String类用两种不同的方式实现compareTo方法——更何况，String类也不应由我们来修改。</p>
<p>Arrays.sort方法还有第二个版本，有一个数组和一个比较器作为参数，比较器是实现了Comparator接口的类的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">compare</span><span class="params">(T first, T second)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LengthComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String first, String second)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first.length() - second.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体完成比较时，需要建立一个实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp = <span class="keyword">new</span> <span class="title class_">LengthComparator</span>();</span><br><span class="line"><span class="keyword">if</span> (comp.compare(word[i], word[j]) &gt; <span class="number">0</span>) ...</span><br></pre></td></tr></table></figure>
<p>与word[i].compareTo(word[j])作比较，这个compare方法要在比较器对象上调用，而不是在字符串本身调用。</p>
<p>尽管LengthComparator对象没有状态，不过还是需要建立这个对象的一个实例。我们需要这个实例来调用compare方法——它不是一个静态方法。</p>
<p>要对一个数组排序，需要为Arrays.sort方法传入一个LengthComparator对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] friends = &#123;<span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;Paul&quot;</span>, <span class="string">&quot;Mary&quot;</span> &#125;;</span><br><span class="line">Arrays.sort(friends, <span class="keyword">new</span> <span class="title class_">LengthComparator</span>());</span><br></pre></td></tr></table></figure>
<h3 id="第三节-对象克隆"><a href="#第三节-对象克隆" class="headerlink" title="第三节 对象克隆"></a>第三节 对象克隆</h3><p>Cloneable这个接口指示一个类提供了安全的clone方法。但克隆并不常见。</p>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>基本数据类型重新复制一份，即重新分配一块空间；</p>
<p>但对象只是新建了一个引用，指向原来的对象空间。</p>
<p>Object类默认就是浅拷贝。</p>
<p>拷贝域就会得到相同子对象的另一个引用，这样一来，原对象和克隆的对象仍然会共享一些信息。</p>
<p><img src="https://s2.loli.net/2022/03/11/oaV92OyJ51XU6qI.png" alt="image-20220311224035463"></p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>全部都重新分配一片空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportException &#123;</span><br><span class="line">        <span class="comment">// call Object.clone()</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">cloned</span> <span class="operator">=</span> (Employee) <span class="built_in">super</span>.clone();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// clone mutable fields</span></span><br><span class="line">        cloned.hiredDay = (Date) hireDay.clone();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在可变的子对象上调用clone来修补默认的clone方法。</p>
<h4 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h4><p>Cloneable接口是Java提供的一组标记接口之一，不包含任何方法，唯一作用就是允许在类型查询中使用instanceof。</p>
<p>将以自己的程序中不要使用标记接口。</p>
<p>克隆没有你想象中那么常用。标准库中只有不到5%的类实现了clone。程序清单6-4中的程序克隆了Employee类</p>
<p>所有数组类型都有一个public的clone方法，而不是protected。可以用这个方法建立一个新数组，包含原数组所有元素的副本。</p>
<h2 id="第三讲-lambda表达式"><a href="#第三讲-lambda表达式" class="headerlink" title="第三讲 lambda表达式"></a>第三讲 lambda表达式</h2><h3 id="第一节-lambda表达式的语法"><a href="#第一节-lambda表达式的语法" class="headerlink" title="第一节 lambda表达式的语法"></a>第一节 lambda表达式的语法</h3><p>lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。</p>
<p>考虑讨论过的排序的例子：传入代码来检查一个字符串是否比另一个字符串短。要计算：first.length() - second.length()</p>
<p>first和second都是字符串，Java是一种强类型语言，所以要指定它们的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(String first, String second)</span><br><span class="line">	-&gt; first.length() - second.length()</span><br></pre></td></tr></table></figure>
<p><strong>lambda表达式就是一个代码块，以及必须传入代码的变量规范！</strong></p>
<h4 id="表达形式"><a href="#表达形式" class="headerlink" title="表达形式"></a>表达形式</h4><p>这种表达形式：<strong>参数，-&gt;，表达式</strong>。</p>
<ol>
<li>如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在{}中，并包含显式的return语句。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(String first, String second) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (first.length() &lt; second.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (first.length() &gt; second.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>即使lambda表达式没有参数，仍然要提供空括号，就像无参数方法一样：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; &#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) System.out.println(i); &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp = </span><br><span class="line">    (first, second) <span class="comment">// same as(String first, String second)</span></span><br><span class="line">    	-&gt; first.length() - second.length();</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果方法只有一个参数，而且这个参数的类型可以推导出，那么还可以省略小括号：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> event -&gt; <span class="comment">// instead of (ActionEvent event)-&gt; or (event)-&gt;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;The time is&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure>
</li>
<li><p>无需指定lambda表达式的返回类型。可由上下文推出。</p>
</li>
<li><p>如果一个lambda表达式只在某些分支返回一个值，而在其他分支不返回值，这是不合法的。</p>
</li>
</ol>
<h3 id="第三节-函数式接口"><a href="#第三节-函数式接口" class="headerlink" title="第三节 函数式接口"></a>第三节 函数式接口</h3><p><strong>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式</strong>，这种接口称为函数式接口(function interface)。</p>
<p>Arrays.sort方法，<strong>它的第二个参数需要一个Comparator实例</strong>，Comparator就是只有一个方法的接口，所以可以提供一个lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(words, </span><br><span class="line">            (first, second) -&gt; first.length() - second.length());</span><br></pre></td></tr></table></figure>
<p>在底层，Arrays.sort方法会接收实现了Comparator<String>的某个类的对象。在这个对象上调用compare方法会执行这个lambda表达式的体。</p>
<h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><p>实际上，在Java中，<strong>对lambda表达式所能做的，也只是能转换为函数式接口。</strong></p>
<p><strong>最好把lambda表达式看作是一个函数，而不是一个对象，另外要接受lambda表达式可以传递到函数式接口。</strong></p>
<p>JavaAPI在java.util.function包中定义了很多非常通用的函数式接口。</p>
<p>想用lambda表达式做某些处理，还是要谨记表达式的用途，为他建立一个特定的函数式接口。</p>
<h3 id="第四节-方法引用"><a href="#第四节-方法引用" class="headerlink" title="第四节 方法引用"></a>第四节 方法引用</h3><p>有时，可能已经有现成的方法可以完成你想要传递到其他代码的动作。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, System.out::println);</span><br></pre></td></tr></table></figure>
<p>表达式System.out::println是一个方法引用(method reference)，等价于lambda表达式：</p>
<p><code>x -&gt; System.out.println(x)</code></p>
<p>要用 :: 操作符分割方法名与对象或类名。</p>
<h4 id="三种情况"><a href="#三种情况" class="headerlink" title="三种情况"></a>三种情况</h4><p>主要有三种情况：</p>
<ul>
<li>object::instanceMethod</li>
<li>Class::staticMethod</li>
<li>Class::instanceMethod</li>
</ul>
<p>在前两种情况中，方法引用等价于提供方法参数的lambda表达式。</p>
<p>类似的，Math::pow等价于(x, y) -&gt; Math.pow(x, y).</p>
<p>对于第三种情况，第一个参数会成为方法的目标。例如，</p>
<p><code>String::compareToIgnoreCase 等同于(x, y) -&gt; x.compareToIgnoreCase(y)</code></p>
<h4 id="注释-2"><a href="#注释-2" class="headerlink" title="注释"></a>注释</h4><ol>
<li><p>如果有多个同名的重载方法，编译器就会尝试从上下文中找出指的是哪一个方法，这取决于转换为哪个函数式接口的方法参数。</p>
</li>
<li><p>方法引用不能独立存在，总是会转换为函数式接口的实例。</p>
</li>
<li>可以使用this参数和super参数：this::equals(x -&gt; this.equals(x)); super::instanceMethod.</li>
</ol>
<h3 id="第五节-构造器引用"><a href="#第五节-构造器引用" class="headerlink" title="第五节 构造器引用"></a>第五节 构造器引用</h3><p>构造器引用与方法引用很类似，只不过方法名为new。例如，Person::new是Person构造器的一个引用。</p>
<p><img src="https://s2.loli.net/2022/03/12/35LA7Yqymd1oUJx.png" alt="image-20220312153116486"></p>
<h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>可以使用数组类型建立构造器引用。例如，int[]::new是一个构造器引用，他有一个参数，即数组的长度。这等价于lambda表达式x -&gt; new int[x]。</p>
<p>Java中有一个限制，无法构造泛型类型T的数组。即表达式new T[n]会产生错误。</p>
<p>但是，流库利用构造器引用解决了这个问题。</p>
<p>Person[] people = stream.toArray(Person[]::new);</p>
<h3 id="第六节-变量作用域"><a href="#第六节-变量作用域" class="headerlink" title="第六节 变量作用域"></a>第六节 变量作用域</h3><p>通常，你可能希望能够在lambda表达式中访问外围方法或类中的变量。举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">repeatMessage</span><span class="params">(String text, <span class="type">int</span> delay)</span> &#123;</span><br><span class="line">    <span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> event -&gt; &#123;</span><br><span class="line">        System.out.println(text);</span><br><span class="line">        Toolkit.getDefaultToolkit().beep();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Timer</span>(delay, listener).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">repeatMessage(<span class="string">&quot;Hello&quot;</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>显然，lambda表达式中的text变量并不是在表达式中定义的，而是repeatMessage的一个参数变量。</p>
<p>lambda表达式有3个部分：</p>
<ul>
<li>一个代码块；</li>
<li>参数</li>
<li>自由变量(非参数且不在lambda表达式中定义的变量)</li>
</ul>
<p>在例子中，这个lambda表达式有1个自由变量text。表示lambda表达式的数据结构必须存储自由变量的值，也就是字符串“Hello“。它被lambda表达式捕获。</p>
<h4 id="注释-3"><a href="#注释-3" class="headerlink" title="注释"></a>注释</h4><p>关于代码块以及自由变量值有一个术语：闭包（closure）。</p>
<h4 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h4><ol>
<li>可以看到，lambda表达式可以捕获外围作用域中变量的值。在Java中，要确保所捕获的值是明确定义的，这里有一个重要的限制。在lambda表达式中，只能引用值不会改变的变量。</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/12/QExd3YS9Ve1IBUw.png" alt="image-20220312162245127"></p>
<p>之所以有这个限制，是有原因的。如果在lambda表达式中改变变量，并发执行多个动作时就会不安全。</p>
<ol>
<li>如果在lambda表达式中引用变量，而这个变量可能在外部改变，这也是不合法的。</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/12/r6miYVUcqI3wkFu.png" alt="image-20220312162403203"></p>
<ol>
<li><p>lambda表达式捕获的变量必须实际上是最终变量(effectively final)。</p>
<p> 实际上的最终变量是指：这个变量初始化后就不会再为它赋新值。</p>
</li>
<li><p>在lambda表达式中声明与一个局部变量同名的参数或局部变量是不合法的。</p>
</li>
<li><p>在方法中，不能有两个同名的局部变量，因此，lambda表达式中同样也不能有同名的局部变量。</p>
</li>
<li><p>在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数。<img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220312162815795.png" alt="image-20220312162815795"></p>
</li>
</ol>
<p>是指，Application对象的toString方法，而不是ActionListener实例的方法。</p>
<h3 id="第七节-处理lambda表达式"><a href="#第七节-处理lambda表达式" class="headerlink" title="第七节 处理lambda表达式"></a>第七节 处理lambda表达式</h3><p>使用lambda表达式的重点是延迟执行(deferred execution)。之所以希望以后再执行代码，这有很多原因，如：</p>
<ul>
<li>在一个单独的线程中运行代码；</li>
<li>多次运行代码；</li>
<li>在算法的适当位置运行代码；</li>
<li>发生某种情况时执行代码；</li>
<li>只在必要时才运行代码。</li>
</ul>
<h3 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h3><p><img src="https://s2.loli.net/2022/03/13/viJ7xyHeopdQIEK.png" alt="image-20220313203803851"></p>
<p><img src="https://s2.loli.net/2022/03/13/Er76df34NKhgRZe.png" alt="image-20220313204036989"></p>
<h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>最好使用以上两表中的接口。</p>
<p>例如，假设要编写一个方法来处理满足某个特定条件的文件。对此有一个遗留接口java.io.FileFilter，不过最好使用标准的Predicate<File>。</p>
<p>如果设计你自己的接口，其中只有一个抽象方法，可以用@FunctionalInterface注解来标记这个接口。</p>
<p>这样做有两个优点，如果你无意中增加了另一个非抽象方法，编译器会产生一个错误消息。另外javadoc页里会指出你的借口是一个函数式接口。</p>
<h3 id="第八节-再谈Comparator"><a href="#第八节-再谈Comparator" class="headerlink" title="第八节 再谈Comparator"></a>第八节 再谈Comparator</h3><p>略</p>
<h2 id="第四讲-内部类"><a href="#第四讲-内部类" class="headerlink" title="第四讲 内部类"></a>第四讲 内部类</h2><p>内部类是定义在另一个类中的类。</p>
<p>使用内部类的原因：</p>
<ul>
<li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。</li>
<li>内部类可以对同一包中的其它类隐藏起来。</li>
<li>当想要定义一个回调函数且不想编写大量的代码时，使用匿名内部类比较便捷。</li>
</ul>
<h3 id="第一节-使用内部类访问对象状态"><a href="#第一节-使用内部类访问对象状态" class="headerlink" title="第一节 使用内部类访问对象状态"></a>第一节 使用内部类访问对象状态</h3><p>内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。</p>
<p>内部类的对象，总有一个隐式引用，它指向了创建它的外部类对象。</p>
<p><img src="https://s2.loli.net/2022/03/13/aprg4X2oNSd5GBk.png" alt="image-20220313210816733"></p>
<p>这个引用在内部类的定义中是不可见的。</p>
<p>外围类的引用在构造器中设置。编译器修改了所有的内部类的构造器，添加了一个外围类引用的参数。因为TimePrinter类没有定义构造器，所以编译器为这个类生成了一个默认的构造器。其代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TimePrinter</span><span class="params">(TalkingClock clock)</span> <span class="comment">// automatically generated code </span></span><br><span class="line">&#123;</span><br><span class="line">	outer = clock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><p>outer不是Java的关键字，只是用它说明内部类的机制。</p>
<h4 id="注释-4"><a href="#注释-4" class="headerlink" title="注释"></a>注释</h4><p>TimePrinter类声明为私有的。这样一来，只有TalkingClock的方法才能够构造TimePrinter对象。只有内部类可以是私有类，而常规类只可以具有包可见性，或公有可见性。</p>
<h3 id="第二节-内部类的特殊语法规则"><a href="#第二节-内部类的特殊语法规则" class="headerlink" title="第二节 内部类的特殊语法规则"></a>第二节 内部类的特殊语法规则</h3><h2 id="第五讲-代理"><a href="#第五讲-代理" class="headerlink" title="第五讲 代理"></a>第五讲 代理</h2><p>利用代理可以在运行时创建一个实现了一组给定接口的新类。</p>
<p>这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用。</p>
<p>对应用程序设计人员来说，遇到这种情况的机会很少。</p>
<h3 id="第一节-何时使用代理"><a href="#第一节-何时使用代理" class="headerlink" title="第一节 何时使用代理"></a>第一节 何时使用代理</h3><p>代理类可以在运行时创建全新的类。这样的代理类能够实现指定的接口。尤其是，它具有下列方法：</p>
<ul>
<li>指定接口所需要的全部方法。</li>
<li>Object类中的全部方法，例如，toString、equals等。</li>
</ul>
<p>然而，不能在运行时定义这些方法的新代码，而是要提供一个调用处理器(invocation handler)。调用处理器是实现了InvocationHandler接口的类对象。这个接口只有一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br></pre></td></tr></table></figure>
<p>无论何时调用代理对象的方法，调用处理器的invoke方法都会被调用，并向其传递Method对象和原始的调用参数。调用处理器必须给出处理调用的方式。</p>
<h1 id="第九章-集合"><a href="#第九章-集合" class="headerlink" title="第九章 集合"></a>第九章 集合</h1><h2 id="第一讲-集合框架"><a href="#第一讲-集合框架" class="headerlink" title="第一讲 集合框架"></a>第一讲 集合框架</h2><h3 id="第一节-分离集合的接口和实现"><a href="#第一节-分离集合的接口和实现" class="headerlink" title="第一节 分离集合的接口和实现"></a>第一节 分离集合的接口和实现</h3><p>Java集合类库将接口(interface)与实现(implementation)分离。</p>
<h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>队列接口的最简形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt; &#123; <span class="comment">// a simplified form of the interface in the standard library</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span>;</span><br><span class="line">    E <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种实现形式：</p>
<ul>
<li>循环数组</li>
<li>使用链表</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/14/gfJ9LtUqxmZ4WTp.png" alt="image-20220314005548688"></p>
<h5 id="注释-5"><a href="#注释-5" class="headerlink" title="注释"></a>注释</h5><p>如果需要一个循环数组队列，就可以使用ArrayDeque类。如果需要一个链表队列，就直接使用LinkedList类，这个类实现了Queue接口。</p>
<p>可以使用接口类型存放集合的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> <span class="title class_">CircularArrayQueue</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">expressLane.add(<span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Harry&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>如果想要修改，可以轻松使用另一种实现，因为只需要修改构造器即可，别的都无需修改。</p>
<h3 id="第二节-Collection接口"><a href="#第二节-Collection接口" class="headerlink" title="第二节 Collection接口"></a>第二节 Collection接口</h3><p>在Java类库中，集合类的基本接口是Collection接口。有两个基本方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E element)</span>;</span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的元素不允许重复。如果添加成功，就返回true。</p>
<h3 id="第三节-迭代器"><a href="#第三节-迭代器" class="headerlink" title="第三节 迭代器"></a>第三节 迭代器</h3><p>Iterator接口包含4个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法浅析"><a href="#方法浅析" class="headerlink" title="方法浅析"></a>方法浅析</h4><h5 id="next和hasNext方法"><a href="#next和hasNext方法" class="headerlink" title="next和hasNext方法"></a>next和hasNext方法</h5><p>通过反复调用next方法，可以逐个访问集合中的每个元素。</p>
<p>但是，如果到达了集合的末尾，next方法将抛出一个NoSuchElementException。</p>
<p>因此，需要在调用next之前调用hasNext方法。如果迭代器对象还有多个供访问的元素，这个方法就返回true。</p>
<p>如果想要查看集合中的所有元素，就请求一个迭代器，并<strong>在hasNext返回true时反复地调用next方法</strong>。</p>
<p><img src="https://s2.loli.net/2022/03/14/RdvDjMHwOi5u2V3.png" alt="image-20220314010906021"></p>
<h4 id="补充next"><a href="#补充next" class="headerlink" title="补充next"></a>补充next</h4><p>因此，应该将Java迭代器认为是位于两个元素之间。当调用next时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。</p>
<p><img src="https://s2.loli.net/2022/03/14/7JSQzp3dvemwkj2.png" alt="image-20220314011328728"></p>
<h5 id="forEachRemaining方法"><a href="#forEachRemaining方法" class="headerlink" title="forEachRemaining方法"></a>forEachRemaining方法</h5><p>在Java SE 8中，甚至不用写循环。可以调用forEachRemaining方法并提供一个lambda表达式（它会处理一个元素）。</p>
<p>将对迭代器的每一个元素调用这个lambda表达式，直到再没有元素为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iterator.forEachRemaining(element -&gt; <span class="keyword">do</span> something with element);</span><br></pre></td></tr></table></figure>
<p>元素被访问的顺序取决于集合类型。</p>
<p>如果访问HashSet中的元素，每个元素将会按照某种随机的次序出现。虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预知元素被访问的次序。</p>
<h5 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h5><p>Iterator接口的remove方法将会删除调用next方法时返回的元素。</p>
<p>在大多数情况下，在决定删除某个元素之前应该先看一下这个元素是很具有实际意义的。</p>
<p><strong>然而，如果想要删除指定位置上的元素，仍然需要越过这个元素</strong>。</p>
<p>例如，下面是如何删除字符串集合中第一个元素的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line">it.next(); <span class="comment">// skip over the first element</span></span><br><span class="line">it.remove(); <span class="comment">// now remove it</span></span><br></pre></td></tr></table></figure>
<h5 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h5><p>更重要的是，<strong>对next方法和remove方法的调用具有互相依赖性。如果调用remove之前没有调用next将是不合法的。</strong>如果这样做，将会抛出一个IllegalStateException异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除两个相邻元素</span></span><br><span class="line"><span class="comment">// 不能这样调用</span></span><br><span class="line">it.remove();</span><br><span class="line">it.remove(); <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须先调用next越过将要删除的元素</span></span><br><span class="line">it.remove();</span><br><span class="line">it.next();</span><br><span class="line">it.remove(); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<h3 id="第四节-泛型实用方法"><a href="#第四节-泛型实用方法" class="headerlink" title="第四节 泛型实用方法"></a>第四节 泛型实用方法</h3><p>由于Collection和Iterator都是泛型接口，可以编写操作任何集合类型的使用方法。</p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>事实上，Collection接口声明了很多有用的方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collection接口</span></span><br><span class="line">Iterator&lt;E&gt; iterator <span class="comment">// 返回一个用于访问集合中每一个元素的迭代器</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">// 返回当前存储的元素个数</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">// 如果集合中没有元素，返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object obj)</span> <span class="comment">// 如果集合中包含了一个与obj相等的对象，返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;? &gt; other)</span> <span class="comment">// 如果这个集合包含other集合中的全部元素，返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Object element)</span> <span class="comment">// 将一个元素添加到集合中，如果集合因此发生了改变，返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collecion&lt;? extends E&gt; other)</span> <span class="comment">// 将other集合中的所有元素添加到这个集合。如果由于这个调用改变了集合，返回true。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object obj)</span> <span class="comment">// 从这个集合中删除等于obj的对象。如果有匹配的对象被删除，返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;? &gt; other)</span> <span class="comment">// 从这个集合中删除other集合中存在的所有元素。如果由于这个调用改变了集合，返回true</span></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span> <span class="comment">// 从这个集合删除filter返回true的所有元素。如果由于这个调用改变了集合，则返回true</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="comment">// 从这个集合中删除所有的元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;? &gt; other)</span> <span class="comment">// 从这个集合中删除所有与other集合中的元素不同的元素。如果由于这个调用改变了集合，返回true</span></span><br><span class="line">Object[] toArray() <span class="comment">// 返回这个集合的对象数组</span></span><br><span class="line">&lt;T&gt; T[] toArray(T[] arrayToFill) <span class="comment">/* 返回这个集合的对象数组。如果arrayToFill足够大，就将集合中的元素填入这个数组中。剩余空间填补null；否则，分配一个新数组，其成员类型与arrayToFill的成员类型相同，其长度等于集合的大小，并填充集合元素。*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Iterator接口    </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> <span class="comment">// 删除上次访问的对象。这个方法必须紧跟在访问一个元素之后执行。如果上次访问之后，集合已经发生了变化，这个方法将抛出一个IllegalStateException。</span></span><br></pre></td></tr></table></figure>
<h3 id="第五节-集合框架中的接口"><a href="#第五节-集合框架中的接口" class="headerlink" title="第五节 集合框架中的接口"></a>第五节 集合框架中的接口</h3><p>Java集合框架为不同类型的集合定义了大量接口。</p>
<p><img src="https://s2.loli.net/2022/03/14/2X4t6qxWeUi5o3u.png" alt="image-20220314123844954"></p>
<p>集合有两个基本接口：Collection和Map。</p>
<p>List是一个有序集合。元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器方法，或者使用一个整数索引来访问。后一种方法称为随机访问，因为这样可以按任意顺序访问元素。List接口定义了多个用于随机访问的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span></span><br></pre></td></tr></table></figure>
<h4 id="RandomAccess接口"><a href="#RandomAccess接口" class="headerlink" title="RandomAccess接口"></a>RandomAccess接口</h4><p>实际中有两种有序集合，其性能开销有很大差异。</p>
<p>由数组支持的有序集合可以快速地随机访问，因此适合使用List方法并提供一个整数索引来访问。</p>
<p>与之不同，链表尽管也是有序的，但是随机访问很慢，所以最好使用迭代器来遍历。</p>
<p><strong>为了避免对链表完成随机访问操作</strong>，Java SE 1.4引入了一个标记接口RandomAccess。这个接口不包含任何方法，不过可以用它来测试一个特定的集合是否支持高效的随机访问：</p>
<p><img src="https://s2.loli.net/2022/03/14/jiRhUT9B3FNXeHy.png" alt="image-20220314143156671"></p>
<h4 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h4><p>Set接口等同于Collection接口，不过其方法的行为有更严谨的定义。</p>
<p>集（set）的add方法不允许增加重复的元素。要</p>
<p>适当地定义集的equals方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。hashCode方法的定义要保证包含相同元素的两个集会得到相同的散列码。</p>
<p>既然方法签名是一样的，为什么还要建立一个单独的接口呢？从概念上讲，并不是所有集合都是集。建立一个Set接口可以让程序员编写只接受集的方法。</p>
<h2 id="第二讲-具体的集合"><a href="#第二讲-具体的集合" class="headerlink" title="第二讲 具体的集合"></a>第二讲 具体的集合</h2><p><img src="https://s2.loli.net/2022/03/14/EmT3ku6SHeoLbJ5.png" alt="image-20220314143318070"></p>
<h3 id="第一节-链表"><a href="#第一节-链表" class="headerlink" title="第一节 链表"></a>第一节 链表</h3><p>Java集合类库提供了一个类LinkedList。</p>
<p>但是链表和泛型集合之间有一个重要的区别，链表是一个有序集合(ordered collection)。</p>
<p>LinkedList.add方法将对象添加到链表的尾部。</p>
<p>为了将元素添加到链表的中间，由于迭代器是描述集合中位置的，因此这种依赖位置的add方法将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有意义。</p>
<h4 id="ListIterator接口"><a href="#ListIterator接口" class="headerlink" title="ListIterator接口"></a>ListIterator接口</h4><p>对应于集合类库提供了子接口ListIterator</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ListIterator</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span>;</span><br><span class="line">    <span class="comment">// 反向遍历链表</span></span><br><span class="line">    E <span class="title function_">previous</span><span class="params">()</span>; <span class="comment">// 返回越过的对象</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add方法在迭代器位置之前添加一个新对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">staff.add(<span class="string">&quot;Amy&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;Carl&quot;</span>);</span><br><span class="line">ListIterator&lt;String&gt; iter = staff.listIterator();</span><br><span class="line">iter.next(); <span class="comment">// skip past first element</span></span><br><span class="line">iter.add(<span class="string">&quot;Juliet&quot;</span>).</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/16/PmdHjKVkrNJ5uX6.png" alt="image-20220316192828055"></p>
<h5 id="并发修改"><a href="#并发修改" class="headerlink" title="并发修改"></a>并发修改</h5><p><img src="https://s2.loli.net/2022/03/16/RIk394JNtCM1PVD.png" alt="image-20220316194023136"></p>
<p>由于iter2检测出这个链表被外部修改了，所以对iter2.next的调用抛出了一个Concurrent ModificationException异常。</p>
<p>为了避免发生并发修改的异常，请遵循下述简单规则：</p>
<p>可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表。</p>
<p>另外，再单独附加一个既能读又能写的迭代器。</p>
<h5 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h5><p>不应该使用让人误解的随机访问方法来遍历链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">    <span class="keyword">do</span> something with list.get(i);</span><br></pre></td></tr></table></figure>
<p>每次查找一个元素都要从列表的头部重新开始搜索。</p>
<p>LinkedList对象根本不做任何缓存位置信息的操作。</p>
<p>我们建议避免使用以整数索引表示链表中位置的所有方法。如果需要对集合进行随机访问，就使用数组或ArrayList，而不要使用链表。</p>
<h3 id="第二节-数组列表"><a href="#第二节-数组列表" class="headerlink" title="第二节 数组列表"></a>第二节 数组列表</h3><p>Vector类的所有方法都是同步的，可以有两个线程安全地访问一个Vector对象，但是如果一个线程访问Vector，代码要再同步操作上耗费大量的时间。</p>
<p>ArrayList方法不是同步的，所以建议在不需要同步时使用ArrayList，而不要使用Vector。</p>
<h3 id="第三节-散列集"><a href="#第三节-散列集" class="headerlink" title="第三节 散列集"></a>第三节 散列集</h3><p>散列表(hash table)可以快速查找出需要的对象。</p>
<h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><p>散列表为每个对象计算一个整数，称为散列码(hash code)。散列码是由对象的实例域产生的一个整数。</p>
<p>散列码只与要散列的对象状态有关，与其他对象无关。</p>
<h4 id="桶"><a href="#桶" class="headerlink" title="桶"></a>桶</h4><p>Java中，散列表用链表数组实现。每个列表被称为桶(bucket)。要想查找表中对象的位置，就要先计算散列码，再对桶的总数取余，即可得该元素的索引。</p>
<p><img src="https://s2.loli.net/2022/03/16/EMFhWBeNrul8qL9.png" alt="image-20220316211952949"></p>
<h4 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h4><p>当然，有时候会遇到桶被占满的情况，即所谓散列冲突。</p>
<p>这时，需要用新对象与桶中所有的对象进行比较，查看这个对象是否已经存在。</p>
<p>如果想更多地控制散列表的运行性能，就要指定一个初始的桶数。如果大致知道最终会有多少个元素要插入到散列表中，就可以设置桶数。通常，将桶数设置为预计元素个数的75%～150%。</p>
<h4 id="再散列"><a href="#再散列" class="headerlink" title="再散列"></a>再散列</h4><p>当然，并不是总能够知道需要存储多少个元素的，也有可能最初的估计过低。</p>
<p>如果散列表太满，就需要再散列（rehashed）。</p>
<p>如果要对散列表再散列，就需要创建一个桶数更多的表，并将所有元素插入到这个新表中，然后丢弃原来的表。</p>
<p>装填因子（load factor）决定何时对散列表进行再散列。</p>
<p>例如，如果装填因子为0.75（默认值），而表中超过75%的位置已经填入元素，这个表就会用双倍的桶数自动地进行再散列。对于大多数应用程序来说，装填因子为0.75是比较合理的。</p>
<h4 id="HashSet类"><a href="#HashSet类" class="headerlink" title="HashSet类"></a>HashSet类</h4><p>实现了基于散列表的集。</p>
<p>可以用add方法添加元素。contains方法已经被重新定义，用来快速地查看是否某个元素已经出现在集中。</p>
<p>散列集迭代器将依次访问所有的桶。由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。<strong>只有不关心集合中元素的顺序时才应该使用HashSet。</strong></p>
<h3 id="第四节-树集"><a href="#第四节-树集" class="headerlink" title="第四节 树集"></a>第四节 树集</h3><p>TreeSet类是一个有序集合。</p>
<p>可以以任意顺序将元素插入到集合中，在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现。</p>
<p>每次将一个元素添加到树中时，都被放置在正确的排序位置上。因此，迭代器总是以排好序的顺序访问每个元素。将一个元素添加到树中要比添加到散列表中慢。</p>
<p><strong>要使用树集，必须能够比较元素</strong>。这些元素必须实现Comparable接口，或者构造集时必须提供一个Comparator</p>
<h3 id="二者比较"><a href="#二者比较" class="headerlink" title="二者比较"></a>二者比较</h3><p>当然了，如果不需要对数据进行排序，就没有必要付出排序的开销。更重要的是，对于某些数据来说，对其排序要比散列函数更加困难。散列函数只是将对象适当地打乱存放，而比较却要精确地判别每个对象。</p>
<h3 id="第五节-队列与双端队列"><a href="#第五节-队列与双端队列" class="headerlink" title="第五节 队列与双端队列"></a>第五节 队列与双端队列</h3><p>有两个端头的队列，即双端队列。</p>
<p>可以有效地在头部和尾部同时添加或删除元素，不支持在队列中间添加元素。</p>
<p>在Java SE 6中引入了Deque接口，并由ArrayDeque和LinkedList类实现。这两个类提供了双端队列，而且在必要时可以增加队列的长度。</p>
<h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><ul>
<li><p>boolean add(E element)</p>
</li>
<li><p>boolean offer(E element)</p>
<p> 如果队列没有满，将给定的元素添加到这个双端队列的尾部并返回true。如果队列满了，第一个方法将抛出一个IllegalStateException，而第二个方法返回false。</p>
</li>
<li><p>E remove()</p>
</li>
<li><p>E poll()</p>
<p> 假如队列不空，删除并返回这个队列头部的元素。如果队列是空的，第一个方法抛出NoSuchElementException，而第二个方法返回null。</p>
</li>
<li><p>E element()</p>
</li>
<li><p>E peek()</p>
<p>  如果队列不空，返回这个队列头部的元素，但不删除。如果队列空，第一个方法将抛出一个NoSuchElementException，而第二个方法返回null。</p>
</li>
</ul>
<p>至于双端队列，addLast和addFirst，替换element，新增一个getLast和getFirst。</p>
<h3 id="第六节-优先级队列"><a href="#第六节-优先级队列" class="headerlink" title="第六节 优先级队列"></a>第六节 优先级队列</h3><p>优先级队列(priority queue)中的元素可以按照任意的顺序插入，却总是按照排序的顺序进行检索。无论何时调用remove方法，总会获得当前优先级队列中最小的元素。</p>
<p>然而，优先级队列并没有对所有的元素进行排序，而是使用了一个优雅且高效的数据结构，称为堆(heap)。</p>
<p>堆是一个可以自我调整的二叉树，对树执行添加(add)和删除(remove)操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。</p>
<p>与TreeSet一样，一个优先级队列既可以保存实现了Comparable接口的类对象，也可以保存在构造器中提供的Comparator对象。</p>
<p>使用优先级队列的典型示例是任务调度。每一个任务有一个优先级，任务以随机顺序添加到队列中。每当启动一个新的任务时，都将<strong>优先级最高的任务从队列中删除</strong>（由于习惯上将1设为“最高”优先级，所以会将最小的元素删除）。</p>
<h2 id="第三讲-映射"><a href="#第三讲-映射" class="headerlink" title="第三讲 映射"></a>第三讲 映射</h2><h3 id="第一节-基本映射操作"><a href="#第一节-基本映射操作" class="headerlink" title="第一节 基本映射操作"></a>第一节 基本映射操作</h3><p>Java类库为映射提供了两个通用的实现，HashMap和TreeMap。这两个类都实现了Map接口。</p>
<p>散列映射对键进行散列，树映射用键的整体顺序对元素进行排列，并将其组织成搜索树。</p>
<p>散列或比较函数只能作用于键，与键关联的值不能进行散列或比较。</p>
<h4 id="键"><a href="#键" class="headerlink" title="键"></a>键</h4><h4 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h4><p>每当往映射中添加对象时，必须同时提供一个键。在这里，键id是一个字符串，对应的值是Employee对象。</p>
<p>要想检索一个对象，必须使用（因而，必须记住）一个键。</p>
<p>如果在映射中没有与给定键对应的信息，get将返回null。</p>
<p>null返回值可能并不方便。有时可以有一个好的默认值，对应映射中不存在的键，即使用getOrDefault方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; scores = ...;</span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scores.get(id, <span class="number">0</span>); <span class="comment">// Gets 0 if the id is not present</span></span><br></pre></td></tr></table></figure>
<h5 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h5><p>键必须是唯一的。不能对同一个键存放两个值。</p>
<p>如果对同一个键两次调用put方法，第二个值就会取代第一个值。实际上，put将返回用这个键参数存储的上一个值。</p>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul>
<li><p>default V getOrDefault(Object key, V defaultValue)获得与键关联的值；返回与键关联的对象，或者如果未在映射中找到这个键，则返回defaultValue。</p>
</li>
<li><p>boolean containsKey(Object key)如果在映射中已经有这个键，返回true。</p>
</li>
<li>default void forEach(BiConsumer&lt;? super K, ? superV&gt; action) 8对这个映射中的所有键/值对应用这个动作。(可以使用一个lambda表达式。)</li>
</ul>
<h3 id="第二节-更新映射项"><a href="#第二节-更新映射项" class="headerlink" title="第二节 更新映射项"></a>第二节 更新映射项</h3><p>正常情况下，可以得到与一个键关联的原值，完成更新，再放回更新后的值。不过，必须考虑一个特殊情况，即键第一次出现。</p>
<p><img src="https://s2.loli.net/2022/03/17/Jdh7qmuGU8crH2l.png" alt="image-20220317235933970"></p>
<p>这种语句完全可以，但是如果是第一次看到word时，get会返回null，因此会出现一个NullPointException异常。</p>
<h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><p>可以使用getOrDefault方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">counts.put(word, counts.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><p>merge方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">counts.merge(word, <span class="number">1</span>, Integer::sum);</span><br></pre></td></tr></table></figure>
<p>如果键原先不存在，将把word与1关联，否则使用Integer::sum函数组合原值和1(原值+1)。</p>
<h3 id="第三节-映射视图"><a href="#第三节-映射视图" class="headerlink" title="第三节 映射视图"></a>第三节 映射视图</h3><p>可以得到映射的视图(view)——这是实现了Collection接口或某个子接口的对象。</p>
<p>有三种视图：键集、值集合(不是一个集)以及键/值对集。对应的方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span></span><br><span class="line">Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span></span><br><span class="line">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</span><br></pre></td></tr></table></figure>
<p>条目集的元素是实现Map.Entry接口的类的对象。</p>
<p><img src="https://s2.loli.net/2022/03/18/GQj5hAJOnqVgoE3.png" alt="image-20220318001553502"></p>
<p><img src="https://s2.loli.net/2022/03/18/6cZRnSNOwDGt1aJ.png" alt="image-20220318001730611"></p>
<p>如果在键集视图上调用迭代器的remove方法，实际上会从映射中删除这个键和与它关联的值。不过，不能向键集视图增加元素。另外，如果增加一个键而没有同时增加值也是没有意义的。</p>
<h2 id="第四讲-视图与包装器"><a href="#第四讲-视图与包装器" class="headerlink" title="第四讲 视图与包装器"></a>第四讲 视图与包装器</h2><p>keySet方法返回一个实现Set接口的类对象，这个类的方法对原映射进行操作。这种集合称为视图。</p>
<h2 id="第五讲-算法"><a href="#第五讲-算法" class="headerlink" title="第五讲 算法"></a>第五讲 算法</h2><p>泛型集合接口有一个很大的优点，即算法只需要实现一次。</p>
<p><img src="https://s2.loli.net/2022/03/18/lg7ADb6VphtKwGT.png" alt="image-20220318003309044"></p>
<h3 id="第一节-排序与混排"><a href="#第一节-排序与混排" class="headerlink" title="第一节 排序与混排"></a>第一节 排序与混排</h3><p>Collections类中的sort方法可以对实现了List接口的集合进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">fill collection</span><br><span class="line">Collections.sort(staff);</span><br></pre></td></tr></table></figure>
<p>这个方法假定列表元素实现了Comparable接口。如果想采用其他方式对列表进行排序，可以使用List接口的sort方法并传入一个Comparator对象。可以如下按工资对一个员工列表排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary);</span><br></pre></td></tr></table></figure>
<h4 id="降序排序"><a href="#降序排序" class="headerlink" title="降序排序"></a>降序排序</h4><p><img src="https://s2.loli.net/2022/03/18/8KyiGAhtd9JENxO.png" alt="image-20220318003625944"></p>
<h4 id="混排"><a href="#混排" class="headerlink" title="混排"></a>混排</h4><p>Collections类有一个算法<strong>shuffle</strong>，其功能与排序刚好相反，即随机地混排列表中元素的顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Card&gt; cards = ...;</span><br><span class="line">Collections.shuffle(cards);</span><br></pre></td></tr></table></figure>
<p>如果提供的列表没有实现RandomAccess接口，shuffle方法将元素复制到数组中，然后打乱数组元素的顺序，最后再将打乱顺序后的元素复制回列表。</p>
<h3 id="第二节-二分查找"><a href="#第二节-二分查找" class="headerlink" title="第二节 二分查找"></a>第二节 二分查找</h3><p>Collections类的binarySearch方法实现了这个算法。</p>
<p>注意，集合必须是排好序的，否则算法将返回错误的答案。要想查找某个元素，必须提供集合（这个集合要实现List接口）以及要查找的元素。如果集合没有采用Comparable接口的compareTo方法进行排序，就还要提供一个比较器对象。</p>
<p><img src="https://s2.loli.net/2022/03/18/PTHabqeAvR1JIt5.png" alt="image-20220318004020199"></p>
<p>如果binarySearch方法返回的数值大于等于0，则表示匹配对象的索引。</p>
<p>也就是说，c.get(i)等于在这个比较顺序下的element。</p>
<p>如果返回负值，则表示没有匹配的元素。</p>
<h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><p>只有采用随机访问，二分查找才有意义。如果必须利用迭代方式一次次地遍历链表的一半元素来找到中间位置的元素，二分查找就完全失去了优势。因此，如果为binarySearch算法提供一个链表，它将自动地变为线性查找。</p>
<h3 id="第三节-简单算法"><a href="#第三节-简单算法" class="headerlink" title="第三节 简单算法"></a>第三节 简单算法</h3><p>● static int frequency(Collection&lt;? &gt; c, Object o) 5.0返回c中与对象o相同的元素个数。</p>
<p>● boolean disjoint(Collection&lt;? &gt; c1, Collection&lt;? &gt; c2) 5.0如果两个集合没有共同的元素，则返回true。</p>
<p>● static void swap(List&lt;? &gt; l, int i, int j) 1.4交换给定偏移量的两个元素。</p>
<p>● static void reverse(List&lt;? &gt; l)逆置列表中元素的顺序。例如，逆置列表[t, a, r]后将得到列表[r, a, t]。这个方法的时间复杂度为O (n), n为列表的长度。</p>
<h3 id="第四节-批操作"><a href="#第四节-批操作" class="headerlink" title="第四节 批操作"></a>第四节 批操作</h3><p>很多操作会“成批”复制或删除元素。以下调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">coll1.removeAll(coll2);</span><br></pre></td></tr></table></figure>
<p>将从coll1中删除coll2中出现的所有元素。与之相反，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">coll1.retainAll(coll2;)</span><br></pre></td></tr></table></figure>
<p>会从coll1中删除所有未在coll2中出现的元素。</p>
<h4 id="寻找交集"><a href="#寻找交集" class="headerlink" title="寻找交集"></a>寻找交集</h4><p><img src="https://s2.loli.net/2022/03/18/xzKQB51bg4cWXwE.png" alt="image-20220318004605897"></p>
<h3 id="第五节-集合与数组的转换"><a href="#第五节-集合与数组的转换" class="headerlink" title="第五节 集合与数组的转换"></a>第五节 集合与数组的转换</h3><h4 id="数组转换为集合"><a href="#数组转换为集合" class="headerlink" title="数组转换为集合"></a>数组转换为集合</h4><p>Arrays.asList包装器可以实现。</p>
<p><img src="https://s2.loli.net/2022/03/18/sbgIZ6P37hapj2U.png" alt="image-20220318004804802"></p>
<h4 id="集合得到数组"><a href="#集合得到数组" class="headerlink" title="集合得到数组"></a>集合得到数组</h4><p><img src="https://s2.loli.net/2022/03/18/3oCSrFPfamsHqJQ.png" alt="image-20220318004854386"></p>
<h4 id="注释-6"><a href="#注释-6" class="headerlink" title="注释"></a>注释</h4><p>你可能奇怪为什么不能直接将一个Class对象（如String.class）传递到toArray方法。原因是这个方法有“双重职责”，不仅要填充一个已有的数组（如果它足够长），还要创建一个新数组。</p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>Java平台的BitSet类用于存放一个位序列（它不是数学上的集，称为位向量或位数组更为合适）。如果需要高效地存储位序列（例如，标志）就可以使用位集。</p>
<p>由于位集将位包装在字节里，所以，使用位集要比使用Boolean对象的ArrayList更加高效。</p>
<p>BitSet类提供了一个便于读取、设置或清除各个位的接口。使用这个接口可以避免屏蔽和其他麻烦的位操作。如果将这些位存储在int或long变量中就必须进行这些繁琐的操作。</p>
<p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220318005146339.png" alt="image-20220318005146339"></p>
<h1 id="Chapter-14-并发"><a href="#Chapter-14-并发" class="headerlink" title="Chapter 14 并发"></a>Chapter 14 并发</h1><p>多线程和多进程的本质区别在于，每个进程拥有自己的一整套变量，而线程则共享数据。共享变量使线程之间的通信更加有效容易。与进程相比，线程更”轻量级”，创建、撤销一个线程比启动新进程的开销要小得多。</p>
<h2 id="第一讲-什么是线程"><a href="#第一讲-什么是线程" class="headerlink" title="第一讲 什么是线程"></a>第一讲 什么是线程</h2><h3 id="第一节-使用线程给其他任务提供机会"><a href="#第一节-使用线程给其他任务提供机会" class="headerlink" title="第一节 使用线程给其他任务提供机会"></a>第一节 使用线程给其他任务提供机会</h3>]]></content>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2022/02/01/SpringMVC/</url>
    <content><![CDATA[<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p><img src="https://s2.loli.net/2022/02/01/rqs2WMkTnNxFtGp.png" alt="image-20220201160516467"></p>
<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="MVC的定义"><a href="#MVC的定义" class="headerlink" title="MVC的定义"></a>MVC的定义</h2><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分。</p>
<h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>Model，模型层，指工程中的JavaBean，作用是处理数据。</p>
<h4 id="JavaBean的两类"><a href="#JavaBean的两类" class="headerlink" title="JavaBean的两类"></a>JavaBean的两类</h4><p>一类是实体类Bean：专门存储业务数据的属性和实例域，如User类等</p>
<p>一类是业务处理Bean：指Service或Dao对象，专门用于处理业务逻辑和数据访问</p>
<h3 id="V"><a href="#V" class="headerlink" title="V"></a>V</h3><p>View，视图层，指工程中的html或jsp等页面，作用是，直接与用户交互，展示数据</p>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>Controller，控制层，指工程中的Servlet，作用是接受请求和响应浏览器。</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>用户通过View层发送请求到服务器，在服务器中，请求被Controller层接收，调用相应的Model层，处理请求。完毕后，将处理结果返回给Controller层，Controller层再根据请求处理的结果，找到相应的View层，响应给浏览器，展示到用户。</p>
<h2 id="SpringMVC的定义"><a href="#SpringMVC的定义" class="headerlink" title="SpringMVC的定义"></a>SpringMVC的定义</h2><p>SpringMVC是Spring的一个后续产品，是Spring的一个子项目。</p>
<p>其是Spring为表述层开发提供的一个一整套完备的解决方案。</p>
<h3 id="SpringMVC的特点"><a href="#SpringMVC的特点" class="headerlink" title="SpringMVC的特点"></a>SpringMVC的特点</h3><ul>
<li>Spring家族原生产品，与IOC容器等基础设施无缝对接</li>
<li>基于原生的Servlet，通过功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理，不用自己写Servlet语法的代码</li>
<li>表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案</li>
<li>代码简洁，大幅提升开发效率</li>
<li>内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相关组件即可</li>
<li>性能显著</li>
</ul>
<h1 id="二、HelloWorld"><a href="#二、HelloWorld" class="headerlink" title="二、HelloWorld"></a>二、HelloWorld</h1><h2 id="1-创建maven工程"><a href="#1-创建maven工程" class="headerlink" title="1. 创建maven工程"></a>1. 创建maven工程</h2><p>pom.xml：</p>
<ul>
<li><p>打包方式</p>
</li>
<li><p>引入依赖</p>
</li>
<li>增加web模块(webapp这个Directory和web.xml)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;TestMaven&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.test.mvc&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springMVC&lt;/artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- SpringMVC --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">5.3</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 日志 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- ServletAPI --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">            &lt;!-- 表示当前的服务器中已经提供了servlet-api，不会存在于整合后的war包中 --&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Spring5和Thymeleaf整合包 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.0</span><span class="number">.12</span>.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;<span class="number">8</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;<span class="number">8</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<!-- 这表示当前的服务器中已经提供了servlet-api，不需要导入，也就是说，他不会存在于整合后的war包中 -->
<pre><code>        &lt;scope&gt;provided&lt;/scope&gt;
</code></pre><h3 id="依赖结果"><a href="#依赖结果" class="headerlink" title="依赖结果"></a>依赖结果</h3><p><img src="https://s2.loli.net/2022/02/01/PQUxFGAhluVaMRC.png" alt="image-20220201223036137"></p>
<h2 id="2-配置web-xml"><a href="#2-配置web-xml" class="headerlink" title="2. 配置web.xml"></a>2. 配置web.xml</h2><p>注册SpringMVC的前端控制器DispatcherServlet</p>
<h3 id="a-默认配置方式"><a href="#a-默认配置方式" class="headerlink" title="a. 默认配置方式"></a>a. 默认配置方式</h3><p>此配置作用下，SpringMVC的配置文件默认为与WEB-INF下，默认名称为<servlet-name>-servlet.xml。</p>
<p>例如，以下配置所对应SpringMVC的配置文件将位于WEB-INF下，文件名为SpringMVC-servlet.xml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        设置SpringMVC的核心控制器所能处理的请求的请求路径</span><br><span class="line">        / 能匹配的请求，可以是类似/login(/a之类)或.html或.js或.css方式的请求路径</span><br><span class="line">        但是不能匹配.jsp请求路径的请求，防止被作为一个普通请求被处理，无法显示.jsp界面</span><br><span class="line">        <span class="string">&quot;/*&quot;</span> 包括.jsp请求在内的所有请求</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<p>位置默认，名称默认，但在maven中，配置文件应当放在resource下，所以：</p>
<h3 id="b-拓展配置方式-常用"><a href="#b-拓展配置方式-常用" class="headerlink" title="b. 拓展配置方式(常用)"></a>b. 拓展配置方式(常用)</h3><p>配置SpringMVC配置文件的位置和名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;web-app xmlns=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="line">         version=<span class="string">&quot;4.0&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">        &lt;!-- 配置SpringMVC配置文件的位置和名称 --&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">        &lt;!-- 将前端控制器的初始化时间提前到服务器启动时，防止第一次访问时因加载过多，而影响访问速度 --&gt;</span><br><span class="line">        &lt;load-on-startup&gt;<span class="number">1</span>&lt;/load-on-startup&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>
<h2 id="3-创建请求控制器"><a href="#3-创建请求控制器" class="headerlink" title="3. 创建请求控制器"></a>3. 创建请求控制器</h2><p>由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理方式，因此需要创建处理具体请求的类，即请求控制器。</p>
<p>请求控制器中每一个处理请求的方法称为控制器方法。</p>
<p>因为SpringMVC的控制器由一个POJO(普通Java类)担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给IOC容器管理，此时SoringMVC才能识别控制器的存在。</p>
<h2 id="4-新建SpringMVC的配置文件"><a href="#4-新建SpringMVC的配置文件" class="headerlink" title="4. 新建SpringMVC的配置文件"></a>4. 新建SpringMVC的配置文件</h2><p>包括视图解析器和组件扫描器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.mvc.controller&quot;</span>&gt;&lt;/context:component-scan&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;!-- 配置Thymeleaf视图解析器 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;viewResolver&quot;</span> class=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 视图解析的优先级 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;order&quot;</span> value=<span class="string">&quot;1&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;characterEncoding&quot;</span> value=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;templateEngine&quot;</span>&gt;</span><br><span class="line">            &lt;bean class=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;templateResolver&quot;</span>&gt;</span><br><span class="line">                    &lt;!-- 解析策略 --&gt;</span><br><span class="line">                    &lt;bean class=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span><br><span class="line">                        &lt;!-- 视图前缀 --&gt;</span><br><span class="line">                        &lt;property name=<span class="string">&quot;prefix&quot;</span> value=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span><br><span class="line">                        &lt;!-- 视图后缀 --&gt;</span><br><span class="line">                        &lt;property name=<span class="string">&quot;suffix&quot;</span> value=<span class="string">&quot;.html&quot;</span>/&gt;</span><br><span class="line">                        &lt;property name=<span class="string">&quot;templateMode&quot;</span> value=<span class="string">&quot;HTML5&quot;</span>/&gt;</span><br><span class="line">                        &lt;property name=<span class="string">&quot;characterEncoding&quot;</span> value=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span><br><span class="line">                    &lt;/bean&gt;</span><br><span class="line">                &lt;/property&gt;</span><br><span class="line">            &lt;/bean&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h2 id="5-测试HelloWorld"><a href="#5-测试HelloWorld" class="headerlink" title="5. 测试HelloWorld"></a>5. 测试HelloWorld</h2><p><img src="https://s2.loli.net/2022/02/02/uBiXqUbThdQwjmL.png" alt="image-20220202220621011"></p>
<p><img src="https://s2.loli.net/2022/02/02/TLouqwFOvmsd3A9.png" alt="image-20220202222041226"></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址与控制器的@RequestMapping注解的value属性值进行匹配。若匹配成功，该注解所标识的控制器方法，就是处理请求的方法。处理请求的方法，需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图对应页面。</p>
<ol>
<li>在pom中配置包名、依赖名和版本号，引入相关依赖</li>
<li>创建webapp这个Directry和web.xml配置文件，并配置SpringMVC配置文件的位置和名称</li>
<li>在SpringMVC中配置前端控制器(和视图解析器)。</li>
<li>建立前端控制器类和相关.html等文件</li>
</ol>
<h1 id="三、-RequestMapping注解"><a href="#三、-RequestMapping注解" class="headerlink" title="三、@RequestMapping注解"></a>三、@RequestMapping注解</h1><p>设置的属性越多，要匹配所需的条件越多，匹配得越精确。</p>
<h2 id="注解的功能"><a href="#注解的功能" class="headerlink" title="注解的功能"></a>注解的功能</h2><p>@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系，要保证请求对应的地址是唯一的(只能存在一个@RequestMapping(/target))</p>
<p>SpringMVC接收到指定的请求，就会找到映射关系中对应的控制器方法来处理这个请求。</p>
<h2 id="注解的位置"><a href="#注解的位置" class="headerlink" title="注解的位置"></a>注解的位置</h2><p>@RequestMapping标识一个类：设置映射请求的请求路径的初始信息</p>
<p>@RequestMapping标识一个方法：设置映射请求的请求路径的具体信息</p>
<p><img src="https://s2.loli.net/2022/02/02/3aqkhF9rJLgSlv6.png" alt="image-20220202234334175"></p>
<p><img src="https://s2.loli.net/2022/02/02/XwRgHEvnBlmjo41.png" alt="image-20220202234417856"></p>
<h2 id="注解的value属性"><a href="#注解的value属性" class="headerlink" title="注解的value属性"></a>注解的value属性</h2><p>@RequestMapping注解的value属性，通过请求的请求地址匹配请求映射</p>
<p>@RequestMapping注解的value属性，是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</p>
<p>@RequestMapping注解的value属性，必须设置，至少通过地址匹配请求映射</p>
<p><img src="https://s2.loli.net/2022/02/03/ZeKs7WV69M4CfbO.png" alt="image-20220203232143281"></p>
<h2 id="注解的method属性"><a href="#注解的method属性" class="headerlink" title="注解的method属性"></a>注解的method属性</h2><p>@RequestMapping注解的method属性通过请求的方式(get或post)匹配请求映射(超链接发送的是get请求)</p>
<p>@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能匹配多种请求方式的请求</p>
<p><img src="https://s2.loli.net/2022/02/04/xQWbVFaI2YkeKMr.png" alt="image-20220204182816755"></p>
<p><strong>在默认的情况下，即不设置method属性时，post和get都支持；但设置完之后，只支持设置的那个方式。</strong></p>
<p>若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported</p>
<p><img src="https://s2.loli.net/2022/02/04/OqnPmQxWXDToGHJ.png" alt="image-20220204182905633"></p>
<p><img src="https://s2.loli.net/2022/02/04/Uk1dpJwjV47YToO.png" alt="image-20220204182957386"></p>
<p>上边可行，下边不可行。</p>
<blockquote>
<ol>
<li>对于处理请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解</li>
</ol>
<ul>
<li>处理get请求：@GetMapping</li>
<li>处理post请求：@PostMapping</li>
<li>处理put请求：@PutMapping</li>
<li>处理delete请求：@DeleteMapping</li>
</ul>
<p>常用的请求方式：get、post、put、delete</p>
<ol>
<li>但目前只支持get和post，若设置了其他表单提交的请求方式，则按照默认的get方式处理。</li>
</ol>
</blockquote>
<h2 id="注解的params属性-了解"><a href="#注解的params属性-了解" class="headerlink" title="注解的params属性(了解)"></a>注解的params属性(了解)</h2><p><img src="https://s2.loli.net/2022/02/04/Qt6ZquWkBxh5G9c.png" alt="image-20220204194532789"></p>
<h2 id="SpringMVC支持ant风格的路径"><a href="#SpringMVC支持ant风格的路径" class="headerlink" title="SpringMVC支持ant风格的路径"></a>SpringMVC支持ant风格的路径</h2><h3 id="："><a href="#：" class="headerlink" title="?："></a>?：</h3><p>表示任意的单个字符</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>这个字符不能是?：在地址栏中，?后匹配的是请求参数(也就是get方式提交数据时的情况)，如果是?，那么路径就只剩下请求中前边那个字符了。</p>
<p><img src="https://s2.loli.net/2022/02/04/6xgjGLtJTF9sDh7.png" alt="image-20220204215412314"></p>
<p>也不能是“/”：在路径中是路径分隔符</p>
<h3 id="：-1"><a href="#：-1" class="headerlink" title="*："></a>*：</h3><p>表示任意的0个或多个字符</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>上边两个注意点依旧成立</p>
<h3 id="：-2"><a href="#：-2" class="headerlink" title="**："></a>**：</h3><p>表示任意的一层或多层目录</p>
<h4 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h4><p>使用时，只能用/**/xxx的方式</p>
<p>也就是说，不能是/a**a/xxx这个样子，否则</p>
<p>会被当做两个”*”占位符来使用。</p>
<h2 id="SpringMVC支持路径中的占位符"><a href="#SpringMVC支持路径中的占位符" class="headerlink" title="SpringMVC支持路径中的占位符"></a>SpringMVC支持路径中的占位符</h2><h3 id="原始方式"><a href="#原始方式" class="headerlink" title="原始方式"></a>原始方式</h3><h4 id="deleteUser-id-1"><a href="#deleteUser-id-1" class="headerlink" title="/deleteUser?id=1"></a>/deleteUser?id=1</h4><h3 id="rest方式"><a href="#rest方式" class="headerlink" title="rest方式"></a>rest方式</h3><h4 id="deleteUser-1"><a href="#deleteUser-1" class="headerlink" title="/deleteUser/1"></a>/deleteUser/1</h4><p>SpringMVC路径中的占位符常用于restful风格中，当<strong>请求路径中将某些数据通过路径的方式</strong>传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符(xxx)表示传输的数据，再通过@PathVariable注解，将占位符所表示的数据，赋值给控制方法的形参。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送请求的格式</span></span><br><span class="line">&lt;a th:href=<span class="string">&quot;@&#123;/a1/target/1/admin&#125;&quot;</span>&gt;访问路径占位符**时&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制器中的请求映射格式</span></span><br><span class="line"> <span class="meta">@RequestMapping(&quot;/a1/target/&#123;id&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">target</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id, <span class="meta">@PathVariable(&quot;username&quot;)</span>String username)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id: &quot;</span> + id + <span class="string">&quot; username: &quot;</span> + username);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/02/04/iDfhW1lpAoVa4BQ.png" alt="image-20220204230621610"></p>
<h1 id="四、SpringMVC获取请求参数"><a href="#四、SpringMVC获取请求参数" class="headerlink" title="四、SpringMVC获取请求参数"></a>四、SpringMVC获取请求参数</h1><h2 id="通过ServletAPI获取-一般不用"><a href="#通过ServletAPI获取-一般不用" class="headerlink" title="通过ServletAPI获取(一般不用)"></a>通过ServletAPI获取(一般不用)</h2><p>因为SpringMVC中，已经封装了相关的ServletAPI的内容，并且提供了更为简洁的方式去调用，所以尽量不用原生的ServletAPI。</p>
<p>将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数，表示封装了当前请求的请求报文的对象。</p>
<p><img src="https://s2.loli.net/2022/02/05/vh9AY3Fa2TO1DwU.png" alt="image-20220205231831742"></p>
<p>因为，DispatcherController会根据当前其所包含数据，自动为控制器方法(@RequestMapping注解的方法)的参数赋值。</p>
<p>但此时，不能使用占位符{}了，因为request.getParameter( )方法，只能根据name来获取value。若是占位符的话，只有值value，没有name，导致方法无法使用。</p>
<h2 id="通过控制器方法的形参获取请求参数"><a href="#通过控制器方法的形参获取请求参数" class="headerlink" title="通过控制器方法的形参获取请求参数"></a>通过控制器方法的形参获取请求参数</h2><p>在控制器方法的形参位置，<strong>设置和请求参数同名的形参</strong>(不同名则无法获取到)，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参。</p>
<p><img src="https://s2.loli.net/2022/02/06/RcNvH2VFSqgTMAD.png" alt="image-20220206233040577"></p>
<p><img src="https://s2.loli.net/2022/02/06/MuETIB9ALP8DOVU.png" alt="image-20220206233218936"></p>
<p><img src="https://s2.loli.net/2022/02/06/nE14u8U29oWLbiF.png" alt="image-20220206233326972"></p>
<p><img src="https://s2.loli.net/2022/02/06/1qiVUuDcRErhCm5.png" alt="image-20220206233236981"></p>
<blockquote>
<h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><p>单个请求参数直接获取即可</p>
<p>若为多个同名的请求参数，可以使用字符串类型(逗号分隔开请求参数的每一个值)或字符串数组类型(用Arrays.toString( )方法输出)。</p>
</blockquote>
<h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p> @RequestParam是将请求参数和控制器方法的形参创建映射关系</p>
<p>原本就有一个默认的值，用不用都可以。</p>
<p>@RequestParam注解一共有三个属性：</p>
<ul>
<li><p>value：指定为形参赋值的请求参数的参数名</p>
</li>
<li><p>required：设置是否必须传输此请求参数(不传就报错)，默认值为true</p>
<p>若设置为true，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present; 若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null。</p>
</li>
<li><p>defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为null时，则使用其为形参赋值。</p>
<p><img src="https://s2.loli.net/2022/02/10/lMr5JvcPwZeWxSR.png" alt="image-20220210155004264"></p>
</li>
</ul>
<h2 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h2><p> @RequestHeader是将请求头信息和控制器方法的形参创建映射关系</p>
<p>参数与上边那个一样。</p>
<p><img src="https://s2.loli.net/2022/02/10/sMIzL37SxneqVly.png" alt="image-20220210161901846"></p>
<p>如果输出host，则输出是localhost:8080</p>
<h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h2><p>@CookieValue是将cookie数据和控制器方法的形参创建映射关系。</p>
<p>三个参数，用法同上</p>
<p>第一次调用getSession()时，Set-Cookie JSESSIONID存在于响应报文中的，但创建并相应到服务器之后之后，存在于请求报文中。</p>
<h2 id="通过POJO获取请求参数"><a href="#通过POJO获取请求参数" class="headerlink" title="通过POJO获取请求参数"></a>通过POJO获取请求参数</h2><p>可以在控制器方法的形参位置设置为一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;form th:action=<span class="string">&quot;@&#123;/testBean&#125;&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    用户名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    密码：&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    性别：&lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;sex&quot;</span> value=<span class="string">&quot;女&quot;</span>&gt;女&lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;sex&quot;</span> value=<span class="string">&quot;男&quot;</span>&gt;男&lt;br&gt;</span><br><span class="line">    年龄：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;使用实体类&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testBean&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testBean</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/02/10/yulhCrWIYTp3Jje.png" alt="image-20220210182908632"></p>
<h2 id="解决获取请求参数的乱码问题"><a href="#解决获取请求参数的乱码问题" class="headerlink" title="解决获取请求参数的乱码问题"></a>解决获取请求参数的乱码问题</h2><p>解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置编码过滤器 --&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;!-- 根据源码获得 --&gt;</span><br><span class="line">        &lt;!-- 设置请求的编码格式 --&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;UTF-<span class="number">8</span>&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;!-- 设置响应的编码经过过滤器 --&gt;</span><br><span class="line">        &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;<span class="literal">true</span>&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="注-1"><a href="#注-1" class="headerlink" title="注"></a>注</h3><p>Springmvc中处理编码的过滤器一定要配置到其他过滤器之前，否则无效</p>
<ol>
<li><p>在Tomcat的service.xml中URIEncoding=UTF-8已经设置过编码了，所以，使用get请求传递参数时，不会出现中文乱码(这个是可以一次操作，终身解决的)。</p>
</li>
<li><p>使用post请求传递参数时，DispatcherServlet会去获取请求参数，对已经获取的请求设置请求的编码格式毫无意义，并不会改变编码格式，所以使用request.setEncodingCharacter没用。也就是说，要在前端控制器获取请求之前，设置传递的编码格式。也就是比Ser-vlet执行更早的组件，需要配置过滤器(Tomcat三大组件加载顺序：监听器、过滤器、Serv-let，由于监听器起到监听作用，监听ServletContext，就是监听创建和销毁，即只执行一次。但过滤器，只要满足设置过的过滤路径，都会进行处理。设置后，每一次发送请求，都会经过过滤器的处理，再交给DisatcherServlet用。由于加载顺序的存在，web.xml中Filter和Servlet配置的前后顺序不产生影响。)</p>
</li>
</ol>
</blockquote>
<h1 id="五、域对象共享数据"><a href="#五、域对象共享数据" class="headerlink" title="五、域对象共享数据"></a>五、域对象共享数据</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>servletcontext(上下文对象)在整个应用范围内有效，也就是服务器开启到服务器关闭这段时间(只创建一次，与浏览器是否关闭无关)。</p>
<p>session在整个浏览器范围内有效，也就是浏览器开启和浏览器关闭这段时间(也就是其中数据与服务器是否关闭无关)。</p>
<p>session中有钝化(服务器关闭，而浏览器未关闭，即会话仍在继续，那么这时，存储在session上的数据，会经过序列化，保存到磁盘上)和活化(浏览器仍未关闭，但服务器重新开启，将钝化过的内容，重新读取到session中)。</p>
<p>只要JSESSIONID所依赖的这个Cookie存在，那么在当前会话中所创建的session，永远都是同一个。</p>
<h2 id="选择域对象"><a href="#选择域对象" class="headerlink" title="选择域对象"></a>选择域对象</h2><p>选择一个能实现功能的，范围最小的(不会浪费资源)。</p>
<h2 id="使用servletAPI向request域对象共享数据"><a href="#使用servletAPI向request域对象共享数据" class="headerlink" title="使用servletAPI向request域对象共享数据"></a>使用servletAPI向request域对象共享数据</h2><p>原生servletAPI，少用咯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequest</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;hello, servletAPI&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;p th:text=<span class="string">&quot;$&#123;testRequestScope&#125;&quot;</span>&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>先调用控制器方法TestController显示出index.html界面，点击超链接，经由thymeleaf视图解析后，跳转到success.html界面，将testServletScope中已经request.setAttribute( )过的域对象，显示出来。</p>
<h2 id="使用ModelAndView向request域对象共享数据-建议用"><a href="#使用ModelAndView向request域对象共享数据-建议用" class="headerlink" title="使用ModelAndView向request域对象共享数据(建议用)"></a>使用ModelAndView向request域对象共享数据(建议用)</h2><h3 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h3><p>SpringMVC提供。</p>
<p>ModelAndView有Model和View的功能</p>
<p><strong>Model主要指的是，向域对象中共享的数据。</strong></p>
<p><strong>View就是视图，指的就是设置好的视图名称。经过视图解析，实现跳转到的指定页面。</strong></p>
<p>不管用什么方法共享数据，最终都会将Model和View封装到ModelAndView这个对象中。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>向request域对象共享数据，设置视图名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelAndView&quot;)</span></span><br><span class="line"><span class="comment">// 返回值必须是ModelAndView，将其交给视图解析器进行解析</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">testModelAndView</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    <span class="comment">// 处理模型数据，向request共享数据</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;Hello, ModelAndView&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置视图名称</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用Model向request域对象共享数据"><a href="#使用Model向request域对象共享数据" class="headerlink" title="使用Model向request域对象共享数据"></a>使用Model向request域对象共享数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testModel</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;Hello, Model&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用map向request域对象共享数据"><a href="#使用map向request域对象共享数据" class="headerlink" title="使用map向request域对象共享数据"></a>使用map向request域对象共享数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testMap</span><span class="params">(Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">    map.put(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;Hello, Map&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用ModelMap向request域对象共享数据"><a href="#使用ModelMap向request域对象共享数据" class="headerlink" title="使用ModelMap向request域对象共享数据"></a>使用ModelMap向request域对象共享数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testModelMap</span><span class="params">(ModelMap modelMap)</span> &#123;</span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;Hello, ModelMap&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Model、ModelMap、Map的关系"><a href="#Model、ModelMap、Map的关系" class="headerlink" title="Model、ModelMap、Map的关系"></a>Model、ModelMap、Map的关系</h2><p>Model、ModelMap、Map类型的参数，本质上都是BindingAwareModelMap类型的(通过Model.getClass().-getName()得到的)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Model</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModelMap</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;String, Object&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendedModelMap</span> <span class="keyword">extends</span> <span class="title class_">ModelMap</span> <span class="keyword">implements</span> <span class="title class_">Mode</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BindingAwareModelMap</span> <span class="keyword">extends</span> <span class="title class_">ExtendedModelMap</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>以上四个方法，都会将模型数据和视图信息封装到一个ModelAndView中，类似：</p>
<p><img src="https://s2.loli.net/2022/02/13/31efY4PZjwzpgik.png" alt="image-20220213205722225"></p>
<h2 id="向session域共享数据"><a href="#向session域共享数据" class="headerlink" title="向session域共享数据"></a>向session域共享数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testSession&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testSession</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">	session.setAttribute(<span class="string">&quot;testSessionScope&quot;</span>, <span class="string">&quot;Hello, session&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="向application域共享数据"><a href="#向application域共享数据" class="headerlink" title="向application域共享数据"></a>向application域共享数据</h2><p>整个工程中要共享的东西，才会放到application中，范围太大</p>
<p>一般都用request和session。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testApplication&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testApplication</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    application.setAttribute(<span class="string">&quot;testApplicationScope&quot;</span>, <span class="string">&quot;Hello, application&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="六、SpringMVC的视图"><a href="#六、SpringMVC的视图" class="headerlink" title="六、SpringMVC的视图"></a>六、SpringMVC的视图</h1><p>SpringMVC中的视图是View接口，视图的作用是渲染数据，将模型Model中的数据展示给用户。</p>
<p>SpringMVC视图的种类有很多，默认有转发视图InternalResourceView和重定向视图RedirectView。</p>
<p>当工程引入jstl的以来，转发视图会自动转换为jstlView</p>
<p>若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView</p>
<h2 id="1-ThymeleafView"><a href="#1-ThymeleafView" class="headerlink" title="1. ThymeleafView"></a>1. ThymeleafView</h2><p>当<strong>控制器方法中所设置的视图名称没有任何前缀时</strong>，此时的视图名称会被SpringMVC配置文件中所配置的Thymeleaf视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过<strong>转发的方式</strong>实现跳转。</p>
<p><img src="https://s2.loli.net/2022/02/14/C8cEGNuyWshHJpw.png" alt="image-20220214210804710"></p>
<h2 id="2-转发视图-用的不是很多"><a href="#2-转发视图-用的不是很多" class="headerlink" title="2. 转发视图(用的不是很多)"></a>2. 转发视图(用的不是很多)</h2><p>SpringMVC中默认的转发视图时InternalResourceView。</p>
<h3 id="情况："><a href="#情况：" class="headerlink" title="情况："></a>情况：</h3><p>当控制器方法中所设置的<strong>视图名称以”forward:”为前缀</strong>时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中的所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过<strong>转发的方式</strong>实现跳转。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p><img src="https://s2.loli.net/2022/02/14/fVYiyWm8usU6NnA.png" alt="image-20220214214405141"></p>
<p><img src="https://s2.loli.net/2022/02/14/MnI9qFLlfKmspPX.png" alt="image-20220214214501985"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testThymeleafView&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testThymeleafView</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testForward</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 转发了一个请求，创建了两个请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/testThymeleafView&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h3><p>只能转发到一个请求，不能直接”forward:”到一个html页面(因为页面必须通过服务器访问，通过转发访问)。</p>
<p>因为Thymeleaf本身就是转发的方式，所以说，这个转发视图用的不多。</p>
<h2 id="3-重定向视图"><a href="#3-重定向视图" class="headerlink" title="3. 重定向视图"></a>3. 重定向视图</h2><p>SpringMVC中默认的重定向视图时RedirectView。</p>
<h3 id="情况"><a href="#情况" class="headerlink" title="情况"></a>情况</h3><p>当控制器方法中所设置的视图名称以”redirect”为前缀时，创建RedirectView视图，此时视图的名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect”去掉，剩余部分作为最终路径通过<strong>重定向的方式</strong>实现跳转。</p>
<h3 id="转发和重定向区别"><a href="#转发和重定向区别" class="headerlink" title="转发和重定向区别"></a>转发和重定向区别</h3><p>转发浏览器只发送一次请求(发生在服务器内部，只能访问内部的页面)，重定向发送两次请求(可以访问服务器外的页面)。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>页面都在WEB-INF下，而WEB-INF下的内容，重定向是无法访问的。再说了现在的页面，都要经过Thymeleaf解析，所以要通过转发去访问Thymeleaf视图，所以要重定向一个请求。</p>
<p><img src="https://s2.loli.net/2022/02/14/ljSBqPiWKIbC7Gt.png" alt="image-20220214220417979"></p>
<p><img src="https://s2.loli.net/2022/02/14/MnI9qFLlfKmspPX.png" alt="image-20220214214501985"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRedirect&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRedirect</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/testThymeleafView&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果对比"><a href="#结果对比" class="headerlink" title="结果对比"></a>结果对比</h3><p><img src="https://s2.loli.net/2022/02/14/yHB8N3ezGEmfW7c.png" alt="image-20220214221223092"></p>
<h4 id="转发时"><a href="#转发时" class="headerlink" title="转发时"></a>转发时</h4><p><img src="https://s2.loli.net/2022/02/14/kGmHx1worAKcFQR.png" alt="image-20220214220956997"></p>
<h4 id="重定向时"><a href="#重定向时" class="headerlink" title="重定向时"></a>重定向时</h4><p><img src="https://s2.loli.net/2022/02/14/D8L4e2MHRk3mElG.png" alt="image-20220214221046150"> </p>
<p>也就是说，虽然发送了一样的请求。</p>
<p>但是转发和重定向，一个，地址栏的地址直接对应的是原请求，即/testForward；而另一个，地址栏的地址变化了，从/testRedirect跳转到了对应的/testThymeleafView。</p>
<h2 id="4-视图控制器view-controller-注意"><a href="#4-视图控制器view-controller-注意" class="headerlink" title="4. 视图控制器view-controller(注意)"></a>4. 视图控制器view-controller(注意)</h2><p>当控制器方法中，仅仅用来实现页面跳转，即只需要设置各种视图名称时，可以将处理器方法使用view-controller标签进行表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">    path：设置处理的请求地址</span><br><span class="line">    view-name：设置请求地址对应的视图名称</span><br><span class="line">--&gt;</span><br><span class="line">&lt;mvc:view-controller path=<span class="string">&quot;/testview&quot;</span> view-name=<span class="string">&quot;success&quot;</span>&gt;&lt;/mvc:view-controller&gt;</span><br></pre></td></tr></table></figure>
<h3 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h3><p>当Springmvc中设置任何一个view-controller时，<strong>控制器中的请求映射将全部失效</strong>。</p>
<p>此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：</p>
<p><code>&lt;mvc:annotation-driven /&gt;</code></p>
<h1 id="七、RESTFul"><a href="#七、RESTFul" class="headerlink" title="七、RESTFul"></a>七、RESTFul</h1><p>REST： Representational State Transfer，表现层(视图+控制层)资源状态转移。</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。</p>
<p>每个资源是服务器上一个可命名的抽象概念，它不仅仅代表服务器文件系统中的一个文件等具体的东西。</p>
<p><strong>资源是以名词为核心来组织的。</strong></p>
<p>首先关注的是名词，一个资源可以由一个或多个URI(统一资源定位符)来标识。URI既是资源的名称，也是资源在Web上的地址，对这个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。</p>
<p>就，知道了要操作的资源是什么，为这个资源设置一个名词，则可以实现通过同一个请求路径实现不同的操作。</p>
<h3 id="资源的表述"><a href="#资源的表述" class="headerlink" title="资源的表述"></a>资源的表述</h3><p>资源的表示是对于资源在某个特定时刻的状态的描述。可以在客户端-服务器之间转移(交换)。</p>
<p>资源的表述可以有多种格式，如HTML/XML/JSON/纯文本/音频等。</p>
<p>资源的表述格式可以通过协商机制来确定。请求-响应的表述通常使用不同的格式。</p>
<h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>状态转移说的是，在客户端和服务器之间转移 (transfer)代表资源状态的 表述(向服务器发送请求，请求什么，服务器就返回什么资源)。通过转移和操作资源的表述(请求路径)，来间接实现操作资源的目的。</p>
<h2 id="2-RESTFul的实现"><a href="#2-RESTFul的实现" class="headerlink" title="2. RESTFul的实现"></a>2. RESTFul的实现</h2><p>具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET(查找)、POST(添加)、PUT(修改)、DELETE(删除)。</p>
<p>REST风格提倡URL地址使用统一的风格设计，<strong>从前到后各个单词使用斜杠分开</strong>，<strong>不使用问号键值对方式携带请求参数</strong>，而是将要发送给服务器的数据作为URL地址的一部分，以保证整体风格的意志。</p>
<p><img src="https://s2.loli.net/2022/02/15/ode2uAYIN8MZvET.png" alt="image-20220215234057710"></p>
<h2 id="3-HiddenHttpMethodFilter"><a href="#3-HiddenHttpMethodFilter" class="headerlink" title="3. HiddenHttpMethodFilter"></a>3. HiddenHttpMethodFilter</h2><p>由于浏览器只支持发送get和post请求，那么如何发送put和delete请求呢？</p>
<p>SpringMVC提供了HiddenHttpMethodFilter来将POST请求转换为DELETE和PUT请求。</p>
<p>要有初始化、执行过滤(重要)、销毁生命周期三个方法。</p>
<p><img src="https://s2.loli.net/2022/02/16/EFekI3uJUSP7gwc.png" alt="image-20220216211605226"></p>
<p>当前过滤器要拦截的请求和响应</p>
<p>获取当前请求的请求方式</p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p><img src="https://s2.loli.net/2022/02/16/bgBsTR47icAuYIW.png" alt="image-20220216213429236"></p>
<ul>
<li>当前请求方式必须为post</li>
<li>当前请求必须传输一个name为“_method”的参数</li>
</ul>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>这个过滤器和设置编码的CharacterEncodingFilter的顺序：</p>
<p>一定是设置请求的编码的CharacterEncodingFilter在前边。在设置编码之前，不能获取任何请求参数。因为如果之前就获取了请求，那么之后对请求设置编码格式自然是无用的。</p>
<h1 id="八、RESTFul案例"><a href="#八、RESTFul案例" class="headerlink" title="八、RESTFul案例"></a>八、RESTFul案例</h1><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>和传统CRUD一样，实现对员工信息的增删改查</p>
<h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><h4 id="1-配置pom-xml"><a href="#1-配置pom-xml" class="headerlink" title="1. 配置pom.xml"></a>1. 配置pom.xml</h4><p>引入依赖：<img src="https://s2.loli.net/2022/02/18/6yr8Ejm54sJBINd.png" alt="image-20220218203617354"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line">&lt;groupId&gt;com.test&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springMVC-rest&lt;/artifactId&gt;</span><br><span class="line">&lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- SpringMVC --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">5.3</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 日志 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- ServletAPI --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;!-- 表示当前的服务器中已经提供了servlet-api，不会存在于整合后的war包中 --&gt;</span><br><span class="line">        &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Spring5和Thymeleaf整合包 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.0</span><span class="number">.12</span>.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-配置web-xml-1"><a href="#2-配置web-xml-1" class="headerlink" title="2. 配置web.xml"></a>2. 配置web.xml</h4><h5 id="1-CharacterEncodingFilter"><a href="#1-CharacterEncodingFilter" class="headerlink" title="1. CharacterEncodingFilter"></a>1. CharacterEncodingFilter</h5><p>确定请求和响应的编码格式为UTF-8</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;!-- 根据源码确定的 --&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;UTF-<span class="number">8</span>&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;<span class="literal">true</span>&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;<span class="literal">true</span>&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;<span class="comment">/*&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">&lt;/filter-mapping&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="2-HiddenHttpMethodFilter"><a href="#2-HiddenHttpMethodFilter" class="headerlink" title="2. HiddenHttpMethodFilter"></a>2. HiddenHttpMethodFilter</h5><p>确定DELETE和PUT两个请求方式可以得到处理</p>
<p>由于请求方式和参数是请求同名的情况下，确定对应的请求处理方式的依据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">  &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">  &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">  &lt;filter-mapping&gt;</span><br><span class="line">      &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">      &lt;url-pattern&gt;<span class="comment">/*&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">  &lt;/filter-mapping&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="3-DispatcherServlet"><a href="#3-DispatcherServlet" class="headerlink" title="3. DispatcherServlet"></a>3. DispatcherServlet</h5><p>配置前端控制器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;!-- 设置使得SpringMVC的配置文件放置在工程中的resources文件夹下 --&gt;</span><br><span class="line">        &lt;param-name&gt;ContextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;load-on-startup&gt;<span class="number">1</span>&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3-建立控制器类xxController-java"><a href="#3-建立控制器类xxController-java" class="headerlink" title="3. 建立控制器类xxController.java"></a>3. 建立控制器类xxController.java</h4><p>用注解@Controller标识创建该控制器对象</p>
<h4 id="4-配置springMVC-xml"><a href="#4-配置springMVC-xml" class="headerlink" title="4. 配置springMVC.xml"></a>4. 配置springMVC.xml</h4><h5 id="1-注解扫描"><a href="#1-注解扫描" class="headerlink" title="1. 注解扫描"></a>1. 注解扫描</h5><h5 id="2-配置视图解析器"><a href="#2-配置视图解析器" class="headerlink" title="2. 配置视图解析器"></a>2. 配置视图解析器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.test&quot;</span>&gt;&lt;/context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置视图解析器 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;viewResolver&quot;</span> class=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span><br><span class="line">    &lt;!-- 视图解析的优先级 --&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;order&quot;</span> value=<span class="string">&quot;1&quot;</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;characterEncoding&quot;</span> value=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;templateEngine&quot;</span>&gt;</span><br><span class="line">        &lt;bean class=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span><br><span class="line">            &lt;property name=<span class="string">&quot;templateResolver&quot;</span>&gt;</span><br><span class="line">                &lt;!-- 解析策略 --&gt;</span><br><span class="line">                &lt;bean class=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span><br><span class="line">                    &lt;!-- 视图前缀 --&gt;</span><br><span class="line">                    &lt;property name=<span class="string">&quot;prefix&quot;</span> value=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span><br><span class="line">                    &lt;!-- 视图后缀 --&gt;</span><br><span class="line">                    &lt;property name=<span class="string">&quot;suffix&quot;</span> value=<span class="string">&quot;.html&quot;</span>/&gt;</span><br><span class="line">                    &lt;property name=<span class="string">&quot;templateMode&quot;</span> value=<span class="string">&quot;HTML5&quot;</span>/&gt;</span><br><span class="line">                    &lt;property name=<span class="string">&quot;characterEncoding&quot;</span> value=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span><br><span class="line">                &lt;/bean&gt;</span><br><span class="line">            &lt;/property&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-准备实体类"><a href="#2-准备实体类" class="headerlink" title="2. 准备实体类"></a>2. 准备实体类</h3><h4 id="1-bean包"><a href="#1-bean包" class="headerlink" title="1. bean包"></a>1. bean包</h4><p>放置实体类(属性、无参构造、有参构造、toString()、getXX()、setXX())</p>
<h4 id="2-Dao包"><a href="#2-Dao包" class="headerlink" title="2. Dao包"></a>2. Dao包</h4><p>代表持久化层、数据访问层，操作数据库的各种方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Employee&gt; employees = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        employees = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Employee&gt;();</span><br><span class="line"></span><br><span class="line">        employees.put(<span class="number">1001</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>, <span class="string">&quot;E-AA&quot;</span>, <span class="string">&quot;aa@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        employees.put(<span class="number">1002</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1002</span>, <span class="string">&quot;E-BB&quot;</span>, <span class="string">&quot;bb@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        employees.put(<span class="number">1003</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1003</span>, <span class="string">&quot;E-CC&quot;</span>, <span class="string">&quot;cc@163.com&quot;</span>, <span class="number">0</span>));</span><br><span class="line">        employees.put(<span class="number">1004</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1004</span>, <span class="string">&quot;E-DD&quot;</span>, <span class="string">&quot;dd@163.com&quot;</span>, <span class="number">0</span>));</span><br><span class="line">        employees.put(<span class="number">1005</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1005</span>, <span class="string">&quot;E-EE&quot;</span>, <span class="string">&quot;ee@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">initId</span> <span class="operator">=</span> <span class="number">1006</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Employee employee)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (employee.getId() == <span class="literal">null</span>) &#123;</span><br><span class="line">            employee.setId(initId++);</span><br><span class="line">        &#125;</span><br><span class="line">        employees.put(employee.getId(), employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;Employee&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> employees.values();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">get</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> employees.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        employees.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-Controller包"><a href="#3-Controller包" class="headerlink" title="3. Controller包"></a>3. Controller包</h4><p>有关的控制器方法</p>
<p>设置资源的名称为employee</p>
<h2 id="2-功能清单"><a href="#2-功能清单" class="headerlink" title="2. 功能清单"></a>2. 功能清单</h2><p>根据请求方式来实现不同功能</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>功能</th>
<th>URL地址</th>
<th>请求方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>访问首页</td>
<td>/</td>
<td>GET</td>
</tr>
<tr>
<td>查询全部数据</td>
<td>/employee</td>
<td>GET</td>
</tr>
<tr>
<td>删除</td>
<td>/employee/2</td>
<td>DELETE</td>
</tr>
<tr>
<td>跳转到添加数据页面</td>
<td>/toAdd</td>
<td>GET</td>
</tr>
<tr>
<td>执行保存</td>
<td>/employee</td>
<td>POST</td>
</tr>
<tr>
<td>跳转到更新数据页面</td>
<td>/employee/3</td>
<td>GET</td>
</tr>
<tr>
<td>执行更新</td>
<td>/employee</td>
<td>PUT</td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-查询所有员工"><a href="#3-查询所有员工" class="headerlink" title="3. 查询所有员工"></a>3. 查询所有员工</h2><p>请求方式为get。</p>
<h3 id="操作：访问首页"><a href="#操作：访问首页" class="headerlink" title="操作：访问首页(*)"></a>操作：访问首页(*)</h3><h4 id="配置springMVC-xml"><a href="#配置springMVC-xml" class="headerlink" title="配置springMVC.xml"></a>配置springMVC.xml</h4><h5 id="1-视图控制器"><a href="#1-视图控制器" class="headerlink" title="1. 视图控制器"></a>1. 视图控制器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置视图控制器 --&gt;</span><br><span class="line">&lt;mvc:view-controller path=<span class="string">&quot;/&quot;</span> view-name=<span class="string">&quot;index&quot;</span>&gt;&lt;/mvc:view-controller&gt;</span><br><span class="line">&lt;mvc:view-controller path=<span class="string">&quot;/toAdd&quot;</span> view-name=<span class="string">&quot;employee_add&quot;</span>&gt;&lt;/mvc:view-controller&gt;</span><br></pre></td></tr></table></figure>
<h5 id="2-访问驱动器"><a href="#2-访问驱动器" class="headerlink" title="2. 访问驱动器"></a>2. 访问驱动器</h5><p>必须要配置，否则除了在视图控制器中声明的请求映射之外，别的在控制器中的请求映射，将无法被处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven /&gt;</span><br></pre></td></tr></table></figure>
<h5 id="3-html页面"><a href="#3-html页面" class="headerlink" title="3. html页面"></a>3. html页面</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span>&gt;</span>查看员工信息<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-html页面"><a href="#1-html页面" class="headerlink" title="1. html页面"></a>1. html页面</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Employee Information<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;dataTable&quot;</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;5&quot;</span>&gt;</span>Employee Information<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>lastName<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>email<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>gender<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>options (<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/toAdd&#125;&quot;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">a</span>&gt;</span>) <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 每次都要循环一行信息，在tr中使用th: 。又因为数据保存在请求域中，所以用$&#123; &#125;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;employee : $&#123;employeeList&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 如果写在&lt;td&gt;$&#123; &#125;&lt;/td&gt;的话，会被当成文本输出，而不是被解析--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 通过超链接来控制一个表单的提交方式，通过vue来处理为其绑定的事件， form表单才是最终的提交方式 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;deleteEmployee&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27; + $&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>delete<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;deleteForm&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;delete&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> vue = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">el</span>:<span class="string">&quot;#dataTable&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">deleteEmployee</span>:<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 根据id获取表单元素</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">var</span> deleteForm = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;deleteForm&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 将触发点击事件的超链接的href属性赋值给表单的action</span></span></span><br><span class="line"><span class="language-javascript">                    deleteForm.<span class="property">action</span> = event.<span class="property">target</span>.<span class="property">href</span>;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 提交表单</span></span></span><br><span class="line"><span class="language-javascript">                    deleteForm.<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 取消超链接的默认行为</span></span></span><br><span class="line"><span class="language-javascript">                    event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-控制器"><a href="#2-控制器" class="headerlink" title="2. 控制器"></a>2. 控制器</h3><p>主要调用了getAll( )方法，将数据库中的数据读取。</p>
<p>之后设置了构成ModelAndView的数据employeeList和(返回了)视图employee_list。</p>
<p>此处的域对象是请求域，因为每次显示数据都需要重新进行查找，所以说这些数据只需在一次请求中有效即可。</p>
<p>选取域对象，要选能实现预期功能的且范围最小的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/employee&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAllEmployees</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    Collection&lt;Employee&gt; employeeList = employeeDao.getAll();</span><br><span class="line">    <span class="comment">// 因为每次都需要重新查，只需在一次请求中有效即可，否则占空间</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;employeeList&quot;</span>, employeeList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;employee_list&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a>4. 删除</h2><p>比较麻烦。</p>
<p>请求方式为delete。</p>
<h3 id="0-思路"><a href="#0-思路" class="headerlink" title="0. 思路"></a>0. 思路</h3><p>首先将delete的超链接绑定到一个表单提交的事件，通过设置表单的提交方式为post并配置参数_method，可以使用HiddenHttpMethodFilter过滤器，将其转换为delete请求方式。</p>
<h3 id="1-设置表单"><a href="#1-设置表单" class="headerlink" title="1. 设置表单"></a>1. 设置表单</h3><ol>
<li>提交方式为post</li>
<li>设置_method参数的值为请求方式delete</li>
</ol>
<p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220218224140190.png" alt="image-20220218224140190"></p>
<h3 id="2-vue设置超链接"><a href="#2-vue设置超链接" class="headerlink" title="2. vue设置超链接"></a>2. vue设置超链接</h3><p>因为在表格中，delete通常是以超链接的形式存在。但是要想发送并能处理这个DELETE请求方式，就必须要通过表单提交的方式(根据HiddenHttpFilter的源码可得)。</p>
<p>所以，这里使用了vue，采取了将超链接绑定一个表单提交的事件的方式，之后通过在控制器中匹配请求名称和请求方式，执行相关的方法。</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>首先根据id获取表单元素</p>
<p>将待点击的超链接的href属性(event.target.href)赋值给表单的action</p>
<p>提交表单.submit( )</p>
<p>取消超链接的默认行为(preventDefaukt( ))。</p>
<p>特别，注意取消超链接默认的点击后跳转行为，否则绑定不生效。</p>
<p><img src="https://s2.loli.net/2022/02/18/oVyTPIF34m8WS7v.png" alt="image-20220218223510735"></p>
<h3 id="3-设置请求格式"><a href="#3-设置请求格式" class="headerlink" title="3. 设置请求格式"></a>3. 设置请求格式</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>采用的发送请求的方式为：通过”/“将参数跟到地址后。</p>
<p>所以要实现在超链接点击后，发送的请求中，要有对应的员工id。</p>
<p><strong>使用Thymeleaf视图解析器的方式，通过增加可解析的参数表达式实现。</strong></p>
<h4 id="错误方式"><a href="#错误方式" class="headerlink" title="错误方式"></a>错误方式</h4><p><img src="https://s2.loli.net/2022/02/17/q9Mnkg3FVoYmQi8.png" alt="image-20220217233308716"></p>
<p><img src="https://s2.loli.net/2022/02/17/WAx37uF6CTotYN1.png" alt="image-20220217233359456"></p>
<p><img src="https://s2.loli.net/2022/02/17/X7VEG1hQabJMnuT.png" alt="image-20220217233427223"></p>
<p>这种写法是错误的，此时只将左右大括号进行了解析，而没有解析表达式(虽不知为何会如此)。</p>
<h4 id="正确方式1："><a href="#正确方式1：" class="headerlink" title="正确方式1："></a>正确方式1：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 放在外边 --&gt;</span><br><span class="line">&lt;a th:href=<span class="string">&quot;@&#123;/employee/&#125; + $&#123;employee.id&#125;&quot;</span>&gt;delete&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<h4 id="正确方式2："><a href="#正确方式2：" class="headerlink" title="正确方式2："></a>正确方式2：</h4><p>前边的会作为路径解析，后边的作为请求参数解析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 放在里边 --&gt;</span><br><span class="line">&lt;a th:href=<span class="string">&quot;@&#123; &#x27;/employee/&#x27;+$&#123;employee.id&#125; &#125;&quot;</span>&gt;delete&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-控制器"><a href="#4-控制器" class="headerlink" title="4. 控制器"></a>4. 控制器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deleteEmployee</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">    <span class="comment">// 将占位符的值和当前形参进行绑定</span></span><br><span class="line">    employeeDao.delete(id);</span><br><span class="line">    <span class="comment">// 删除成功后，再展示数据，与原来的请求无关，故而采用重定向</span></span><br><span class="line">    <span class="comment">// 下面这样，类似于在地址栏重新输入地址，是get方式</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-Tips"><a href="#5-Tips" class="headerlink" title="5. Tips"></a>5. Tips</h3><p>解决当时遇到的405 请求方式无法解析的问题。</p>
<h4 id="1-打包"><a href="#1-打包" class="headerlink" title="1. 打包"></a>1. 打包</h4><p>借助vue.js，将超链接绑定一个表单提交事件的配置没有生效。</p>
<p>因为是在工程运行打包之后，又增加的vue.js文件。所以在当前已经打包过的资源中，它不存在，需要重新打包。</p>
<p>如下图所示：</p>
<p><img src="https://s2.loli.net/2022/02/18/4ZqrSvm1z6wjIbD.png" alt="image-20220218225905824"></p>
<h4 id="2-配置默认的servlet"><a href="#2-配置默认的servlet" class="headerlink" title="2. 配置默认的servlet"></a>2. 配置默认的servlet</h4><p>SpringMVC无法处理静态资源。</p>
<p>所以在重新打包，保证新引入的vue.js文件在打好的war包中后，仍旧会报 404 not found 的问题。</p>
<p>静态资源是要靠默认的servlet来处理的，故而需要在SpringMVC中新增配置，开放对静态资源的访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mvc:<span class="keyword">default</span>-servlet-handler /&gt;</span><br></pre></td></tr></table></figure>
<p>加上之后，所有的请求都会先被DispatcherServlet首先处理，如果找不到对应的请求映射，就会交给默认的servlet处理。</p>
<p>如果默认的servlet可以处理，那就访问，找不到的话，就提示404。</p>
<h5 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h5><p>当然，此时一定要加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven /&gt;</span><br></pre></td></tr></table></figure>
<p>如果不加的话，所有的请求都会被默认的servlet处理。</p>
<h2 id="5-添加"><a href="#5-添加" class="headerlink" title="5. 添加"></a>5. 添加</h2><p>请求方式为post</p>
<h3 id="0-思路-1"><a href="#0-思路-1" class="headerlink" title="0. 思路"></a>0. 思路</h3><p>先跳转到toAdd.html页面，将数据从表单中提交，之后通过在控制器中匹配请求名称和请求方式，执行相关的方法。</p>
<h3 id="1-html页面-1"><a href="#1-html页面-1" class="headerlink" title="1. html页面"></a>1. html页面</h3><p><img src="https://s2.loli.net/2022/02/18/ztSKYaZBFbvHrgp.png" alt="image-20220218233019137"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Add Employee<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    lastName: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    email: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    gender: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>male</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span>female<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;add&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-控制器-1"><a href="#2-控制器-1" class="headerlink" title="2. 控制器"></a>2. 控制器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addEmployee</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">    employeeDao.save(employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-修改"><a href="#6-修改" class="headerlink" title="6. 修改"></a>6. 修改</h2><p>跟delete差不多，但是因为它有独立的页面，可以执行表单提交，所以不用将超链接绑定表单提交事件。</p>
<p>请求方式为put。</p>
<h3 id="0-思路-2"><a href="#0-思路-2" class="headerlink" title="0. 思路"></a>0. 思路</h3><p>首先点击add超链接，根据提交的请求名和请求方式(超链接默认的请求方式是get)，找到第一个控制器方法</p>
<p>进入employee_update页面，回显信息，修改之后，提交信息，找到第二个控制器方法，显示当前所有员工。</p>
<h3 id="1-html页面-2"><a href="#1-html页面-2" class="headerlink" title="1. html页面"></a>1. html页面</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Update Employee<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;put&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span></span><br><span class="line">    lastName: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    email: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    gender: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>male</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>female<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;update&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-控制器方法"><a href="#2-控制器方法" class="headerlink" title="2. 控制器方法"></a>2. 控制器方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getEmployeeById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, Model model)</span> &#123;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeDao.get(id);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;employee&quot;</span>, employee);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;employee_update&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.PUT)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">updateEmployee</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">        employeeDao.save(employee);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所有工程的web.xml文件在Tomcat的conf文件夹中。</p>
<p>若自己工程配置的web.xml，与所有工程的不同(产生冲突)，以就近为准，选择自己的。</p>
<h1 id="九、-HttpMessageConverter"><a href="#九、-HttpMessageConverter" class="headerlink" title="九、 HttpMessageConverter"></a>九、 HttpMessageConverter</h1><p>HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象(要通过Java接收报文)，或将Java对象转换为响应报文(服务器用的是Java语言，但浏览器只能接收响应报文)。</p>
<p>提供了两个注解和两个类型</p>
<p>@RequestBody(将请求报文中的请求体转化为Java对象)</p>
<p><strong>@ResponseBody</strong>(将Java对象转换为响应体)</p>
<p>RequestEntity(请求实体，可以用来接收整个请求报文，既可以用来接受请求头，还能接收请求体)</p>
<p><strong>ResponseEntity</strong>(将Java数据转化为响应报文)。</p>
<p>两个请求用的少，因为请求就可以随便获取。</p>
<p>黑体的两个响应用的多，因为将Java转换为响应报文，用起来会很方便。</p>
<h2 id="1-RequestBody"><a href="#1-RequestBody" class="headerlink" title="1. @RequestBody"></a>1. @RequestBody</h2><p>@RequestBody可以获取请求体，需要在控制器方式设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testRequestBody&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestBody&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestBody</span><span class="params">(<span class="meta">@RequestBody</span> String requestBody)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody: &quot;</span> + requestBody);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220219163030353.png" alt="image-20220219163030353"></p>
<h2 id="2-RequestEntity"><a href="#2-RequestEntity" class="headerlink" title="2. RequestEntity"></a>2. RequestEntity</h2><p>RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders( )获取请求头信息，通过getBody( )获取请求体信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestEntity&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestEntity</span><span class="params">(RequestEntity&lt;String&gt; requestEntity)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestHeader: &quot;</span> + requestEntity.getHeaders());</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody: &quot;</span> + requestEntity.getBody());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/02/19/V3SJZAkdEe45aFb.png" alt="image-20220219170728090"></p>
<h2 id="3-ResponseBody"><a href="#3-ResponseBody" class="headerlink" title="3. @ResponseBody"></a>3. @ResponseBody</h2><p>@RequestBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseBody&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testResponseBody</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若不加注解，则返回的是视图名称；</p>
<p>加上注解之后，返回的是响应体的内容success。</p>
<p><img src="https://s2.loli.net/2022/02/19/nvm8gT4BW37z1US.png" alt="image-20220219172826712"></p>
<h2 id="4-SpringMVC处理Json"><a href="#4-SpringMVC处理Json" class="headerlink" title="4. SpringMVC处理Json"></a>4. SpringMVC处理Json</h2><p>到目前为止都只能return一个(字符串)文本内容，因为浏览器只能接收服务器传过来的字符串内容，它不认识Java对象，也不知道服务器用的什么语言。这是因为Http协议为服务器和浏览器之间制定了一个统一的通信规范，跟浏览器和服务器语言无关，只要按照要求传输请求报文和响应报文就可以实现通信，故而这也导致浏览器并不清楚服务器的处理方式。</p>
<p>此时，如果传输对象(例如user)的话，会：</p>
<p><img src="https://s2.loli.net/2022/02/19/kuEdqOGUeigb8LQ.png" alt="image-20220219214430230"></p>
<p>为了实现顺利传输，使用json。</p>
<p>JSON是一种数据交互格式。</p>
<h3 id="1-引入jackson依赖"><a href="#1-引入jackson依赖" class="headerlink" title="1. 引入jackson依赖"></a>1. 引入jackson依赖</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.12</span><span class="number">.5</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/02/19/Dxa8i2qvmybwGlH.png" alt="image-20220219214859189"></p>
<p>此时user对象转换为json时，转换的是json对象(最外层是{ }，数组(最外层是[ ]))。</p>
<h3 id="2-开启mvc的注解驱动"><a href="#2-开启mvc的注解驱动" class="headerlink" title="2. 开启mvc的注解驱动"></a>2. 开启mvc的注解驱动</h3><p>在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJacksonHttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-ResponseBody注解"><a href="#3-ResponseBody注解" class="headerlink" title="3. @ResponseBody注解"></a>3. @ResponseBody注解</h3><h3 id="4-Java对象作为返回值"><a href="#4-Java对象作为返回值" class="headerlink" title="4. Java对象作为返回值"></a>4. Java对象作为返回值</h3><p>将Java对象直接作为控制器方法的返回值返回，就会自动转换为<strong>Json格式的字符串</strong></p>
<p><img src="https://s2.loli.net/2022/02/19/sDKpjTU6SOZ7kJd.png" alt="image-20220219215721022"></p>
<p>Json对象是放在{ }中，以键值对的方式存储；实体类、Map转换为Json之后，是Json对象。</p>
<p>Json数组是放在[ ]中，存储的是一个一个数据。 List集合是Json数组。</p>
<h2 id="5-SpringMVC处理Ajax"><a href="#5-SpringMVC处理Ajax" class="headerlink" title="5. SpringMVC处理Ajax"></a>5. SpringMVC处理Ajax</h2><p>Ajax本身就是页面不刷新，与服务器交互。所以现在在服务器中不能使用转发和重定向，只能响应浏览器数据。</p>
<p>通过超链接绑定Ajax，但是超链接有默认行为，所以要使用vue来取消。</p>
<p>服务器响应浏览器数据，就是在当前的方法上加上@ResponseBody，将返回的内容变成响应体。</p>
<h3 id="1-发送请求的超链接"><a href="#1-发送请求的超链接" class="headerlink" title="1. 发送请求的超链接"></a>1. 发送请求的超链接</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;testAxios&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testAxios&#125;&quot;</span>&gt;</span>SpringMVC处理ajax<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-通过vue和axios处理点击事件"><a href="#2-通过vue和axios处理点击事件" class="headerlink" title="2. 通过vue和axios处理点击事件"></a>2. 通过vue和axios处理点击事件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/axios.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">testAxios</span>:<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">url</span>:event.<span class="property">target</span>.<span class="property">href</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">params</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">username</span>:<span class="string">&quot;admin&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">password</span>:<span class="string">&quot;123456&quot;</span></span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">alert</span>(response.<span class="property">data</span>)</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">                event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-控制器方法"><a href="#3-控制器方法" class="headerlink" title="3. 控制器方法"></a>3. 控制器方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testAxios&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAxios</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">    System.out.println(username +<span class="string">&quot;,&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello, axios&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-RestController注解"><a href="#6-RestController注解" class="headerlink" title="6. @RestController注解(*)"></a>6. @RestController注解(*)</h2><p>@RestController注解是SpringMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每一个方法增加了@RequestBody注解。</p>
<h2 id="7-ResponseEntity"><a href="#7-ResponseEntity" class="headerlink" title="7. ResponseEntity"></a>7. ResponseEntity</h2><p>ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是相应到浏览器的响应报文。</p>
<p>用于实现文件上传和下载。</p>
<h1 id="十、文件的上传和下载"><a href="#十、文件的上传和下载" class="headerlink" title="十、文件的上传和下载"></a>十、文件的上传和下载</h1><h2 id="1-文件下载"><a href="#1-文件下载" class="headerlink" title="1. 文件下载"></a>1. 文件下载</h2><p>使用ResponseEntity实现下载文件的功能</p>
<p>实现，自定义响应报文来响应浏览器</p>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>根据在工程中的相对路径，获取文件在服务器中的绝对路径</li>
<li>创建输入流，将文件放入输入流</li>
<li>从输入流读文件进入字节数组</li>
<li>将字节数组中的数据，作为响应报文的响应体</li>
<li>创建响应头HttpHeaders()和响应状态码HttpStatus</li>
<li>将以上三部分，放入后构造器方法，创建ResponseEntity对象</li>
<li>关闭输入流</li>
<li>返回ResponseEntity对象作为响应报文</li>
</ol>
<p>inputStream.available()； headers.add(“Content-Disposition”, “attachment;filename=cherry.jpg”);</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- file.html --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 从服务器将文件下载到客户端；将文件上传到服务器中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testDown&#125;&quot;</span>&gt;</span>下载cherry<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUpAndDownController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testDown&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;<span class="type">byte</span>[]&gt; testResponseEntity(HttpSession session) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取ServletContext对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">        <span class="comment">// getRealPath()获取服务器中的工程部署路径，从而获取服务器中文件的真实路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;/static/img/cherry.jpg&quot;</span>);</span><br><span class="line">        System.out.println(realPath);</span><br><span class="line">        <span class="comment">// 文件复制就是先读后写</span></span><br><span class="line">        <span class="comment">// 创建输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath);</span><br><span class="line">        <span class="comment">// 获取字节数组，输入流所对应的文件的所有字节，假如文件里有100个字节，那就是available方法的值就是100。</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[inputStream.available()];</span><br><span class="line">        <span class="comment">// 将流读到字节数组中</span></span><br><span class="line">        inputStream.read(bytes);</span><br><span class="line">        <span class="comment">// 将响应的内容byte数组(响应体)转化为ResponseEntity</span></span><br><span class="line">        <span class="comment">// 创建HttpHeaders对象设置响应头信息</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; headers = <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        <span class="comment">// 设置要下载的方式(attachment:以附件的形式下载)和文件名称(整个语句，只能改文件名称)</span></span><br><span class="line">        headers.add(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=cherry.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置响应状态码为200</span></span><br><span class="line">        <span class="type">HttpStatus</span> <span class="variable">statusCode</span> <span class="operator">=</span> HttpStatus.OK;</span><br><span class="line">        <span class="comment">// 创建ResponseEntity对象</span></span><br><span class="line">        ResponseEntity&lt;<span class="type">byte</span>[]&gt; responseEntity = <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(bytes, headers, statusCode);</span><br><span class="line">        <span class="comment">// 关闭输入流</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        <span class="keyword">return</span> responseEntity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-文件上传"><a href="#2-文件上传" class="headerlink" title="2. 文件上传"></a>2. 文件上传</h2><p>上传按照二进制方式，而不是name=value的映射方式。</p>
<p>post和multi-…一个都不能少，否则会完成不了上传。</p>
<p>显示一个按钮，点击后可以去选择文件。</p>
<p>获取表单属性的name元素值。</p>
<p>当前文件的名字</p>
<p>覆盖的是文件里的内容，当两个文件同名，后者将前者文件里的内容进行了覆盖。</p>
<p><img src="https://s2.loli.net/2022/02/21/hjz9eRDUJQKoY2E.png" alt="image-20220221001840497"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testUp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testUp</span><span class="params">(MultipartFile photo, HttpSession session)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    <span class="comment">// 放置上传文件的文件夹在服务器中的绝对路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">photoPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;photo&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(photoPath);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        file.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> photo.getOriginalFilename();</span><br><span class="line">    <span class="comment">// 获取文件的后缀名，如.jpg</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">suffixName</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="comment">// 随机生成一个文件名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// 组装成一个带有后缀的真正文件名</span></span><br><span class="line">    fileName = uuid + suffixName;</span><br><span class="line">    <span class="comment">// 生成文件的绝对路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">finalPath</span> <span class="operator">=</span> photoPath + File.separator + fileName;</span><br><span class="line">    <span class="comment">// MultipartFile中封装的上传文件的方法</span></span><br><span class="line">    photo.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(finalPath));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十一、拦截器"><a href="#十一、拦截器" class="headerlink" title="十一、拦截器"></a>十一、拦截器</h1><h2 id="1-拦截器的配置"><a href="#1-拦截器的配置" class="headerlink" title="1. 拦截器的配置"></a>1. 拦截器的配置</h2><p>SpringMVC中的拦截器用于拦截控制方法的执行。(Controller方法，也叫Handler方法，也就是处理器方法，</p>
<p>SpringMVC中的拦截器需要实现HandlerInterceptor。</p>
<p>SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当前的拦截器就是FirstInterceptor对象 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对所有的请求进行拦截，使用ref bean也是如此 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;bean class=&quot;com.test.interceptors.FirstInterceptor&quot;&gt;&lt;/bean&gt; </span></span><br><span class="line"><span class="comment">		&lt;ref bean==&quot;firstInterceptor&quot;&gt;&lt;/ref&gt; </span></span><br><span class="line"><span class="comment">		拦截DispatcherServlet中配置的所有请求(因为如果没有控制器方法的话，拦不了)</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">			在拦截器中，/**表示的才是所有请求，/*表示的仅是上下文路径下的第一层目录，如/index之类的 </span></span><br><span class="line"><span class="comment">			排除了访问首页的请求</span></span><br><span class="line"><span class="comment">			设置拦截器为FirstInterceptor类的对象(FirstInterceptor要加注解，注册成为IOC容器中的对象)</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	以上配置方法可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<p>doFilter：调用下一个过滤器，其实就是放行的意思。</p>
<h2 id="2-拦截器的三个抽象方法"><a href="#2-拦截器的三个抽象方法" class="headerlink" title="2. 拦截器的三个抽象方法"></a>2. 拦截器的三个抽象方法</h2><p>SpringMVC中的拦截器有三个抽象方法：</p>
<p>preHandler：控制器方法执行之前执行preHandler( )，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法</p>
<p>postHandler：控制器方法执行之后执行postHandler( )</p>
<p>afterCompletion：处理完视图和模型数据，将模型填充完视图(就是将ModelAndView中的Model填充到View中之后)，即渲染完视图之后执行afterCompletion( )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册成为IOC容器中的对象</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;First Handler --&gt; preHandler&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;First Handler --&gt; postHandler&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;First Handler --&gt; afterCompletion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/04/y6sGFKnoAuwiC5g.png" alt="image-20220304211303104"></p>
<h3 id="3-多个拦截器的执行顺序"><a href="#3-多个拦截器的执行顺序" class="headerlink" title="3. 多个拦截器的执行顺序"></a>3. 多个拦截器的执行顺序</h3><h4 id="1-若每个拦截器的preHandle-都返回true"><a href="#1-若每个拦截器的preHandle-都返回true" class="headerlink" title="1. 若每个拦截器的preHandle()都返回true"></a>1. 若每个拦截器的preHandle()都返回true</h4><p>preHandler：按照配置的顺序执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.interceptorList.size() - <span class="number">1</span>; i++)</span><br></pre></td></tr></table></figure>
<p>postHandler和afterCompletion：按照配置的反序执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.size() - <span class="number">1</span>; i &gt;=<span class="number">0</span> ; i--)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/05/fRGnkNeWdjrybtp.png" alt="image-20220305161717406"></p>
<p><img src="https://s2.loli.net/2022/03/05/vKESaZ7xAf8ib9J.png" alt="image-20220305170713313"></p>
<p><img src="https://s2.loli.net/2022/03/05/tEf9o2JpMOPWSs1.png" alt="image-20220305170926324"></p>
<h4 id="2-若某个拦截器的preHandler-返回了false"><a href="#2-若某个拦截器的preHandler-返回了false" class="headerlink" title="2. 若某个拦截器的preHandler()返回了false"></a>2. 若某个拦截器的preHandler()返回了false</h4><p>preHandle( )返回false和它之前的拦截器的preHandle( )都会执行，postHandle( )都不执行，返回false的拦截器之前的拦截器的afterCompletion( )会执行。</p>
<p><img src="https://s2.loli.net/2022/03/05/pD5AYMTGyLSO9HP.png" alt="image-20220305173638365"></p>
<p>因为一旦preHandle返回了false，那么方法会直接return，即其下的所有语句都不会执行(包括postHandle( )和afterCompletion( ))。</p>
<p><img src="https://s2.loli.net/2022/03/05/6OqsKRAnFB3l9uI.png" alt="image-20220305173800001"></p>
<h1 id="十二、异常处理器"><a href="#十二、异常处理器" class="headerlink" title="十二、异常处理器"></a>十二、异常处理器</h1><h2 id="1-基于配置的异常处理"><a href="#1-基于配置的异常处理" class="headerlink" title="1. 基于配置的异常处理"></a>1. 基于配置的异常处理</h2><p>SpringMVC提供了一个处理控制器方法过程中所出现的异常的接口：HandlerExceptionResolver</p>
<p>该接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver(用于自定义异常处理)。</p>
<p>使用方式：</p>
<p>exceptionAttribute: 存储当前的异常信息，默认将其保存在当前请求域中，以value为该异常信息的键。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置异常处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">				properties的键表示处理器方法执行过程中出现的异常</span></span><br><span class="line"><span class="comment">				properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面</span></span><br><span class="line"><span class="comment">			--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ArithmeticException&quot;</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">		exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享。</span></span><br><span class="line"><span class="comment">		设置将异常信息共享在请求域中的键value，可以在请求域中获取异常信息</span></span><br><span class="line"><span class="comment"> 	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/05/hK6PRFvd97aOzok.png" alt="image-20220305193514369"></p>
<h2 id="2-基于注解的异常处理"><a href="#2-基于注解的异常处理" class="headerlink" title="2. 基于注解的异常处理"></a>2. 基于注解的异常处理</h2><p>此时就不需要在SpringMVC中进行配置了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有将类标识为组件的功能</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value=&#123;ArithmeticException.class, NullPointerException.class&#125;)</span></span><br><span class="line">    <span class="comment">// 这里的Exception指的是当前的出现异常，设置Model是为了将异常放到请求域中</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testException</span><span class="params">(Exception ex, Model model)</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;ex&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十三、-注解配置SpringMVC"><a href="#十三、-注解配置SpringMVC" class="headerlink" title="十三、 注解配置SpringMVC"></a>十三、 注解配置SpringMVC</h1><p>使用配置类和注解代替web.xml和SpringMVC配置文件的功能</p>
<h2 id="1-创建初始化类，代替web-xml"><a href="#1-创建初始化类，代替web-xml" class="headerlink" title="1. 创建初始化类，代替web.xml"></a>1. 创建初始化类，代替web.xml</h2><p>在Servlet3.0的环境中，容器会在类路径中查找实现Javax.servlet.ServletContainerInitializer接口的类，如果找到的话，就用它来配置servlet容器。</p>
<p>Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。</p>
<p>当我们的类拓展了AbstractAnnotationConfigDispatcherServletInitializer(WebApplicationInitializer的一个基础实现)并将其部署到<strong>Servlet3.0容器</strong>的时候，容器会自动发现它，并用它来配置上下文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebInit</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc: 指定Spring的配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Class&lt;?&gt;[]&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/5 21:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="comment">// 返回配置类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc: 指定SpringMVC的配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Class&lt;?&gt;[]&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/5 21:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="comment">// 这个类要有</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc:指定DispatcherServlet的映射规则，即url-pattern</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Class&lt;?&gt;[]&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/5 21:13</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc: 注册过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Filter[]&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/5 21:25</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">characterEncodingFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        characterEncodingFilter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        characterEncodingFilter.setForceRequestEncoding(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">HiddenHttpMethodFilter</span> <span class="variable">hiddenHttpMethodFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HiddenHttpMethodFilter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;characterEncodingFilter, hiddenHttpMethodFilter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-配置WebConfig类，代替SpringMVC-xml"><a href="#2-配置WebConfig类，代替SpringMVC-xml" class="headerlink" title="2. 配置WebConfig类，代替SpringMVC.xml"></a>2. 配置WebConfig类，代替SpringMVC.xml</h2><h3 id="视图解析器部分"><a href="#视图解析器部分" class="headerlink" title="视图解析器部分"></a>视图解析器部分</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> WebConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 代替SpringMVC的配置文件</span></span><br><span class="line"><span class="comment"> * 1. 扫描组件 2.视图解析器 3.view-controller 4.default-servlet-handler 5.mvc注解驱动</span></span><br><span class="line"><span class="comment"> * 6.文件上传解析器 7.异常处理 8.拦截器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/03/2022/3/5 21:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 扫描组件</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="comment">// mvc注解驱动</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc: 生成模板解析器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> org.thymeleaf.templateresolver.ITemplateResolver&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/5 21:42</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ITemplateResolver <span class="title function_">templateResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">WebApplicationContext</span> <span class="variable">webApplicationContext</span> <span class="operator">=</span></span><br><span class="line">                ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">templateResolver</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(</span><br><span class="line">                        webApplicationContext.getServletContext());</span><br><span class="line">        templateResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        templateResolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> templateResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc: 生成模板引擎并为其注入模板解析器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> templateResolver</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> SpringTemplateEngine&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/5 21:41</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SpringTemplateEngine <span class="title function_">templateEngine</span><span class="params">(ITemplateResolver templateResolver)</span> &#123;</span><br><span class="line">        <span class="type">SpringTemplateEngine</span> <span class="variable">templateEngine</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SpringTemplateEngine</span>();</span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> templateEngine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc: 生成视图解析器并将解析器注入模板引擎</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> templateEngine</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> ViewResolver&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/5 21:40</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ViewResolver <span class="title function_">viewResolver</span><span class="params">(SpringTemplateEngine templateEngine)</span> &#123;</span><br><span class="line">        <span class="type">ThymeleafViewResolver</span> <span class="variable">viewResolver</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThymeleafViewResolver</span>();</span><br><span class="line">        viewResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        viewResolver.setTemplateEngine(templateEngine);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>整体的步骤可以根据之前配置的SpringMVC.xml文件中的视图解析器的配置得到。</p>
<p>由其中代码可得：最外部的Thymeleaf视图解析器，其中按照内部bean的方式，配置了一个SpringTemplate-Engine的属性，而对于这个SpringTemplateEngine，其中又以内部bean的方式配置了一个ITemplateResolver的属性。则可得，想要完成这个视图解析器，需要一一将内部的属性给表示出来，并注册到IOC容器中，使属性成为一个可以给参数赋值的bean。</p>
<h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>@Bean这个注解，加上之后，当前方法的返回值就是IOC的一个bean。</li>
</ol>
<p>​        当前创建的IOC容器，如果是Java工程，就是一个ApplicationContext，如果当前工程是一个web环境，就是WebApplicationContext。</p>
<ol>
<li><p>方法中的参数，都是通过自动装配的方式，进行赋值的，这就要求能够使用的参数，必须是当前Spring的IOC容器中已经拥有的bean，可以为该参数赋值的情况下。(当前方法中的参数，必须要符合自动装配的规则，否则会报错，提示could not autowire…)</p>
</li>
<li><p>通过set方法对内部属性进行赋值(自动装配，在Spring中，必须要有set方法，才能在配置文件中进行属性赋值)。</p>
</li>
</ol>
<h3 id="剩余部分"><a href="#剩余部分" class="headerlink" title="剩余部分"></a>剩余部分</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc: 4. default-servlet-handler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> configurer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/7 20:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">    configurer.enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc: 8. 拦截器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/7 20:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    <span class="type">TestInterceptor</span> <span class="variable">testInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestInterceptor</span>();</span><br><span class="line">    registry.addInterceptor(testInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc: 3. view-controller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/7 20:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">    registry.addViewController(<span class="string">&quot;/hello&quot;</span>).setViewName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc: 6. 文件上传解析器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> MultipartResolver&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/7 20:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MultipartResolver <span class="title function_">multipartResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">CommonsMultipartResolver</span> <span class="variable">commonsMultipartResolver</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CommonsMultipartResolver</span>();</span><br><span class="line">    <span class="keyword">return</span> commonsMultipartResolver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc: 7. 异常处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resolvers</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/7 20:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; resolvers)</span> &#123;</span><br><span class="line">    <span class="type">SimpleMappingExceptionResolver</span> <span class="variable">exceptionResolver</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SimpleMappingExceptionResolver</span>();</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    properties.setProperty(<span class="string">&quot;java.lang.ArithmeticException&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    exceptionResolver.setExceptionMappings(properties);</span><br><span class="line">    exceptionResolver.setExceptionAttribute(<span class="string">&quot;exception&quot;</span>);</span><br><span class="line">    resolvers.add(exceptionResolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><p>大部分是通过实现接口WebMvcConfigurer提供的方法。</p>
<p>其中的文件上传解析器，是根据SpringMVC.xml中的配置(只需一个bean标签即可)，自行构造一个Multipart-Resolver接口的实现类commonsMultipartResolver的对象后，将其通过@Bean注解注册到IOC容器中成为一个bean的。</p>
<p>至于其他部分，直接根据待实现的方法，构造参数即可。需要注意的是异常处理的方法。</p>
<h5 id="异常处理部分"><a href="#异常处理部分" class="headerlink" title="异常处理部分"></a>异常处理部分</h5><p>首先它的参数是一个List</p>
<p>其次，这一部分在配置文件中，设置了props标签，所以需要在方法中设置properties这一属性。</p>
<p>而后，由于properties操作属性集properties文件，该文件中存储的键和值都只能是字符串，所以说在操作属性集文件时，不能使用get和set方法，而要使用专门提供的setProperty( )方法。</p>
<h1 id="十四、SpringMVC执行流程"><a href="#十四、SpringMVC执行流程" class="headerlink" title="十四、SpringMVC执行流程"></a>十四、SpringMVC执行流程</h1><h2 id="1-SpringMVC常用组件"><a href="#1-SpringMVC常用组件" class="headerlink" title="1. SpringMVC常用组件"></a>1. SpringMVC常用组件</h2><h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><p>前端控制器，不需要工程师开发，由框架提供。</p>
<p>作用：统一处理请求和响应，是整个流程控制的中心，由他调用其他组件处理用户的请求。</p>
<h3 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h3><p>处理器映射器，不需要工程师开发，由框架提供</p>
<p>作用：根据请求的url、method等信息查找Handler，即控制器方法</p>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>处理器(控制器)，需要工程师开发</p>
<p>作用：在DispatcherServlet的控制下，针对具体的用户请求进行处理</p>
<h3 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h3><p>处理器适配器，不需要工程师开发，由框架提供</p>
<p>作用：通过HandlerAdapter对处理器进行执行</p>
<h3 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h3><p>视图解析器，不需要工程师开发，由框架提供</p>
<p>作用：进行视图解析，得到相应的视图，如ThymeleafView、InternalResourceView、RedirectView</p>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>视图，需要进行页面设置</p>
<p>作用：将模型数据通过页面展示给用户</p>
<h2 id="2-DispatcherServlet初始化过程"><a href="#2-DispatcherServlet初始化过程" class="headerlink" title="2. DispatcherServlet初始化过程"></a>2. DispatcherServlet初始化过程</h2><p>本质上是一个Servlet，所以遵循Servlet的生命周期，所以宏观上是Servlet生命周期来进行调度。</p>
<p><img src="https://s2.loli.net/2022/03/07/6sl8LdIiEZYab9v.png" alt="image-20220307215703655"></p>
<p><img src="https://s2.loli.net/2022/03/07/VphscB7t1LewbrH.png" alt="image-20220307215730504"></p>
<p>Spring的IOC容器为父容器，而SpringMVC的IOC为子容器</p>
<p>FrameworkServlet创建WebApplicationContext后，需要刷新容器，即调用onRefresh(wac)方法(FrameworkServlet中，没有该方法的方法体)。此方法在DispatcherServlet中进行了重写，调用了InitStrategies(context)方法，即初始化策略，初始化DispatcherServlet的各个组件。</p>
<p><img src="https://s2.loli.net/2022/03/07/H5UfF4STskA73tp.png" alt="image-20220307221416187"></p>
<h2 id="3-DispatcherServlet调用组件处理请求"><a href="#3-DispatcherServlet调用组件处理请求" class="headerlink" title="3. DispatcherServlet调用组件处理请求"></a>3. DispatcherServlet调用组件处理请求</h2><h3 id="1-processRequest"><a href="#1-processRequest" class="headerlink" title="1. processRequest()"></a>1. processRequest()</h3><p>向下转型</p>
<h2 id="4-SpringMVC的执行流程"><a href="#4-SpringMVC的执行流程" class="headerlink" title="4. SpringMVC的执行流程"></a>4. SpringMVC的执行流程</h2><ol>
<li>用户向服务器发送请求，请求被SpringMVC前端控制器DispatcherServlet捕获。</li>
<li>DispatcherServlet对请求URL进行解析，得到请求资源标识符(URI)，判断请求URI对应的映射：<ol>
<li>不存在<ol>
<li>再判断是否配置了mvc:default-servlet-handler</li>
<li>如果没配置，则控制台报映射查找不到，客户端展示404错误</li>
<li>如果有配置，则访问目标资源(一般为静态资源，如JS、CSS、HTML)，找不到的话，客户端也会展示404错误</li>
</ol>
</li>
<li>存在则执行下面的流程<ol>
<li>根据该URI，调用HandlerMapping获得该Handler配置的所有相关对象(控制器方法、拦截器集合、拦截器索引)，最后以HandlerExecutionChain执行链对象的形式返回。</li>
<li>DispatcherServlet根据获得的Handler，选择一个合适的HandlerAdapter。</li>
<li>如果成功获得，此时开始执行拦截器的preHandler方法</li>
<li>提取Request中的模型数据，填充Handler入参，开始执行Handler(Controller)方法，处理请求。在填充Handler的入参过程中，根据配置，Spring将：<ol>
<li>HttpMessageConveter：将请求消息(如Json、xml等数据)转换成一个对象，将对象转换成指定的响应信息</li>
<li>数据转换：对请求消息进行数据转换，如String转换成Integer等</li>
<li>数据格式化：对请求消息进行数据格式化，如将字符串转换成格式化数字或格式化日期等</li>
<li>数据验证：验证数据的有效性(长度、格式)，验证结果存储到BindingResult或Error中</li>
<li>Handler执行完成后，向DispatcherServlet返回一个ModelAndView对象</li>
<li>此时将开始执行拦截器的postHandler()方法</li>
<li>根据返回的ModelAndView(此时判断是否存在异常，若存在，则执行HandlerExceptionResolver进行异常处理)，选择合适的ViewResolver视图解析器进行视图解析，根据Model和View来渲染视图。</li>
<li>渲染视图完毕，执行拦截器的afterCompletion()方法</li>
<li>将渲染结果返回给客户端。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="末章-补充信息"><a href="#末章-补充信息" class="headerlink" title="末章 补充信息"></a>末章 补充信息</h1><h2 id="1-ServletContext介绍"><a href="#1-ServletContext介绍" class="headerlink" title="1. ServletContext介绍"></a>1. ServletContext介绍</h2><h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>ServletContext官方叫servlet上下文。</p>
<p>服务器会为每一个工程创建一个对象，这个对象就是ServletContext对象。这个对象全局唯一，而且工程内部的所有servlet都共享这个对象。所以叫，<strong>全局应用程序共享对象</strong>。</p>
<p><img src="https://s2.loli.net/2022/02/20/XrfVwxHI28oMdFO.png" alt="image-20220220123848890"></p>
<h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h3><ul>
<li><p><strong>是一个域对象</strong></p>
</li>
<li><p>可以读取全局配置参数</p>
</li>
<li>可以搜索当前工程目录下面的资源文件</li>
</ul>
<h4 id="1-域对象"><a href="#1-域对象" class="headerlink" title="1. 域对象"></a>1. 域对象</h4><p>域对象是服务器在内存上创建的存储空间，用于在不同动态资源(servlet)之间传递与共享数据。</p>
<h4 id="2-域对象方法"><a href="#2-域对象方法" class="headerlink" title="2. 域对象方法"></a>2. 域对象方法</h4><p>凡是域对象都有如下3个方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>setAttribute(name, value);name为String类型，value是Object类型；</td>
<td>向域对象中添加数据，以key-value形式</td>
</tr>
<tr>
<td>getAttribute(name)；</td>
<td>根据指定的key读取域对象中的数据</td>
</tr>
<tr>
<td>removeAttribute(name);</td>
<td>根据指定的key从域对象中删除数据</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-存储特点"><a href="#3-存储特点" class="headerlink" title="3. 存储特点"></a>3. 存储特点</h4><p>servletContext中的数据，全局共享，所有的动态资源都可以写入和获取</p>
<p>服务器启动的时候创建，服务器关闭的时候销毁，因为这是全局应用程序对象，全局共享对象。</p>
<h4 id="4-可以读取全局配置参数"><a href="#4-可以读取全局配置参数" class="headerlink" title="4. 可以读取全局配置参数"></a>4. 可以读取全局配置参数</h4><p>servletContext读取全局参数的核心方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>getServletContext().getInitParameter(name);</td>
<td>根据指定的参数名获取参数值</td>
</tr>
<tr>
<td>getServletContext().getInitParameterNames();</td>
<td>获取所有参数名称列表</td>
</tr>
</tbody>
</table>
</div>
<p> <img src="https://s2.loli.net/2022/02/20/xKa1uY6ReSy3ft9.png" alt="image-20220220144024285"></p>
<h4 id="5-搜索工程下资源文件"><a href="#5-搜索工程下资源文件" class="headerlink" title="5. 搜索工程下资源文件"></a>5. 搜索工程下资源文件</h4><p>path：相对路径</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>getServletContext().getRealPath(path);</td>
<td>根据相对路径获取服务器上资源的绝对路径</td>
</tr>
<tr>
<td>getServletContext().getResourceAsStream(path);</td>
<td>根据相对路径获取服务器上资源的输入字节流</td>
</tr>
</tbody>
</table>
</div>
<h4 id="6-获取当前工程名字"><a href="#6-获取当前工程名字" class="headerlink" title="6. 获取当前工程名字"></a>6. 获取当前工程名字</h4><p>getServletContext().getContextPath()：获取当前工程名字</p>
<h2 id="2-Servlet三大域对象"><a href="#2-Servlet三大域对象" class="headerlink" title="2. Servlet三大域对象"></a>2. Servlet三大域对象</h2><p>域对象的作用：保存数据、获取数据、共享数据。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>对象名称</th>
<th>对象的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>HttpServletRequest</td>
</tr>
<tr>
<td>session</td>
<td>HttpSession</td>
</tr>
<tr>
<td>application</td>
<td>ServletContext</td>
</tr>
</tbody>
</table>
</div>
<h3 id="1-request"><a href="#1-request" class="headerlink" title="1. request"></a>1. request</h3><p>创建：客户端向服务器发送一次请求，服务器就会创建request对象</p>
<p>销毁：服务器对这次请求做出响应之后就会销毁request对象</p>
<p>有效：仅在当前请求中有效</p>
<p>方法：request.getParameter(); request.setAttribute()。</p>
<h3 id="2-session"><a href="#2-session" class="headerlink" title="2. session"></a>2. session</h3><p>创建：服务器端第一次调用getSession()；(保存在服务器内存中)</p>
<p>销毁：</p>
<ul>
<li>非正常关闭服务器(正常关闭session会序列化，再次启动session会被反序列化)</li>
<li>session过期(Tomcat中为30分钟)</li>
<li>手动调用session.invalidate();</li>
</ul>
<p>有效：从用户打开浏览器会话开始，直到关闭浏览器会话结束。一次会话只创建一个session对象。</p>
<p>方法：(String) request.getSession().getAttribute(“imageMsg”); </p>
<p>request.getSession().setAttribute(“user”, user)；</p>
<h3 id="3-application"><a href="#3-application" class="headerlink" title="3. application"></a>3. application</h3><p>创建：服务器启动时，为每个web应用创建一个属于该项目的对象ServletContext类；</p>
<p>销毁：服务器关闭或项目从服务器中移除的时候</p>
<p>有效：此信息在整个服务器上被保留</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><img src="https://s2.loli.net/2022/02/20/HAfMwiCgpSoX1nO.png" alt="image-20220220145904822"></p>
<h3 id="附：pageContext-jsp"><a href="#附：pageContext-jsp" class="headerlink" title="附：pageContext(jsp)"></a>附：pageContext(jsp)</h3><p>对象类型：pageContext</p>
<p>有效范围最小。</p>
<p>当前页面有效，超过这个页面就不能使用。</p>
<h2 id="3-相关的配置"><a href="#3-相关的配置" class="headerlink" title="3. 相关的配置"></a>3. 相关的配置</h2><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>TestMaven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringMVC-demo6<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringMVC --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- ServletAPI --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 表示当前的服务器中已经提供了servlet-api，不会存在于整合后的war包中 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Spring5和Thymeleaf整合包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceRequestEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>ContextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="springMVC-xml"><a href="#springMVC-xml" class="headerlink" title="springMVC.xml"></a>springMVC.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 视图解析的优先级 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateEngine&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateResolver&quot;</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 解析策略 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 视图前缀 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 视图后缀 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HTML5&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 视图控制器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;index&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启mvc的注解驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartFile&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 配置拦截器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当前的拦截器就是FirstInterceptor对象 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 对所有的请求进行拦截，使用ref bean也是如此 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;bean class=&quot;com.test.interceptors.FirstInterceptor&quot;&gt;&lt;/bean&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置异常处理器</span></span><br><span class="line"><span class="comment">    &lt;bean name=&quot;exceptionResolver&quot; class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;exceptionMappings&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;props&gt;</span></span><br><span class="line"><span class="comment">                &lt;prop key=&quot;java.lang.ArithmeticException&quot;&gt;error&lt;/prop&gt;</span></span><br><span class="line"><span class="comment">            &lt;/props&gt;</span></span><br><span class="line"><span class="comment">        &lt;/property&gt;</span></span><br><span class="line"><span class="comment">        设置将异常信息共享在请求域中的键，在请求域中获取异常信息</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">    &lt;/bean&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="打包方式1"><a href="#打包方式1" class="headerlink" title="打包方式1"></a>打包方式1</h3><p><img src="https://s2.loli.net/2022/04/03/S9wqUtgkACyWMJp.png" alt="image-20220403160602247"></p>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>cache</title>
    <url>/2021/10/31/cache/</url>
    <content><![CDATA[<h1 id="cache存储器"><a href="#cache存储器" class="headerlink" title="cache存储器"></a>cache存储器</h1><h2 id="一-背景"><a href="#一-背景" class="headerlink" title="一  背景"></a>一  背景</h2><p>在计算机系统中，CPU的工作速度远超主存储器的工作速度。一方面，因为高速的静态存储器芯片因为容量小且价格高，并不适合组成大容量的主存储器，故而主存储器一般采用动态存储器实现。但由于其读取速度慢，一定程度上限制了CPU的工作速度。另一方面，通过大量统计发现，程序对存储空间的90%的访问局限于存储空间10%的区域，另外10%的访问则分布在存储空间的90%的区域中。</p>
<p>所谓，时势造英雄。为了中和CPU和主存之间速度的不匹配，诞生了cache这一重要的技术。</p>
<h2 id="二-简介"><a href="#二-简介" class="headerlink" title="二  简介"></a>二  简介</h2><h3 id="1-功能"><a href="#1-功能" class="headerlink" title="1  功能"></a>1  功能</h3><p>cache是介于CPU和主存之间的小容量存储器，存取速度比主存块。它能高速地向CPU提供指令和数据，加快程序的执行速度。它的内容为主存一部分内容的副本。当储存器收到读取指令时，先在cache中查找此信息是否存在，若有，则不经主存，直接从cache中取出，否则直接从主存中取出，同时写出cache，以备再次使用。</p>
<h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2  原理"></a>2  原理</h3><p>CPU与cache之间的数据交换是==以字为单位==，而cache与主存之间的数据交换是==以块为单位==。一个块由若干定长字组成。当CPU读取主存中的一个字时，便发出<strong>此字的地址到cache和主存</strong>。此时cache控制逻辑，依据地址判断此字是否在cache中，若是，此字立即传送给CPU；若非，则用主存读周期把此字从主存读出送到CPU，与此同时，把含有这个字的<strong>整个数据块</strong>从主存读出送到cache中。</p>
<h3 id="3-工作过程"><a href="#3-工作过程" class="headerlink" title="3  工作过程"></a>3  工作过程</h3><p>1.当CPU执行访问指令时，将所要访问的字的地址送到相联存储器(cam)中和主存。</p>
<p>2.在相联存储器中进行地址查找，若相联存储器指出，所要访问的字W在cache中(命中)，则把W直接由cache送入CPU；反之(不命中)，则从主存中读取W，送入CPU，顺便把包含W在内的4个字(一个块)送入cache。(分配给cache的地址，保存在相联存储器(cam)中，它是按照内容寻址的。)</p>
<h3 id="4-cache的命中率"><a href="#4-cache的命中率" class="headerlink" title="4  cache的命中率"></a>4  cache的命中率</h3><p>增加cache的目的，就是在性能上使主存的平均读出时间尽可能接近cache的读出时间。因此，cache的命中率应接近于1。在一个程序执行期间，设Nc表示cache完成存取的次数，Nm表示主存完成存取的总次数，H定义为命中率，则有：</p>
<script type="math/tex; mode=display">
H=Nc/(Nc+Nm)</script><p>若tc表示命中时cache访问时间，tm表示未命中时的主存访问时间，则cache/贮存系统的平均访问时间ta为：</p>
<script type="math/tex; mode=display">
ta=tc*H+(1-H)*tm</script><script type="math/tex; mode=display">
r=tm/tc表示主存慢于cache的倍率，e=tc/ta表示访问效率</script><p>为提高访问效率，命中率H越接近于1越好，r值以5-10为宜，不宜过大。</p>
<p>注：</p>
<ul>
<li>命中率与程序的行为、cache的容量、组织方式、块的大小有关。</li>
<li>程序的行为：程序顺序执行最佳。</li>
<li>cache的容量：容量越大，可存放的部分复本越多，调进调出的动作少。</li>
<li>组织方式：cache与主存的相连方式影响调进调出的次数。</li>
<li>块的大小：块太小，块太大都影响调进调出的次数。</li>
</ul>
<h3 id="5-主存与cache的地址映射"><a href="#5-主存与cache的地址映射" class="headerlink" title="5  主存与cache的地址映射"></a>5  主存与cache的地址映射</h3><p>cache的容量很小，它保存的内容只是主存内容的一个子集，且cache与主存的数据交换是以块为单位。</p>
<p>地址映射即是应用某种方法把主存地址定位到cache中。地址映射的方式有<strong>全相联方式、直接映射方式和组相联方式三种。</strong></p>
<h4 id="1-全相联方式"><a href="#1-全相联方式" class="headerlink" title="1. 全相联方式"></a>1. 全相联方式</h4><p>主存中的一个<strong>块的地址与块的内容</strong>一起存于cache的行中，其中<strong>块地址存于cache行的标记部分</strong>中，是由于此种方式，<strong>内存中的块可以映射到cache任意一行中</strong>。块的大小 = 行的大小。</p>
<p><img src="https://s2.loli.net/2022/02/26/uOPmRoygLaAMlf3.png" alt="image-20220226230105281"></p>
<p>此处的含义其实是，主存一共有256行，用8位来表示主存中的块号。</p>
<p>因为，主存一行中256字，故而还需要一个8位来表示对应块的块内地址。</p>
<p>这就需要一块一块地进行比对，耗时。</p>
<p>由于其电路设计复杂，更多用于小容量cache。<img src="https://s2.loli.net/2021/12/22/dmGe41p2RknPCAt.png" alt="image-20211031151344855"></p>
<h4 id="2-直接映射方式"><a href="#2-直接映射方式" class="headerlink" title="2. 直接映射方式"></a>2. 直接映射方式</h4><p>这也是一种多对一的映射关系，但一个主存块只能拷贝到cache的一个特定行位置上去。</p>
<p>cache的行号i和主存的块号j有如下函数关系：</p>
<script type="math/tex; mode=display">
i=j (mod) m(m为cache的行数)</script><p><img src="https://s2.loli.net/2021/12/22/2AgZ6BmErHPQC1M.png" alt="image-20211031151518192"></p>
<p>注意比较的顺序，另外由于几个内存块对应同一行，容易发生空间冲突。适合于大容量cache。</p>
<h4 id="3-组相联映射"><a href="#3-组相联映射" class="headerlink" title="3.组相联映射"></a>3.组相联映射</h4><p>将cache分为u组，每组v行，主存块存放到哪个组是固定的(直接映射方式)，至于存放到该组哪一行，是灵活的(全相联映射方式)。</p>
<p><img src="https://s2.loli.net/2021/12/22/btAswxjhvFGR92y.png" alt="image-20211031152253327"></p>
<p>注意比较的顺序。</p>
<h3 id="6-替换策略"><a href="#6-替换策略" class="headerlink" title="6  替换策略"></a>6  替换策略</h3><p>cache的工作原理要求其尽可能保存最新的数据，则必然存在将有用的信息从主存调入cache，这样就产生替换。</p>
<blockquote>
<p><strong><em>针对直接映射的cache来说，因为其在cache中的位置是固定的，故而只需把特定位置上的原主存块换出cache即可，将新增信息调进即可。</em></strong></p>
</blockquote>
<p>对<strong>全相联和组相联的cache而言</strong>，就要从允许存放新主存块的若干特定行中选取一行换出，这就涉及到常用的替换算法了。</p>
<h4 id="1-最不长使用法-类似队列先进先出-："><a href="#1-最不长使用法-类似队列先进先出-：" class="headerlink" title="1.最不长使用法(类似队列先进先出)："></a>1.最不长使用法(类似队列先进先出)：</h4><p>将一段时间内，访问次数最少的那行数据换出。即每行设置一计数器，每访问一次，就增加一次计数，最后替换计数最小的一行。</p>
<h4 id="2-近期最少使用法-LRU"><a href="#2-近期最少使用法-LRU" class="headerlink" title="2.近期最少使用法(LRU):"></a>2.近期最少使用法(LRU):</h4><p>将近期长久未被访问过的那行数据换出。即每行设置一计数器，每访问一次，就将所访问者计数器清零，其他计数值加1，最后替换计数最大的一行(可用<em>标记许久未使用的行，<em>*常用</em></em>)。</p>
<h3 id="7-cache的写操作策略"><a href="#7-cache的写操作策略" class="headerlink" title="7  cache的写操作策略"></a>7  cache的写操作策略</h3><p>CPU对cache的写入，更改了cache的内容。为保持主存与cache中信息的一致性，避免CPU在读写过程中，将cache中的新数据遗失，造成错误的读数据，确保cache中数据不会因覆盖而消失，必须将cache中的数据更新及时反映到主存中。</p>
<p>可选用三种写操作策略，以使cache内容和主存内容保持一致。</p>
<h4 id="1-写回法-回写式"><a href="#1-写回法-回写式" class="headerlink" title="1.写回法(回写式)"></a>1.写回法(回写式)</h4><p>​    当CPU写cache命中时，只修改cache内容，而不立即写入内存，只有当此行(块)被换出时，才写回内存。</p>
<p>这种方法减少了CPU访问内存的次数，但存在内存不一致的隐患。</p>
<p>实现这种方法时，每一个cache须设置一个修改位，以反映此行是否被CPU修改过。(常用)</p>
<h4 id="2-全写法-直写式"><a href="#2-全写法-直写式" class="headerlink" title="2.全写法(直写式)"></a>2.全写法(直写式)</h4><p>​    当写cache命中时，cache与主存同时发生写修改，因而较好维护了cache与主存内容的一致性。</p>
<p>当写cache未命中时，直接向主存中写入。cache每行无需设置修改位以及相应的判断逻辑。此时可将修改内容调进cache中，也可不调进。</p>
<p>减弱了cache的效果。</p>
<h4 id="3-写一次法-缓冲直写式"><a href="#3-写一次法-缓冲直写式" class="headerlink" title="3.写一次法(缓冲直写式)"></a>3.写一次法(缓冲直写式)</h4><p>两种方法的结合。写命中与写未命中与写回法相同。只是第一次写命中时，会启动一个存储写周期，即同时写入主存，而其他cache块监听到此周期时，也顺便更新自身该数据块数据。便于维护系统中所有cache的一致性。(奔腾CPU采用)</p>
]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>github</title>
    <url>/2021/12/03/github/</url>
    <content><![CDATA[<blockquote>
<p>首先，喜事：终于成功把第一个小项目放到Github上去啦！</p>
<p>戳<a href="https://github.com/Phoenix-Nrvn/Ming">Phoenix-Nrvn/Ming (github.com)</a>即可访问</p>
</blockquote>
<h1 id="更新Github上的代码"><a href="#更新Github上的代码" class="headerlink" title="更新Github上的代码"></a>更新Github上的代码</h1><h2 id="一、克隆自己Github上的项目代码到本地"><a href="#一、克隆自己Github上的项目代码到本地" class="headerlink" title="一、克隆自己Github上的项目代码到本地"></a>一、克隆自己Github上的项目代码到本地</h2><p>原因嘛，Github上不能删除文件夹的，只能把项目拉到本地删除再更新</p>
<ol>
<li><p>首先随便创建一个文件夹(存放下载下来的代码)</p>
</li>
<li><p>输入指令克隆自己的代码</p>
<p><code>git clone https://github.com/用户名/仓库名.git</code></p>
</li>
</ol>
<h2 id="二、查看一下仓库状态"><a href="#二、查看一下仓库状态" class="headerlink" title="二、查看一下仓库状态"></a>二、查看一下仓库状态</h2><p><code>git status</code></p>
<p>注意要先切换到存储原来GitHub本地代码的位置，不是刚刚下载代码才建的文件夹。</p>
<h2 id="三、更新"><a href="#三、更新" class="headerlink" title="三、更新"></a>三、更新</h2><ol>
<li><p>直接在本地，把改好的文件替换原来的相应部分就好</p>
<p><code>git add *--表示更新全部</code></p>
</li>
<li><p>添加更新说明，commit只是将其提交到缓存区域</p>
<p><code>git commit -m &quot;update&quot;(可将update替换为别的内容)</code></p>
</li>
<li><p>上传</p>
<p><code>git push origin 分支名 --(若是多人同时开发维护，首先git pull，拉取当前分支最新代码)</code></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>A Good Day</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><p>即虚拟机与外界通讯时，要求与主机处于同一个网段。使用桥接模式，需要为虚拟机单独分配IP地址，但IP地址是有限的，会消耗资源，容易造成IP冲突。</p>
<h4 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h4><p>虚拟机分配的IP地址，不需要与主机在同一网段。而且设置后，主机会生成一个虚拟的网卡，在虚拟机和主机之间，建立联系互通，也可以跟外网通讯，且不造成IP冲突。其为网络地址转换模式。内网可以连接外网，但外网不能返回内网，因为内网可以通信，是因为地址转换，即通过了主机代理。</p>
<h4 id="主机模式"><a href="#主机模式" class="headerlink" title="主机模式"></a>主机模式</h4><p>即一个独立的系统，不和外部发生联系，想怎么配怎么配。</p>
]]></content>
  </entry>
  <entry>
    <title>实战Java高并发</title>
    <url>/2022/02/14/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="Chapter1-走入并向世界"><a href="#Chapter1-走入并向世界" class="headerlink" title="Chapter1 走入并向世界"></a>Chapter1 走入并向世界</h1><h2 id="1-一些概念"><a href="#1-一些概念" class="headerlink" title="1. 一些概念"></a>1. 一些概念</h2><h3 id="1-同步-Synchronous-和异步-Asynchronous"><a href="#1-同步-Synchronous-和异步-Asynchronous" class="headerlink" title="1. 同步(Synchronous)和异步(Asynchronous)"></a>1. 同步(Synchronous)和异步(Asynchronous)</h3><p>同步和异步通常用来形容一次方法的调用。</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>同步方法调用一旦开始，必须要等到方法调用结束返回后，才能继续后续的行为。(去现场买一个空调，要等商家调货，等买完之后回家，才能做别的事。)</p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>异步方法调用一旦开始，方法调用就会立即返回，调用者就可以进行后续的操作。而异步方法通常会在另一个线程中“真实地”执行，如果需要返回结果，调用结束后，会通知调用者。(在网上买一个空调，付完钱，就可以去做别的事，而商家则回去设计空调到达的过程。等空调到了之后，去签收即可。)</p>
<p><img src="https://s2.loli.net/2022/02/14/Zwo3rjEmqQFbRGB.png" alt="image-20220214225304471"></p>
<h3 id="2-并发-Concurrency-和并行-Parallelism"><a href="#2-并发-Concurrency-和并行-Parallelism" class="headerlink" title="2. 并发(Concurrency)和并行(Parallelism)"></a>2. 并发(Concurrency)和并行(Parallelism)</h3><p>并发和并行是两个非常容易被混淆的概念。他们都可以表示两个或多个任务一起执行，但偏重点不同。</p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>侧重于多个任务交替执行，而多个任务之间还有可能是串行的。</p>
<h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><p>则是真正意义上的”同时执行”。</p>
<p><img src="https://s2.loli.net/2022/02/14/ARdnbFXZYBPHs2r.png" alt="image-20220214225610517"></p>
<p>严格意义上来说，并行的多个任务是真实的同时执行。</p>
<p>而对于并发来说，这个过程只是交替的，一会儿运行任务A一会儿执行任务B，系统会不停地在两者间切换。但对于外部观察者来说，即使多个任务之间是串行并发的，也会造成多任务间是并行执行的错觉。</p>
<blockquote>
<p>由于并发的最终结果可能是和并行一眼的，因此，如果没有特别的需要，本书不会特别强调两者的区别。</p>
</blockquote>
<h3 id="3-临界区"><a href="#3-临界区" class="headerlink" title="3. 临界区"></a>3. 临界区</h3><p>临界区用来表示一种公共资源或者说是共享资源，可以被多个线程使用。</p>
<p>但是每一次，只能有一个线程在使用它。一旦临界资源被占用，其他线程若想使用，只能等待。</p>
<p>在并行程序中，临界区资源是保护的对象。</p>
<h3 id="4-阻塞-Blocking-和非阻塞-Non-Blocking"><a href="#4-阻塞-Blocking-和非阻塞-Non-Blocking" class="headerlink" title="4. 阻塞(Blocking)和非阻塞(Non-Blocking)"></a>4. 阻塞(Blocking)和非阻塞(Non-Blocking)</h3><p>阻塞和非阻塞，通常用来形容多线程间的相互影响。</p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>比如一个线程占用了临界区资源，那么其他所有需要这个资源的线程就必须在这个临界区中进行等待。等待会导致线程挂起，这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作。</p>
<h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><p>其意思与上相反，它强调没有一个线程可以妨碍其他线程执行。所有的线程都会尝试不断前向执行。</p>
<h3 id="5-死锁-Deadlock-、饥饿-Starvation-和活锁-Livelock"><a href="#5-死锁-Deadlock-、饥饿-Starvation-和活锁-Livelock" class="headerlink" title="5. 死锁(Deadlock)、饥饿(Starvation)和活锁(Livelock)"></a>5. 死锁(Deadlock)、饥饿(Starvation)和活锁(Livelock)</h3><p>死锁、饥饿和活锁都属于多线程的活跃性问题。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>是一个很严重的，并且应该避免和时时小心的问题。</p>
<p><img src="https://s2.loli.net/2022/02/14/2T9t3KHF7C6MuoW.png" alt="image-20220214230702973"></p>
<h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。比如它的线程优先级可能太低，而高优先级的线程不断抢占它需要的资源，导致低优先级线程无法工作。</p>
<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>如果线程的智力不够，且都秉承着“谦让”的原则，主动将资源释放给他人使用，那么就会出现资源不断在两个线程中跳动，而没有一个线程可以同时拿到所有资源而正常执行(两个人相互让路)。</p>
<h2 id="2-并发级别"><a href="#2-并发级别" class="headerlink" title="2. 并发级别"></a>2. 并发级别</h2>]]></content>
      <tags>
        <tag>实战Java高并发程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-1</title>
    <url>/2021/08/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">design</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">//若在IDE使用Console, 出错</span></span><br><span class="line">		System.out.println(<span class="string">&quot;请输入数字A&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		System.out.println(<span class="string">&quot;请选择运算符号(+、-、*、/):&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">B</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入数字B:&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">C</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		<span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> Double.parseDouble(C);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (B.equals(<span class="string">&quot;/&quot;</span>) &amp;&amp; c == <span class="number">0</span>) </span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> clclt(Double.parseDouble(A), B, c);</span><br><span class="line">		System.out.println(<span class="string">&quot;The answer is &quot;</span> + ans);</span><br><span class="line">		</span><br><span class="line">		&#125;<span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;您的输入有误,分母不能为零。故为 &quot;</span> + e.getMessage());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">clclt</span><span class="params">(<span class="type">double</span> A, String operator, <span class="type">double</span> C)</span> &#123;</span><br><span class="line">	<span class="type">double</span> <span class="variable">D</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">switch</span>(operator) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;+&quot;</span> :</span><br><span class="line">			D = A + C;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;-&quot;</span> :</span><br><span class="line">			D = A - C;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;*&quot;</span> :</span><br><span class="line">			D = A * C;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;/&quot;</span> :</span><br><span class="line">				D = A / C;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> D;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，此处使用Console进行输入会报错，原因是Java.io.Console只能用在 标准输入、输出流未被重定向 的原始控制台使用，在Eclipse或其他IDE的控制台是用不了的</p>
<p>增加上简单工厂模式后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operationFactory</span> &#123;</span><br><span class="line">	String operator;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">operationFactory</span><span class="params">(String opt)</span> &#123;</span><br><span class="line">		operator = opt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> operation <span class="title function_">creatOperator</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">		<span class="type">operation</span> <span class="variable">op</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">switch</span>(operator) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;+&quot;</span> :</span><br><span class="line">			op = <span class="keyword">new</span> <span class="title class_">operationAdd</span>(a, b);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;-&quot;</span> :</span><br><span class="line">			op = <span class="keyword">new</span> <span class="title class_">operationSub</span>(a, b);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;*&quot;</span> :</span><br><span class="line">			op = <span class="keyword">new</span> <span class="title class_">operationMul</span>(a, b);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;/&quot;</span> :</span><br><span class="line">			op = <span class="keyword">new</span> <span class="title class_">operationDiv</span>(a, b);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> op;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">operation</span> &#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">double</span> A;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">double</span> B;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">operation</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.A = a;</span><br><span class="line">		<span class="built_in">this</span>.B = b;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">GetResult</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;	</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入数字A&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		<span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> Double.parseDouble(A);</span><br><span class="line">		System.out.println(<span class="string">&quot;请选择运算符号(+、-、*、/):&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">B</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入数字B:&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">C</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		<span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> Double.parseDouble(C);</span><br><span class="line">		<span class="type">operationFactory</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">operationFactory</span>(B);</span><br><span class="line">		<span class="type">operation</span> <span class="variable">prtn</span> <span class="operator">=</span> p.creatOperator(a, c);</span><br><span class="line">		System.out.println(<span class="string">&quot;结果是 &quot;</span> + prtn.GetResult());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operationAdd</span> <span class="keyword">extends</span> <span class="title class_">operation</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">operationAdd</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">GetResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> A + B;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operationSub</span> <span class="keyword">extends</span> <span class="title class_">operation</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">operationSub</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">GetResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> A - B;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operationMul</span> <span class="keyword">extends</span> <span class="title class_">operation</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">operationMul</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">GetResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> A * B;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operationDiv</span> <span class="keyword">extends</span> <span class="title class_">operation</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">operationDiv</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">GetResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (B == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;输入出错，除数不能为零！&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> A / B;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <tags>
        <tag>代码历程</tag>
      </tags>
  </entry>
  <entry>
    <title>Insights</title>
    <url>/2022/03/05/Insights/</url>
    <content><![CDATA[<p>Chapter 1 </p>
<p>经济学的原理告诉我们：所有理性的人都知道必须面对权衡取舍。但在权衡取舍的过程中，我们往往并不理性：我们会被一时的快感牵制，而忘记了真正有价值的事情。当快感消退后，又会重新陷入懊悔之中，我们会因为短暂的不良情绪而无法正常处理事务，但当我们情绪恢复后，又会觉得刚才思考的问题不过是杞人忧天。</p>
<p>所谓专注法则，就是要如何摆脱在纠结和懊悔之间返回徘徊的方法。</p>
<p>如果在你行动之前丝毫没有准则，就会凭借着一时兴起做出决定，就会在很多事情上犯下错误。只有把我的优势在哪里？我要如何最大化优势？目前的紧急任务是什么？我应该怎么做？这一一系列问题原则化，给出自己在不同情况下的行为模式，才能更好地掌控自己。</p>
<h2 id="关于To-do-list"><a href="#关于To-do-list" class="headerlink" title="关于To do list"></a>关于To do list</h2><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>第一、列出应该做的任务，而不是所有需要做的任务</p>
<p>必须要分清楚，什么任务是你真正应该做的，而什么任务时你需要做但是实际上并不会立刻就做的。</p>
<p>第二、为任务规划时间，而不是随意地安排</p>
<p>在正确的时间做正确的事。按照所需要的能力将任务分为四大类：体力、创造力、逻辑思维能力、记忆力，然后思考不同时间段最应该做的事情是什么。寻找自己在什么时间多做什么事情最高效的规律。</p>
<p>第三、制定计划时要面向未来，但最重要的时间是接下来一个小时。</p>
<p>规划较长期的任务是：不要规划的过于复杂，而要集中专注于一件大事。</p>
<p>真正有意义的事，需要你在一段时间内坚持投入时间。</p>
<p>当你决定这个月应该做什么的时候，一定要集中专注于一件大事，并且把它拆解开来，然后分配到每一天。</p>
<p>但无论你在 To do list 中列出了什么，你都要记住最关键的时间永远是接下来的1小时。不要总是把任务一口气安排到最后，看上去井井有条但实际上永远拖延到最后1分钟，这并不是好的时间管理方式。</p>
<p>最好的状态是，如果自己觉得这会儿不错，尽管并没有安排接下来的任务，也不要浪费接下来的1 个小时。每一个“接下来1小时”都是最重要的，这才是时间管理的精髓。</p>
<h3 id="制作任务清单"><a href="#制作任务清单" class="headerlink" title="制作任务清单"></a>制作任务清单</h3><p>第一、每天一件令你有成就感的工作</p>
<p>第二、留出过渡时间，列出备用任务</p>
<p>把每天的任务都塞得足够满，恨不得再多做一些事——但真正执行起来的时候，结果往往不如人意。面对这种情况，你可以每天为自己预留出1~2个小时作为调整和过度。</p>
<p><img src="https://s2.loli.net/2022/03/05/B9q2Sotwj8YE1ax.png" alt="image-20220305154024366"></p>
<p>第三、把To do list当作自己的回顾日志</p>
<ul>
<li>自己今天完成了哪些任务？能不能回顾一下这些任务，加深一遍印象？</li>
<li>有哪些未完成的计划？是自己的状态不佳，还是计划太难，应该要如何调整？</li>
<li>有哪些事情是更值得做的，但是却因为做另一些不那么重要的事情，而被放弃了？应该如何调整？</li>
</ul>
<h3 id="柳比歇夫的时间记录法"><a href="#柳比歇夫的时间记录法" class="headerlink" title="柳比歇夫的时间记录法"></a>柳比歇夫的时间记录法</h3><p>如果你只是列出计划，但却不能完成计划，计划用时和实际用时相差甚远，就会导致执行计划时感到并没有太大的用处：“计划不如变化”，那还不如不列任务清单呢。</p>
<p>把每天的有效工作时间和所做的事项记录下来。</p>
<p><img src="https://s2.loli.net/2022/03/05/zaUV7Y2ET4spM9A.png" alt="image-20220305154610065"></p>
<p>如果你想要实现真正地专注，我建议你试一试这种时间记录法。当你开始记录的时候，千万要知道这份记录不是为了做给别人看，也不是为了炫耀或者满足自己的虚荣心而做，而是切切实实地为掌控自己的时间而做，因此你需要自己监督自己，自己向自己汇报。</p>
<p>记住，这种方法真正的要义在于：了解自己，精确地感知时间。</p>
<h4 id="要义"><a href="#要义" class="headerlink" title="要义"></a>要义</h4><p>一、只记录纯粹工作时间</p>
<p>它是指你真正集中精力、全神贯注工作的那段时间。</p>
<p><img src="https://s2.loli.net/2022/03/05/IYjfGW67p9BlS2z.png" alt="image-20220305154827014"></p>
<p>当你开始把纯粹工作时间从杂七杂八的事项中提取出来，你才能意识到自己有多少时间都被耗费在没有意义的事情上。</p>
<p>这种情况在一开始可能是经常发生的，你需要有意识地去改变。例如事先规定和朋友讨论的时间，设置一个闹钟，防止长时间的瞎侃；搜集资料的时候，从一开始就尽量不点开一些无用的链接，以防自己的注意力被分散。</p>
<p>他感受到，生命只有一次，不可复得，而且生命中的每一天也同样具有这种只有一次、不可复得的性质。</p>
<p>二、可持续是你最应该考虑到的</p>
<p>当你在做这件事情的时候，随时提醒一下自己初衷是什么：是切切实实地自我提升，通过更多时间的工作和学习来充实自己，同时更好地提升效率；而绝不是为了账面上的好看，瞎填些模棱两可的时间和工作记录来哄骗自己。</p>
<p><strong>打破你的仪式感，这是第一步。</strong></p>
<p><strong>最关键的事情，就是从现在开始着手，而不是仅仅停留在“理论上我知道应该这么做”。</strong></p>
<p>接下来你要做的就是坚持下去。你可能有一万种理由坚持不下去，例如今天实在太累，例如已经忘记早上做了什么，例如今天没有带那个用于记录的小本子……我无法列举出所有可能令你终止的情况，但是无论是哪种情况，它其实对我们来说都只是一个借口而已。</p>
<p>三、如何使用这份记录？</p>
<p>时间记录的本身并不是目的，它只是为了对抗两件事：第一件事是我们总是不能清楚地知道我们应该做什么；第二件事是我们总是不能清楚地知道我们做过什么</p>
<p>你可以把时间记录法看作是 To do list 的逆过程：To do list 是在事前对将要做的所有事情进行规划，而时间记录法则是对已做的事情进行总结。</p>
<h3 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h3><p>实际上，番茄工作法的核心规则并不在于用什么软件来记录番茄，也不在于到底是“番茄”计时还是“土豆”计时，而在于这个工作法背后隐藏的关于时间的法则——那就是设定单位时间，以单位时间安排任务，提高对时间的敏感度。</p>
<p>单位时间尺度是番茄工作法的核心：将所有任务都切分为一个一个的时间块，而不是笼统地进行一项任务。</p>
<h3 id="四象限工作法"><a href="#四象限工作法" class="headerlink" title="四象限工作法"></a>四象限工作法</h3><p>将什么样的任务划分在这四个象限中的哪个位置，并不是固定的，而是根据你当时具体的情况决定的。这也就是说，四象限工作法的划分需要你随着时间更改。</p>
<p>你可以每一个月都将自己近期的任务这样分一次类，做成一个表格，最好将这个表格记录下来。这样在你无所事事的时候更容易提醒自己：“哦，我还有书要看，而看书这项任务已经被标记为紧急，我必须完成。”</p>
<p>有一些任务需要长时间投入，因此在这个过程中这项任务几乎都处于不紧急的状态；但当它变得紧急的时候，你才会意识到这项任务如此重要，但又无法在短时间内挽回，最终只能懊悔“我要是早一点开始就好了”。</p>
<p>人们面临的最大困境之一就是短视。</p>
<p>因为只能看到眼前一小段时间的利益，所以总是把紧急不重要的任务放在前面，当完成这些任务之后，便松了口气，觉得那些不紧急的任务，都可以一拖再拖，直到无法再拖下去为止，而运用四象限工作法正是要解决这个问题。</p>
]]></content>
      <tags>
        <tag>读书整理</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis</title>
    <url>/2022/03/13/MyBatis/</url>
    <content><![CDATA[<h1 id="Chapter-1-简介"><a href="#Chapter-1-简介" class="headerlink" title="Chapter 1 简介"></a>Chapter 1 简介</h1><h2 id="1-创建Maven工程"><a href="#1-创建Maven工程" class="headerlink" title="1. 创建Maven工程"></a>1. 创建Maven工程</h2><ol>
<li><p>打包方式：jar</p>
</li>
<li><p>引入依赖</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MyBatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MyBatis_demo1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Mybatis核心 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-创建MyBatis的核心配置文件"><a href="#2-创建MyBatis的核心配置文件" class="headerlink" title="2. 创建MyBatis的核心配置文件"></a>2. 创建MyBatis的核心配置文件</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>习惯上命名为mybatis-config.xml，但将来整合Spring后，这个配置文件可以省略。(SSM整合之后，全部都可以交给Spring来管理。)</p>
<p>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息</p>
<p>存放的位置时src/main/resources目录下</p>
<h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta"> 		<span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"> 		<span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置连接数据库的环境 --&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>/&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;517@limy.Acwco&quot;</span>/&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!-- 引入映射文件 --&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-创建mapper接口"><a href="#3-创建mapper接口" class="headerlink" title="3. 创建mapper接口"></a>3. 创建mapper接口</h2><p>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，不需要提供实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mybatis.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc: 添加用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> int&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/13 12:23</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-创建MyBatis的映射文件"><a href="#5-创建MyBatis的映射文件" class="headerlink" title="5. 创建MyBatis的映射文件"></a>5. 创建MyBatis的映射文件</h2><h3 id="0-相关概念"><a href="#0-相关概念" class="headerlink" title="0. 相关概念"></a>0. 相关概念</h3><p>ORM(Object Relationship Mapping) 对象关系映射</p>
<ul>
<li>对象：Java的实体类对象</li>
<li>关系：关系型数据库</li>
<li>映射：二者之间的映射关系</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Java概念</th>
<th>数据库概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>类</td>
<td>表</td>
</tr>
<tr>
<td>属性</td>
<td>字段/列</td>
</tr>
<tr>
<td>对象</td>
<td>记录/行</td>
</tr>
</tbody>
</table>
</div>
<h3 id="1-命名规则"><a href="#1-命名规则" class="headerlink" title="1. 命名规则"></a>1. 命名规则</h3><p>表所对应的实体类的类名+Mapper.xml</p>
<p>例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml</p>
<p>因此，一个映射文件对应一个实体类，对应一张表</p>
<p>MyBatis映射文件用于编写SQL，访问以及操作表中的数据</p>
<p>MyBatis映射文件存放的位置是src/main/resourcs/mappers目录下</p>
<h3 id="2-MyBatis中可以面向接口"><a href="#2-MyBatis中可以面向接口" class="headerlink" title="2. MyBatis中可以面向接口"></a>2. MyBatis中可以面向接口</h3><p>MyBatis面向接口编程的两个一致(调用方法就是为了执行SQL语句)：</p>
<p>根据全类名去匹配映射文件，再根据方法名，去匹配SQL语句。</p>
<ol>
<li>映射文件的namespace要和mapper接口的全类名保持一致</li>
<li>映射文件中SQL语句的id要和mapper接口中的方法名一致(保证当前所调用的方法，对应正确的SQL语句，因为不只会出现一个实现插入的SQL语句)</li>
</ol>
<h3 id="3-映射文件和核心配置文件"><a href="#3-映射文件和核心配置文件" class="headerlink" title="3. 映射文件和核心配置文件"></a>3. 映射文件和核心配置文件</h3><p>映射文件和核心配置文件使用的dtd不同，前者为mybatis-3-mapper.dtd，后者为mybatis-3-config.dtd</p>
<p>dtd文件不同，那么所使用的标签也是不一样的。</p>
<h2 id="6-使用junit测试功能"><a href="#6-使用junit测试功能" class="headerlink" title="6. 使用junit测试功能"></a>6. 使用junit测试功能</h2><h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>加载核心配置文件，获取对应的字节输入流</p>
<p>通过工厂builder创建工厂对象……</p>
<ul>
<li><p>SqlSession：代表java程序和数据库之间的会话。(HttpSession是Java程序和浏览器之间的会话)</p>
</li>
<li><p>SqlSessionFactory：是生产SqlSession的工厂。</p>
</li>
<li><p>工厂模式：如果创建某一个对象，使用的过程基本固定，那么就可以把创建这个对象的相关代码封装到一个工厂类中，以后都使用这个工厂类来生产需要的对象。</p>
</li>
</ul>
<p>如果执行一个添加操作，虽然事务未被提交，但是执行了响应的SQL语句，id已被占用了。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMyBatis</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 加载核心配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resource</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-conf.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取SqlSessionFactoryBuilder</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="comment">// 获取SqlSessionFactory</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(resource);</span><br><span class="line">        <span class="comment">// 获取MyBatis操作数据库的会话对象SqlSession</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">// 获取mapper接口对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="comment">// 测试功能</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.insertUser();</span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;result: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mapper接口中的全类名要和相对应的映射文件中的namespace一致</p>
<p>要调用的方法名要和SQL语句的id一致</p>
<p>通过sqlSession的getMapper方法来获取mapper接口对象，方法底层使用代理模式</p>
<p>SqlSession默认不自动提交事务，若需要自动提交事务，可以使用SqlSessionFactory.openSession(true); 代表该方法的其中一个参数autoCommit = true</p>
<h2 id="7-使用log4j的日志功能"><a href="#7-使用log4j的日志功能" class="headerlink" title="7. 使用log4j的日志功能"></a>7. 使用log4j的日志功能</h2><p>通过日志功能检测当前实现的功能所执行的SQL。</p>
<h3 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-log4j的配置文件"><a href="#2-log4j的配置文件" class="headerlink" title="2. log4j的配置文件"></a>2. log4j的配置文件</h3><p>log4j的配置文件，log4j.xml，放置在src/main/resources下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">log4j</span>:configuration <span class="keyword">SYSTEM</span> <span class="string">&quot;log4j.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;Encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;ConversionPattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m</span></span></span><br><span class="line"><span class="string"><span class="tag">(%F:%L) \n&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;java.sql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.ibatis&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-日志级别"><a href="#3-日志级别" class="headerlink" title="3. 日志级别"></a>3. 日志级别</h3><p>FATAL(致命)&gt;ERROR(错误)&gt;WRAN(警告)&gt;INFO(信息)&gt;DEBUG(调试)</p>
<p>从左到右打印的内容越来越详细，级别越高，输出的信息越少。</p>
<p>因为当前级别所记录的日志信息的内容，包含了大于等于它的级别的所有日志信息。所以级别越低，信息越多。(低级别的信息都记录了，那么高级别的信息肯定也要记录上。)</p>
<h1 id="Chapter-2-MyBatis的增删查改"><a href="#Chapter-2-MyBatis的增删查改" class="headerlink" title="Chapter 2 MyBatis的增删查改"></a>Chapter 2 MyBatis的增删查改</h1><h2 id="1-修改和删除功能"><a href="#1-修改和删除功能" class="headerlink" title="1. 修改和删除功能"></a>1. 修改和删除功能</h2><p>MyBatis中是面向接口编程的，所以先要在UserMapper中添加方法，再通过方法找到当前映射文件中的SQL。</p>
<p>增删改的返回值固定，所以可以返回void或int。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><ol>
<li>增加方法到UserMapper接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>配置UserMapper.xml文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- void updateUser(); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser()&quot;</span>&gt;</span></span><br><span class="line">    update t_user set username=&#x27;张三&#x27; where id=&#x27;4&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- void deleteUser(); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser()&quot;</span>&gt;</span></span><br><span class="line">    delete from t_user where id = 4</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>测试功能</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-conf.xml&quot;</span>);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    mapper.updateUser();</span><br><span class="line">    <span class="comment">// mapper.deleteUser();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-查询功能"><a href="#2-查询功能" class="headerlink" title="2. 查询功能"></a>2. 查询功能</h2><p>配置resultType之前，会报错，提示这里少了resultType或resultMap。</p>
<p><img src="https://s2.loli.net/2022/03/16/yjv9HatIuUx4OKq.png" alt="image-20220316102933217"></p>
<p>(再次说明了执行SQL语句的过程，也就是根据命名空间中的全类名找映射文件，再根据方法名找SQL语句。)</p>
<h3 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h3><p>报错是因为没有指定结果类型。执行完SQL语句，MyBatis并不知道要转换成怎样的实体类对象。</p>
<p>MyBatis避免了大部分JDBC代码，以及参数的手动设置和结果集的处理，但也是仅仅处理了结果集，特别是处理结果集时，应当指定当前查询出的数据，对应的实体类是什么。</p>
<h3 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h3><p>resultType：结果类型；resultMap：结果映射</p>
<p>设置出resultType后，便可将查询出的结果转换成所设置的结果类型，再把结果作为返回值返回给当前的方法。</p>
<h4 id="相关介绍"><a href="#相关介绍" class="headerlink" title="相关介绍"></a>相关介绍</h4><p>查询功能的标签必须设置resultType或resultMap。</p>
<p>resultType：设置默认的映射关系</p>
<p>resultMap：设置自定义的映射关系</p>
<p>将查询出结果的字段名和属性名相对应，如果能匹配到属性则赋值，匹配不到则不赋值</p>
<p>当属姓名和字段名不一样，或者要处理一对多和多对一的关系，要通过resultMap来实现自定义映射。</p>
<p>因为查询时，结果不固定，所以，要根据情况设置返回值。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><ol>
<li>配置UserMapper接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User <span class="title function_">getUserById</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>配置UserMapper.xml文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- User getUserById(); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById()&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mybatis.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user where id = 3</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- List&lt;User&gt; getAllUsers(); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUsers()&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mybatis.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>测试结果</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCRUD</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-conf.xml&quot;</span>);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    <span class="comment">// User user = mapper.getUserById();</span></span><br><span class="line">    <span class="comment">// System.out.println(user);</span></span><br><span class="line">    List&lt;User&gt; users = mapper.getAllUsers();</span><br><span class="line">    users.forEach(user -&gt; &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Chapter-3-核心文件配置详解"><a href="#Chapter-3-核心文件配置详解" class="headerlink" title="Chapter 3 核心文件配置详解"></a>Chapter 3 核心文件配置详解</h1><h2 id="0-一些简介"><a href="#0-一些简介" class="headerlink" title="0. 一些简介"></a>0. 一些简介</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- environments: 配置多个连接数据库的环境</span></span><br><span class="line"><span class="comment">    属性：</span></span><br><span class="line"><span class="comment">        default：设置默认使用的环境(的id)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        environment: 配置某个具体的环境</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">            id: 表示连接数据的环境唯一标识，不能重复</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        transactionManager: 设置事务管理方式</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">            type=&quot;JDBC|MANAGED&quot;</span></span><br><span class="line"><span class="comment">            JDBC: 表示当前环境中，执行SQL时，使用的是JDBC中原生的事务管理方式，事物的提交或回滚需要手动来处理</span></span><br><span class="line"><span class="comment">            MANAGED: 被管理，例如被Spring管理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        DataSource：设置数据源</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">            type：设置数据源的类型</span></span><br><span class="line"><span class="comment">            type=&quot;POOLED|UNPOOLED|JNDI&quot;</span></span><br><span class="line"><span class="comment">            POOLED: 表示使用数据库连接池缓存数据库连接</span></span><br><span class="line"><span class="comment">            UNPOOLED：表示不使用数据库连接池</span></span><br><span class="line"><span class="comment">            JNDI：使用上下文的数据源</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        SSM整合之后，MyBatis中不需要再设置数据源，因为Spring中会提供</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-配置顺序"><a href="#1-配置顺序" class="headerlink" title="1. 配置顺序"></a>1. 配置顺序</h2><p>核心配置文件的标签必须按照固定的顺序。</p>
<p><img src="https://s2.loli.net/2022/03/16/ZwGDkusN4lY8fHa.png" alt="image-20220316161807800"></p>
<h2 id="2-properties标签"><a href="#2-properties标签" class="headerlink" title="2. properties标签"></a>2. properties标签</h2><h3 id="1-properties文件"><a href="#1-properties文件" class="headerlink" title="1. properties文件"></a>1. properties文件</h3><p>jdbc.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root12345</span></span><br></pre></td></tr></table></figure>
<p>由于可能会有很多个properties文件，为避免名称发生重名现象(为符合见名知义的命名方式，可能会重名)，这里<strong>为名称添加了前缀</strong>。</p>
<h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h3><p>在MyBatis核心配置文件中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 显然，添加上文件名即可引入 --&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-TypeAliases标签"><a href="#3-TypeAliases标签" class="headerlink" title="3. TypeAliases标签"></a>3. TypeAliases标签</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>全类名很麻烦，可以使用类型别名的功能。</p>
<p>即，为当前的类起个别名，在MyBatis的范围之内，都可以通过这个别名去访问该类。</p>
<p>类型别名不区分大小写！！！</p>
<h3 id="方式一-用得少"><a href="#方式一-用得少" class="headerlink" title="方式一(用得少)"></a>方式一(用得少)</h3><p>如果不设置alias部分的话，就会给它一个默认的别名，即其类名且不区分大小写。所以，其实可写可不写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置类型别名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.mybatis.pojo.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">typeAlias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方式二-用得多"><a href="#方式二-用得多" class="headerlink" title="方式二(用得多)"></a>方式二(用得多)</h3><p>以包为单位，将包下所有的类，全部都设置默认的类型别名，即其类名且不区分大小写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置类型别名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.mybatis.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-mappers标签"><a href="#4-mappers标签" class="headerlink" title="4. mappers标签"></a>4. mappers标签</h2><p>为避免在核心配置文件中设置过多的mapper标签，所以使用package，一次引入一个包中所有的映射配置文件。</p>
<p>而配置文件都放在resources下，所以需要在resources文件夹下建立包。</p>
<h3 id="建包"><a href="#建包" class="headerlink" title="建包"></a>建包</h3><p>resources中不能直接去建package，想要建包的话，只能建立Directory，且命名形如com/mybatis/xml</p>
<p>即以/隔开各层目录，如果com.mybatis.xml的话，那么不会建立分层目录，而是直接将整体作为一个文件的名。</p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>mapper标签中，以包为单位，引入包下所有的xml文件</p>
<h4 id="两个要求"><a href="#两个要求" class="headerlink" title="两个要求"></a>两个要求</h4><ol>
<li><p>Mapper接口所在的包，要和映射文件所在的包名一致，一个在mapper包，另一个也要在mapper包下，二者所在路径可以不一致，但是所在包名要一致。</p>
</li>
<li><p>Mapper接口，要和映射文件的名字一致，UserMapper.xml对应UserMapper接口</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/16/AsVeJNqDEtfM9Rp.png" alt="image-20220316164022999"></p>
<p><img src="https://s2.loli.net/2022/03/16/QcJfUtWHIpzSAaF.png" alt="image-20220316164721064"></p>
<p>其他还有很多标签。</p>
<h1 id="Chapter-4-MyBatis获取参数值的两种方式"><a href="#Chapter-4-MyBatis获取参数值的两种方式" class="headerlink" title="Chapter 4 MyBatis获取参数值的两种方式(*)"></a>Chapter 4 MyBatis获取参数值的两种方式(*)</h1><p>Mapper接口方法中的这个参数，在映射文件中该如何获取。</p>
<h2 id="0-两种方式"><a href="#0-两种方式" class="headerlink" title="0. 两种方式"></a>0. 两种方式</h2><p>MyBatis获取参数值的两种方式：${} 和 #{}</p>
<p>${}的本质就是字符串拼接，#{} 的本质就是占位符赋值(常用)</p>
<p>${} 使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号。</p>
<h1 id="使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单括号。"><a href="#使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单括号。" class="headerlink" title="{} 使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单括号。"></a>{} 使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单括号。</h1><h2 id="1-单个字面量类型的参数"><a href="#1-单个字面量类型的参数" class="headerlink" title="1. 单个字面量类型的参数"></a>1. 单个字面量类型的参数</h2><p>占位符赋值，与传输过来的参数的名字无关，只与传过来的值有关，与值叫什么也无关，只与位置有关。建议用参数名。。。。。。</p>
<p>都可以通过任意的名称，来获取对应的参数值。</p>
<p>若mapper接口中的方法参数为单个的字面量类型</p>
<p>此时可以使用${}和#{}以任意的名称获取参数的值，注意前者需要手动加括号。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>接口：ParameterMapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User <span class="title function_">getUserByUsername</span><span class="params">(String username)</span>;</span><br></pre></td></tr></table></figure>
<p>配置文件：ParameterMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 法一 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- User getUserByUsername(String username); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- #&#123;&#125;中，可以是username，也可以是aaa，什么名称，无所谓，都能接收到值 --&gt;</span></span><br><span class="line">    select * from t_user where username = #&#123;username&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 法二，注意单引号 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- User getUserByUsername(String username); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span> &gt;</span></span><br><span class="line">    select * from t_user where username = &#x27;$&#123;username&#125;&#x27;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试方法：ParameterMapperTest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetUserByUsername</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">ParameterMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">zhang</span> <span class="operator">=</span> mapper.getUserByUsername(<span class="string">&quot;zhang&quot;</span>);</span><br><span class="line">    System.out.println(zhang);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>法二：</p>
<p><img src="https://s2.loli.net/2022/03/18/ZqckQvewrdBzUy7.png" alt="image-20220318221826359"></p>
<p>法一：</p>
<p><img src="https://s2.loli.net/2022/03/18/5Jz6XxUBeMryktW.png" alt="image-20220318221951540"></p>
<h2 id="2-多个字面量类型的参数"><a href="#2-多个字面量类型的参数" class="headerlink" title="2. 多个字面量类型的参数"></a>2. 多个字面量类型的参数</h2><p>若mapper接口中的方法参数为多个时</p>
<h3 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h3><p>此时MyBatis会自动将这些参数放在一个map集合中，以arg0，arg1…为键，以参数为值；以param1，param2…为键，以参数为值；</p>
<p>也就是说，既可以写 <code>&#39;$&#123;arg0&#125;&#39;和&#39;$&#123;arg1&#125;&#39; 或#&#123;arg0&#125;和#&#123;param2&#125;</code>，也可以用<code>&#39;$&#123;param1&#125;&#39;和&#39;$&#123;param2&#125;&#39;</code> 分别代指第一个和第二个参数等。</p>
<p>没有param0！！！</p>
<p>因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意前者要手动加单括号。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><p>ParameterMapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User <span class="title function_">checkUser</span><span class="params">(String username, String password)</span>;</span><br></pre></td></tr></table></figure>
<p>ParameterMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- User checkUser(String username, String password); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user where username = #&#123;arg0&#125; and password = #&#123;param2&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>ParameterMapperTest测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">testCheckUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">ParameterMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.checkUser(<span class="string">&quot;zhang&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://s2.loli.net/2022/03/19/gbni2EUtBoxf16Y.png" alt="image-20220319191443639"></p>
<h3 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h3><p>可以自定义键，手动将这些参数放在一个map中存储。</p>
<p>这时，只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意前者要手动加单括号。</p>
<p>就，此时的键是在map中自己设置的，而不是上面的那种由MyBatis自动设置的。</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><p>mapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User <span class="title function_">checkUser2</span><span class="params">(Map&lt;String, Object&gt; map)</span>;</span><br></pre></td></tr></table></figure>
<p>mapper配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- User checkUser2(Map&lt;String, Object&gt; map); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkUser2&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCheckUser2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">ParameterMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;zhang&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.checkUser2(map);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果同上</p>
<h3 id="情况三-常用"><a href="#情况三-常用" class="headerlink" title="情况三(常用)"></a>情况三(常用)</h3><p>使用@Param注解来命名参数(常用)</p>
<p>通过@Param注解来命名参数，MyBatis会自动将其放入map集合中，以注解中的值为键，所注解的方法参数的值为值。</p>
<p>相当于是方法二和方法三的结合。</p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><p>mapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User <span class="title function_">checkUserByParam</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username, <span class="meta">@Param(&quot;password&quot;)</span> String password)</span>;</span><br></pre></td></tr></table></figure>
<p>mapper配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- User checkUserByParam(String username, String password); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkUserByParam&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCheckUserByParam</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">ParameterMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.checkUserByParam(<span class="string">&quot;zhang&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><p><img src="https://s2.loli.net/2022/03/19/9Cg2GFjzvnPRuBq.png" alt="image-20220319194839458"></p>
<h2 id="3-传输表单数据-常用"><a href="#3-传输表单数据-常用" class="headerlink" title="3. 传输表单数据(常用)"></a>3. 传输表单数据(常用)</h2><p>传输的是表单数据，可以在控制层获取，并保存成为实体类对象进行存储。</p>
<p>mapper接口方法的参数是实体类类型的参数。</p>
<p>map集合用键来访问值，而实体类类型以属性名来访问。</p>
<p>关于属性，主要看的是set和get方法。</p>
<p>代码中通过以属性的方式访问属性值即可。</p>
<p>mapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">checkUserByInsert</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure>
<p>mapper配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- int checkUserByInsert(User user); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;checkUserByInsert&quot;</span>&gt;</span></span><br><span class="line">    insert into t_user values (null, #&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;sex&#125;, #&#123;email&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCheckUserByInsert</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">ParameterMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.checkUserByInsert(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>, <span class="string">&quot;Li&quot;</span>, <span class="string">&quot;12345&quot;</span>, <span class="number">20</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;1234@163.com&quot;</span>));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/19/6Mn17SZiUJvzTWk.png" alt="image-20220319222620257"></p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>总的而言，是两种类别的，一份是实体类类型传实体类对象进数据库，另一个是@Param的传参数。</p>
<h4 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h4><p>MyBatis中SQL的唯一标识：命名空间.SQL的ID，Mapper的全类名+方法名</p>
<p>MapperMethod方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br></pre></td></tr></table></figure>
<p>获取参数的过程，就是将方法的参数转换成SQL语句的参数。传输到底层，只有传过来的参数值和对应的参数的索引(第一个参数对应0，第二个对应1)，没有什么参数名</p>
<p>ParamNameResolver.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取方法的参数的类型</span></span><br><span class="line"><span class="keyword">final</span> Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line"><span class="comment">// 获取对应参数的所有注解，第一维放参数，第二维参数对应的所有注解，可能有0个及以上。</span></span><br><span class="line"><span class="keyword">final</span> Annotation[][] paramAnnotations = method.getParameterAnnotations();</span><br><span class="line"><span class="keyword">final</span> SortedMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 二维数组的length获取的是行数，也就是参数的个数。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">paramCount</span> <span class="operator">=</span> paramAnnotations.length;</span><br><span class="line"><span class="comment">// get names from @Param annotations</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">paramIndex</span> <span class="operator">=</span> <span class="number">0</span>; paramIndex &lt; paramCount; paramIndex++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isSpecialParameter(paramTypes[paramIndex])) &#123;</span><br><span class="line">    <span class="comment">// skip special parameters</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 遍历方法中一个参数对应的全部注解</span></span><br><span class="line">  <span class="keyword">for</span> (Annotation annotation : paramAnnotations[paramIndex]) &#123;</span><br><span class="line">      <span class="comment">// 如果是Param这个注解</span></span><br><span class="line">    <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Param) &#123;</span><br><span class="line">        <span class="comment">// 标识为true</span></span><br><span class="line">      hasParamAnnotation = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 将注解转换成Param类型</span></span><br><span class="line">      name = ((Param) annotation).value();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 参数的索引，注解的value  </span></span><br><span class="line">map.put(paramIndex, name);</span><br><span class="line"><span class="comment">// names和map基本一致  </span></span><br><span class="line">names = Collections.unmodifiableSortedMap(map);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历names中的键值对</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;</span><br><span class="line">    <span class="comment">// 放置username和zhang进入param这个集合。</span></span><br><span class="line">  param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">  <span class="comment">// add generic param names (param1, param2, ...)</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">String</span> <span class="variable">genericParamName</span> <span class="operator">=</span> GENERIC_NAME_PREFIX + (i + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// ensure not to overwrite parameter named with @Param</span></span><br><span class="line">    <span class="comment">// 如果没有，添加param1和zhang进入param这个集合</span></span><br><span class="line">  <span class="keyword">if</span> (!names.containsValue(genericParamName)) &#123;</span><br><span class="line">    param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 此时，param集合中，应该有两个键值对</span></span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/21/JoClUB3NVDwrfhE.png" alt="image-20220321225535121"></p>
<p><img src="https://s2.loli.net/2022/03/21/ZFdn6g8p7Y2QrCs.png" alt="image-20220321225551600"></p>
<p><img src="https://s2.loli.net/2022/03/21/29EhSH6IalVWwJd.png" alt="image-20220321225850862"></p>
<p><img src="https://s2.loli.net/2022/03/21/FrK3nMxY6eqDoti.png" alt="image-20220321224300333"></p>
<p>ok，结束。</p>
<h1 id="Chapter-5-MyBatis的各种查询功能"><a href="#Chapter-5-MyBatis的各种查询功能" class="headerlink" title="Chapter 5 MyBatis的各种查询功能"></a>Chapter 5 MyBatis的各种查询功能</h1><h2 id="1-查询一个实体类对象"><a href="#1-查询一个实体类对象" class="headerlink" title="1. 查询一个实体类对象"></a>1. 查询一个实体类对象</h2><p>可以直接通过实体类对象或者集合接收</p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SelectMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span>Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- User getUserById(@Param(&quot;id&quot;)Integer id); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetUserById</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">SelectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SelectMapper.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.getUserById(<span class="number">5</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://s2.loli.net/2022/03/23/eGXuNgLxQoV8piz.png" alt="image-20220323215946831"></p>
<h2 id="2-查询一个list集合"><a href="#2-查询一个list集合" class="headerlink" title="2. 查询一个list集合"></a>2. 查询一个list集合</h2><p>如果查询的数据有多条，那么就不能通过实体类对象接收，会抛出TooManyResultsException</p>
<p>可以通过List集合接收。</p>
<p><img src="https://s2.loli.net/2022/03/23/wJDxhOmUeMrNjcG.png" alt="image-20220323220148902"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;User&gt; getAllUsers(); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">SelectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SelectMapper.class);</span><br><span class="line">    List&lt;User&gt; users = mapper.getAllUsers();</span><br><span class="line">    users.forEach(user -&gt; &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// System.out.println(user);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://s2.loli.net/2022/03/23/SaIlENBgk6o8DH7.png" alt="image-20220323223049138"></p>
<h2 id="3-查询单个数据"><a href="#3-查询单个数据" class="headerlink" title="3. 查询单个数据"></a>3. 查询单个数据</h2><p>查询单行单列的值。</p>
<p>查询出来的结果是什么，在resultType中就写什么类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer <span class="title function_">getSelectCount</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Integer getSelectCount(); --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- int-&gt;Integer; integer-&gt;Integer; _int-&gt;int; _integer-&gt;int，所以写Integer或int也可以 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getSelectCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">    select count(*) from t_user;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetSelectCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">SelectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SelectMapper.class);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> mapper.getSelectCount();</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果-3"><a href="#运行结果-3" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://s2.loli.net/2022/03/23/vRfVl8QmHkIA6O2.png" alt="image-20220323224838138"></p>
<h2 id="4-查询一条数据为map集合"><a href="#4-查询一条数据为map集合" class="headerlink" title="4. 查询一条数据为map集合"></a>4. 查询一条数据为map集合</h2><p>如果通过SQL语句查询出的结果，没有任何一个实体类能与之对应。此时，可以将查询的结果转换为一个map集合，以字段为键，以字段的值为值。</p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; <span class="title function_">getUserByIdToMap</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Map&lt;String, Object&gt; getUserByIdToMap(@Param(&quot;id&quot;) Integer id); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByIdToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetUserByIdToMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">SelectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SelectMapper.class);</span><br><span class="line">    Map&lt;String, Object&gt; map = mapper.getUserByIdToMap(<span class="number">5</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果-4"><a href="#运行结果-4" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://s2.loli.net/2022/03/23/2KZ8Pfz3LENI97c.png" alt="image-20220323230723056"></p>
<h2 id="5-查询多条数据为map集合"><a href="#5-查询多条数据为map集合" class="headerlink" title="5. 查询多条数据为map集合"></a>5. 查询多条数据为map集合</h2><ol>
<li><p>可以通过map类型的list集合接收</p>
</li>
<li><p>可以在mapper接口的方法上添加@MapKey注解，此时就可以将每条数据转换的map集合作为值，以某个字段的值作为键，放在同一个map集合中。</p>
</li>
</ol>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">getAllUserToMap</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapKey(&quot;id&quot;)</span></span><br><span class="line">    Map&lt;String, Object&gt; <span class="title function_">getAllUserToMap</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Map&lt;String, Object&gt;&gt; getAllUserToMap(); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetAllUserToMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">SelectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SelectMapper.class);</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = mapper.getAllUserToMap();</span><br><span class="line">    <span class="comment">// Map&lt;String, Object&gt; maps = mapper.getAllUserToMap();</span></span><br><span class="line">    System.out.println(maps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果-5"><a href="#运行结果-5" class="headerlink" title="运行结果"></a>运行结果</h3><h4 id="结果一"><a href="#结果一" class="headerlink" title="结果一"></a>结果一</h4><p><img src="https://s2.loli.net/2022/03/23/CmRpndy2fMDaSKH.png" alt="image-20220323232600736"></p>
<h4 id="结果二"><a href="#结果二" class="headerlink" title="结果二"></a>结果二</h4><p><img src="https://s2.loli.net/2022/03/23/lw5xR6FQce7sUIn.png" alt="image-20220323232456216"></p>
<h1 id="Chapter-6-特殊SQL的执行"><a href="#Chapter-6-特殊SQL的执行" class="headerlink" title="Chapter 6 特殊SQL的执行"></a>Chapter 6 特殊SQL的执行</h1><h2 id="1-模糊查询"><a href="#1-模糊查询" class="headerlink" title="1. 模糊查询"></a>1. 模糊查询</h2><h3 id="出错"><a href="#出错" class="headerlink" title="出错"></a>出错</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user where username Like &#x27;%#&#123;username&#125;%&#x27;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用模糊查询，所以#{}应该放在%%之内，那么就会放在’ ‘之内，那么此时，将${ }替代的 ？会被当成字符解析，也就是说，此时SQL语句中，没有什么占位符，只有一个?字符，那么为占位符赋值就会报错。</p>
<p><img src="https://s2.loli.net/2022/03/24/7qziaLSPtK8v1g2.png" alt="image-20220324005029457"></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="1-用-替代"><a href="#1-用-替代" class="headerlink" title="1. 用${ }替代"></a>1. 用${ }替代</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user where username Like &#x27;%$&#123;username&#125;%&#x27;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/24/2tnb4swAdvSkCIB.png" alt="image-20220324005311797"></p>
<h4 id="2-用concat进行拼接"><a href="#2-用concat进行拼接" class="headerlink" title="2. 用concat进行拼接"></a>2. 用concat进行拼接</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user where username Like concat(&#x27;%&#x27;, #&#123;username&#125;, &#x27;%&#x27;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/24/Mr4FPnIQxj18fgU.png" alt="image-20220324005710882"></p>
<h4 id="3-“-”-username-”-”拼接"><a href="#3-“-”-username-”-”拼接" class="headerlink" title="3. “%”#{username}”%”拼接(*)"></a>3. “%”#{username}”%”拼接(*)</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user where username Like &quot;%&quot;#&#123;username&#125;&quot;%&quot;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/24/5M8xcBKaGEpbQzL.png" alt="image-20220324005442460"></p>
<h2 id="2-批量删除"><a href="#2-批量删除" class="headerlink" title="2. 批量删除"></a>2. 批量删除</h2><p>此处不能使用#{ }，因为它会自动添加单引号，那么转换之后，就是” where id in (‘1, 2, 3’) “。显然，没有任何记录满足这个条件，而且也不符合预期。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deleteUserByIn</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> String ids)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- int deleteUserByIn(@Param(&quot;ids&quot;) String ids); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUserByIn&quot;</span>&gt;</span></span><br><span class="line">    delete from t_user where id in ($&#123;ids&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/24/jaRLfrCp9hneSZ1.png" alt="image-20220324102205685"></p>
<h2 id="3-动态设置表名"><a href="#3-动态设置表名" class="headerlink" title="3. 动态设置表名"></a>3. 动态设置表名</h2><p>表名不能加单引号(只能在字符串上加单引号)，所以说，这里不能使用#{ }。</p>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; <span class="title function_">getUserByTableName</span><span class="params">(<span class="meta">@Param(&quot;tableName&quot;)</span> String tableName)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;User&gt; getUserByTableName(@Param(&quot;tableName&quot;) String tableName); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByTableName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select * from $&#123;tableName&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="运行结果-6"><a href="#运行结果-6" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://s2.loli.net/2022/03/24/ytOZvxLrP48UBqh.png" alt="image-20220324104712257"></p>
<h2 id="4-添加功能获取自增的主键"><a href="#4-添加功能获取自增的主键" class="headerlink" title="4. 添加功能获取自增的主键"></a>4. 添加功能获取自增的主键</h2><p>在一对多的情况中，要把表的关系设置在多的这一方，如在学生表中设置其所对应的班级id，那么id作为主键，一般是具有自动递增的特性，想要获取，赋值时一般为空，所以想要获取，需要方法。</p>
<p>由于增加语句的返回值是固定的，所以不能把获得的主键通过返回值传输。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>故而，此处</p>
<p>useGeneratedKeys：设置当前标签中的sql使用了自增的主键</p>
<p>keyProperty：将自增的主键的值赋给传输到映射文件中参数的某个属性，此处将它赋给了id这个属性。</p>
<h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;User&gt; insertUser(User user); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">   insert into t_user values(null, #&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;sex&#125;, #&#123;email&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsertUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">SQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SQLMapper.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>, <span class="string">&quot;wang&quot;</span>,<span class="string">&quot;123456&quot;</span>, <span class="number">23</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;123@163.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.insertUser(user);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    System.out.println(user);</span><br></pre></td></tr></table></figure>
<h3 id="运行结果-7"><a href="#运行结果-7" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://s2.loli.net/2022/03/24/IfcDb3mnli2LMRr.png" alt="image-20220324125314433"></p>
<h1 id="Chapter-7-自定义映射resultMap"><a href="#Chapter-7-自定义映射resultMap" class="headerlink" title="Chapter 7 自定义映射resultMap"></a>Chapter 7 自定义映射resultMap</h1><h2 id="1-字段名和属性名的映射"><a href="#1-字段名和属性名的映射" class="headerlink" title="1. 字段名和属性名的映射"></a>1. 字段名和属性名的映射</h2><p>若字段名和实体类中的属性名一致，则可以通过resultMap设置自定义映射。</p>
<p>字段名用_链接两个单词，而属性名用驼峰式。所以，很容易出现二者不同的情况。</p>
<h3 id="1-解决方法"><a href="#1-解决方法" class="headerlink" title="1. 解决方法"></a>1. 解决方法</h3><h4 id="1-字段起别名"><a href="#1-字段起别名" class="headerlink" title="1. 字段起别名"></a>1. 字段起别名</h4><p>为字段起别名，保持和属性名的一致</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Emp&gt; getAllEmp(); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmp&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 为字段起了和属性名一致的别名 --&gt;</span></span><br><span class="line">    select eid, emp_name empName, age, sex, email from t_emp;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/24/dNZEfjJYWy2wiOR.png" alt="image-20220324161953137"></p>
<h4 id="2-设置全局配置"><a href="#2-设置全局配置" class="headerlink" title="2. 设置全局配置"></a>2. 设置全局配置</h4><p>设置全局配置mapUnderscoreToCamelCase，将字段名中的下划线字段映射为驼峰，但有规则(字段名有字段名的规则，属性有属性的规则)</p>
<ol>
<li>在MyBatis的核心配置文件中，设置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置MyBatis的全局配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将_自动映射为驼峰，但有规则，如em_pname会映射成emPname--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>其余不变</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmp&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- select eid, emp_name empName, age, sex, email from t_emp; --&gt;</span></span><br><span class="line">    select * from t_emp;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-ResultMap"><a href="#3-ResultMap" class="headerlink" title="3. ResultMap"></a>3. ResultMap</h4><p>只在查询中有用，增删改不需要设置映射关系。</p>
<p>resultMap：设置自定义映射关系</p>
<p>id：该标签的唯一标识，不能重复</p>
<p>type：设置映射关系中的实体类类型(即存在属性和字段不匹配的类名)</p>
<p>子标签：</p>
<p>id 对应主键的字段名</p>
<p>result 对应普通的字段名，所有的字段的对应关系，都要写上。</p>
<p>属性：</p>
<p>property是类的属性名(type属性所设置的实体类类型中的属性名)，column是表格的字段名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- List&lt;Emp&gt; getAllEmp(); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmp&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/24/SuryonJHqbxs8jK.png" alt="image-20220324164345930"></p>
<h3 id="2-处理多对一的映射关系"><a href="#2-处理多对一的映射关系" class="headerlink" title="2. 处理多对一的映射关系"></a>2. 处理多对一的映射关系</h3><h4 id="1-级联属性赋值"><a href="#1-级联属性赋值" class="headerlink" title="1. 级联属性赋值"></a>1. 级联属性赋值</h4><p>由于在表格t_emp中，对于Dept属性的描述是一个int类型，所以无法与Dept类进行对应，需要通过级联的方式进行输出dept。</p>
<p><img src="https://s2.loli.net/2022/03/24/oXGxYquBkdlKvZL.png" alt="image-20220324203935704"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Emp getEmpAndDept(@Param(&quot;eid&quot;) Integer eid); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptResultMapOne&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp left join t_dept on t_emp.did = t_dept.did where t_emp.eid = #&#123;eid&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要将级联查出的did、dept_name和dept实体类进行映射，然后赋值给Emp中的dept属性。</p>
<h4 id="2-association标签"><a href="#2-association标签" class="headerlink" title="2. association标签"></a>2. association标签</h4><p>处理多对一的映射关系</p>
<p>property：需要处理多对一关系的属性名</p>
<p>javaType：该属性的类型</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptResultMapOne&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptResultMapTwo&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp left join t_dept on t_emp.did = t_dept.did where t_emp.eid=#&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-分步查询"><a href="#3-分步查询" class="headerlink" title="3. 分步查询(*)"></a>3. 分步查询(*)</h4><p>先查出员工信息，得到部门id，之后通过部门id，去查询部门的信息。</p>
<p>SQL语句的唯一标识即：命名空间+SQL语句的id</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分步查询第一步：查询员工信息，包括部门id</span></span><br><span class="line">Emp <span class="title function_">getEmpAndDeptByStep</span><span class="params">(<span class="meta">@Param(&quot;eid&quot;)</span> Integer eid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分步查询第二步：根据所得部门id，查询部门信息</span></span><br><span class="line">Dept <span class="title function_">getEmpAndDeptByStepTwo</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag">                 &lt;!<span class="attr">--</span> 此处的<span class="attr">SQL</span>语句唯一标识：命名空间+<span class="attr">SQL</span>语句的<span class="attr">id</span>，即<span class="attr">namespace</span>+<span class="attr">SQL</span>的<span class="attr">id</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">                 select=&quot;com.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span><br><span class="line">                 column=&quot;did&quot;&gt;<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Emp getEmpAndDeptByStep(@Param(&quot;eid&quot;) Integer eid); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStep&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;getEmpAndDept&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp where eid = #&#123;eid&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- List&lt;Emp&gt; getAllEmp(); 查询部门信息的SQL语句，放在DeptMapper.xml中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepTwo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">        select * from t_dept where did = #&#123;did&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/25/KNiZ9Bm4UMVaX21.png" alt="image-20220325090413307"></p>
<h4 id="4-延迟加载"><a href="#4-延迟加载" class="headerlink" title="4. 延迟加载"></a>4. 延迟加载</h4><p>分步查询的优点：可以实现延迟加载，但必须在核心配置文件中设置全局配置信息(即将下划线映射为驼峰式的setting标签)</p>
<p>默认不开启延迟加载</p>
<p>lazyLoadingEnabled：延迟加载的全局开关，当开启时，所有关联对象都会延迟加载</p>
<p>aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性(此时，开启的延迟加载无效，所以开启延迟加载，需要关闭这个，不过默认是false，所以不管就行)。否则，每个属性会按需加载。</p>
<p>当<strong>开启了全局配置中的延迟加载</strong>后，此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。那么，<strong>此时可以手动通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType=”lazy(延迟加载)|eager(立即加载)”</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置MyBatis的全局配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 将_自动映射为驼峰，但有规则 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开启延迟加载 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetEmpAndDept</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> mapper.getEmpAndDeptByStep(<span class="number">3</span>);</span><br><span class="line">    System.out.println(emp.getEmpName());</span><br><span class="line">    System.out.println(<span class="string">&quot;abaababa&quot;</span>);</span><br><span class="line">    System.out.println(emp.getDept());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="开启延迟加载"><a href="#开启延迟加载" class="headerlink" title="开启延迟加载"></a>开启延迟加载</h5><p>开启延迟加载，只会执行需要的部分</p>
<p><img src="https://s2.loli.net/2022/03/25/x568dl7Y9VowWHD.png" alt="image-20220325092326758"></p>
<p><img src="https://s2.loli.net/2022/03/25/Uq3Krm4T2gJ5LQk.png" alt="image-20220325092746767"></p>
<h5 id="不开启延迟加载"><a href="#不开启延迟加载" class="headerlink" title="不开启延迟加载"></a>不开启延迟加载</h5><p>不开启延迟加载，SQL语句会先全部执行，之后再获取所需的数据</p>
<p><img src="https://s2.loli.net/2022/03/25/FC7vLsMVBt2gcfz.png" alt="image-20220325092416121"></p>
<p><img src="https://s2.loli.net/2022/03/25/vj63LI9gKJmMVtW.png" alt="image-20220325092709734"></p>
<h2 id="3-处理一对多的映射关系"><a href="#3-处理一对多的映射关系" class="headerlink" title="3. 处理一对多的映射关系"></a>3. 处理一对多的映射关系</h2><p>多对一对应对象，一对多对应集合。</p>
<p>一对多没有级联属性赋值的方式来处理。</p>
<h3 id="1-collection标签"><a href="#1-collection标签" class="headerlink" title="1. collection标签"></a>1. collection标签</h3><p>通过一个SQL，将所有的数据都查出来，然后再让字段一一匹配属性。</p>
<p><strong>collection标签专门用来处理一对多的属性。</strong></p>
<p><strong>ofType：表示该属性所对应的集合中存储数据的类型(集合中的类型)。</strong></p>
<p>association需要知道属性的类型，即javaType，collection需要知道集合中存储的类型，即ofType。</p>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dept <span class="title function_">getDeptAndEmp</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmp&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;empS&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 不需要写部门的信息，否则部门里有员工信息，员工里有部门，部门里还写员工，嵌套了 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Dept getDeptAndEmp(@Param(&quot;did&quot;) Integer did); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmp&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;getDeptAndEmp&quot;</span>&gt;</span></span><br><span class="line">    select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #&#123;did&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetDeptAndEmp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">DeptMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DeptMapper.class);</span><br><span class="line">    <span class="type">Dept</span> <span class="variable">dept</span> <span class="operator">=</span> mapper.getDeptAndEmp(<span class="number">1</span>);</span><br><span class="line">    System.out.println(dept);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行结果-8"><a href="#运行结果-8" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="https://s2.loli.net/2022/03/26/CqFOsYcmvaQJj65.png" alt="image-20220326224811895"></p>
<p><img src="https://s2.loli.net/2022/03/26/Xn8BcOhyIforG3d.png" alt="image-20220326224857079"></p>
<h3 id="2-分步查询"><a href="#2-分步查询" class="headerlink" title="2. 分步查询"></a>2. 分步查询</h3><p>先查出部门信息，再根据部门id查询出所有的员工信息。</p>
<p>column对应分步查询的条件，即查询所依据的列。</p>
<p>分步查询，一般而言，只有第一步需要设置resultMap，第二步只要设置resultType即可。</p>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dept <span class="title function_">getDeptAndEmpStepOne</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br><span class="line"></span><br><span class="line">Emp <span class="title function_">getDeptAndEmpByStep</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpByStep&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;empS&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">select</span>=<span class="string">&quot;com.mybatis.mapper.EmpMapper.getDeptAndEmpByStep&quot;</span></span></span><br><span class="line"><span class="tag">                &lt;!<span class="attr">--</span> <span class="attr">column</span>对应分步查询的条件，即查询所依据的列。 <span class="attr">--</span>&gt;</span></span><br><span class="line">                column=&quot;did&quot;&gt;<span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Dept getDeptAndEmpStepOne(@Param(&quot;did&quot;) Integer did); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;getDeptAndEmpByStep&quot;</span>&gt;</span></span><br><span class="line">    select * from t_dept where did = #&#123;did&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Emp getDeptAndEmpByStep(@Param(&quot;did&quot;) Integer did); --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpByStep&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from t_emp where t_emp.did = #&#123;did&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetDeptAndEmp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">DeptMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DeptMapper.class);</span><br><span class="line">    <span class="type">Dept</span> <span class="variable">dept</span> <span class="operator">=</span> mapper.getDeptAndEmpStepOne(<span class="number">1</span>);</span><br><span class="line">    System.out.println(dept);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行结果-9"><a href="#运行结果-9" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="https://s2.loli.net/2022/03/26/klVIxGBuNYt7DEm.png" alt="image-20220326230104921"></p>
<p><strong>支持延迟加载！！！</strong></p>
<p>字段名和属性名不一致的情况</p>
<p>多对一和一对多的映射</p>
<h1 id="Chapter-8-动态SQL"><a href="#Chapter-8-动态SQL" class="headerlink" title="Chapter 8 动态SQL"></a>Chapter 8 动态SQL</h1><p>MyBatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题。</p>
<p>多条件查询的问题在于，如何去拼接SQL，保证其中某些选择条件不成立时(如age等属性)，没有多余的语句部分(如果所有选择条件都没有，多出来一个where)。</p>
<p>动态SQL指的是映射文件中的一系列标签，通过这些标签，更简单更方便地动态拼接SQL语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Emp&gt; <span class="title function_">getEmpByCondition</span><span class="params">(Emp emp)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetEmpByCondition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">DynamicSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">    List&lt;Emp&gt; list = mapper.getEmpByCondition(<span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>, <span class="literal">null</span>, <span class="number">22</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">    list.forEach(emp -&gt; &#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h2><p>需要判断的前提如下：</p>
<p>如果数据没有传输到服务器中，在服务器中去获取时，就应该传输一个null</p>
<p>如果数据是一个空，没有任何内容，在服务器中去获取时，就应该是一个””(空字符串)。</p>
<h3 id="1-if"><a href="#1-if" class="headerlink" title="1. if(*)"></a>1. if(*)</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>if标签可根据test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行，即不会拼接到SQL语句中。</p>
<p>同时，为了防止where和and这些连接词的多余，此处增加了恒成立条件1=1，这样不仅不会影响查询，而且避免了因连接词多余导致的SQL语句发成语法错误。</p>
<h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">        and emp_name = #&#123;empName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and age = #&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and sex = #&#123;sex&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        email = #&#123;email&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="运行结果-10"><a href="#运行结果-10" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="https://s2.loli.net/2022/03/27/VobeuXKZYdOSQrB.png" alt="image-20220327173201724"></p>
<h3 id="2-where"><a href="#2-where" class="headerlink" title="2. where(*)"></a>2. where(*)</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>当where标签中有内容时，会自动生成where关键字，并且将内容前多余的and或or去掉(如and age = #{age})</p>
<p>当where标签中没有内容时，此时的where标签没有任何效果</p>
<p>注意：where标签不能将其中内容后面多余的and或or去掉(如 age = #{age} and)</p>
<h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">        and emp_name = #&#123;empName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and age = #&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and sex = #&#123;sex&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        email = #&#123;email&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="运行结果-11"><a href="#运行结果-11" class="headerlink" title="运行结果"></a>运行结果</h4><ol>
<li><p><img src="https://s2.loli.net/2022/03/27/cKhnp7EfYiBGrF8.png" alt="image-20220327173327575"></p>
</li>
<li></li>
</ol>
<p><img src="https://s2.loli.net/2022/03/27/NMJeRfzIjD2hAkm.png" alt="image-20220327173418351"></p>
<h3 id="3-trim"><a href="#3-trim" class="headerlink" title="3. trim"></a>3. trim</h3><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>当标签中有内容时，</p>
<p>prefix|suffix：将trim标签中内容前面或后面添加指定内容</p>
<p>prefixOverrides|suffixOverrides：将trim标签中内容前面或后面去掉指定内容</p>
<p>若标签中没有内容，trim标签没有任何效果</p>
<h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and|or&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            emp_name = #&#123;empName&#125; and</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            age = #&#123;age&#125; and</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            sex = #&#123;sex&#125; or</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            email = #&#123;email&#125;;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="运行结果-12"><a href="#运行结果-12" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="https://s2.loli.net/2022/03/27/kOX82QSIdnZ5bNa.png" alt="image-20220327175207944"></p>
<h3 id="4-choose、when、otherwise"><a href="#4-choose、when、otherwise" class="headerlink" title="4. choose、when、otherwise"></a>4. choose、when、otherwise</h3><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p>when和otherwise都需要写在choose标签之中，前者类似于if…else if…，即选择条件中的多个条件，后者相当于else，即其他情况</p>
<p>可以有多个when，只能有一个else</p>
<p>只要满足一个条件，剩下的条件就不再执行</p>
<h4 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Emp&gt; getEmpByChoose(Emp emp); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            emp_name = #&#123;empName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            age = #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            sex = #&#123;sex&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            email = #&#123;email&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Emp&gt; list = mapper.getEmpByChoose(<span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>, <span class="string">&quot;li&quot;</span>, <span class="number">32</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br></pre></td></tr></table></figure>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>以此语句为例，此时并没有满足条件的员工，但是程序运行结果确实li的信息，这说明，此时根本就没有判断年龄是否是32岁，只要有username是li这个员工，自然就会输出。</p>
<p>其与if的区别就在于此，if是每个条件都会判断，即一连串的if语句；但是这个，只要一个条件满足，其余的条件便不再执行，即if…else if…else if…else…</p>
<h4 id="运行结果-13"><a href="#运行结果-13" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="https://s2.loli.net/2022/03/27/elxB1rORNQUFScn.png" alt="image-20220327182625232"></p>
<h3 id="5-foreach"><a href="#5-foreach" class="headerlink" title="5. foreach(*)"></a>5. foreach(*)</h3><h4 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h4><p>collection：设置需要循环的数组或集合</p>
<p>item：表示数组或集合中的每一个数据</p>
<p>separator：各个循环体之间的分隔符</p>
<p>open：foreach标签所循环的所有内容的开始符</p>
<p>close：foreach标签所循环的所有内容的结束符</p>
<p>最后两个很少用，偶尔在where eid in( , , )这种情况下，需要在所有的循环体最外层添加一个()。</p>
<h4 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h4><h5 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deleteMoreByArray</span><span class="params">(<span class="meta">@Param(&quot;eids&quot;)</span> Integer[] eids)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- int deleteMoreByArray(@Param(&quot;eids&quot;) Integer[] eids); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMoreByArray&quot;</span>&gt;</span></span><br><span class="line">    delete from t_emp where</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;eids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;or&quot;</span>&gt;</span></span><br><span class="line">        eid = #&#123;eid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteMore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">DynamicSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.deleteMoreByArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="运行结果-14"><a href="#运行结果-14" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="https://s2.loli.net/2022/03/27/BMieQAXOlmNjd9D.png" alt="image-20220327201859954"></p>
<p><img src="https://s2.loli.net/2022/03/27/UI5drhpX4iucWoJ.png" alt="image-20220327202049922"></p>
<h4 id="批量增加"><a href="#批量增加" class="headerlink" title="批量增加"></a>批量增加</h4><h5 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertMoreByList</span><span class="params">(<span class="meta">@Param(&quot;emps&quot;)</span> List&lt;Emp&gt; emps)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- int insertMoreByList(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertMoreByList&quot;</span>&gt;</span></span><br><span class="line">    insert into t_emp values</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        (null, #&#123;emp.empName&#125;, #&#123;emp.age&#125;, #&#123;emp.sex&#125;, #&#123;emp.email&#125;, null)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsertMore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">DynamicSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>, <span class="string">&quot;a1&quot;</span>, <span class="number">23</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;1234@qq.com&quot;</span>);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>, <span class="string">&quot;a2&quot;</span>, <span class="number">24</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;1234@qq.com&quot;</span>);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>, <span class="string">&quot;a3&quot;</span>, <span class="number">24</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;1234@qq.com&quot;</span>);</span><br><span class="line">    List&lt;Emp&gt; emps = Arrays.asList(emp1, emp2, emp3);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.insertMoreByList(emps);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="运行结果-15"><a href="#运行结果-15" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="https://s2.loli.net/2022/03/27/cKFaetXgzWwm6N2.png" alt="image-20220327204822731"></p>
<p><img src="https://s2.loli.net/2022/03/27/Oih7q6MjU5S28TV.png" alt="image-20220327204852449"></p>
<h3 id="6-sql"><a href="#6-sql" class="headerlink" title="6. sql"></a>6. sql</h3><p>可以将常用的sql片段进行记录</p>
<p>将经常查询的字段放入一个sql片段中。</p>
<p>需要这些字段时，引用这个sql片段即可。</p>
<p><img src="https://s2.loli.net/2022/03/27/kHNyoQSLcueXI2W.png" alt="image-20220327210041125"></p>
<h1 id="Chapter-9-MyBatis的缓存"><a href="#Chapter-9-MyBatis的缓存" class="headerlink" title="Chapter 9 MyBatis的缓存"></a>Chapter 9 MyBatis的缓存</h1><p>缓存是对查询出的数据的记录，如果下次再查询相同的数据，就会直接到缓存中去取，而不用到数据库中。</p>
<p>也就是说，缓存只对查询功能有效。</p>
<h2 id="1-MyBatis的一级缓存"><a href="#1-MyBatis的一级缓存" class="headerlink" title="1. MyBatis的一级缓存"></a>1. MyBatis的一级缓存</h2><p>一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问</p>
<p><img src="https://s2.loli.net/2022/03/28/lhztCpSkyI1MfZQ.png" alt="image-20220328221833402"></p>
<h3 id="一级缓存失效的四种情况"><a href="#一级缓存失效的四种情况" class="headerlink" title="一级缓存失效的四种情况"></a>一级缓存失效的四种情况</h3><ol>
<li>不同的SqlSession对应不同的一级缓存</li>
<li>同一个SqlSession但是查询条件不同</li>
<li>同一个SqlSession两次查询期间执行了任何一次增删改查操作</li>
<li>同一个SqlSession两次查询期间手动清空缓存</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/28/eB1nX6EgWO5a9kT.png" alt="image-20220328222651855"></p>
<h2 id="2-MyBatis的二级缓存"><a href="#2-MyBatis的二级缓存" class="headerlink" title="2. MyBatis的二级缓存"></a>2. MyBatis的二级缓存</h2><p>二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再执行相同的查询语句，结果就会从缓存中获取</p>
<h3 id="1-二级缓存开启的条件"><a href="#1-二级缓存开启的条件" class="headerlink" title="1. 二级缓存开启的条件"></a>1. 二级缓存开启的条件</h3><p>缺一不可</p>
<ol>
<li>在核心配置文件中，设置全局配置属性cacheEnables=”true”，默认为true，不需要设置</li>
<li>在映射文件中设置标签<cache /></li>
<li>二级缓存必须在SqlSession关闭或提交之后有效(sqlSession.commit(); sqlSession.close()，没有提交和关闭就保存在一级缓存，之后才在二级缓存中)</li>
<li>查询的数据所转换的实体类类型必须实现序列化的接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">&lt;cache /&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 通过SqlSessionFactory获取两个SqlSession对象</span></span><br><span class="line">sqlSession1.close();</span><br><span class="line">sqlSession2.close();</span><br></pre></td></tr></table></figure>
<h4 id="运行结果-16"><a href="#运行结果-16" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="https://s2.loli.net/2022/03/28/taGXJFS43POLUEd.png" alt="image-20220328225506938"></p>
<h3 id="2-二级缓存失效"><a href="#2-二级缓存失效" class="headerlink" title="2. 二级缓存失效"></a>2. 二级缓存失效</h3><p>两次查询之间执行了任意的增删查改，会使一级和二级缓存同时失效。</p>
<h3 id="简析"><a href="#简析" class="headerlink" title="简析"></a>简析</h3><p>因为要保证查询数据的真实性，所以一旦数据库中数据发生改变，缓存就会失效。</p>
<h3 id="3-二级缓存的相关配置"><a href="#3-二级缓存的相关配置" class="headerlink" title="3. 二级缓存的相关配置"></a>3. 二级缓存的相关配置</h3><p>了解</p>
<p><img src="https://s2.loli.net/2022/03/28/UZoSO9riXJmyERF.png" alt="image-20220328230111679"></p>
<h2 id="3-MyBatis缓存查询顺序"><a href="#3-MyBatis缓存查询顺序" class="headerlink" title="3. MyBatis缓存查询顺序"></a>3. MyBatis缓存查询顺序</h2><p>二级缓存大，所以先搜索大范围，没有的话，再去搜索小范围。</p>
<ul>
<li>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接用</li>
<li>如果二级缓存没有命中，再查询一级缓存</li>
<li>如果一级缓存也没有命中，则查询数据库</li>
<li>SqlSession关闭之后，一级缓存中的数据会写入二级缓存中</li>
</ul>
<h2 id="5-整合第三方缓存EHCache"><a href="#5-整合第三方缓存EHCache" class="headerlink" title="5. 整合第三方缓存EHCache"></a>5. 整合第三方缓存EHCache</h2><p>从内存中读快于从磁盘上读，所以缓存的存在，很有意义。</p>
<p>MyBatis作为一个持久层框架，做缓存的能力有待提高，所以可以使用第三方的技术来代替MyBatis的二级缓存，但是一级缓存无法被代替。</p>
<p>只要会配，简单地了解一下就可以。</p>
<h3 id="1-引入依赖-1"><a href="#1-引入依赖-1" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyBatis EHCache整合包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- slf4j日志门面(规定接口)的一个具体实现(具体的方式) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-各jar包功能"><a href="#2-各jar包功能" class="headerlink" title="2. 各jar包功能"></a>2. 各jar包功能</h3><div class="table-container">
<table>
<thead>
<tr>
<th>jar包名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>mybatis-ehcache</td>
<td>MyBatis和EHCache的整合包</td>
</tr>
<tr>
<td>ehcache</td>
<td>EHCache核心包</td>
</tr>
<tr>
<td>slf4j-api</td>
<td>SLF4j日志门面包</td>
</tr>
<tr>
<td>logback-classic</td>
<td>支持SLF4j门面接口的一个具体实现</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-创建EHCache的配置文件ehcache-xml"><a href="#3-创建EHCache的配置文件ehcache-xml" class="headerlink" title="3. 创建EHCache的配置文件ehcache.xml"></a>3. 创建EHCache的配置文件ehcache.xml</h3><p>名称固定为ehcache.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span> = <span class="string">&quot;../config/ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 磁盘保存路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;E:\ehcache&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">    	&lt;!<span class="attr">--</span> 在内存中缓存的<span class="attr">element</span>的最大数目，必须配置 <span class="attr">--</span>&gt;</span></span><br><span class="line">        maxElementsMemory=&quot;1000&quot;</span><br><span class="line">    	<span class="comment">&lt;!-- 在磁盘上缓存的element的最大数目，若是0表示无穷大，必须有的 --&gt;</span></span><br><span class="line">        maxElementsOnDisk=&quot;1000000&quot;</span><br><span class="line">    <span class="comment">&lt;!-- 设置缓存的elements是否永远不过期，如果为true，则缓存的数据始终有效，如果是false还要根据timeToIdleSeconds、 timeToLiveSeconds判断，必须有 --&gt;</span></span><br><span class="line">        eternal=&quot;false&quot;</span><br><span class="line">    <span class="comment">&lt;!-- 设定当内存缓存溢出时，是否将过期的element缓存到磁盘上，必须有 --&gt;</span></span><br><span class="line">        overflowToDisk=&quot;true&quot;</span><br><span class="line">    <span class="comment">&lt;!-- 当缓存在EHCache中的数据前后两次的访问时间超过timeToIdleSeconds的取值时，这些数据便会删除， 默认值是0，也就是可闲置时间无穷大，不是必须 --&gt;</span></span><br><span class="line">        timeToIdleSeconds=&quot;120&quot;</span><br><span class="line">    <span class="comment">&lt;!-- 缓存element的有效生命期，默认是0，也就是存活时间无穷大，非必须 --&gt;</span></span><br><span class="line">        timeToLiveSeconds=&quot;120&quot;</span><br><span class="line">    <span class="comment">&lt;!-- diskSpoolBufferSizeMB：DiskStore的缓存区大小，默认是30MB，每个Cache都应该有自己的一个缓冲区，非必须 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	磁盘缓存的清理线程运行间隔，默认是120s。每隔120s，相应的线程会进行一次EhCache中数据的清理工作，非必须 --&gt;</span></span><br><span class="line">        diskExpiryThreadIntervalSeconds=&quot;120&quot;</span><br><span class="line">    <span class="comment">&lt;!-- diskPersistent：在VM重启时，是否启用磁盘保存EhCache中的数据，默认是false，非必须</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 当内存缓存达到最大，有新的element加入的时候，移除缓存中element的策略，默认是LRU(最近最少使用)，还可取LFU (最不常使用)和FIFO(先进先出)，非必须 --&gt;</span></span><br><span class="line">        memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-设置二级缓存类型"><a href="#4-设置二级缓存类型" class="headerlink" title="4. 设置二级缓存类型"></a>4. 设置二级缓存类型</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-加入logback日志配置文件"><a href="#5-加入logback日志配置文件" class="headerlink" title="5. 加入logback日志配置文件"></a>5. 加入logback日志配置文件</h3><p>存在SLF4j时，作为简易日志的log4j将失效，此时需要借助SLF4j的具体实现logback来打印日志</p>
<p>创建logback的配置文件logback.xml，名称固定</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定日志输出的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志输出的格式 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置全局日志级别，日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定打印日志的appender，这里通过STDOUT引用了前面配置的appender --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 根据特殊需求指定局部日志级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.mybatis.mapper&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="Chapter-10-MyBatis的逆向工程"><a href="#Chapter-10-MyBatis的逆向工程" class="headerlink" title="Chapter 10 MyBatis的逆向工程"></a>Chapter 10 MyBatis的逆向工程</h1><h2 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h2><p>正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate支持正向工程。</p>
<p>逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：</p>
<ul>
<li>Java实体类</li>
<li>Mapper接口</li>
<li>Mapper映射文件</li>
</ul>
<h2 id="1-创建逆向工程的步骤-简洁版"><a href="#1-创建逆向工程的步骤-简洁版" class="headerlink" title="1. 创建逆向工程的步骤(简洁版)"></a>1. 创建逆向工程的步骤(简洁版)</h2><h3 id="1-引入依赖-pom-xml"><a href="#1-引入依赖-pom-xml" class="headerlink" title="1. 引入依赖 pom.xml"></a>1. 引入依赖 pom.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MyBatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MyBatis-MBG<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- MyBatis核心包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 控制Maven在构建过程中相关配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 构建过程中用到的插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 具体插件，逆向工程的操作是以构建过程中的插件形式出现的 --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">&lt;!-- 插件的依赖 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                   <span class="comment">&lt;!-- 逆向工程的核心依赖 --&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                   <span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                   <span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-创建MyBatis的核心配置文件-1"><a href="#2-创建MyBatis的核心配置文件-1" class="headerlink" title="2. 创建MyBatis的核心配置文件"></a>2. 创建MyBatis的核心配置文件</h3><p>没有核心配置文件，哪儿来的数据库连接环境。</p>
<h3 id="3-逆向工程的配置文件"><a href="#3-逆向工程的配置文件" class="headerlink" title="3. 逆向工程的配置文件"></a>3. 逆向工程的配置文件</h3><p>名称固定：generatorConfig.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        targetRuntime：执行生成的 逆向工程的版本</span></span><br><span class="line"><span class="comment">        MyBatis3Simple：生成基本的CRUD(清新简洁版)</span></span><br><span class="line"><span class="comment">        MyBatis3：生成带条件的CRUD(豪华尊享版)</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3Simple&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库连接信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;root12345&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- JavaBean的生成策略，即实体类</span></span><br><span class="line"><span class="comment">			第一个中的true表示 设置.为一层目录，即可以使用子包</span></span><br><span class="line"><span class="comment"> 			第二个为 将字段名转换为属性名时，去掉字段名中的空格。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.mybatis.bean&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SQL映射文件的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.mybatis.mapper&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\resources&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Mapper接口的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.mybatis.mapper&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 逆向分析的表 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- tableName设置为*，可以对应所有的表，此时不写domainObjectName --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_emp&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Emp&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_dept&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Dept&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="执行一下"><a href="#执行一下" class="headerlink" title="执行一下"></a>执行一下</h3><p>双击图示</p>
<p><img src="https://s2.loli.net/2022/03/30/nYgLklBe2VQfbiA.png" alt="image-20220330212316860"></p>
<h4 id="执行结果1"><a href="#执行结果1" class="headerlink" title="执行结果1"></a>执行结果1</h4><p><img src="https://s2.loli.net/2022/03/30/F6gV4kRrf7bnDhz.png" alt="image-20220330212427006"></p>
<h4 id="执行结果2"><a href="#执行结果2" class="headerlink" title="执行结果2"></a>执行结果2</h4><p><img src="https://s2.loli.net/2022/03/30/9qoEAK42lX5amRJ.png" alt="image-20220330212556112"></p>
<h2 id="2-创建逆向工程-豪华尊享版"><a href="#2-创建逆向工程-豪华尊享版" class="headerlink" title="2. 创建逆向工程(豪华尊享版)(*)"></a>2. 创建逆向工程(豪华尊享版)(*)</h2><h3 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1. 步骤"></a>1. 步骤</h3><p>1、首先将逆向工程配置文件中</p>
<p><img src="https://s2.loli.net/2022/03/30/GRu5WdgQmyfB9Se.png" alt="image-20220330215221040"></p>
<p>改为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>表示创建的是豪华尊享版。</p>
<p>2、<img src="https://s2.loli.net/2022/03/30/nYgLklBe2VQfbiA.png" alt="image-20220330212316860"></p>
<p>3、<img src="https://s2.loli.net/2022/03/30/PqwNVRXrdgMLf7D.png" alt="image-20220330215413518"></p>
<p><img src="https://s2.loli.net/2022/03/30/n4XCzWm5E7dVxLr.png" alt="image-20220330215440649"></p>
<p>可以发现，多了很多东西。</p>
<p>另外，存在example的地方，即根据条件来进行操作。</p>
<h4 id="一些区别"><a href="#一些区别" class="headerlink" title="一些区别"></a>一些区别</h4><p>如果属性值为null，普通插入会直接赋值属性为null，但选择性插入就不会让该属性出现在添加字段中，但其实最后该属性的值还是null(没赋值，自动就给值为null)。</p>
<p>修改时，如果属性赋值为null，普通修改会将该属性的值修改为null，但选择性修改则不会修改该属性的值。</p>
<h3 id="2-测试"><a href="#2-测试" class="headerlink" title="2. 测试"></a>2. 测试</h3><p>QBC风格：Query By Criteria。</p>
<h4 id="1-代码一"><a href="#1-代码一" class="headerlink" title="1. 代码一"></a>1. 代码一</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMBG</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resource</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resource);</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"></span><br><span class="line">        List&lt;Emp&gt; list = mapper.selectByExample(<span class="literal">null</span>);</span><br><span class="line">        list.forEach(emp -&gt; System.out.println(emp));</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行结果-17"><a href="#运行结果-17" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="https://s2.loli.net/2022/03/30/Dh7eS2QrbGUdLHg.png" alt="image-20220330221027037"></p>
<h4 id="2-代码二"><a href="#2-代码二" class="headerlink" title="2. 代码二"></a>2. 代码二</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMBG</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resource</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resource);</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*List&lt;Emp&gt; list = mapper.selectByExample(null);</span></span><br><span class="line"><span class="comment">        list.forEach(emp -&gt; System.out.println(emp));*/</span></span><br><span class="line"></span><br><span class="line">        <span class="type">EmpExample</span> <span class="variable">empExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmpExample</span>();</span><br><span class="line">        empExample.createCriteria().andEmpNameEqualTo(<span class="string">&quot;zhang&quot;</span>).andAgeGreaterThan(<span class="number">20</span>);</span><br><span class="line">        empExample.or().andDidIsNotNull();</span><br><span class="line">        List&lt;Emp&gt; list = mapper.selectByExample(empExample);</span><br><span class="line">        list.forEach(emp -&gt; System.out.println(emp));</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行结果-18"><a href="#运行结果-18" class="headerlink" title="运行结果"></a>运行结果</h4><p>可以发现用or连接两个部分：</p>
<p><img src="https://s2.loli.net/2022/03/30/wILvBm5OXas29rz.png" alt="image-20220330221423172"></p>
<p><img src="https://s2.loli.net/2022/03/30/FjOx2uVg3YXAGt8.png" alt="image-20220330221446539"></p>
<p>好用！</p>
<h1 id="Chapter-11-分页插件"><a href="#Chapter-11-分页插件" class="headerlink" title="Chapter 11 分页插件"></a>Chapter 11 分页插件</h1><h2 id="1-分页插件使用步骤"><a href="#1-分页插件使用步骤" class="headerlink" title="1. 分页插件使用步骤"></a>1. 分页插件使用步骤</h2><p>在SQL语句中，存在于limit后，即</p>
<p>limit index，pageSize</p>
<p>index：当前页的起始索引(索引从0开始)</p>
<p>pageSize：每页显示的条数</p>
<h3 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-配置分页插件"><a href="#2-配置分页插件" class="headerlink" title="2. 配置分页插件"></a>2. 配置分页插件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置分页插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-分页插件的使用"><a href="#2-分页插件的使用" class="headerlink" title="2. 分页插件的使用"></a>2. 分页插件的使用</h2><p>使用MyBatis的分页插件实现分页功能：</p>
<ol>
<li><p>需要在查询功能之前开启分页</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PageHelper.startPage(<span class="type">int</span> pageNum, <span class="type">int</span> pageSize);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在查询功能之后获取分页相关信息</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list表示分页数据，5表示当前导航分页的数量</span></span><br><span class="line">PageInfo&lt;Emp&gt; page = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(list, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>常用数据：</p>
<p>pageNum：当前页的页码</p>
<p>pageSize：每页显示的条数</p>
<p>size：当前页现实的真实条数</p>
<p>total：总记录数</p>
<p>pages：总页数</p>
<p>prePage：上一页的页码</p>
<p>nextPage：下一页的页码</p>
<p>isFirstPage/isLastPage：是否为第一页/最后一页</p>
<p>hasPreviousPage/hasNextPage：是否存在上一页/下一页</p>
<p>navigatePage：导航分页的页码数</p>
<p>navigatepageNums：导航分页的页码，[1,2,3,4,5]</p>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>面经</title>
    <url>/2022/03/12/%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>JavaSE、JavaWeb、框架的学习。看网课，博客文章，专栏总结，写博客加深理解</p>
<p>复习基础知识</p>
<p>多线程、集合类的相关知识</p>
<p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220312131749056.png" alt="image-20220312131749056"></p>
<p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220312132650637.png" alt="image-20220312132650637"></p>
]]></content>
      <tags>
        <tag>some future</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/14/%E9%B8%AD%E5%AD%90%E8%A1%8C%E4%B8%BA/</url>
    <content><![CDATA[<h1 id="鸭子行为"><a href="#鸭子行为" class="headerlink" title="鸭子行为"></a>鸭子行为</h1><p>在原有系统的基础上，给鸭子增加会飞这一行为。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="在Duck类中增加方法"><a href="#在Duck类中增加方法" class="headerlink" title="在Duck类中增加方法"></a>在Duck类中增加方法</h3><p>在Duck类中，增加fly()和quark()方法，让每个子类都拥有飞行和呱呱叫的行为，对于无法飞行和叫的鸭子，可以覆盖重写这两个方法。</p>
<h3 id="需要逐个判断，重写多次"><a href="#需要逐个判断，重写多次" class="headerlink" title="需要逐个判断，重写多次"></a>需要逐个判断，重写多次</h3><p>每次都需要重写。即每次新增一个鸭子类型，都需要检查fly()和quark()方法，以确定是否需要重写，维护成本高。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="分别放入两个接口中，按需实现"><a href="#分别放入两个接口中，按需实现" class="headerlink" title="分别放入两个接口中，按需实现"></a>分别放入两个接口中，按需实现</h3><p>使会飞和会呱呱叫的鸭子，分别实现这两个接口<br>根据鸭子的特性，分别实现这两个接口</p>
<h3 id="重复的代码增多，重用性降低"><a href="#重复的代码增多，重用性降低" class="headerlink" title="重复的代码增多，重用性降低"></a>重复的代码增多，重用性降低</h3><h2 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h2><h3 id="将会变化的部分取出，单独封装"><a href="#将会变化的部分取出，单独封装" class="headerlink" title="将会变化的部分取出，单独封装"></a>将会变化的部分取出，单独封装</h3><p>即将fly()和quark()两个方法作为两个接口，单独存放</p>
<h2 id="针对接口"><a href="#针对接口" class="headerlink" title="针对接口"></a>针对接口</h2><h3 id="利用多态，将接口作为引用类型"><a href="#利用多态，将接口作为引用类型" class="headerlink" title="利用多态，将接口作为引用类型"></a>利用多态，将接口作为引用类型</h3><p>将接口作为引用，其指向的对象是具体的接口的实现类。<br>利用多态它动态绑定的特性，在运行时才确定具体调用是哪个方法。<br>还可以动态更改行为，即利用setter method来更改预先设定的鸭子的行为。</p>
<h2 id="多用组合"><a href="#多用组合" class="headerlink" title="多用组合"></a>多用组合</h2><h3 id="has-a要优于is-a"><a href="#has-a要优于is-a" class="headerlink" title="has-a要优于is-a"></a>has-a要优于is-a</h3><p>使用组合建立系统具有很大的弹性，不仅可将算法族封装成类，更可以在运行时动态地改变行为。</p>
]]></content>
  </entry>
  <entry>
    <title>Head_First_设计模式</title>
    <url>/2022/02/22/Head_First_Design_Pattern/</url>
    <content><![CDATA[<h1 id="Chapter-1-设计模式入门"><a href="#Chapter-1-设计模式入门" class="headerlink" title="Chapter 1 设计模式入门"></a>Chapter 1 设计模式入门</h1><p>建立可维护的OO系统，要诀就在于随时想到一同以后可能需要的变化以及应付变化的原则。</p>
<h2 id="1-第一个设计原则"><a href="#1-第一个设计原则" class="headerlink" title="1. 第一个设计原则"></a>1. 第一个设计原则</h2><p><strong>封装变化</strong></p>
<p>找出应用中可能需要变化之处，把它们独立起来，不要和那些不需要变化的代码混在一起。</p>
<h2 id="2-第二个设计原则"><a href="#2-第二个设计原则" class="headerlink" title="2. 第二个设计原则"></a>2. 第二个设计原则</h2><p><strong>针对接口编程，而不是针对实现编程。</strong></p>
<p>行为是通过Duck超类的具体实现或继承某个接口的子类自行实现而来，即所谓针对实现编程。</p>
<p>鸭子的子类将使用接口所表示的行为，便是一种意义上的针对接口编程。</p>
<p>其实，针对接口，实际上是针对超类型编程，并不是直观意义上的Java interface类型。</p>
<p>而针对接口编程，关键就在多态。利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为，而不会被绑死在超类型的行为上。”针对超类型编程”，可以更明确说成”变量的声明类型应该是超类型，通常是一个抽象类或者是一个接口，如此，只要是具体实现此超类型的类所产生的对象，都可以指定给这个变量。这也意味着，声明类时不用理会以后执行时的真正对象类型！”</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>针对实现编程：Dog d = new Dog(); d.bark();</p>
<p>针对接口编程：Animal a = new Dog(); a.makeSound();</p>
<p><img src="https://s2.loli.net/2022/03/12/qUXn9Y7HkoA35Sl.png" alt="image-20220312194627080" style="zoom:80%;" /></p>
<p>在运行时，才指定具体的实现的对象。</p>
<h4 id="动态设定行为"><a href="#动态设定行为" class="headerlink" title="动态设定行为"></a>动态设定行为</h4><p>可以通过”设定方法(setter method)”来在方法内部设定鸭子的行为。</p>
<h2 id="3-第三个设计原则"><a href="#3-第三个设计原则" class="headerlink" title="3. 第三个设计原则"></a>3. 第三个设计原则</h2><p><strong>多用组合，少用继承。</strong></p>
<p>不再把鸭子的行为说成是”一组行为”，而开始把行为想成是”一族算法”。再SimUDuck的设计中，算法代表鸭子能做的事。</p>
<h4 id="“有一个”可能比”是一个”更好"><a href="#“有一个”可能比”是一个”更好" class="headerlink" title="“有一个”可能比”是一个”更好"></a>“有一个”可能比”是一个”更好</h4><p>每个鸭子都有一个FlyBehavior和一个QuarkBehavior，好将飞行和呱呱叫委托给它们代为处理。</p>
<p>当你将两个类结合起来使用，如同本例一样，这就是组合。</p>
<p>使用组合建立系统具有很大的弹性，不仅可将算法族封装成类，更可以在运行时动态地改变行为。</p>
<h2 id="4-策略模式"><a href="#4-策略模式" class="headerlink" title="4. 策略模式"></a>4. 策略模式</h2><p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>
<p><img src="https://s2.loli.net/2022/03/12/VrCsmPQFBw32nMJ.png" alt="image-20220312200432241"></p>
<p>模式不是代码，而是针对设计问题的通用解决方法。</p>
<h2 id="5-tips"><a href="#5-tips" class="headerlink" title="5. tips"></a>5. tips</h2><h4 id="OO基础"><a href="#OO基础" class="headerlink" title="OO基础"></a>OO基础</h4><ul>
<li>抽象</li>
<li>封装</li>
<li>多态</li>
<li>继承</li>
</ul>
<h4 id="OO原则"><a href="#OO原则" class="headerlink" title="OO原则"></a>OO原则</h4><ul>
<li>封装变化</li>
<li>多用组合，少用继承</li>
<li>针对接口编程，不针对实现编程</li>
</ul>
<h2 id="6-总结过程"><a href="#6-总结过程" class="headerlink" title="6. 总结过程"></a>6. 总结过程</h2><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><p>在原有系统的基础上，给鸭子增加会飞这一行为。</p>
<p> <a href="E:\CS\鸭子行为.xmind">鸭子行为.xmind</a> </p>
<p><img src="https://s2.loli.net/2022/03/14/l8Eyksr4ovcTm2b.png" alt="鸭子行为"></p>
<h3 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MiniDuckSimulator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Duck</span> <span class="variable">mallard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MallardDuck</span>();</span><br><span class="line">        mallard.performFly();</span><br><span class="line">        mallard.performQuark();</span><br><span class="line">        mallard.setFlyBehavior(<span class="keyword">new</span> <span class="title class_">FlyNoWay</span>());</span><br><span class="line">        mallard.setQuackBehavior(<span class="keyword">new</span> <span class="title class_">MuteQuark</span>());</span><br><span class="line">        mallard.performQuark();</span><br><span class="line">        mallard.performFly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Chapter-2-观察者-Observer-模式"><a href="#Chapter-2-观察者-Observer-模式" class="headerlink" title="Chapter 2 观察者(Observer)模式"></a>Chapter 2 观察者(Observer)模式</h1><h2 id="1-定义观察者模式"><a href="#1-定义观察者模式" class="headerlink" title="1. 定义观察者模式"></a>1. 定义观察者模式</h2><p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p>
<p><img src="https://s2.loli.net/2022/03/15/tczoSCNpTxsjl4A.png" alt="image-20220315171227252"></p>
<p>实现观察者模式的方法不止一种，但是以包含Subject和Observer接口的类设计的做法最常见。</p>
<h2 id="2-松耦合"><a href="#2-松耦合" class="headerlink" title="2. 松耦合"></a>2. 松耦合</h2><p>当两个对象松耦合时，它们依然可以交互，但是不太清楚彼此的细节。</p>
<p>观察者模式提供了一种对象设计，让主题和观察者之间松耦合。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>关于观察者的一切，主题只知道观察者实现了某个接口(Observer接口)。主题不需要知道观察者的具体类以及做了什么。</p>
<p>任何时候，我们都可以新增观察者。因为主题唯一依赖的是一个实现了Observer接口的对象列表。事实上，就算在运行时用心地观察着取代现有的观察者，主题不会受到任何影响。</p>
<p>有新类型的观察者出现时，主题的代码不需要修改。所有要做的只是在新的类里实现观察者接口，然后注册为观察者即可。</p>
<h2 id="3-第四个设计原则"><a href="#3-第四个设计原则" class="headerlink" title="3. 第四个设计原则"></a>3. 第四个设计原则</h2><p>为了交互对象的松耦合设计而努力。</p>
<p>松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低。</p>
<h2 id="4-气象站"><a href="#4-气象站" class="headerlink" title="4. 气象站"></a>4. 气象站</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://s2.loli.net/2022/03/15/mgf5ciDBNqFYnCX.png" alt="image-20220315172330150"></p>
<p>在主题接口中，需要方法来注册观察者、删除观察者和通知观察者状态。</p>
<p>在WeatherData类中，需要有一个列表ArrayList，在构造器中建立，记录当前的所有观察者，以便push改变后的状态给所有观察者。</p>
<p>布告板要实现Observer接口和DisplayElement接口，以获取更新(update()方法)并展示当前的内容(display()方法)</p>
<h3 id="代码展示-1"><a href="#代码展示-1" class="headerlink" title="代码展示"></a>代码展示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherDatas</span> <span class="keyword">implements</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc: 记录观察者，在构造器中建立</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/15 0:13</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList observers;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherDatas</span><span class="params">()</span> &#123;</span><br><span class="line">        observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; observers.size(); i++) &#123;</span><br><span class="line">            <span class="type">Observer</span> <span class="variable">observer</span> <span class="operator">=</span> (Observer) observers.get(i);</span><br><span class="line">            observer.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc: 当气象站得到更新观测值时，通知观察者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/14 18:38</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measurementsChanged</span><span class="params">()</span> &#123;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMeasurements</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-Java内置的观察者模式"><a href="#5-Java内置的观察者模式" class="headerlink" title="5. Java内置的观察者模式"></a>5. Java内置的观察者模式</h2><p>Java API中有内置的观察者模式。java.util包中包含最基本的Observer接口和Observable类。</p>
<h3 id="1-修改后的类图"><a href="#1-修改后的类图" class="headerlink" title="1. 修改后的类图"></a>1. 修改后的类图</h3><p><img src="https://s2.loli.net/2022/03/15/rPdnWUevOwSg7Xc.png" alt="image-20220315174217295"></p>
<h4 id="1-把对象变为观察者"><a href="#1-把对象变为观察者" class="headerlink" title="1. 把对象变为观察者"></a>1. 把对象变为观察者</h4><ol>
<li>实现观察者接口</li>
<li>调用Observable对象的addObserver方法</li>
<li>不想当观察者时，调用deleteObservable方法</li>
</ol>
<h4 id="2-观察者送出通知"><a href="#2-观察者送出通知" class="headerlink" title="2. 观察者送出通知"></a>2. 观察者送出通知</h4><ol>
<li>扩展java.util.Observable接口产生”可观察者”类</li>
<li>调用setChanged()方法，标记状态改变的事实</li>
<li>调用notifyObservers()(观察者自己pull数据)或notifyObservers(Object arg)(主题push数据给观察者)</li>
</ol>
<h4 id="3-观察者接收数据"><a href="#3-观察者接收数据" class="headerlink" title="3. 观察者接收数据"></a>3. 观察者接收数据</h4><p>观察者实现了更新的方法，但是方法签名不同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数标识主题</span></span><br><span class="line"><span class="comment">// 第二个参数是从主题处push的数据，即传入notifyObservers()的数据对象</span></span><br><span class="line">update(Observable o, Object arg)</span><br></pre></td></tr></table></figure>
<h4 id="4-关于setChanged"><a href="#4-关于setChanged" class="headerlink" title="4. 关于setChanged"></a>4. 关于setChanged</h4><p>setChanged方法用来标记状态已经改变的事实。</p>
<p>如果调用notifyObserver()之前没有先调用setChanged()，观察者就不会被通知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setChanged() &#123;</span><br><span class="line">    changed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">notifyObservers(Object arg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">        <span class="keyword">for</span> every observer on the list &#123;</span><br><span class="line">            call <span class="title function_">update</span><span class="params">(<span class="built_in">this</span>, arg)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        changed = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">notifyObservers() &#123;</span><br><span class="line">    notifyObservers(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-java-util-Observable"><a href="#2-java-util-Observable" class="headerlink" title="2. java.util.Observable"></a>2. java.util.Observable</h3><p>它的实现有许多问题，限制了它的使用和复用。</p>
<h4 id="Observable是一个类"><a href="#Observable是一个类" class="headerlink" title="Observable是一个类"></a>Observable是一个类</h4><ol>
<li>必须设计一个类继承它，由于Java不支持多重继承，这就使得不能同时继承Observable类和另一个超类，限制了Observable的复用潜力</li>
<li>因为没有Observable接口，无法建立自己的实现，和Java内置的Observable API搭配使用</li>
<li>将关键的方法保护起来，即setChanged方法被protected。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>有多个观察者时，不可以依赖特定的通知次序</p>
</li>
<li><p>使用此模式，可以由被观察者处推push或观察者拉pull数据</p>
</li>
<li><p>观察者和可观察者之间用松耦合方式结合( loosecoupling ) ，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/15/AQc8iSnM1263gOj.png" alt="image-20220315181625798"></p>
<h1 id="Chapter-3-装饰者模式"><a href="#Chapter-3-装饰者模式" class="headerlink" title="Chapter 3 装饰者模式"></a>Chapter 3 装饰者模式</h1><p>可以在不修改任何底层代码的情况下，给对象赋予新的职责。</p>
<p>引入星巴兹的故事。</p>
<p>通过动态地组合对象，可以写新的代码增加新功能，而无需修改现有代码，可以减少引进bug和产生副作用。</p>
<p>代码应该免于改变，能够拓展。</p>
<h2 id="1-第五个设计原则"><a href="#1-第五个设计原则" class="headerlink" title="1. 第五个设计原则"></a>1. 第五个设计原则</h2><p><strong>开放-关闭原则</strong></p>
<p><strong>类应该对拓展开放，对修改关闭。</strong></p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>这样，在不修改现有代码的基础上，就可搭配新的行为，设计具有弹性，可以接受新的功能来应对改变的需求。</p>
<p>将注意力集中在设计中最有可能改变的地方，然后应用开放-关闭原则。</p>
<h2 id="2-装饰者模式"><a href="#2-装饰者模式" class="headerlink" title="2. 装饰者模式"></a>2. 装饰者模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>装饰者模式动态地将责任附加到对象上。若要拓展功能，装饰提供了比继承更有弹性的替代方案。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>装饰者和被装饰对象有相同的超类型</li>
<li>可以用一个或多个装饰者包装一个对象</li>
<li>可以在任何需要原始对象(被包装对象)的场合，用装饰过的对象替代它</li>
<li>装饰者可以在所委托的被装饰者的行为之前或(/与)之后，加上自己的行为，以达到特定的目的</li>
<li>对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用装饰者来装饰对象</li>
</ul>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="https://s2.loli.net/2022/03/19/QIStJgXo5yMcG1s.png" alt="image-20220319182432157"></p>
<h2 id="3-回到星巴兹"><a href="#3-回到星巴兹" class="headerlink" title="3. 回到星巴兹"></a>3. 回到星巴兹</h2><h3 id="1-类图"><a href="#1-类图" class="headerlink" title="1. 类图"></a>1. 类图</h3><p><img src="https://s2.loli.net/2022/03/19/sWNk9LT27bcIOvF.png" alt="image-20220319182722745"></p>
<h3 id="2-装饰者模式下的cost"><a href="#2-装饰者模式下的cost" class="headerlink" title="2. 装饰者模式下的cost"></a>2. 装饰者模式下的cost</h3><p><img src="https://s2.loli.net/2022/03/19/U6iFmjsoKNSqGy5.png" alt="image-20220319182833028"></p>
<h3 id="3-继承？"><a href="#3-继承？" class="headerlink" title="3. 继承？"></a>3. 继承？</h3><p>装饰者和被装饰者必须是一样的类型，也就是拥有相同的超类。所以在这里，我们<strong>使用继承来达到”类型匹配”，而不是利用继承来获得”行为”</strong>。</p>
<p>也就是说，使用Beverage抽象类，是为了保证拥有正确的类型，而不是继承它的行为。行为来自装饰者和基础组件，或与其他装饰者之间的组合关系。</p>
<p>通常装饰者模式是采用抽象类，但是在Java中可以使用接口。</p>
<h3 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StarBuzzCoffee</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Beverage</span> <span class="variable">beverage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Espresso</span>();</span><br><span class="line">        System.out.println(beverage.getDescription() + <span class="string">&quot; $&quot;</span> + beverage.cost());</span><br><span class="line"></span><br><span class="line">        <span class="type">Beverage</span> <span class="variable">beverage2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DarkRoast</span>();</span><br><span class="line">        beverage2 = <span class="keyword">new</span> <span class="title class_">Mocha</span>(beverage2);</span><br><span class="line">        beverage2 = <span class="keyword">new</span> <span class="title class_">Mocha</span>(beverage2);</span><br><span class="line">        beverage2 = <span class="keyword">new</span> <span class="title class_">Whip</span>(beverage2);</span><br><span class="line">        System.out.println(beverage2.getDescription() + <span class="string">&quot; $&quot;</span> + beverage2.cost());</span><br><span class="line"></span><br><span class="line">        <span class="type">Beverage</span> <span class="variable">beverage3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseBlend</span>();</span><br><span class="line">        beverage3 = <span class="keyword">new</span> <span class="title class_">Soy</span>(beverage3);</span><br><span class="line">        beverage3 = <span class="keyword">new</span> <span class="title class_">Mocha</span>(beverage3);</span><br><span class="line">        beverage3 = <span class="keyword">new</span> <span class="title class_">Whip</span>(beverage3);</span><br><span class="line">        System.out.println(beverage3.getDescription() + <span class="string">&quot; $&quot;</span> + beverage3.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-others"><a href="#5-others" class="headerlink" title="5. others"></a>5. others</h3><p>如果把代码写成依赖于具体的组件类型，那么装饰者就会导致程序出问题。只有在针对抽象组件类型编程时，才不会因为装饰者而受到影响。</p>
<p>装饰者该做的事，就是增加行为到被包装对象上。当需要窥视装饰者链中的每一个装饰者，这就超出他们的天赋了，但并非做不到。</p>
<h2 id="4-Java-I-O"><a href="#4-Java-I-O" class="headerlink" title="4. Java I/O"></a>4. Java I/O</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://s2.loli.net/2022/03/19/MKG7YrlsJim6dFU.png" alt="image-20220319183837739"></p>
<h2 id="5-要点"><a href="#5-要点" class="headerlink" title="5. 要点"></a>5. 要点</h2><p>组合和委托可用于在运行时动态地加上新的行为。</p>
<p>装饰者模式反映出被装饰的组件的类型(事实上，它们用于相同的类型，都经过接口或继承实现)。</p>
<p>装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。</p>
<h1 id="Chapter-4-工厂模式"><a href="#Chapter-4-工厂模式" class="headerlink" title="Chapter 4 工厂模式"></a>Chapter 4 工厂模式</h1><h2 id="1-谈谈new"><a href="#1-谈谈new" class="headerlink" title="1. 谈谈new"></a>1. 谈谈new</h2><p>当使用new时，是在实例化一个具体的类，也就是说，此时用的是实现，而不是接口。</p>
<p>针对接口编程，可以隔离掉以后系统可能发生的一堆改变。因为，如果代码是针对接口而写，那么通过多态，可以与任何新类实现该接口。但是当代码使用大量的具体类时，等于是自找麻烦。因为一旦加入新的具体类，就必须改变代码。也就是说，代码并非”对修改关闭”。</p>
<p>那么，此时需要”找出会变化的部分，把他们从不变的部分分离出来”。</p>
<h2 id="2-对象村比萨店"><a href="#2-对象村比萨店" class="headerlink" title="2. 对象村比萨店"></a>2. 对象村比萨店</h2><h3 id="1-开张"><a href="#1-开张" class="headerlink" title="1. 开张"></a>1. 开张</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pizza <span class="title function_">orderPizza</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    Pizza pizza;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据pizza的类型，实例化具体的类</span></span><br><span class="line">    <span class="keyword">if</span> (type.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;pepperoni&quot;</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> <span class="title class_">PepperoniPizza</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pizza.prepare();</span><br><span class="line">    pizza.bake();</span><br><span class="line">    pizza.cut();</span><br><span class="line">    pizza.box();</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去很不错，因为我们的鸭子就是按照这种方式。</p>
<h3 id="2-新增比萨类型"><a href="#2-新增比萨类型" class="headerlink" title="2. 新增比萨类型"></a>2. 新增比萨类型</h3><p>为了增加竞争力，需要新增或去掉比萨的种类。这就意味着，我们要打开orderPizza的代码进行修改。</p>
<p>但是，整个orderPizza代码中，除了具体类的new之外，其余的比萨准备、烘烤等部分都维持不变，所以这些代码是不变的部分，会发生改变的部分是发生这些动作的比萨。</p>
<p>很明显，如果实例化”某些”具体的类，将使orderPizza( )出问题，而且也无法让orderPizza( )对修改关闭，但所幸，已经知道哪些会改变，哪些不会改变，是时候使用封装了。</p>
<h3 id="3-封装创建对象的代码"><a href="#3-封装创建对象的代码" class="headerlink" title="3. 封装创建对象的代码"></a>3. 封装创建对象的代码</h3><p>将创建比萨的代码移到另一个对象中，由这个新对象专职创建比萨。</p>
<h4 id="1-工厂"><a href="#1-工厂" class="headerlink" title="1. 工厂"></a>1. 工厂</h4><p>工厂处理创建对象的细节。那么orderPizza( )只关心从工厂得到了一个比萨，而这个比萨实现了pizza接口。</p>
<h4 id="2-建立一个简单的比萨工厂"><a href="#2-建立一个简单的比萨工厂" class="headerlink" title="2. 建立一个简单的比萨工厂"></a>2. 建立一个简单的比萨工厂</h4><p>定义一个类SimplePizzaFactory，为所有的比萨封装创建对象的代码。</p>
<p>首先，在这个工厂中定义一个createPizza( )的方法，所有客户用这个方法来实例化新对象。</p>
<p>之后，实现改变时，只需要修改这个类即可。</p>
<h5 id="静态？"><a href="#静态？" class="headerlink" title="静态？"></a>静态？</h5><p>利用静态方法定义一个简单的工厂，是很常见的，被称为静态工厂。</p>
<p>为何使用静态方法?</p>
<p>因为不需要使用创建对象的方法来实例化对象，直接使用类名即可调用，但这样不能通过继承来改变创建方法的行为。</p>
<h4 id="3-此时的PizzaStore"><a href="#3-此时的PizzaStore" class="headerlink" title="3. 此时的PizzaStore"></a>3. 此时的PizzaStore</h4><p><img src="https://s2.loli.net/2022/03/22/MmxkJAh13vBcGl6.png" alt="image-20220322165649784"></p>
<h3 id="4-定义简单工厂"><a href="#4-定义简单工厂" class="headerlink" title="4. 定义简单工厂"></a>4. 定义简单工厂</h3><p><strong>简单工厂实际上并不是一个设计模式，反而像是一种编程习惯。</strong></p>
<h4 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h4><p><img src="https://s2.loli.net/2022/03/22/jSmAeftbg3hk8OL.png" alt="image-20220322170113022"></p>
<h3 id="重要提醒"><a href="#重要提醒" class="headerlink" title="重要提醒"></a>重要提醒</h3><p>所谓的”实现一个接口”，并不一定表示”下一个类，并利用implements关键字来实现某个Java接口”。</p>
<p>“实现一个接口”泛指，<strong>“实现某个超类型(可以似乎类或接口)的某个方法”</strong>。</p>
<h2 id="3-加盟比萨店"><a href="#3-加盟比萨店" class="headerlink" title="3. 加盟比萨店"></a>3. 加盟比萨店</h2><p>为了让比萨制作活动局限于PizzaStore类，同时又能让这些加盟店可以自由地制作该区域的风味，方法：</p>
<p><strong>把createPizza( )方法放回到PizzaStore中，把它设置为”抽象方法”</strong>，然后为每个区域创建一个PizzaStore的子类。</p>
<h3 id="1-允许子类做决定"><a href="#1-允许子类做决定" class="headerlink" title="1. 允许子类做决定"></a>1. 允许子类做决定</h3><p>做法是让PizzaStore的各个子类负责定义自己的createPizza( )方法。</p>
<p>所以我们会得到一些PizzaStore具体的子类，每个子类都有自己的比萨变体，而仍然适合PizzaStore框架，并使用调试好的orderPizza( )方法(可以将它声明为final，以防止被子类覆盖)。</p>
<h4 id="子类做决定？"><a href="#子类做决定？" class="headerlink" title="子类做决定？"></a>子类做决定？</h4><p>orderPizza( )方法对Pizza对象做了许多事情，但由于Pizza对象是抽象的，所以orderPizza( )并不知道那些实际的具体类参与进来了。换句话说，这就是”解耦(decouple)！”</p>
<p><img src="https://s2.loli.net/2022/03/22/UCuHqcWe8PoXYMA.png" alt="image-20220322173641308"></p>
<p>从orderPizza()的角度来看，如果选择在NYStylePizzaStore订购比萨，就是由这个子类(NYStylePizzaStore）决定。</p>
<p>严格来说，并非由这个子类实际做“决定”，而是由“顾客”决定到哪一家风味的比萨店才决定了比萨的风味。</p>
<h3 id="2-开家比萨店"><a href="#2-开家比萨店" class="headerlink" title="2. 开家比萨店"></a>2. 开家比萨店</h3><p>加盟店，只需要继承PizzaStore，然后提供createPizza( )方法实现自己的比萨风味即可。</p>
<h4 id="1-声明一个工厂方法"><a href="#1-声明一个工厂方法" class="headerlink" title="1. 声明一个工厂方法"></a>1. 声明一个工厂方法</h4><p>原本是由一个对象负责所有具体类的实例化，现在变成由一群子类来负责。</p>
<p>工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户程序中关于超类的代码(orderPizza( ))就和子类对象创建代码解耦了。</p>
<p><img src="https://s2.loli.net/2022/03/22/jQ6zEAmOpuaC1WV.png" alt="image-20220322191620477"></p>
<h4 id="2-订购工序"><a href="#2-订购工序" class="headerlink" title="2. 订购工序"></a>2. 订购工序</h4><p>首先建立一家纽约风味比萨的加盟店，之后调用orderPizza( )并传入cheese这一比萨类型进行点单，因为纽约风味的加盟店中没有重写orderPizza( )方法，那么会到PizzaStore类中调用父类的orderPizza( )方法，在该方法中，进一步调用createPizza( )制造纽约风味的芝士披萨，将其返回给客户。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaTestDrive</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PizzaStore</span> <span class="variable">nyStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NYPizzaStore</span>();</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> nyStore.orderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Ethan ordered a &quot;</span> + pizza.getName() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">orderPizza</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        Pizza pizza;</span><br><span class="line">        pizza = createPizza(type);</span><br><span class="line"></span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Pizza <span class="title function_">createPizza</span><span class="params">(String type)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NYPizzaStore</span> <span class="keyword">extends</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Pizza <span class="title function_">createPizza</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NYStyleCheesePizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>超类从来不管细节，通过实例化正确的比萨类，子类会自动照料一切。</p>
<h2 id="4-工厂模式"><a href="#4-工厂模式" class="headerlink" title="4. 工厂模式"></a>4. 工厂模式</h2><p>所有的工厂模式都用来封装对象的创建。</p>
<p>工厂方法模式通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</p>
<h3 id="1-类图-1"><a href="#1-类图-1" class="headerlink" title="1. 类图"></a>1. 类图</h3><h4 id="创建者类"><a href="#创建者类" class="headerlink" title="创建者类"></a>创建者类</h4><p><img src="https://s2.loli.net/2022/03/22/GIAtPdLrXRQveEs.png" alt="image-20220322195917649"></p>
<h4 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h4><p><img src="https://s2.loli.net/2022/03/22/F6cfgA2uVoJ3md5.png" alt="image-20220322200049860"></p>
<h3 id="2-平行的类层级"><a href="#2-平行的类层级" class="headerlink" title="2. 平行的类层级"></a>2. 平行的类层级</h3><p>将一个orderPizza方法和一个工厂方法联合起来，就可以成为一个框架。除此之外，工厂方法将生产知识封装进各个创建者，这样的做法，也可以被视为是一个框架。</p>
<h3 id="3-定义工厂方法模式"><a href="#3-定义工厂方法模式" class="headerlink" title="3. 定义工厂方法模式"></a>3. 定义工厂方法模式</h3><p>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的是哪一个。工厂方法让类把实例化推迟到子类。</p>
<p>工厂方法模式能够封装具体类型的实例化。抽象的Creator提供了一个创建对象的方法的接口，也称为工厂方法。在抽象的Creator中，任何其他实现的方法，都可能使用到这个工厂方法所制造出来的产品，但只有子类真正实现这个工厂方法并创建产品。</p>
<p>“工厂方法让子类决定要实例化的类是哪一个”，所谓的“决定”，并不是指模式允许子类本身在运行时做决定，而是指<strong>在编写创建者类时，不需要知道实际创建的产品是哪一个</strong>。选择了使用哪个子类，自然就决定了实际创建的产品是什么。</p>
<p><img src="https://s2.loli.net/2022/03/22/Z7EWQijVMTOg5dl.png" alt="image-20220322200841468"></p>
<h3 id="4-特点"><a href="#4-特点" class="headerlink" title="4. 特点"></a>4. 特点</h3><ol>
<li><p>工厂方法模式将产品的实现从使用中解耦，如果增加产品或改变产品的实现，Creator并不会受到影响。</p>
</li>
<li><p>注意工厂方法模式和简单工厂的区别</p>
<ol>
<li>简单工厂把所有的事情，在一个地方都处理完了，将对象创建封装起来，但是不能变更正在创建的产品。</li>
<li>但工厂方法却是创建一个框架，让子类决定要如何实现。</li>
</ol>
</li>
<li><p>将创建对象的代码集中在一个对象或方法中，可以避免代码中的重复，并且更方便以后的维护，这也意味着客户在实例化对象时，只会依赖于接口，而不是具体类。</p>
</li>
</ol>
<p><strong>对象的创建是现实的，如果不创建任何对象，就无法创建任何Java程序，可将这些创建对象的代码用栅栏围起来进行保护。</strong></p>
<h2 id="5-第六个设计原则"><a href="#5-第六个设计原则" class="headerlink" title="5. 第六个设计原则"></a>5. 第六个设计原则</h2><p><strong>依赖倒置原则(Dependency Inversion Principle)</strong></p>
<p>当直接实例化一个对象时，就是在依赖他的具体类，代码里减少对于具体类的依赖是件好事。</p>
<p><strong>要依赖抽象，不要依赖具体类。</strong></p>
<p>这个原则说明了，不能让高层组件依赖低层组件，而且，不管高层组件还是低层组件，都应该依赖于抽象。</p>
<p>所谓”高层组件”，是有其他低层组件定义其行为的类。</p>
<p>PizzaStore是”高层组件”，而比萨实现是”低层组件”，所以，应该：</p>
<p><img src="https://s2.loli.net/2022/03/22/l8eQyCBLhEWtZRf.png" alt="image-20220322202720059"></p>
<h3 id="1-何谓倒置"><a href="#1-何谓倒置" class="headerlink" title="1. 何谓倒置?"></a>1. 何谓倒置?</h3><p><img src="https://s2.loli.net/2022/03/22/d8XMwF1UVTqGsNg.png" alt="image-20220322202854226"></p>
<p><img src="https://s2.loli.net/2022/03/22/lUeTXdz5hSwpYMA.png" alt="image-20220322203058058"></p>
<h3 id="2-指导方针"><a href="#2-指导方针" class="headerlink" title="2. 指导方针"></a>2. 指导方针</h3><ul>
<li>变量不可以持有具体类的引用(如果使用new，就会持有具体类的医用，改用工厂)</li>
<li>不要让类派生自具体类(否则就会以来具体类，改用抽象)</li>
<li>不要覆盖基类中已实现的方法(应该由子类共享)</li>
</ul>
<p>应该尽量达到这个原则，而不是随时都要遵守这个原则。</p>
<p><img src="https://s2.loli.net/2022/03/22/NLwnU2jdhVOYrJ4.png" alt="image-20220322203424951"></p>
<h2 id="6-回到比萨店"><a href="#6-回到比萨店" class="headerlink" title="6. 回到比萨店"></a>6. 回到比萨店</h2><p>对于不同风味的比萨，显然会使用不同的原料。也就是说，所有的比萨都使用相同的组件制造而成，但是不同的区域对于这些组件却有不同的实现。</p>
<h3 id="1-建造原料工厂"><a href="#1-建造原料工厂" class="headerlink" title="1. 建造原料工厂"></a>1. 建造原料工厂</h3><p>为工厂定义一个接口，负责创建所有的原料：</p>
<p><img src="https://s2.loli.net/2022/03/22/SZgUOm9hGfFV6NQ.png" alt="image-20220322203758366"></p>
<h4 id="建造纽约工厂等"><a href="#建造纽约工厂等" class="headerlink" title="建造纽约工厂等"></a>建造纽约工厂等</h4><p>对于原料家族的每一种原料，提供不同区域的版本。</p>
<h3 id="2-重做比萨"><a href="#2-重做比萨" class="headerlink" title="2. 重做比萨"></a>2. 重做比萨</h3><p>此时，要将prepare( )方法声明为抽象。</p>
<p><img src="https://s2.loli.net/2022/03/22/iLPayqMVJAQ97dZ.png" alt="image-20220322210504651"></p>
<p><img src="https://s2.loli.net/2022/03/22/3MtYXAG5oWldhSJ.png" alt="image-20220322204156849"></p>
<h3 id="3-到底做了什么？"><a href="#3-到底做了什么？" class="headerlink" title="3. 到底做了什么？"></a>3. 到底做了什么？</h3><p>引入了新类型的工厂，也就是所谓的抽象工厂，来创建比萨原料家族。</p>
<p>通过抽象工厂所提供的接口，可以创建产品的家族，利用这个接口书写代码，将代码从实际工厂解耦，以便在不同上下文中实现各式各样的工厂，制造出各种不同的产品。</p>
<h4 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h4><p><img src="https://s2.loli.net/2022/03/22/LGrUKoq4OEIJ8cs.png" alt="image-20220322204454977"></p>
<p><img src="https://s2.loli.net/2022/03/22/uSjd7qnEBZPQmg1.png" alt="image-20220322204629684"></p>
<p>在createPizza( )中用到了抽象工厂。</p>
<h2 id="7-抽象工厂模式"><a href="#7-抽象工厂模式" class="headerlink" title="7. 抽象工厂模式"></a>7. 抽象工厂模式</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>抽象工作模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体的类。</strong></p>
<p>抽象工厂允许客户使用抽象的借口来创建一组相关的产品，而不需要知道实际产出的具体产品是什么。这样一来，客户就从具体的产品中被解耦。</p>
<h3 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h3><p><img src="https://s2.loli.net/2022/03/22/2yvcI3WiDeaGPEr.png" alt="image-20220322205149761"></p>
<h3 id="抽象方法和工厂方法"><a href="#抽象方法和工厂方法" class="headerlink" title="抽象方法和工厂方法"></a>抽象方法和工厂方法</h3><p>抽象工厂的方法经常以工厂方法的方式实现。</p>
<p>抽象工厂的任务是定义一个负责创建一组产品的接口，这个接口内的每个方法都负责创建一个具体的产品，同时我们利用实现抽象工厂的子类来提供这些具体的做法。</p>
<p><strong>工厂方法，使用继承。</strong>要利用它创建对象，需要拓展一个类，并覆盖它的工厂方法。整个工厂方法模式，只不过就是通过子类来创建对象。</p>
<p><strong>抽象工厂，使用对象组合。</strong>要利用它，必须先实例化它，然后将它传入一些针对抽象类型所写的代码中。</p>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><ul>
<li>所有的工厂都是用来封装对象的创建。</li>
<li>简单工厂，虽然不是个真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类中解耦。</li>
<li>工厂方法使用继承，把对象的创建委托给子类，子类实现工厂方法并创建对象。</li>
<li>抽象工厂使用对象组合，对象的创建被实现在工厂接口所暴露出来的方法中。</li>
<li>依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象。</li>
</ul>
<h1 id="Chapter-5-单件模式"><a href="#Chapter-5-单件模式" class="headerlink" title="Chapter 5 单件模式"></a>Chapter 5 单件模式</h1><p>用来创建独一无二的、只能有一个实例的对象。</p>
<h2 id="1-经典的单件模式"><a href="#1-经典的单件模式" class="headerlink" title="1. 经典的单件模式"></a>1. 经典的单件模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="comment">// 私有构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       	<span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="延迟实例化"><a href="#延迟实例化" class="headerlink" title="延迟实例化"></a>延迟实例化</h3><p>如果uniqueInstance是空的，表示还没有创建实例，则此时利用私有的构造器产生一个Singleton实例并把它赋值到uniqueInstance静态变量中。请注意，如果我们不需要这个实例，它就永远不会产生。这就是”延迟实例化(lazy instantiaze)”。</p>
<p>利用单件模式，可以保证程序中使用的全局资源只有一份。</p>
<p>没有公开的构造器，所以要取得实例，必须”请求”得到，而无法自行实例化。调用静态方法getInstance得到的实例，可能是这次调用被创建的，也可能很早就被创建出来了。</p>
<h2 id="2-巧克力工厂"><a href="#2-巧克力工厂" class="headerlink" title="2. 巧克力工厂"></a>2. 巧克力工厂</h2><h3 id="1-定义单件模式"><a href="#1-定义单件模式" class="headerlink" title="1. 定义单件模式"></a>1. 定义单件模式</h3><p>单件模式确保一个类只有一个实例，并提供一个全局访问点。</p>
<h3 id="2-类图"><a href="#2-类图" class="headerlink" title="2. 类图"></a>2. 类图</h3><p><img src="https://s2.loli.net/2022/03/28/8ZnMvr7zhoUQDwP.png" alt="image-20220328210822172"></p>
<h3 id="3-多线程时？"><a href="#3-多线程时？" class="headerlink" title="3. 多线程时？"></a>3. 多线程时？</h3><p>针对巧克力工厂，可能产生两个锅炉对象。</p>
<h3 id="4-处理多线程"><a href="#4-处理多线程" class="headerlink" title="4. 处理多线程"></a>4. 处理多线程</h3><p>把getInstance()变成同步(synchronized)方法，就可以解决多线程的灾难。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 迫使每个线程进入这个方法之前，要先等候别的线程离开，即不会有两个线程可以同时进入该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，只有第一次执行这个方法时，才真正需要同步。一旦设置好uniqueInstance变量，就不再需要同步这个方法了，否则，会影响性能。</p>
<h3 id="5-改善多线程"><a href="#5-改善多线程" class="headerlink" title="5. 改善多线程"></a>5. 改善多线程</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p><strong>如果getInstance( )的性能对应用程序不是很关键，就什么也别做</strong></p>
<p>如果应用程序可以接受造成的性能下降，就别管啦，因为这样同步简单又有效。</p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p><strong>使用”急切”创建实例，而不用延迟实例化的做法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 在静态初始化器中，创建单件，保证了线程安全。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">uniqueInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用这个做法，依赖JVM在加载这个类时马上创建此唯一的单件实例。</p>
<p><strong>JVM保证在任何线程访问uniqueInstance静态变量之前，一定先创建此实例。</strong></p>
<h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>用”双重检查加锁”，在getInstance( )中减少使用同步</p>
<p>利用双重检查加锁(double-checked locking)，首先检查是否实例已经创建了，如果尚未创建，才进行同步。这样一来，只有第一次会同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 检查实例，如果不存在，就进入同步区块，只有第一次才执行这些</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 进入后，再检查一次</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>volatile关键字确保，当uniqueInstance变量被初始化成Singleton实例时，多个线程正在正确地处理uniqueInstance变量。</p>
<h4 id="一些对比"><a href="#一些对比" class="headerlink" title="一些对比"></a>一些对比</h4><p><img src="https://s2.loli.net/2022/03/28/Zo1NaJWXHiqrksQ.png" alt="image-20220328213902078"></p>
<h3 id="6-全局变量和单件模式"><a href="#6-全局变量和单件模式" class="headerlink" title="6. 全局变量和单件模式"></a>6. 全局变量和单件模式</h3><p>在Java中，全局变量基本上就是对对象的静态引用。全局变量可以提供全局访问，但是不能确保只有一个实例。</p>
<p>单件模式的目的：确保类只有一个实例并提供全局访问。</p>
<h3 id="7-注意"><a href="#7-注意" class="headerlink" title="7. 注意"></a>7. 注意</h3><p>在Java中实现单件模式需要私有的构造器，一个静态方法和一个静态变量。</p>
<p>确定在性能和资源上的限制，然后小心地选择适当的方案来实现单件，以解决多线程的问题。</p>
<p>如果类使用多个类加载器，可能回到会导致单件失效而产生多个实例。</p>
<h1 id="Chapter-6-命令模式"><a href="#Chapter-6-命令模式" class="headerlink" title="Chapter 6 命令模式"></a>Chapter 6 命令模式</h1><p>把方法调用封装起来。</p>
<p>命令模式可将”动作的请求者”从”动作的执行者”对象中解耦。</p>
<h2 id="1-遥控器"><a href="#1-遥控器" class="headerlink" title="1. 遥控器"></a>1. 遥控器</h2><p>创建一组控制遥控器的API，让每个插槽都能够控制一个或一组装置。</p>
<p>利用命令对象，将请求封装成一个特定对象，让每个按钮都存储一个命令对象。遥控器不需要知道工作内容是什么，只要有个命令对象能和正确的对象沟通，把事情做好即可。</p>
<h3 id="1-对象村餐厅"><a href="#1-对象村餐厅" class="headerlink" title="1. 对象村餐厅"></a>1. 对象村餐厅</h3><p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220404171644535.png" alt="image-20220404171644535"></p>
<p>通过订单，可以实现女招待和厨师之间解耦。</p>
<p>同样地，也可以分隔开”发出请求的按钮代码”和”执行请求的厂商特定对象”。也就是说，遥控器不需要知道事情是怎么发生的，也不需要知道涉及哪些对象。</p>
<h3 id="2-从餐厅到命令模式"><a href="#2-从餐厅到命令模式" class="headerlink" title="2. 从餐厅到命令模式"></a>2. 从餐厅到命令模式</h3><h4 id="对应关系"><a href="#对应关系" class="headerlink" title="对应关系"></a>对应关系</h4><p><img src="https://s2.loli.net/2022/04/04/Wqmjgf9uP57BKwc.png" alt="image-20220404172017022"></p>
<h4 id="转化类图"><a href="#转化类图" class="headerlink" title="转化类图"></a>转化类图</h4><p><img src="https://s2.loli.net/2022/04/04/yZkxjElUdpo1hgG.png" alt="image-20220404171958001"></p>
<h3 id="3-第一个命令对象"><a href="#3-第一个命令对象" class="headerlink" title="3. 第一个命令对象"></a>3. 第一个命令对象</h3><h4 id="1-实现命令接口"><a href="#1-实现命令接口" class="headerlink" title="1. 实现命令接口"></a>1. 实现命令接口</h4><p>首先，让所有的命令对象实现相同的包含一个方法的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-打开电灯"><a href="#2-打开电灯" class="headerlink" title="2. 打开电灯"></a>2. 打开电灯</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightOnCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    Light light;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightOnCommand</span><span class="params">(Light light)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-使用命令对象"><a href="#3-使用命令对象" class="headerlink" title="3. 使用命令对象"></a>3. 使用命令对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRemoteControl</span> &#123;</span><br><span class="line">    Command slot;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRemoteControl</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buttonWasPressed</span><span class="params">()</span> &#123;</span><br><span class="line">        slot.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-遥控器的简单测试"><a href="#4-遥控器的简单测试" class="headerlink" title="4. 遥控器的简单测试"></a>4. 遥控器的简单测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteControlTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleRemoteControl</span> <span class="variable">remote</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRemoteControl</span>();</span><br><span class="line">        <span class="type">Light</span> <span class="variable">light</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">        <span class="comment">// 创建一个命令对象，将接收者传递给他</span></span><br><span class="line">        <span class="type">LightOnCommand</span> <span class="variable">lightOn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightOnCommand</span>(light);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将命令传递给调用者对象</span></span><br><span class="line">        remote.setCommand(lightOn);</span><br><span class="line">        remote.buttonWasPressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-命令模式"><a href="#2-命令模式" class="headerlink" title="2. 命令模式"></a>2. 命令模式</h2><h3 id="1-定义命令模式"><a href="#1-定义命令模式" class="headerlink" title="1. 定义命令模式"></a>1. 定义命令模式</h3><p>命令模式将”请求”封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。命令模式也支持可撤销的操作。</p>
<p>一个命令对象通过在特定接收者上绑定一组动作来封装一个请求。这个命令对象那个只暴露出一个execute()方法。当这个方法被调用时，接收者就会进行者一组动作。从外面来看，其他对象不知道究竟哪个接收者进行了哪些动作，只知道如果调用execute()方法，请求的目的就能达到。</p>
<h3 id="2-类图-1"><a href="#2-类图-1" class="headerlink" title="2. 类图"></a>2. 类图</h3><p><img src="https://s2.loli.net/2022/04/04/awspj8R5EzVnTIP.png" alt="image-20220404175347921"></p>
<h3 id="3-NoCommand"><a href="#3-NoCommand" class="headerlink" title="3. NoCommand"></a>3. NoCommand</h3><p>在遥控器中，为避免每次都检查是否某个插槽都加载了命令，可以实现一个不做事情的命令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么一来，在RemoteControl构造器中，将每个插槽都预先指定成NoCommand对象，以便确定每个插槽永远都有命令对象。</p>
<p>之后在测试中，没有被明确指定命令的插槽，其命令将是默认的NoCommand对象。</p>
<p><img src="https://s2.loli.net/2022/04/04/14kIgNFy9SDxU2M.png" alt="image-20220404175818437"></p>
<h3 id="4-撤销？"><a href="#4-撤销？" class="headerlink" title="4. 撤销？"></a>4. 撤销？</h3><p>当命令支持撤销时，该命令就必须提供和execute( )方法相反的undo( )方法。不管execute( )做什么，undo( )都会倒转回来。</p>
<h4 id="更新遥控器"><a href="#更新遥控器" class="headerlink" title="更新遥控器"></a>更新遥控器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteControlWithUndo</span> &#123;</span><br><span class="line">    Command[] onCommands;</span><br><span class="line">    Command[] offCommands;</span><br><span class="line">    <span class="comment">// 记录前一个命令</span></span><br><span class="line">    Command undoCommand;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteControlWithUndo</span><span class="params">()</span> &#123;</span><br><span class="line">        onCommands = <span class="keyword">new</span> <span class="title class_">Command</span>[<span class="number">7</span>];</span><br><span class="line">        offCommands = <span class="keyword">new</span> <span class="title class_">Command</span>[<span class="number">7</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="type">Command</span> <span class="variable">noCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NoCommand</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            onCommands[i] = noCommand;</span><br><span class="line">            offCommands[i] = noCommand;</span><br><span class="line">        &#125;</span><br><span class="line">        undoCommand = noCommand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(<span class="type">int</span> slot, Command onCommand, Command offCommand)</span> &#123;</span><br><span class="line">        onCommand[slot] = onCommand;</span><br><span class="line">        offCommand[slot] = offCommand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onButtonWasPushed</span><span class="params">(<span class="type">int</span> slot)</span> &#123;</span><br><span class="line">        onCommands[slot].execute();</span><br><span class="line">        undoCommand = onCommands[slot];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offButtonWasPushed</span><span class="params">(<span class="type">int</span> slot)</span> &#123;</span><br><span class="line">        offCommands[slot].execute();</span><br><span class="line">        undoCommand = offCommands[slot];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undoButtonWasPushed</span><span class="params">()</span> &#123;</span><br><span class="line">        undoCommand.undo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常，想要实现撤销的功能，需要记录一些状态。</p>
<h3 id="5-宏命令"><a href="#5-宏命令" class="headerlink" title="5. 宏命令"></a>5. 宏命令</h3><p>如果拥有了一个遥控器，却无法光凭按下一个按钮，就同时能打开灯、打开音响和电视、设置好DVD，并让热水器开始加温，那么要这个遥控器还有什么意义？</p>
<p><img src="https://s2.loli.net/2022/04/04/tYByPrkU3uh2DHn.png" alt="image-20220404181236293"></p>
<h3 id="6-Q-amp-A"><a href="#6-Q-amp-A" class="headerlink" title="6. Q&amp;A"></a>6. Q&amp;A</h3><h4 id="“聪明”命令对象"><a href="#“聪明”命令对象" class="headerlink" title="“聪明”命令对象?"></a>“聪明”命令对象?</h4><p>一般来说，尽量设置”傻瓜”命令对象，它只懂得调用一个接收者的一个行为。</p>
<p>然而，偶尔会有”聪明”命令对象会实现许多逻辑，直接完成一个请求。但是这样，调用者和接收者之间的解耦程度，是比不上”傻瓜”命令对象的。</p>
<h4 id="单独创建Party-Command？"><a href="#单独创建Party-Command？" class="headerlink" title="单独创建Party-Command？"></a>单独创建Party-Command？</h4><p>使用宏命令，可以动态决定PartyCommand是由哪些命令组成，所以使用更灵活，也不需要更多的新代码。</p>
<h3 id="7-拓展"><a href="#7-拓展" class="headerlink" title="7. 拓展"></a>7. 拓展</h3><h4 id="队列请求"><a href="#队列请求" class="headerlink" title="队列请求"></a>队列请求</h4><p><img src="https://s2.loli.net/2022/04/04/7h5e8Mndit2j9rN.png" alt="image-20220404182035550"></p>
<h4 id="日志请求"><a href="#日志请求" class="headerlink" title="日志请求"></a>日志请求</h4><p>新增store()和load()两个方法，命令被执行时，store()到磁盘中；系统死机后，重新load()</p>
<p><img src="https://s2.loli.net/2022/04/04/TUan9xObQZ6vSCf.png" alt="image-20220404182059425"></p>
<h1 id="Chapter-7-适配器模式与外观模式"><a href="#Chapter-7-适配器模式与外观模式" class="headerlink" title="Chapter 7 适配器模式与外观模式"></a>Chapter 7 适配器模式与外观模式</h1><p>适配器位于美式插头和欧式插头的中间，将欧式插座转换为美式插座，好让美式插头可以插进这个插座得到电力。</p>
<h2 id="1-面向对象适配器"><a href="#1-面向对象适配器" class="headerlink" title="1. 面向对象适配器"></a>1. 面向对象适配器</h2><p><img src="https://s2.loli.net/2022/04/08/DJrEgiXMTyH4S7C.png" alt="image-20220408165315066"></p>
<p> 引入适配器后：</p>
<p><img src="https://s2.loli.net/2022/04/08/UuqOtYbzhLIn4N8.png" alt="image-20220408165416051"></p>
<h2 id="2-火鸡冒充鸭子？"><a href="#2-火鸡冒充鸭子？" class="headerlink" title="2. 火鸡冒充鸭子？"></a>2. 火鸡冒充鸭子？</h2><h3 id="1-火鸡和鸭子接口"><a href="#1-火鸡和鸭子接口" class="headerlink" title="1. 火鸡和鸭子接口"></a>1. 火鸡和鸭子接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quark</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Turkey</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显而易见，因为火鸡和鸭子的接口不同，所以不能直接使用。</p>
<h3 id="2-火鸡转换器"><a href="#2-火鸡转换器" class="headerlink" title="2. 火鸡转换器"></a>2. 火鸡转换器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先要实现目标接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="comment">// 接着要获得被适配者的实例</span></span><br><span class="line">    Turkey turkey;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TurkeyAdapter</span><span class="params">(Turkey turkey)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quark</span><span class="params">()</span> &#123;</span><br><span class="line">        turkey.gobble();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 火鸡飞行距离短，故而设置为火鸡飞5次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            turkey.fly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-适配器模式解析"><a href="#3-适配器模式解析" class="headerlink" title="3. 适配器模式解析"></a>3. 适配器模式解析</h3><p>适配器实现了目标接口，并持有被适配者的实例。</p>
<h4 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h4><ol>
<li>客户通过目标接口调用适配器的方法对适配器发出请求。</li>
<li>适配器使用被适配者接口把请求转换为被适配者的一个或多个调用接口。</li>
<li>客户接受到调用的结果，但并未察觉这一切是适配器在起转换作用。</li>
</ol>
<p>实现一个适配器所需要进行的工作，和一个目标接口的大小成正比。</p>
<h2 id="3-适配者模式"><a href="#3-适配者模式" class="headerlink" title="3. 适配者模式"></a>3. 适配者模式</h2><h3 id="1-定义适配者模式"><a href="#1-定义适配者模式" class="headerlink" title="1. 定义适配者模式"></a>1. 定义适配者模式</h3><p>适配者模式将一个类的接口，转换成客户期望的另一个接口，让原本接口不兼容的类可以合作无间。</p>
<p>这个模式可以通过创建适配器进行接口转换，让不兼容的接口变成兼容。这可以让客户从实现的接口解耦。</p>
<h3 id="2-类图-2"><a href="#2-类图-2" class="headerlink" title="2.类图"></a>2.类图</h3><p><img src="https://s2.loli.net/2022/04/08/WqynBrgfNE9VAp7.png" alt="image-20220408171641489"></p>
<p>把客户和接口绑定起来，而不是和实现绑定起来。</p>
<h3 id="3-对象和类的适配器"><a href="#3-对象和类的适配器" class="headerlink" title="3. 对象和类的适配器"></a>3. 对象和类的适配器</h3><p>上述类图是对象的适配器。</p>
<p>而关于类的适配器，需要多重继承，这对于Java而言，显然是无法实现的。</p>
<p><img src="https://s2.loli.net/2022/04/08/9gO2QpiMrWhk1Ry.png" alt="image-20220408171918792"></p>
<h4 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h4><p>对象适配器利用组合的方式将请求传送给被适配者。</p>
<p>类适配器不需要重新实现整个被适配者。</p>
<h3 id="4-真实世界的适配器"><a href="#4-真实世界的适配器" class="headerlink" title="4. 真实世界的适配器"></a>4. 真实世界的适配器</h3><h4 id="旧世界的枚举器"><a href="#旧世界的枚举器" class="headerlink" title="旧世界的枚举器"></a>旧世界的枚举器</h4><p>Java中早期的集合(collection)类型都实现了一个elements( )的方法。这个方法会返回一个Enumeration接口，它可以逐一走过此集合内的每个元素，而无需知道他们在集合内是如何被管理的。</p>
<p><img src="https://s2.loli.net/2022/04/08/QCzFu13GZU5vlkc.png" alt="image-20220408172828769"></p>
<h4 id="新世界的迭代器"><a href="#新世界的迭代器" class="headerlink" title="新世界的迭代器"></a>新世界的迭代器</h4><p>更新后的集合类，开始使用Iterator(迭代器)接口，与枚举接口不同的是，迭代器提供了删除元素的能力。</p>
<p><img src="https://s2.loli.net/2022/04/08/OzjBW3ivDxQmYSG.png" alt="image-20220408173009124"></p>
<h4 id="将枚举适配到迭代器"><a href="#将枚举适配到迭代器" class="headerlink" title="将枚举适配到迭代器"></a>将枚举适配到迭代器</h4><p><img src="https://s2.loli.net/2022/04/08/lEYOxtyJ8SPnZCd.png" alt="image-20220408173125362"></p>
<p>关于remove方法</p>
<p>枚举不支持删除，因为枚举是一个”只读”接口。</p>
<p>适配器无法实现一个有实际功能的remove()方法，最多只能抛出一个运行时异常。</p>
<p>而迭代器接口的设计者事先料到了这样的需求，所以将remove()方法定义成会抛出UnsupportedOperationException。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumerationIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    Enumeration enums;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EnumerationIterator</span><span class="params">(Enumeration enums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.enums = enums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> enums.hasMoreElements();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> enums.nextElement();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperatorException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-家庭影院"><a href="#4-家庭影院" class="headerlink" title="4. 家庭影院"></a>4. 家庭影院</h2><h3 id="1-播放电影"><a href="#1-播放电影" class="headerlink" title="1. 播放电影"></a>1. 播放电影</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>建造家庭影院后，想看电影，必须经过的步骤：</p>
<p><img src="https://s2.loli.net/2022/04/08/OH3nKzXefbNq9FJ.png" alt="image-20220408174025443"></p>
<h4 id="对应方法"><a href="#对应方法" class="headerlink" title="对应方法"></a>对应方法</h4><p><img src="https://s2.loli.net/2022/04/08/LomzuD6baBrcplZ.png" alt="image-20220408174155588"></p>
<h3 id="2-构建外观"><a href="#2-构建外观" class="headerlink" title="2. 构建外观"></a>2. 构建外观</h3><p>创建一个外观类，将家庭影院的诸多组件视为一个子系统，通过调用这个子系统，来实现watchMovie()方法。</p>
<p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220408174434535.png" alt="image-20220408174434535"></p>
<p>当然，外观只是提供更直接的操作，并未将原来的子系统阻隔起来。</p>
<h3 id="3-观赏电影"><a href="#3-观赏电影" class="headerlink" title="3. 观赏电影"></a>3. 观赏电影</h3><p><img src="https://s2.loli.net/2022/04/08/AOkrG6PjDxEobKy.png" alt="image-20220408174919643"></p>
<h2 id="5-外观模式"><a href="#5-外观模式" class="headerlink" title="5. 外观模式"></a>5. 外观模式</h2><h3 id="1-定义外观模式"><a href="#1-定义外观模式" class="headerlink" title="1. 定义外观模式"></a>1. 定义外观模式</h3><p>外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p>
<h3 id="2-类图-3"><a href="#2-类图-3" class="headerlink" title="2. 类图"></a>2. 类图</h3><p><img src="https://s2.loli.net/2022/04/08/EFrqxAj7HuDloc8.png" alt="image-20220408175117688"></p>
<h3 id="3-外观-amp-外观VS适配器"><a href="#3-外观-amp-外观VS适配器" class="headerlink" title="3. 外观 &amp; 外观VS适配器"></a>3. 外观 &amp; 外观VS适配器</h3><h4 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h4><p>外观没有”封装”子系统的类，外观只提供简化的接口。</p>
<p>这也是外观的特征之一：在提供简化的接口的同时，依然将系统完整的功能暴露出来，以供需要的人使用。</p>
<p>也就是说，外观不只是简化了接口，也将客户从组件的子系统中解耦。</p>
<p>一个子系统可以有多个外观。</p>
<h4 id="根本区别"><a href="#根本区别" class="headerlink" title="根本区别"></a>根本区别</h4><p>外观和适配器的根本区别在于，外观的意图是简化接口，而适配器的意图是转换接口。</p>
<h2 id="6-第七个设计原则"><a href="#6-第七个设计原则" class="headerlink" title="6. 第七个设计原则"></a>6. 第七个设计原则</h2><p>“最少知识”原则</p>
<p>最少知识原则：只和你的密友交谈。</p>
<h3 id="what？"><a href="#what？" class="headerlink" title="what？"></a>what？</h3><p>要减少对象之间的交互，只留下几个”密友”。</p>
<p>在设计中，不要让太多的类耦合在一起，免得修改系统中的一部分，会影响到其他部分。</p>
<h3 id="how？"><a href="#how？" class="headerlink" title="how？"></a>how？</h3><p>只允许调用下列对象的方法：</p>
<ul>
<li>该对象本身</li>
<li>被当作方法的参数而传递进来的对象</li>
<li>此方法创建或实例化的对象</li>
<li>对象的任何组件</li>
</ul>
<p>前三者说明了，如果某对象是调用其他的方法的返回结果，不要调用该对象的方法。</p>
<p><img src="https://s2.loli.net/2022/04/08/dThQFIgYLz9pev2.png" alt="image-20220408175555380"></p>
<h3 id="汽车类"><a href="#汽车类" class="headerlink" title="汽车类"></a>汽车类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="comment">// 是类的一个组件，可以调用它的方法</span></span><br><span class="line">    Engine engine;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Key key)</span> &#123;</span><br><span class="line">        <span class="comment">// 此处创建了一个对象，可以调用它的方法</span></span><br><span class="line">        <span class="type">Doors</span> <span class="variable">doors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Doors</span>();</span><br><span class="line">        <span class="comment">// key作为方法参数传进来的对象，可以调用方法</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">authorized</span> <span class="operator">=</span> key.turns();</span><br><span class="line">        <span class="keyword">if</span> (authorized) &#123;</span><br><span class="line">            <span class="comment">// 调用对象组件的方法</span></span><br><span class="line">            engine.start();</span><br><span class="line">            <span class="comment">// 调用同一个对象内的本地方法</span></span><br><span class="line">            updateDashboardDisplay();</span><br><span class="line">            <span class="comment">// 调用所创建或实例化的对象的方法</span></span><br><span class="line">            doors.lock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateDashboardDisplay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 更新展示</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然了，所有的原则，都应该在有帮助的时候才遵守。</p>
<p>采用最少知识原则，会导致更多的包装类被制造出来，以处理和其他组件的沟通，这会导致复杂度和开发时间的增加，降低性能。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行。</p>
<h3 id="一些对比-1"><a href="#一些对比-1" class="headerlink" title="一些对比"></a>一些对比</h3><p>适配器将一个对象包装起来，以改变其接口；</p>
<p>装饰者将一个对象包装起来，以增加新的行为和责任；</p>
<p>外观将一群对象”包装”起来，以简化其接口。</p>
<h1 id="Chapter-8-模板方法"><a href="#Chapter-8-模板方法" class="headerlink" title="Chapter 8 模板方法"></a>Chapter 8 模板方法</h1><h2 id="1-咖啡和茶"><a href="#1-咖啡和茶" class="headerlink" title="1. 咖啡和茶"></a>1. 咖啡和茶</h2><h3 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h3><p><img src="https://s2.loli.net/2022/04/12/X5dkPh89ey2KIs4.png" alt="image-20220412163629309"></p>
<h3 id="抽取共同点"><a href="#抽取共同点" class="headerlink" title="抽取共同点"></a>抽取共同点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CaffeineBeverage</span> &#123;</span><br><span class="line">    <span class="comment">// 此处final表明，不希望子类覆盖这个方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">prepareRecipe</span><span class="params">()</span> &#123;</span><br><span class="line">        boliWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">boilWater</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Boiling water&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pourInCup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Pouring into cup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则，咖啡和茶类各自实现即可。</p>
<h3 id="认识模板方法"><a href="#认识模板方法" class="headerlink" title="认识模板方法"></a>认识模板方法</h3><p><img src="https://s2.loli.net/2022/04/12/Abs4DzBupax7SHo.png" alt="image-20220412195823972"></p>
<h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><ol>
<li>它是一个方法</li>
<li>它用作一个算法(制作饮料)的模板</li>
</ol>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>在该模板中，算法内的每一个步骤都被一个方法代替了。</p>
<p>必须要由子类实现的步骤，要声明为abstract。</p>
<p>模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。</p>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><h3 id="定义模板方法模式"><a href="#定义模板方法模式" class="headerlink" title="定义模板方法模式"></a>定义模板方法模式</h3><p>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。</p>
<p>模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤(即提供具体实现)。</p>
<h3 id="类图-4"><a href="#类图-4" class="headerlink" title="类图"></a>类图</h3><p><img src="https://s2.loli.net/2022/04/12/7bt2yQdqrsANmxT.png" alt="image-20220412200553658"></p>
<h3 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h3><p>钩子是一种被声明在抽象类中的方法，但只有空的和默认的实现。子类可以选择是否实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CaffeineBeverage</span> &#123;</span><br><span class="line">    <span class="comment">// 此处final表明，不希望子类覆盖这个方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">prepareRecipe</span><span class="params">()</span> &#123;</span><br><span class="line">        boliWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="keyword">if</span> (customerWantsCondiments()) &#123;</span><br><span class="line">            addCondiments();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">boilWater</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Boiling water&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pourInCup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Pouring into cup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 钩子方法，通常是空的缺省实现。子类可以覆盖这个方法</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">customerWantsCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="when？"><a href="#when？" class="headerlink" title="when？"></a>when？</h4><p>当子类必须提供算法中某个方法或步骤的实现时，就是用抽象方法；</p>
<p>若算法的这个部分是可选的，就用钩子。子类可以选择实现或不实现。</p>
<h2 id="第八个设计原则"><a href="#第八个设计原则" class="headerlink" title="第八个设计原则"></a>第八个设计原则</h2><p>好莱坞原则</p>
<p>别调用我们，我们会调用你。</p>
<h3 id="why？"><a href="#why？" class="headerlink" title="why？"></a>why？</h3><p>可以防止”依赖腐败”，即高层组件依赖底层组件，低层组件又依赖高层组件。</p>
<p>允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些组件。也就是说，高层组件对低层组件的方式：”别调用我们，我们会调用你”。</p>
<h3 id="how？-1"><a href="#how？-1" class="headerlink" title="how？"></a>how？</h3><p><img src="https://s2.loli.net/2022/04/12/fFJ8ibZmQx95VwN.png" alt="image-20220412201824940"></p>
<h3 id="和模板方法"><a href="#和模板方法" class="headerlink" title="和模板方法"></a>和模板方法</h3><p>当设计模板方法模式时，就告诉子类，”别调用我们，我们会调用你”。</p>
<p><img src="https://s2.loli.net/2022/04/12/pjg7atbXJ5I1VFk.png" alt="image-20220412202111601"></p>
<h3 id="和依赖倒置原则"><a href="#和依赖倒置原则" class="headerlink" title="和依赖倒置原则"></a>和依赖倒置原则</h3><p>依赖倒置原则教我们尽量减少使用具体类，而多使用抽象，即注重在设计中避免依赖</p>
<p>好莱坞原则则是用在创建框架或组件的一种技巧，好让低层组件能被挂钩进计算中，而且又不会让高层组件依赖低层组件。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>允许底层操作能够互相操作，而又防止其他类太过依赖他们</p>
<p>根本目的是避免高层和底层之间明显的环状依赖。</p>
<h2 id="Java中的模板方法"><a href="#Java中的模板方法" class="headerlink" title="Java中的模板方法"></a>Java中的模板方法</h2><p><img src="https://s2.loli.net/2022/04/12/Ij13v4gPER7iZBJ.png" alt="image-20220412202921775"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>模板方法模式定义了一个算法的大纲，而由子类确定具体的实现某些步骤的内容。</p>
<p> 策略模式定义一个算法家族，并让这些算法可以互换。正因为每一个算法都被封装起来，所以客户可以轻易地使用不同的算法。</p>
</li>
<li><p>策略模式和模板方法模式都封装算法，一个使用组合，一个用继承。</p>
</li>
<li><p>工厂方法是模板方法的一个特殊版本。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Head First 设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java编程的逻辑</title>
    <url>/2022/03/27/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<h1 id="Chapter-15-并发基础"><a href="#Chapter-15-并发基础" class="headerlink" title="Chapter 15 并发基础"></a>Chapter 15 并发基础</h1><h2 id="15-1-线程的基本概念"><a href="#15-1-线程的基本概念" class="headerlink" title="15.1 线程的基本概念"></a>15.1 线程的基本概念</h2><h3 id="15-1-1-创建线程"><a href="#15-1-1-创建线程" class="headerlink" title="15.1.1 创建线程"></a>15.1.1 创建线程</h3><p>线程表示一条单独的执行流，它有自己的程序执行计数器，有自己的栈。</p>
<p>创建线程两种方式</p>
<h4 id="1-继承Thread"><a href="#1-继承Thread" class="headerlink" title="1. 继承Thread"></a>1. 继承Thread</h4><p>Java中java.lang.Thread这个类表示线程，一个类可以继承Thread并重写其run方法来实现一个线程。</p>
<p>调用start方法表示启动该线程，使其成为一条单独的执行流，操作系统会分配线程相关的资源，每个线程会有单独的程序计数器和栈，操作系统会把这个线程作为一个单独的个体进行调度，分配时间片让他执行，执行的起点就是run方法。</p>
<p>如果直接调用run方法，并不会启动一天单独的执行流，依旧是在main线程中执行的，run方法只是main方法调用的一个普通方法。</p>
<h5 id="currentThread"><a href="#currentThread" class="headerlink" title="currentThread"></a>currentThread</h5><p>每个Thread都有一个id和name：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Thread.currentThread().getName()，即可得当前线程的name</span></span><br><span class="line">System.out.println(<span class="string">&quot;thread name: &quot;</span> + Thread.currentThread().getName());</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/27/1z8W6NImvY53ouF.png" alt="image-20220327145526760"></p>
<p>调用start之后，就有了两个执行流，新的一条执行run方法，旧的一条继续执行main方法，两条执行流并发执行，操作系统负责调度。</p>
<h4 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2. 实现Runnable接口"></a>2. 实现Runnable接口</h4><p>仅仅实现Runnable是不够的，要启动线程，还是要创建一个Thread对象，但传递一个Runnable对象。</p>
<p><img src="https://s2.loli.net/2022/03/27/nNM9S2XmPwr3VYp.png" alt="image-20220327145814126"></p>
<p>无论是通过继承Thread还是实现Runnable接口来创建线程，启动线程都是调用start方法。</p>
<h3 id="15-1-2-线程的基本属性和方法"><a href="#15-1-2-线程的基本属性和方法" class="headerlink" title="15.1.2 线程的基本属性和方法"></a>15.1.2 线程的基本属性和方法</h3><h4 id="1-id和name"><a href="#1-id和name" class="headerlink" title="1. id和name"></a>1. id和name</h4><p>每个线程都有一个id和name。id是一个递增的整数，每创建一个线程，就加一。</p>
<p>name的默认值是Thread-后跟一个编号，可以setName</p>
<h4 id="2-优先级"><a href="#2-优先级" class="headerlink" title="2. 优先级"></a>2. 优先级</h4><p>在Java中，优先级从1到10，默认为5。可以setPriority和getPriority。</p>
<p>这个优先级会被映射到操作系统中线程的优先级。不过，操作系统不一定都有10个优先级，所以Java中不同的优先级，到了操作系统中可能被映射到相同的优先级。</p>
<p>优先级对于操作系统而言，主要是一种提示和建议，而非强制。</p>
<h4 id="3-状态"><a href="#3-状态" class="headerlink" title="3. 状态"></a>3. 状态</h4><p>getState()，返回值类型为Thread.State，是一个枚举类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    NEW, <span class="comment">// 没有调用过start的线程</span></span><br><span class="line">    RUNNABLE, <span class="comment">// 运行结束后的线程</span></span><br><span class="line">    BLOCKED, <span class="comment">// 在执行run方法且没有阻塞时，不一定正在执行该线程，只是该线程没有在等待其他条件</span></span><br><span class="line">    WAITING, <span class="comment">// 此三者表示线程被阻塞</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-是否daemon线程"><a href="#4-是否daemon线程" class="headerlink" title="4. 是否daemon线程"></a>4. 是否daemon线程</h4><p>Thread有一个是否daemon线程的属性，其相关方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setDaemon</span><span class="params">(<span class="type">boolean</span> on)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isDaemon</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>daemon线程，一般是其他线程的辅助线程，在它辅助的主线程退出的时候，它就没有存在的意义了。</p>
<p>在运行一个”Hello World”类型的程序时，Java也会创建多个线程，除了main线程之外，至少还有一个复杂垃圾回收的线程，这个线程就是daemon线程，在main线程结束时，垃圾回收线程也会退出。</p>
<h4 id="5-sleep方法"><a href="#5-sleep方法" class="headerlink" title="5. sleep方法"></a>5. sleep方法</h4><p><code>public static native void sleep(long millis) throws InterruptedException</code></p>
<p>调用该方法会让当前线程睡眠指定的时间，以毫秒为单位。</p>
<p>睡眠期间，该线程会让出CPU，如果此时线程被中断，sleep会抛出InterruptedException。</p>
<h4 id="6-yield方法"><a href="#6-yield方法" class="headerlink" title="6. yield方法"></a>6. yield方法</h4><p>让出CPU的方法</p>
<p><code>public static native void yield();</code></p>
<p>调用该方法，是告诉操作系统的调度器：可以让其他线程先运行</p>
<p>不过这仅仅是建议</p>
<h4 id="7-join方法"><a href="#7-join方法" class="headerlink" title="7. join方法"></a>7. join方法</h4><p>可以调用join的线程等待该线程结束。</p>
<p>调用join的线程，可以让等待该线程结束。</p>
<p><code>public final void join() throws InterruptedException</code></p>
<p>在等待线程结束时，这个等待可能被中断，如果被中断，会抛出InterruptedException异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">	<span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-1-3-共享内存及可能存在的问题"><a href="#15-1-3-共享内存及可能存在的问题" class="headerlink" title="15.1.3 共享内存及可能存在的问题"></a>15.1.3 共享内存及可能存在的问题</h3><p>线程之间可以共享内存，它们可以访问和操作相同的对象。</p>
<p>执行流、内存和程序代码</p>
<ol>
<li><p>该例有三条执行流，一条执行main方法，另外两条执行两个ChildThread的run方法。</p>
</li>
<li><p>不同的执行流可以访问和操作相同的变量</p>
</li>
<li><p>不同执行流可以执行相同的程序代码。在分析代码执行的过程时，理解代码在被哪个线程执行是很重要的。</p>
</li>
<li>当多条执行流执行相同的程序代码时，每条执行流都有单独的栈，方法中的参数和局部变量都有自己的一份。</li>
</ol>
<p>共享内存的意料之外：</p>
<ol>
<li>竞态条件</li>
</ol>
<p>所谓竞态条件是指，当多个线程访问和操作同一个对象时，最终的执行结果和执行时序有关。</p>
<p>这是因为，执行的操作可能不是原子操作。一条语句可能分为几个步骤执行，如果不能保证原子性，多个线程同时操作一个数据时，可能让步骤之间发生重叠，从而无法得到正确的修改结果。</p>
<p><img src="https://s2.loli.net/2022/03/27/QkDeYtGEojMZfs4.png" alt="image-20220327162727873"></p>
<ol>
<li>内存可见性</li>
</ol>
<p>多个线程可以共享访问和操作相同的变量，但一个线程对一个共享变量的修改，另一个线程不一定马上就能看到。</p>
<p>在计算机系统中，除了内存，数据还会被缓存在CPU的寄存器以及各级缓存中，当访问一个变量时，可能直接从寄存器或CPU缓存中获取，而不一定到内存中获取。当修改一个变量时，也可能是先写到缓存中，稍后才会同步更新到内存中。</p>
<p>一个线程对内存的修改，另一个线程看不到，一是修改没有及时同步到内存，二是另一个线程根本就没从内存读。</p>
<p><img src="https://s2.loli.net/2022/03/27/PwYQ6shCxX2MzyU.png" alt="image-20220327162741710"></p>
<h2 id="15-2-synchronized"><a href="#15-2-synchronized" class="headerlink" title="15.2 synchronized"></a>15.2 synchronized</h2><h3 id="15-2-1-用法和基本原理"><a href="#15-2-1-用法和基本原理" class="headerlink" title="15.2.1 用法和基本原理"></a>15.2.1 用法和基本原理</h3><p>synchronized可以用于修饰类的实例方法、静态方法和代码块。</p>
<h4 id="1-实例方法"><a href="#1-实例方法" class="headerlink" title="1. 实例方法"></a>1. 实例方法</h4><p>方法内的代码就变成了原子操作。</p>
<p>允许多个线程同时执行同一个synchronized实例方法，只要它们访问的对象不同。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Counter</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line"><span class="type">Counter</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CouterThread</span>(c1);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterThread</span>(c2);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>
<p>这里的t1和t2可以同时执行被synchronized修饰的Counter类中的incr()方法，因为访问的对象不同呀。</p>
<p><strong>synchronized修饰实例方法，实际保护的是同一个对象的方法调用，确保只有一个线程执行。也就是说，他保护的是当前实例对象，即this。</strong></p>
<p><strong>this对象有只能被一个线程持有的锁，以及等待获得该锁的等待队列(其中的线程被阻塞且等待唤醒，即BLOCKED状态)。</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li><p><strong>synchronized保护的是对象而非代码。</strong></p>
</li>
<li><p>只要是访问同一个对象的synchronized方法，即使是不同的代码，也会被同步顺序访问。</p>
</li>
<li><p>一般在保护变量时，会给所有访问该变量的方法加上synchronized修饰符。</p>
</li>
</ol>
<h4 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2. 静态方法"></a>2. 静态方法</h4><p>对于实例方法而言，保护的是当前实例对象this；</p>
<p><strong>对于静态方法而言，保护的是类对象，即StaticCounter.class。</strong></p>
<p>实际上，每个对象都有一个锁和一个等待队列，连类对象也不例外。</p>
<p>由于静态方法和实例方法保护的对象不同，所有可以两个线程，一个访问synchronized静态方法，一个访问synchronized实例方法。</p>
<h4 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3. 代码块"></a>3. 代码块</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123; <span class="comment">// 括号里是保护的对象，即实例对象，或synchronized(StaticCounter.class)</span></span><br><span class="line">        count++; <span class="comment">// 此处是同步执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-2-2-进一步理解"><a href="#15-2-2-进一步理解" class="headerlink" title="15.2.2 进一步理解"></a>15.2.2 进一步理解</h3><h4 id="1-可重用性"><a href="#1-可重用性" class="headerlink" title="1.可重用性"></a>1.可重用性</h4><p>对于同一个执行的线程，它在获得锁之后，在调用其他同样需要锁的代码时，可以直接调用。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>可重用性是通过记录锁的持有线程和持有数量(应该是指，调用的 需要同样锁的 方法的 数量)来实现的。</p>
<p>调用被synchronized保护的代码时</p>
<p><img src="https://i.niupic.com/images/2022/04/09/9YEL.png" alt="image-20220402195944393"></p>
<p>当想要释放锁时，需要减少持有数量。</p>
<p>只有当数量变为0时，才释放整个锁。</p>
<h4 id="2-内存可见性"><a href="#2-内存可见性" class="headerlink" title="2. 内存可见性"></a>2. 内存可见性</h4><p>synchronized可以保证内存可见性。</p>
<p>在释放锁时，所有的写入都会被写回内存，而获得锁后，都会从内存中读取最新数据。</p>
<h5 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h5><p>不过若是单纯想要保证内存可见性，使用synchronized未免开销大了点，可以使用更加轻量级的volatile。</p>
<h4 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3. 死锁"></a>3. 死锁</h4><p>A持有对象lockA的锁，等待加锁lockB；而B持有对象lockB的锁，申请加锁lockA，即二者相互等待。</p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><ol>
<li>避免在持有一个锁的时候，去申请另外一个锁</li>
<li>如果实在需要多个锁，那么约定按照相同的顺序去申请锁。(如先去加锁lockA，再去加锁lockB)</li>
</ol>
<h3 id="15-2-3-同步容器及其注意事项"><a href="#15-2-3-同步容器及其注意事项" class="headerlink" title="15.2.3 同步容器及其注意事项"></a>15.2.3 同步容器及其注意事项</h3><p>所谓同步容器，是通过给所有的容器方法都加上synchronized来实现安全的。</p>
<p>类似于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(length) &#123;</span><br><span class="line">        <span class="keyword">return</span> c.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处的线程安全，指的是容器对象。</p>
<p>这种方式可以减少多个线程并发访问时，再加synchronized的麻烦。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><h5 id="1-复合操作"><a href="#1-复合操作" class="headerlink" title="1. 复合操作"></a>1. 复合操作</h5><p>即先检查再更新。</p>
<p>如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnhancedMap</span>&lt;K,V&gt; &#123;</span><br><span class="line">    Map&lt;K, V&gt; map;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EnhancedMap</span><span class="params">(Map&lt;K, V&gt; map)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = Collections.synchronizedMap(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EnhancedMap是一个装饰类，接受一个Map对象，调用synchronizedMap转换为了同步容器对象map，增加了一个方法putIfAbsent，该方法只有在原Map中没有对应键的时候才添加。</p>
<p>map的每个方法都是安全的，但这个复合方法并不安全。</p>
<p>在多线程的情况下，可能有多个线程都执行完了检查这一步，都发现Map中没有对应的键，然后就会调用put。</p>
<h5 id="2-伪同步"><a href="#2-伪同步" class="headerlink" title="2. 伪同步"></a>2. 伪同步</h5><p>即，同步错了对象。</p>
<p>由于上边分析，方法putIfAbsent并不安全，但是直接对putIfAbsent加锁，因为该方法是实例方法，所以同步的是EnhancedMap对象，但是其他方法使用的却Collections.synchronizedMap返回的map对象，两者，是不同的对象。</p>
<p>则，所有的方法必须使用相同的对象锁(此处可以对map加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(map) &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-迭代"><a href="#3-迭代" class="headerlink" title="3. 迭代"></a>3. 迭代</h5><p>举个栗子，此时创建一个同步List对象，一个线程修改List，另一个遍历List，结果，抛出了并发修改异常。</p>
<p>这很显然，因为<strong>在遍历的同时，容器发生了结构性的变化，就会抛出ConcurrentModificationException异常</strong>。</p>
<p>所以，在遍历时，应该给整个容器对象加锁。</p>
<p><img src="https://s2.loli.net/2022/04/02/3eZgS1AkpBFWVoM.png" alt="image-20220402210616592"></p>
<h5 id="4-并发容器"><a href="#4-并发容器" class="headerlink" title="4. 并发容器"></a>4. 并发容器</h5><p>同步容器的性能较低。</p>
<p>Java中还有很多转为并发设计的容器类，如：</p>
<ul>
<li>CopyOnWriteArrayList</li>
<li>ConcurrentHashMap</li>
<li>ConcurrentLinkedQueue</li>
<li>ConcurrentSkipListSet</li>
</ul>
<h2 id="15-3-线程的基本协作机制"><a href="#15-3-线程的基本协作机制" class="headerlink" title="15.3 线程的基本协作机制"></a>15.3 线程的基本协作机制</h2><p>多线程协作的基本机制wait/notify。</p>
<h3 id="15-3-1-协作的场景"><a href="#15-3-1-协作的场景" class="headerlink" title="15.3.1 协作的场景"></a>15.3.1 协作的场景</h3><h4 id="1-生产者-消费者协作模式"><a href="#1-生产者-消费者协作模式" class="headerlink" title="1. 生产者/消费者协作模式"></a>1. 生产者/消费者协作模式</h4><p>这是一种常见的协作模式，生产者线程和消费者线程通过共享队列进行协作。</p>
<p>生产者将数据或任务放到队列上，而消费者从队列上取数据或任务，如果队列长度有限，在队列满的时候，生产者需要等待，而在队列为空的时候，消费者需要等待。</p>
<h4 id="2-同时开始"><a href="#2-同时开始" class="headerlink" title="2. 同时开始"></a>2. 同时开始</h4><p>类似运动员比赛，在某些程序中，要求多个线程能够同时开始。</p>
<h4 id="3-等待结束"><a href="#3-等待结束" class="headerlink" title="3. 等待结束"></a>3. 等待结束</h4><p>主从协作模式也是一种常见的协作模式，主线程将任务分解为若干子任务，为每个子任务创建一个线程，主线程在继续执行其他任务之前，需要等待每个子任务执行完毕。</p>
<h4 id="4-异步结果"><a href="#4-异步结果" class="headerlink" title="4. 异步结果"></a>4. 异步结果</h4><p>在主从协作模式中，主线程手动创建子线程的写法比较麻烦，一种常见的模式是将子线程的管理封装为异步调用，异步调用马上返回，但返回的不是最终结果，而是一个一般称为Future的对象，通过它可以在随后获得最终的结果。</p>
<h4 id="5-集合点"><a href="#5-集合点" class="headerlink" title="5. 集合点"></a>5. 集合点</h4><p>每个线程负责一部分计算，然后在集合点等待其他线程完成，所有线程到齐之后，交换数据和计算结果，再进行下一次迭代。</p>
<h3 id="15-3-2-wait-notify"><a href="#15-3-2-wait-notify" class="headerlink" title="15.3.2 wait/notify"></a>15.3.2 wait/notify</h3><p>Java在Object类而非Thread类中定义了一些线程协作的基本方法，使得每个对象都可以调用这些方法。</p>
<p>这些方法有两类，一类是wait，另一类是notify。</p>
<h4 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a>wait方法</h4><p>主要有两个：</p>
<p><img src="https://s2.loli.net/2022/04/02/125XceL4K8OImGH.png" alt="image-20220402211608428"></p>
<p>一个带时间参数，单位是毫秒，表示最多等待这么长时间，参数0表示无限期等待；</p>
<p>一个不带时间参数，表示无限期等待，实际就是调用wait(0)。</p>
<p>除了用于锁的等待队列，每个对象还有另一个等待队列，表示<strong>条件队列</strong>，该队列用于线程间的协作。</p>
<p>调用wait就会把当前线程放到条件队列上并阻塞，表示当前线程执行不下去了，它需要等待一个条件，这个条件它自己改变不了，需要其他线程改变。</p>
<h4 id="notify方法"><a href="#notify方法" class="headerlink" title="notify方法"></a>notify方法</h4><p>当其他线程改变了条件后，应该调用Object的notify方法：</p>
<p><img src="https://s2.loli.net/2022/04/02/GraJTLlHjRg3Cdt.png" alt="image-20220402211811317"></p>
<p>notify做的事情就是从条件队列中选一个线程，将其从队列中移除并唤醒，notifyAll和notify的区别是，它会移除条件队列中所有的线程并全部唤醒。</p>
<h4 id="需要对象锁"><a href="#需要对象锁" class="headerlink" title="需要对象锁"></a>需要对象锁</h4><p>实际上，wait和notify方法只能在synchronized代码块内被调用，如果调用wait/notify方法时，当前线程没有持有对象锁，会抛出异常java.lang.IllegalMonitor-StateException。</p>
<p>但是</p>
<p>如果wait必须被synchronized保护，那一个线程在wait时，另一线程怎么可能调用同样被synchronized保护的notify方法呢？</p>
<h5 id="详解wait"><a href="#详解wait" class="headerlink" title="详解wait"></a>详解wait</h5><p>它虽然在synchronized方法内，但调用wait时，线程会释放对象锁。</p>
<p>wait的具体过程是：</p>
<ol>
<li>将当前线程放入条件等待队列，释放对象锁，阻塞等待，线程状态变为WAITING或TIMED_WAITING。</li>
<li>等待时间到或被其他线程调用notify/notifyAll从条件队列中移除，这时要重新竞争对象锁。<ol>
<li>如果能够获得对象锁，线程状态变为RUNNABLE，并从wait调用中返回</li>
<li>否则，该线程加入对象锁等待队列，线程状态变为BLOCKED，只有在获得锁后才会从wait调用中返回。</li>
</ol>
</li>
</ol>
<p>线程从wait中返回后，不代表其等待的条件就一定成立了，它需要重新检查其等待的条件。<img src="https://s2.loli.net/2022/04/02/GnJFYVa5IksCBbW.png" alt="image-20220402212936889"></p>
<p>调用notify会把在条件队列中等待的线程唤醒并从队列中移除，但它不会释放对象锁，也就是说，只有在包含notify的synchronized代码块执行完后，等待的线程才会从wait调用中返回。</p>
]]></content>
      <tags>
        <tag>Some</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL技术内幕</title>
    <url>/2022/03/20/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/</url>
    <content><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>从MySQl5.5版本开始，InnoDB是默认的表存储引擎。特点是行锁设计、支持MVCC、支持外键、提供一致性非锁定读、同时被设计用来最有效地利用以及使用内存和CPU。</p>
<h2 id="1-InnoDB体系架构"><a href="#1-InnoDB体系架构" class="headerlink" title="1. InnoDB体系架构"></a>1. InnoDB体系架构</h2><p><img src="https://s2.loli.net/2022/03/20/3H6OawNh1yCD5vg.png" alt="image-20220320145613996"></p>
<p>InnoDB存储引擎有多个内存块，这些内存块组成了一个大的内存池。</p>
<p>后台线程主要负责刷新内存池中的数据、将已修改的数据刷新到磁盘等等。</p>
<h3 id="1-1后台线程"><a href="#1-1后台线程" class="headerlink" title="1.1后台线程"></a>1.1后台线程</h3><h4 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h4><p>最核心的一个线程，主要负责将缓冲池的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO页的回收等。</p>
<h4 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h4><p>在InnoDB中大量使用了异步IO来处理写IO请求，IO Thread主要负责这些IO请求的回调处理</p>
<h4 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h4><p>事务被提交后，undo log可能不再需要，使用Purge Thread来回收已经使用并分配的undo页。可运行多个，以加快undo页的回收。</p>
<h4 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h4><p>将脏页的刷新操作都放入该单独的线程中来完成，减轻Master Thread的工作及对于用户查询线程的阻塞。</p>
<h2 id="1-2-内存"><a href="#1-2-内存" class="headerlink" title="1.2 内存"></a>1.2 内存</h2><p>InnoDB存储引擎是基于磁盘存储的，使用了缓冲池技术来提高数据库的整体性能。</p>
<p>读取页时，首先将磁盘读到的页放在缓冲池中，下一次读取相同的页，先判断该页是否在缓冲池中。</p>
<p>对于数据库中页的修改操作，首先修改在缓冲池中页，然后再以一定的频率刷新到磁盘，并不是每次页发生改变就刷新回磁盘。</p>
<h3 id="1-数据页类型"><a href="#1-数据页类型" class="headerlink" title="1. 数据页类型"></a>1. 数据页类型</h3><p>索引页、数据页、undo页、插入缓冲、自适应哈希索引、InnoDB的锁信息、数据字典信息等，其中索引页和数据页占缓冲池的很大一部分。</p>
<p>在InnoDB中，<strong>缓冲池的页大小默认为16KB</strong>。</p>
<p><img src="https://s2.loli.net/2022/03/20/OzVt7hIZXREdmin.png" alt="image-20220320150901337"></p>
<h3 id="2-Buffer-Pool"><a href="#2-Buffer-Pool" class="headerlink" title="2. Buffer Pool"></a>2. Buffer Pool</h3><p>Buffer Pool其实是一片连续的内存空间。所以，为了更好地管理被缓存的页，InnoDB为每个缓存页都创建了一些所谓的控制信息，包括该页所属的表空间编号、页号、页在Buffer Pool中的地址，一些所信息以及LSN信息等。</p>
<p>每个缓存页对应的控制信息占用的内存大小是相同的，将其称为控制块。</p>
<p>控制块和缓存页是一一对应的，都被存放在Buffer Pool中，其中控制块被存放到Buffer Pool的前边，缓存页被存放到Buffer Pool后边，所以：</p>
<p><img src="https://s2.loli.net/2022/03/20/snmudBkgfVbPL9W.png" alt="image-20220320151615244"></p>
<p>碎片是无法再分配的剩余的内存空间，最后内存中会有一点点的空间不足以容纳一对控制体和缓存页。</p>
<h3 id="3-三大链表"><a href="#3-三大链表" class="headerlink" title="3. 三大链表"></a>3. 三大链表</h3><h4 id="Free-List"><a href="#Free-List" class="headerlink" title="Free List"></a>Free List</h4><p>最初启动MySQL服务器的时候，需要完成对Buffer Pool的初始化过程，就是分配Buffer Pool的内存空间，把它划分成若干对控制块和缓存页。</p>
<p>但是此时并没有真实的磁盘页被缓存到Buffer Pool中（因为还没有用到），之后随着程序的运行，会不断的有磁盘上的页被缓存到Buffer Pool中，为了标识空闲的缓存页，将其包装为一个结点，放入Free链表中。</p>
<p>刚完成初始化时的Buffer Pool中的Free List效果图：</p>
<p><img src="https://s2.loli.net/2022/03/20/DhevUY5y7ixPnkp.png" alt="image-20220320152535381"></p>
<h5 id="间接对应"><a href="#间接对应" class="headerlink" title="间接对应"></a>间接对应</h5><p>在每个Free链表的节点中都记录了某个缓存页控制块的地址，而每个缓存页控制块都记录着对应的缓存页地址，所以相当于每个Free链表节点都对应一个空闲的缓存页。</p>
<p>每当需要从磁盘中加载一个页到Buffer Pool中时，就从Free链表中取出一个空闲的缓存页，并且把该页对应的控制块信息填上，然后把该缓存页对应的Free链表结点从链表中移除。</p>
<h4 id="LRU-List"><a href="#LRU-List" class="headerlink" title="LRU List"></a>LRU List</h4><p>由于Buffer Pool的大小有限，所以要淘汰一些缓存页。</p>
<p>淘汰机制：近期最少使用，即LRU。</p>
<h5 id="1-简单LRU的缺陷"><a href="#1-简单LRU的缺陷" class="headerlink" title="1. 简单LRU的缺陷"></a>1. 简单LRU的缺陷</h5><ol>
<li><p>进行全表扫描时，所有的数据也都会被全部塞入LRU链表，并且通通加载到Buffer Pool中，会迅速清空其他查询语句留下来的高频的数据页。也就是说，此时的Buffer Pool可能全是低频的数据页，大大降低缓存命中率。</p>
</li>
<li><p>InnoDB的预读机制。分为线性预读和随机预读。</p>
<ol>
<li>线性预读：当一个区中有连续56(默认值为56)个页面被加载到Buffer Pool中，会将该区所有的页面都加载到Buffer Pool。</li>
<li><p>随机预读：当一个区中随机13(默认值为13)个页面被加载到Buffer Pool中，会将该区所有的页面都加载到Buffer Pool。随机预读默认是关闭，由变量innodb_random_read_ahead控制。</p>
<p>也就是说，预读机制会预读一些额外的页到Buffer Pool中，就算这些页不是高频的页，也会被加入LRU链表，就会将链表末尾一些高频的页给淘汰掉，降低命中率。</p>
</li>
</ol>
</li>
</ol>
<h5 id="2-InnoDB的LRU"><a href="#2-InnoDB的LRU" class="headerlink" title="2. InnoDB的LRU"></a>2. InnoDB的LRU</h5><p>InnoDB将LRU链表分为了两个部分，也就是所谓的old区和young区。</p>
<p>young区在链表的头部，存放经常被访问的数据页，即热数据，</p>
<p>old区在链表的尾部，存放不经常被访问的数据页，即冷数据。</p>
<p>两个部分的交汇区称为==midpoint==。</p>
<p>midpoint由参数innodb_old_blocks_pct控制。</p>
<p>两个区的比例：</p>
<p><img src="https://s2.loli.net/2022/03/20/fotUPwL7JNxKA8h.png" alt="image-20220320222835302"></p>
<p>这说明了old区的比例是37%，也就是冷数据大概占LRU链表的3/8，剩下的就是young区的热数据。</p>
<h5 id="3-LRU链表图"><a href="#3-LRU链表图" class="headerlink" title="3. LRU链表图"></a>3. LRU链表图</h5><p><img src="https://s2.loli.net/2022/03/20/1q2RaDS7YdPATIh.png" alt="image-20220320223434117"></p>
<p>一般生产的机器，内存比较大。会把innodb_old_blocks_pct值调低，防止热数据被刷出内存。</p>
<h5 id="5-两区交换"><a href="#5-两区交换" class="headerlink" title="5. 两区交换"></a>5. 两区交换</h5><p>数据页第一次被加载进Buffer Pool时在old区头部。</p>
<p>当这个数据页在old区，再次被访问到，会做判断如下：</p>
<ul>
<li>如果这个数据页在LRU链表中old区存在的时间<strong>超过了1秒，就把它移动到young区</strong></li>
<li>这个存在时间由innodb_old_blocks_time控制，表示页读取到mid位置后需要等待多久才会被加入到LRU列表的热端，可以通过该参数保证热数据不轻易被刷出。</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/20/ufMqlhcIDGWrpk8.png" alt="image-20220320224103298"></p>
<h5 id="监控冷热数据"><a href="#监控冷热数据" class="headerlink" title="监控冷热数据"></a>监控冷热数据</h5><p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220320224154519.png" alt="image-20220320224154519"></p>
<ol>
<li>数据页从冷到热，称为young；not young就是数据在没有成为热数据的情况下就被刷走的量(累计值)。</li>
<li>non-youngs/s，这个数值如果较高，一般情况下就是系统存在严重的全表扫描，意味着很高的物理读。</li>
<li>youngs/s，这个数值如果相对较高，最好增加一个innodb_old_blocks_time，降低innodb_old_blocks_pct，保护热数据。</li>
</ol>
<h4 id="FLUSH-List"><a href="#FLUSH-List" class="headerlink" title="FLUSH List"></a>FLUSH List</h4><p>用来储存脏页，凡是在LRU链表中被修改过的页都需要加入这个链表中，因为这个链表中的页都是需要被刷新到磁盘上的，所以也叫FLUSH链表。</p>
<h5 id="脏页修改"><a href="#脏页修改" class="headerlink" title="脏页修改"></a>脏页修改</h5><p>脏页修改指的是此页被加载进Buffer Pool后第一次被修改，只有第一次被修改时才需要加入FLUSH链表。</p>
<p>需要注意的是，脏页数据实际上还在LRU链表中，而FLUSH链表中的脏页记录只是通过指针指向LRU链表中的脏页，并且在FLUSH链表中的脏页是根据oldest_lsn（这个值表示这个页第一次被更改时的lsn号，对应值oldest_modification，每个页头部记录）进行排序刷新到磁盘的，值越小表示要最先被刷新，避免数据不一致。</p>
<h5 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h5><p>脏页既存在于LRU列表中，也存在与Flush列表中。LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘，二者互不影响。</p>
<h4 id="4-三表关系"><a href="#4-三表关系" class="headerlink" title="4. 三表关系"></a>4. 三表关系</h4><p><img src="https://s2.loli.net/2022/03/20/q1WTchjuiYPbLQf.png" alt="image-20220320225028481"></p>
<p>Free链表跟LRU链表的关系是相互流通的，页在这两个链表间来回置换。而FLUSH链表记录了脏页数据，也是通过指针指向了LRU链表，所以图中FLUSH链表被LRU链表包裹。</p>
<h2 id="2-CheckPoint技术"><a href="#2-CheckPoint技术" class="headerlink" title="2. CheckPoint技术"></a>2. CheckPoint技术</h2><h3 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h3><ul>
<li><p>缩短数据库恢复时间</p>
</li>
<li><p>缓冲池不够用时，将脏页刷新到磁盘</p>
</li>
</ul>
<p>根据LRU算法，溢出最近最少使用的页，如果页为脏页，强制执行checkpoint，将脏页刷新回磁盘。</p>
<ul>
<li>重做日志不可用时，刷新脏页</li>
</ul>
<p>重做日志不可用，是指重做日志的这部分不可以被覆盖。</p>
<p>原因：由于重做日志的设计是循环使用的。这部分对应的数据还未刷新到磁盘上。数据库恢复时，如果不需要这部分日志，即可被覆盖；如果需要，必须强制执行checkpoint，将缓冲池中的也至少刷新到当前重做日志的位置。</p>
<h3 id="两种checkpoint"><a href="#两种checkpoint" class="headerlink" title="两种checkpoint"></a>两种checkpoint</h3><h4 id="Sharp-Checkpoint"><a href="#Sharp-Checkpoint" class="headerlink" title="Sharp Checkpoint"></a>Sharp Checkpoint</h4><p>发生在数据库关闭时，将所有的脏页都刷新回磁盘，这是默认的工作方式。</p>
<p>innodb_fast_shutdown = 1。</p>
<p>不适用于数据库运行时的刷新。</p>
<h4 id="Fuzzy-Checkpoint"><a href="#Fuzzy-Checkpoint" class="headerlink" title="Fuzzy Checkpoint"></a>Fuzzy Checkpoint</h4><p>只刷新一部分脏页</p>
<h5 id="MasterThread-Checkpoint"><a href="#MasterThread-Checkpoint" class="headerlink" title="MasterThread Checkpoint"></a>MasterThread Checkpoint</h5><p>异步刷新，每秒或每10秒从缓冲池脏页列表刷新一定比例的页会磁盘。异步刷新时，用户查询线程不受阻。</p>
<h5 id="FLUSH-LRU-LIST-Checkpoint"><a href="#FLUSH-LRU-LIST-Checkpoint" class="headerlink" title="FLUSH_LRU_LIST Checkpoint"></a>FLUSH_LRU_LIST Checkpoint</h5><p>InnoDB存储引擎需要保证LRU列表中差不多有100个空闲页可供使用。用户查询线程会检查LRU列表是否有足够的空间操作。如果没有，根据LRU算法，溢出LRU列表尾端的页，<strong>如果这些页有脏页，需要进行checkpoint</strong>。因此叫：flush_lru_list</p>
<h5 id="Async-Sync-Flush-Checkpoint"><a href="#Async-Sync-Flush-Checkpoint" class="headerlink" title="Async/Sync Flush Checkpoint"></a>Async/Sync Flush Checkpoint</h5><p>指重做日志不可用的情况，需要强制刷新页回磁盘，此时的页是脏页列表选取的。<br>这种情况是保证重做日志的可用性，就是，重做日志中可以循环覆盖的部分空间太少了，换种说法，就是极短时间内产生了大量的redo log。</p>
<h5 id="Dirty-Page-too-much-Checkpoint"><a href="#Dirty-Page-too-much-Checkpoint" class="headerlink" title="Dirty Page too much Checkpoint"></a>Dirty Page too much Checkpoint</h5><p>脏页太多，强制checkpoint，保证缓冲池有足够可用的页。</p>
<h1 id="Chapter-1-MySQL体系结构和存储引擎"><a href="#Chapter-1-MySQL体系结构和存储引擎" class="headerlink" title="Chapter 1 MySQL体系结构和存储引擎"></a>Chapter 1 MySQL体系结构和存储引擎</h1><h2 id="1-1-定义数据库和实例"><a href="#1-1-定义数据库和实例" class="headerlink" title="1.1 定义数据库和实例"></a>1.1 定义数据库和实例</h2><p>数据库：物理操作系统文件或其他形式文件类型的集合。</p>
<p>实例：由后台线程以及一个共享内存区组成。共享内存可以被运行的后台线程所共享。数据库实例才是真正用于操作数据库文件的。</p>
<p>应用程序只有通过数据库实例才能和数据库打交道。</p>
<p>MySQL被设计为一个单进程多线程架构的数据库。</p>
<p><strong>MySQL数据库实例在系统上的表现就是一个进程。</strong></p>
<h2 id="1-2-MySQL体系结构"><a href="#1-2-MySQL体系结构" class="headerlink" title="1.2 MySQL体系结构"></a>1.2 MySQL体系结构</h2><p><img src="https://s2.loli.net/2022/03/21/6gG9HjI7dWlKZrk.png" alt="image-20220321173153974"></p>
<p>MySQL组成部分</p>
<ul>
<li>连接池组件</li>
<li>管理服务和工具组件</li>
<li>SQL接口组件</li>
<li>查询分析器组件</li>
<li>优化器组件</li>
<li>缓冲(cache)组件</li>
<li>插件式存储引擎</li>
<li>物理文件</li>
</ul>
<p>MySQL区别于其他数据库的最重要的一个特点就是<strong>其插件式的表存储引擎</strong>。</p>
<p><strong>存储引擎是基于表的，而不是数据库。</strong></p>
<h2 id="1-3-MySQL存储引擎"><a href="#1-3-MySQL存储引擎" class="headerlink" title="1.3 MySQL存储引擎"></a>1.3 MySQL存储引擎</h2><h1 id="Chapter-3-文件"><a href="#Chapter-3-文件" class="headerlink" title="Chapter 3 文件"></a>Chapter 3 文件</h1><p>分析构成MySQL数据库和InnoDB存储引擎表的各种类型文件。</p>
<h2 id="3-1-参数文件"><a href="#3-1-参数文件" class="headerlink" title="3. 1 参数文件"></a>3. 1 参数文件</h2><p>参数文件是以文本文件的方式存储的。</p>
<p>当MySQL实例启动时，数据库会先去读一个配置文件，用来寻找数据库的各种文件所在位置以及指定某些初始化参数，这些参数定义了某种内存有多大等。默认情况下，MySQL实例会按照一定顺序从指定位置读取。</p>
<p>MySQL实例可以不需要参数文件，这时所有的参数值使用编译时和源代码中指定的默认值(Oracle实例在启动时没有参数文件无法装载)。</p>
<p>但如果没有mysql架构记录了访问该实例的权限，所以如果没有mysql架构，启动会失效。</p>
<h3 id="3-1-1-什么是参数"><a href="#3-1-1-什么是参数" class="headerlink" title="3.1.1 什么是参数"></a>3.1.1 什么是参数</h3><p>数据库参数，可以看作是键值对。</p>
<p>如，innodb_buffer_pool_size = 1G，等号左侧为键，右侧1G为值。</p>
<p>通过SHOW VARIABLES，可以查看数据库中所有参数。</p>
<h3 id="3-1-2-参数类型"><a href="#3-1-2-参数类型" class="headerlink" title="3.1.2 参数类型"></a>3.1.2 参数类型</h3><p>MySQL数据库中参数分为两类：</p>
<h4 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h4><p>动态参数意味着可以通过SET命令，在MySQL实例运行中更改。</p>
<p>SET语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span></span><br><span class="line"><span class="operator">|</span> [<span class="keyword">global</span> <span class="operator">|</span> session] system_var_name <span class="operator">=</span> expr</span><br><span class="line"><span class="operator">|</span> [@<span class="variable">@global</span>. <span class="operator">|</span> @<span class="variable">@session</span>. <span class="operator">|</span> @@]system_var_name <span class="operator">=</span> expr</span><br></pre></td></tr></table></figure>
<p>其中的global和session关键字，表明该参数的修改是基于当前会话还是整个实例的生命周期。</p>
<p><img src="https://s2.loli.net/2022/03/29/zftEOHb4gB8Mkcn.png" alt="image-20220329002557667"></p>
<p>对变量的全局值进行修改，在这次的实力生命周期内都有效，但MySQL实例本身并不会对参数文件进行修改。也就是说，下次MySQL启动时还是会读取参数文件。所以要根据需要，去修改参数文件。</p>
<h4 id="静态参数"><a href="#静态参数" class="headerlink" title="静态参数"></a>静态参数</h4><p>静态参数说明在整个实例生命周期中都不得进行更改。</p>
<p>如果对其修改，会报错。</p>
<h2 id="3-2-日志文件"><a href="#3-2-日志文件" class="headerlink" title="3.2 日志文件"></a>3.2 日志文件</h2><p>日志文件记录了影响MySQL数据库的各种类型活动。</p>
<h3 id="3-2-1-错误日志-error-log"><a href="#3-2-1-错误日志-error-log" class="headerlink" title="3.2.1 错误日志(error log)"></a>3.2.1 错误日志(error log)</h3><p>错误日志对MySQL的启动、运行、关闭过程进行了记录。该文件不仅记录了所有的错误信息，也记录了一些警告信息或正确的信息。</p>
<p>MySQL遇到问题时，应该首先查看该文件以便定位问题。</p>
<p>在默认情况下，错误日志的文件名为服务器的主机名，若主机名starg，则错误文件名为starg.err。</p>
<h3 id="3-2-2-慢查询日志-slow-query-log"><a href="#3-2-2-慢查询日志-slow-query-log" class="headerlink" title="3.2.2 慢查询日志(slow query log)"></a>3.2.2 慢查询日志(slow query log)</h3><p>可以帮助定位可能存在问题的SQL语句，从而进行SQL语句层面的优化。</p>
<h3 id="3-2-3-查询日志-log"><a href="#3-2-3-查询日志-log" class="headerlink" title="3.2.3 查询日志(log)"></a>3.2.3 查询日志(log)</h3><h3 id="3-2-4-二进制日志-binlog"><a href="#3-2-4-二进制日志-binlog" class="headerlink" title="3.2.4 二进制日志(binlog)"></a>3.2.4 二进制日志(binlog)</h3>]]></content>
      <tags>
        <tag>InnoDB存储引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM</title>
    <url>/2022/03/31/SSM/</url>
    <content><![CDATA[<p>SSM框架中，由Spring负责业务层，SpringMVC负责表现层(JSP)，MyBatis负责持久层。</p>
<h1 id="Chapter-1-MyBatis层"><a href="#Chapter-1-MyBatis层" class="headerlink" title="Chapter 1 MyBatis层"></a>Chapter 1 MyBatis层</h1><h2 id="0-建立数据库"><a href="#0-建立数据库" class="headerlink" title="0. 建立数据库"></a>0. 建立数据库</h2><h3 id="1-建数据库和表"><a href="#1-建数据库和表" class="headerlink" title="1. 建数据库和表"></a>1. 建数据库和表</h3><h3 id="2-关联数据库"><a href="#2-关联数据库" class="headerlink" title="2. 关联数据库"></a>2. 关联数据库</h3><p>在引入依赖之后执行</p>
<h4 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h4><p><img src="https://s2.loli.net/2022/04/01/nVNj4IloykTA5UK.png" alt="image-20220401193614669"></p>
<h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h4><p><img src="https://s2.loli.net/2022/04/01/jLi7pbTNnq9MSuB.png" alt="image-20220401193842788"></p>
<h4 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h4><p><img src="https://s2.loli.net/2022/04/01/gRnivUwZ6HraLqC.png" alt="image-20220401194123393"></p>
<h4 id="step-4"><a href="#step-4" class="headerlink" title="step 4"></a>step 4</h4><p><img src="https://s2.loli.net/2022/04/01/Rbu3w5o74srl2hi.png" alt="image-20220401194224464"></p>
<h4 id="jdbc-properties"><a href="#jdbc-properties" class="headerlink" title="jdbc.properties"></a>jdbc.properties</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment"># MySQL8.0以上的版本，这里需要增加一个时区的配置，url&amp;serverTimezone=Asia/shanghai</span></span><br><span class="line"><span class="comment"># 下边这个是使用身份验证和设定编码格式</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root12345</span></span><br></pre></td></tr></table></figure>
<h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h2><p>需要的依赖：junit、数据库驱动、连接池、servlet、jsp、MyBatis、mybatis-spring、Spring</p>
<h3 id="1-Lombok"><a href="#1-Lombok" class="headerlink" title="1. Lombok"></a>1. Lombok</h3><p>主要用在实体类上</p>
<p>Lombok是一个Java库，能自动插入编辑器并构建工具，简化Java开发，通过添加注解的方式，不需要为类编写getter或equals等方法，同时可以自动化日志变量。</p>
<p>@Data注解在类上，会为类的所有属性自动生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。</p>
<h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><p><img src="https://s2.loli.net/2022/04/01/xK1MO9f7yFVXJQP.png" alt="image-20220401004356943"></p>
<h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test.ssm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssmbuild<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- junit --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 数据库驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Servlet - JSP --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- MyBatis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Spring --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Lombok --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 解决静态资源导出问题，保证java和resources目录下的静态资源可以顺利导出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-核心配置文件"><a href="#2-核心配置文件" class="headerlink" title="2. 核心配置文件"></a>2. 核心配置文件</h2><p>MyBatis-config.xml</p>
<p>要做的：取别名，引入映射接口</p>
<p><strong>不用配置访问数据库，因为MyBatis中整合数据源的事情，交给了Spring去做。</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- MyBatis中配置整合数据源的事情，交给Spring去做 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置访问数据库的properties --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;properties resource=&quot;jdbc.properties&quot;/&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 以包为单位设置类型别名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.ssm.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- &lt;!-- 配置连接数据库的环境</span></span><br><span class="line"><span class="comment">    &lt;environments default=&quot;development&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;environment id=&quot;development&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span></span><br><span class="line"><span class="comment">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span></span><br><span class="line"><span class="comment">                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;</span></span><br><span class="line"><span class="comment">                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span></span><br><span class="line"><span class="comment">                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span></span><br><span class="line"><span class="comment">                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span></span><br><span class="line"><span class="comment">            &lt;/dataSource&gt;</span></span><br><span class="line"><span class="comment">        &lt;/environment&gt;</span></span><br><span class="line"><span class="comment">    &lt;/environments&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 以包为单位引入映射文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.ssm.dao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;mapper class=&quot;com.ssm.dao.BookMapper&quot; /&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有参构造</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="comment">// 无参构造</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br></pre></td></tr></table></figure>
<h2 id="3-持久化层"><a href="#3-持久化层" class="headerlink" title="3. 持久化层"></a>3. 持久化层</h2><p>采用dao模式，建立实体类和数据库表映射，也就是哪个类对应哪个表，哪个属性对应哪个列。</p>
<p>持久层的目的就是，完成对象数据和关系数据的转换。</p>
<h3 id="0-组成部分"><a href="#0-组成部分" class="headerlink" title="0. 组成部分"></a>0. 组成部分</h3><p><img src="https://s2.loli.net/2022/04/01/qU3BXP5ZVNRLxCy.png" alt="image-20220401204306939"></p>
<h3 id="1-实体类"><a href="#1-实体类" class="headerlink" title="1. 实体类"></a>1. 实体类</h3><p>pojo包，Book实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ssm.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Books</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/03/2022/3/31 21:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Books</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> bookID;</span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> bookCount;</span><br><span class="line">    <span class="keyword">private</span> String detail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>service层作为业务逻辑层，要调用dao层来操作数据库，所以需要组合dao层的Java类。</p>
<p>dao和service层，即MVC的Model层</p>
<h3 id="2-映射接口"><a href="#2-映射接口" class="headerlink" title="2. 映射接口"></a>2. 映射接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc: 增加一本书</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> books</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> int&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/31 21:56</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">addBook</span><span class="params">(Books books)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc: 删除一本书，通过id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> int&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/31 21:56</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteBookById</span><span class="params">(<span class="meta">@Param(&quot;bookId&quot;)</span><span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc: 修改书的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> books</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> int&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/31 21:56</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateBook</span><span class="params">(Books books)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc: 通过id查询书</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Books&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/31 21:56</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Books <span class="title function_">queryBookById</span><span class="params">(<span class="meta">@Param(&quot;bookId&quot;)</span> <span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Desc: 查询所有的书</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> List&lt; Books&gt;&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LISHANSHAN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/3/31 21:57</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Books&gt; <span class="title function_">queryAllBooks</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-映射文件"><a href="#3-映射文件" class="headerlink" title="3. 映射文件"></a>3. 映射文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.ssm.dao.BookMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- int addBook(Books books); --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addBook&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Books&quot;</span>&gt;</span></span><br><span class="line">        insert into books (bookName, bookCounts, detail)</span><br><span class="line">        values (#&#123;bookName&#125;, #&#123;bookCounts&#125;, #&#123;detail&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- int deleteBookById(int id); --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteBookById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        delete from ssmbuild.books where bookID = #&#123;bookId&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- int updateBook(Books book); --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBook&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Books&quot;</span>&gt;</span></span><br><span class="line">        update ssmbuild.books set bookName=#&#123;bookName&#125;, bookCounts=#&#123;bookCounts&#125;, detail=#&#123;detail&#125;</span><br><span class="line">        where bookID = #&#123;bookID&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Books queryBookById(int id); --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBookById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Books&quot;</span>&gt;</span></span><br><span class="line">        select * from ssmbuild.books where bookID = #&#123;bookId&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- List&lt;Books&gt; queryAllBooks(); --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAllBooks&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Books&quot;</span>&gt;</span></span><br><span class="line">        select * from books;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-业务层-service-层"><a href="#4-业务层-service-层" class="headerlink" title="4. 业务层(service 层)"></a>4. 业务层(service 层)</h2><p>采用事务脚本模式，将一个业务中所有的操作封装成一个方法，同时保证方法中所有的数据库更新操作，同时成功或同时失败，避免部分成功部分失败引起的数据混乱操作。</p>
<p>业务层也是承接层，用来处理业务逻辑，通常使用数据库中的事务来进行，按照web层的要求来对数据进行增删改查。</p>
<p>封装通用的业务逻辑、操作；与数据层交互等</p>
<h3 id="BookService接口"><a href="#BookService接口" class="headerlink" title="BookService接口"></a>BookService接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">addBook</span><span class="params">(Books books)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteBookById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateBook</span><span class="params">(Books books)</span>;</span><br><span class="line"></span><br><span class="line">    Books <span class="title function_">queryBookById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Books&gt; <span class="title function_">queryAllBooks</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BookServiceImpl"><a href="#BookServiceImpl" class="headerlink" title="BookServiceImpl"></a>BookServiceImpl</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addBook</span><span class="params">(Books books)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookMapper.addBook(books);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteBookById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookMapper.deleteBookById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateBook</span><span class="params">(Books books)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookMapper.updateBook(books);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Books <span class="title function_">queryBookById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookMapper.queryBookById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Books&gt; <span class="title function_">queryAllBooks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookMapper.queryAllBooks();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BookMapper <span class="title function_">getBookMapper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookMapper</span><span class="params">(BookMapper bookMapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookMapper = bookMapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Chapter-2-Spring层"><a href="#Chapter-2-Spring层" class="headerlink" title="Chapter 2 Spring层"></a>Chapter 2 Spring层</h1><h2 id="0-创建applicationContext-xml"><a href="#0-创建applicationContext-xml" class="headerlink" title="0. 创建applicationContext.xml"></a>0. 创建applicationContext.xml</h2><p>导入之后的所有配置文件，保证它们处于同一个上下文中，防止因配置文件无法读取而影响执行。</p>
<h2 id="1-整合dao层"><a href="#1-整合dao层" class="headerlink" title="1. 整合dao层"></a>1. 整合dao层</h2><p>创建spring-dao.xml配置文件</p>
<p>关联数据库配置文件，配置数据库连接，包括数据源和连接池等，绑定MyBatis核心文件，扫描dao包以实现与dao层的连接。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 关联数据库配置文件，这是专门导入数据库配置文件的标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">&lt;!-- 连接池</span></span><br><span class="line"><span class="comment">		dbcp：半自动化操作，不能自动连接</span></span><br><span class="line"><span class="comment">		c3p0：自动化操作，自动化地加载配置文件，并且可以自动设置到对象中</span></span><br><span class="line"><span class="comment">		druid： hikari ：公司用的</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- c3p0连接池的私有属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 关闭连接后不自动commit --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;autoCommitOnClose&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 获取连接超时时间 10s--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;checkoutTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当获取连接失败重试次数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireRetryAttempts&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">	<span class="comment">&lt;!-- sqlSessionFactory --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入dataSource数据源，即注入数据库连接池，通过ref引用上边配置的dataSource --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 绑定MyBatis的核心配置文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置dao接口扫描包，动态地实现了dao接口注入到Spring容器中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入sqlSessionFactory --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 给出需要扫描的Dao接口包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.ssm.dao&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上边的最后一个步骤，主要是为了代替BookMapper接口的实现类BookMapperImpl，省得每一个接口都要写一个实现类 --&gt;</span></span><br></pre></td></tr></table></figure>
<p>专门导入数据库的配置文件的标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样，数据库的配置文件就可以通过Spring去读了，之前都是通过MyBatis去读的。</p>
<h2 id="2-整合service层"><a href="#2-整合service层" class="headerlink" title="2. 整合service层"></a>2. 整合service层</h2><p>扫描service注解、将处理业务的类，注入到IOC容器、声明式事务配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描service下的包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ssm.service&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将所有的业务类，注入到Spring的IOC容器中，通过配置实现 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;BookServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ssm.service.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookMapper&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookMapper&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明式事务配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSourceTransactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入数据库连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- aop事务支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="ApplicationContxt-xml中"><a href="#ApplicationContxt-xml中" class="headerlink" title="ApplicationContxt.xml中"></a>ApplicationContxt.xml中</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;spring-service.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;spring-dao.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将所有业务类注入到Spring，可以通过配置或注解实现</p>
<p>三个层要相互关联(即配置文件要放在相同的上下文中)，否则就会报错</p>
<p><img src="https://s2.loli.net/2022/03/31/y1wuGzglMIKV6SA.png" alt="image-20220331232229337"></p>
<p>两种解决方式</p>
<p>​    通过import，导入Spring文件到ApplicationContext.xml下</p>
<p>​    直接就在创建时，设置将它们放在同一个上下文下(页面上边冒出来的那个条)</p>
<p>两种方式：配置和注解</p>
<h1 id="Chapter-3-SpringMVC层"><a href="#Chapter-3-SpringMVC层" class="headerlink" title="Chapter 3 SpringMVC层"></a>Chapter 3 SpringMVC层</h1><h2 id="1-在项目结构中增加对web的支持"><a href="#1-在项目结构中增加对web的支持" class="headerlink" title="1. 在项目结构中增加对web的支持"></a>1. 在项目结构中增加对web的支持</h2><p>右键项目，选择Add Framework Support，选择web模块即可</p>
<h3 id="配置web-xml文件"><a href="#配置web-xml文件" class="headerlink" title="配置web.xml文件"></a>配置web.xml文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 乱码过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceRequestEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- put和delete --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 前端控制器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置绑定的配置文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Session过期时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>15<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-spring-mvc配置文件"><a href="#3-spring-mvc配置文件" class="headerlink" title="3. spring-mvc配置文件"></a>3. spring-mvc配置文件</h2><p>注解驱动、静态资源、扫描controller层、视图解析器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1.开启SpringMVC注解驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2.静态资源默认使用servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3.扫描包:controller --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ssm.controller&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 4.显示ViewResolver视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="在applicationContext-xml文件中"><a href="#在applicationContext-xml文件中" class="headerlink" title="在applicationContext.xml文件中"></a>在applicationContext.xml文件中</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;spring-mvc.xml&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class="line">http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd</span><br><span class="line">导入的是cache，需要修改为mvc的。</span><br></pre></td></tr></table></figure>
<p>将controller层和jsp交互起来。</p>
<p>controller层调用service层</p>
<h3 id="排错思路"><a href="#排错思路" class="headerlink" title="排错思路"></a>排错思路</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>bean不存在</p>
<p><img src="https://s2.loli.net/2022/04/04/nlJqRbhtBWoFaNH.png" alt="image-20220404113024872"></p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol>
<li>查看这个bean注入是否成功(在Controller页面)</li>
</ol>
<p><img src="https://s2.loli.net/2022/04/04/S7u8zWJNsqBiwhQ.png" alt="image-20220404103615754"></p>
<ol>
<li>Junit单元测试，看代码是否可以查询出结果</li>
</ol>
<p><img src="https://s2.loli.net/2022/04/04/SkEHbxFZj4CXWDf.png" alt="image-20220404112333471"></p>
<ol>
<li><p>这说明，问题不在底层，而是Spring出了问题。此时如果将@AutoWired和@Qualifier(“BookServiceImpl”)，替换为 <code>private BookService bookService = new BookServiceImpl();</code>即手动装配，依旧失败，显示为空指针。但是很显然，第2步存在结果，说明这不是一个空指针，所以</p>
</li>
<li><p>SpringMVC，整合的时候没有调用到service层的bean</p>
<ol>
<li><p>applicationContext.xml没有注入bean</p>
</li>
<li><p>要注意web.xml中，也绑定过配置文件。</p>
<p> 但是如果classpath中绑定的是spring-mvc.xml，那么肯定没有service层的xml配置文件，因为它没去扫描，即没导入这个配置文件，所以将classpath后的改成applicationContext.xml即可。这样就可以拿到bean啦</p>
</li>
</ol>
</li>
</ol>
<h1 id="Chapter-4-常用功能"><a href="#Chapter-4-常用功能" class="headerlink" title="Chapter 4 常用功能"></a>Chapter 4 常用功能</h1><h2 id="1-查询书籍功能"><a href="#1-查询书籍功能" class="headerlink" title="1. 查询书籍功能"></a>1. 查询书籍功能</h2><h3 id="0-控制层"><a href="#0-控制层" class="headerlink" title="0. 控制层"></a>0. 控制层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/allBook&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">list</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">    List&lt;Books&gt; list = bookService.queryAllBooks();</span><br><span class="line">    model.addAttribute(<span class="string">&quot;list&quot;</span>, list);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;allBook&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-主页：index-jsp"><a href="#1-主页：index-jsp" class="headerlink" title="1. 主页：index.jsp"></a>1. 主页：index.jsp</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: LISHANSHAN</span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">3</span>/<span class="number">31</span></span><br><span class="line">  Time: <span class="number">23</span>:<span class="number">31</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">      &lt;style&gt;</span><br><span class="line">          a &#123;</span><br><span class="line">              text-decoration: none;</span><br><span class="line">              color: black;</span><br><span class="line">              font-size: 18px;</span><br><span class="line">          &#125;</span><br><span class="line">          h3 &#123;</span><br><span class="line">              width: 180px;</span><br><span class="line">              height: 38px;</span><br><span class="line">              margin: 100px auto;</span><br><span class="line">              text-align: center;</span><br><span class="line">              line-height: 38px;</span><br><span class="line">              background: deepskyblue;</span><br><span class="line">              border-radius: 5px;</span><br><span class="line">          &#125;</span><br><span class="line">      &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;h3&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/book/allBook&quot;</span>&gt;进入书籍界面&lt;/a&gt;</span><br><span class="line">  &lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-书籍展示：allBook-jsp"><a href="#2-书籍展示：allBook-jsp" class="headerlink" title="2. 书籍展示：allBook.jsp"></a>2. 书籍展示：allBook.jsp</h3><p>此处将数据进行展示，引入BootStrap来美化页面</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: LISHANSHAN</span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">4</span>/<span class="number">1</span></span><br><span class="line">  Time: <span class="number">21</span>:<span class="number">18</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;书籍展示&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">   &lt;%-- BootStrap美化界面 --%&gt;</span><br><span class="line">    &lt;link href=<span class="string">&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">&quot;row clearfix&quot;</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">&quot;col-md-12 column&quot;</span>&gt;</span><br><span class="line">            &lt;div class=<span class="string">&quot;page-header&quot;</span>&gt;</span><br><span class="line">                &lt;h1&gt;</span><br><span class="line">                    &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt;</span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">&quot;row clearfix&quot;</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">&quot;col-md-12 column&quot;</span>&gt;</span><br><span class="line">            &lt;table class=<span class="string">&quot;table table-hover table-striped&quot;</span>&gt;</span><br><span class="line">                &lt;thead&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;th&gt;书籍编号&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;书籍名称&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;书籍数量&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;书籍详情&lt;/th&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">                &lt;/thead&gt;</span><br><span class="line">                &lt;tbody&gt;</span><br><span class="line">                &lt;%-- 书籍从数据库中查询出来，从list中遍历出来：foreach --%&gt;</span><br><span class="line">                &lt;c:forEach <span class="keyword">var</span>=<span class="string">&quot;book&quot;</span> items=<span class="string">&quot;$&#123;list&#125;&quot;</span>&gt;</span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;book.bookID&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;book.bookName&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;book.bookCount&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;book.detail&#125;&lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line">                &lt;/c:forEach&gt;</span><br><span class="line">                &lt;/tbody&gt;</span><br><span class="line">            &lt;/table&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>对于bootstrap，需要增加了解。</p>
<h2 id="2-添加书籍功能"><a href="#2-添加书籍功能" class="headerlink" title="2. 添加书籍功能"></a>2. 添加书籍功能</h2><h3 id="0-控制层-1"><a href="#0-控制层-1" class="headerlink" title="0. 控制层"></a>0. 控制层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toAddBook&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toAddBooks</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;addBook&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/addBook&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addBook</span><span class="params">(Books books)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;addBook-&gt;&quot;</span> + books);</span><br><span class="line">    bookService.addBook(books);</span><br><span class="line">    <span class="comment">// 重定向请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/book/allBook&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-addBook-jsp页面"><a href="#1-addBook-jsp页面" class="headerlink" title="1. addBook.jsp页面"></a>1. addBook.jsp页面</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">allBook.jsp页面</span><br><span class="line">&lt;div class=<span class="string">&quot;row&quot;</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">&quot;col-md-4 column&quot;</span>&gt;</span><br><span class="line">        &lt;%-- toAddBook --%&gt;</span><br><span class="line">        &lt;a class=<span class="string">&quot;btn btn-primary&quot;</span> href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/book/toAddBook&quot;</span>&gt;新增书籍&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: LISHANSHAN</span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">4</span>/<span class="number">4</span></span><br><span class="line">  Time: <span class="number">18</span>:<span class="number">47</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;新增书籍&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;link href=<span class="string">&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">&quot;row clearfix&quot;</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">&quot;col-md-12 column&quot;</span>&gt;</span><br><span class="line">            &lt;div class=<span class="string">&quot;page-header&quot;</span>&gt;</span><br><span class="line">                &lt;h1&gt;</span><br><span class="line">                    &lt;small&gt;新增书籍&lt;/small&gt;</span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/book/addBook&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">&quot;form-group&quot;</span>&gt;</span><br><span class="line">        &lt;label&gt;书籍名称&lt;/label&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> class=<span class="string">&quot;form-control&quot;</span> name=<span class="string">&quot;bookName&quot;</span> required&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">&quot;form-group&quot;</span>&gt;</span><br><span class="line">        &lt;label&gt;书籍数量&lt;/label&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> class=<span class="string">&quot;form-control&quot;</span> name=<span class="string">&quot;bookCounts&quot;</span> required&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">&quot;form-group&quot;</span>&gt;</span><br><span class="line">        &lt;label&gt;书籍详情&lt;/label&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> class=<span class="string">&quot;form-control&quot;</span> name=<span class="string">&quot;detail&quot;</span> required&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">&quot;form-group&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> class=<span class="string">&quot;form-control&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="页面展示"><a href="#页面展示" class="headerlink" title="页面展示"></a>页面展示</h3><p><img src="https://s2.loli.net/2022/04/04/9BUTx2CEGKjZIOa.png" alt="image-20220404193219509"></p>
<h2 id="3-修改和删除功能"><a href="#3-修改和删除功能" class="headerlink" title="3. 修改和删除功能"></a>3. 修改和删除功能</h2><h3 id="0-控制层-2"><a href="#0-控制层-2" class="headerlink" title="0. 控制层"></a>0. 控制层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toUpdateBook&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toUpdateBook</span><span class="params">(Integer id, Model model)</span> &#123;</span><br><span class="line">    <span class="type">Books</span> <span class="variable">books</span> <span class="operator">=</span> bookService.queryBookById(id);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;books&quot;</span>, books);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;updateBook&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/updateBook&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">updateBook</span><span class="params">(Books books)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;books -&gt;&quot;</span> + books);</span><br><span class="line">    <span class="comment">// 真正修改，要靠业务层去修改</span></span><br><span class="line">    bookService.updateBook(books);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/book/allBook&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/deleteBook/&#123;bookId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deleteBook</span><span class="params">(<span class="meta">@PathVariable(&quot;bookId&quot;)</span>Integer id)</span> &#123;</span><br><span class="line">    System.out.println(id);</span><br><span class="line">    bookService.deleteBookById(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/book/allBook&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-updateBook-jsp"><a href="#1-updateBook-jsp" class="headerlink" title="1. updateBook.jsp"></a>1. updateBook.jsp</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: LISHANSHAN</span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">4</span>/<span class="number">4</span></span><br><span class="line">  Time: <span class="number">18</span>:<span class="number">47</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;新增书籍&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;link href=<span class="string">&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">&quot;row clearfix&quot;</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">&quot;col-md-12 column&quot;</span>&gt;</span><br><span class="line">            &lt;div class=<span class="string">&quot;page-header&quot;</span>&gt;</span><br><span class="line">                &lt;h1&gt;</span><br><span class="line">                    &lt;small&gt;修改书籍&lt;/small&gt;</span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/book/updateBook&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">&quot;form-group&quot;</span>&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;hidden&quot;</span> name=<span class="string">&quot;bookID&quot;</span> value=<span class="string">&quot;$&#123;books.bookID&#125;&quot;</span>&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">&quot;form-group&quot;</span>&gt;</span><br><span class="line">            &lt;label&gt;书籍名称&lt;/label&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;text&quot;</span> class=<span class="string">&quot;form-control&quot;</span> name=<span class="string">&quot;bookName&quot;</span> value=<span class="string">&quot;$&#123;books.bookName&#125;&quot;</span> required&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">&quot;form-group&quot;</span>&gt;</span><br><span class="line">            &lt;label&gt;书籍数量&lt;/label&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;text&quot;</span> class=<span class="string">&quot;form-control&quot;</span> name=<span class="string">&quot;bookCounts&quot;</span> value=<span class="string">&quot;$&#123;books.bookCounts&#125;&quot;</span> required&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">&quot;form-group&quot;</span>&gt;</span><br><span class="line">            &lt;label&gt;书籍详情&lt;/label&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;text&quot;</span> class=<span class="string">&quot;form-control&quot;</span> name=<span class="string">&quot;detail&quot;</span> value=<span class="string">&quot;$&#123;books.detail&#125;&quot;</span> required&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">&quot;form-group&quot;</span>&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;submit&quot;</span> class=<span class="string">&quot;form-control&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-allBook-jsp"><a href="#2-allBook-jsp" class="headerlink" title="2. allBook.jsp"></a>2. allBook.jsp</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: LISHANSHAN</span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">4</span>/<span class="number">1</span></span><br><span class="line">  Time: <span class="number">21</span>:<span class="number">18</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;书籍展示&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">   &lt;%-- BootStrap美化界面 --%&gt;</span><br><span class="line">    &lt;link href=<span class="string">&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">&quot;row clearfix&quot;</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">&quot;col-md-12 column&quot;</span>&gt;</span><br><span class="line">            &lt;div class=<span class="string">&quot;page-header&quot;</span>&gt;</span><br><span class="line">                &lt;h1&gt;</span><br><span class="line">                    &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt;</span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=<span class="string">&quot;row&quot;</span>&gt;</span><br><span class="line">            &lt;div class=<span class="string">&quot;col-md-4 column&quot;</span>&gt;</span><br><span class="line">                &lt;%-- toAddBook --%&gt;</span><br><span class="line">                &lt;a class=<span class="string">&quot;btn btn-primary&quot;</span> href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/book/toAddBook&quot;</span>&gt;新增书籍&lt;/a&gt;</span><br><span class="line">                &lt;a class=<span class="string">&quot;btn btn-primary&quot;</span> href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/book/allBook&quot;</span>&gt;显示全部书籍&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=<span class="string">&quot;col-md-4 column&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div class=<span class="string">&quot;col-md-4 column&quot;</span>&gt;</span><br><span class="line">                &lt;form class=<span class="string">&quot;form-inline&quot;</span> action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/book/queryBook&quot;</span> method=<span class="string">&quot;post&quot;</span> style=<span class="string">&quot;float:right&quot;</span>&gt;</span><br><span class="line">                    &lt;span style=<span class="string">&quot;color:red; font-weight:bold&quot;</span>&gt;$&#123;error&#125;&lt;/span&gt;</span><br><span class="line">                    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;bookName&quot;</span> class=<span class="string">&quot;form-control&quot;</span> placeholder=<span class="string">&quot;请输入要查询的书籍名称&quot;</span>&gt;</span><br><span class="line">                    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;查询&quot;</span> class=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span><br><span class="line">                &lt;/form&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">&quot;row clearfix&quot;</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">&quot;col-md-12 column&quot;</span>&gt;</span><br><span class="line">            &lt;table class=<span class="string">&quot;table table-hover table-striped&quot;</span>&gt;</span><br><span class="line">                &lt;thead&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;th&gt;书籍编号&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;书籍名称&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;书籍数量&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;书籍详情&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;操作&lt;/th&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">                &lt;/thead&gt;</span><br><span class="line">                &lt;tbody&gt;</span><br><span class="line">                &lt;%-- 书籍从数据库中查询出来，从list中遍历出来：foreach --%&gt;</span><br><span class="line">                &lt;c:forEach <span class="keyword">var</span>=<span class="string">&quot;book&quot;</span> items=<span class="string">&quot;$&#123;list&#125;&quot;</span>&gt;</span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;book.bookID&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;book.bookName&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;book.bookCounts&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;book.detail&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;</span><br><span class="line">                            &lt;%-- 新增的部分 --%&gt;</span><br><span class="line">                            &lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/book/toUpdateBook?id=$&#123;book.bookID&#125;&quot;</span>&gt;修改&lt;/a&gt;</span><br><span class="line">                            &amp;nbsp; | &amp;nbsp;</span><br><span class="line">                            &lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/book/deleteBook/$&#123;book.bookID&#125;&quot;</span>&gt;删除&lt;/a&gt;</span><br><span class="line">                        &lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line">                &lt;/c:forEach&gt;</span><br><span class="line">                &lt;/tbody&gt;</span><br><span class="line">            &lt;/table&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="页面展示-1"><a href="#页面展示-1" class="headerlink" title="页面展示"></a>页面展示</h3><p><img src="https://s2.loli.net/2022/04/05/F24kMwphDms5yBG.png" alt="image-20220405233021578"></p>
<h2 id="4-根据书籍名称查找"><a href="#4-根据书籍名称查找" class="headerlink" title="4. 根据书籍名称查找"></a>4. 根据书籍名称查找</h2><p>从0新增的一个功能。</p>
<p>由于访问的顺序是：前端jsp-&gt;控制器-&gt;service层-&gt;dao层-&gt;数据库。</p>
<p>所以需要从底向上写。</p>
<h3 id="1-dao层"><a href="#1-dao层" class="headerlink" title="1. dao层"></a>1. dao层</h3><h4 id="BookMapper接口"><a href="#BookMapper接口" class="headerlink" title="BookMapper接口"></a>BookMapper接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Books <span class="title function_">queryBookByName</span><span class="params">(<span class="meta">@Param(&quot;bookName&quot;)</span>String bookName)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="BookMapper-xml"><a href="#BookMapper-xml" class="headerlink" title="BookMapper.xml"></a>BookMapper.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Books queryBookByName(@Param(&quot;bookName&quot;)String bookName); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBookByName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Books&quot;</span>&gt;</span></span><br><span class="line">    select * from ssmbuild.books where bookName = #&#123;bookName&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-service层"><a href="#2-service层" class="headerlink" title="2. service层"></a>2. service层</h3><h4 id="BookService接口-1"><a href="#BookService接口-1" class="headerlink" title="BookService接口"></a>BookService接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Books <span class="title function_">queryBookByName</span><span class="params">(String bookName)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="BookServiceImpl实现类"><a href="#BookServiceImpl实现类" class="headerlink" title="BookServiceImpl实现类"></a>BookServiceImpl实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Books <span class="title function_">queryBookByName</span><span class="params">(String bookName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bookMapper.queryBookByName(bookName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-控制器"><a href="#3-控制器" class="headerlink" title="3. 控制器"></a>3. 控制器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/queryBook&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">queryBook</span><span class="params">(String bookName, Model model)</span> &#123;</span><br><span class="line">    <span class="type">Books</span> <span class="variable">books</span> <span class="operator">=</span> bookService.queryBookByName(bookName);</span><br><span class="line">    List&lt;Books&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 如果查询结果为空，显示全部书籍</span></span><br><span class="line">    <span class="keyword">if</span> (books == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// return list(model);</span></span><br><span class="line">        list = bookService.queryAllBooks();</span><br><span class="line">        model.addAttribute(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;未查到&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list.add(books);</span><br><span class="line">    &#125;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;list&quot;</span>, list);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;allBook&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-jsp页面"><a href="#4-jsp页面" class="headerlink" title="4. jsp页面"></a>4. jsp页面</h3><h4 id="allBook-jsp"><a href="#allBook-jsp" class="headerlink" title="allBook.jsp"></a>allBook.jsp</h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: LISHANSHAN</span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">4</span>/<span class="number">1</span></span><br><span class="line">  Time: <span class="number">21</span>:<span class="number">18</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;书籍展示&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">   &lt;%-- BootStrap美化界面 --%&gt;</span><br><span class="line">    &lt;link href=<span class="string">&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">&quot;row clearfix&quot;</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">&quot;col-md-12 column&quot;</span>&gt;</span><br><span class="line">            &lt;div class=<span class="string">&quot;page-header&quot;</span>&gt;</span><br><span class="line">                &lt;h1&gt;</span><br><span class="line">                    &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt;</span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=<span class="string">&quot;row&quot;</span>&gt;</span><br><span class="line">            &lt;div class=<span class="string">&quot;col-md-4 column&quot;</span>&gt;</span><br><span class="line">                &lt;%-- toAddBook --%&gt;</span><br><span class="line">                &lt;a class=<span class="string">&quot;btn btn-primary&quot;</span> href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/book/toAddBook&quot;</span>&gt;新增书籍&lt;/a&gt;</span><br><span class="line">                &lt;a class=<span class="string">&quot;btn btn-primary&quot;</span> href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/book/allBook&quot;</span>&gt;显示全部书籍&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=<span class="string">&quot;col-md-4 column&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div class=<span class="string">&quot;col-md-4 column&quot;</span>&gt;</span><br><span class="line">                &lt;form class=<span class="string">&quot;form-inline&quot;</span> action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/book/queryBook&quot;</span> method=<span class="string">&quot;post&quot;</span> style=<span class="string">&quot;float:right&quot;</span>&gt;</span><br><span class="line">                    &lt;span style=<span class="string">&quot;color:red; font-weight:bold&quot;</span>&gt;$&#123;error&#125;&lt;/span&gt;</span><br><span class="line">                    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;bookName&quot;</span> class=<span class="string">&quot;form-control&quot;</span> placeholder=<span class="string">&quot;请输入要查询的书籍名称&quot;</span>&gt;</span><br><span class="line">                    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;查询&quot;</span> class=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span><br><span class="line">                &lt;/form&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">&quot;row clearfix&quot;</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">&quot;col-md-12 column&quot;</span>&gt;</span><br><span class="line">            &lt;table class=<span class="string">&quot;table table-hover table-striped&quot;</span>&gt;</span><br><span class="line">                &lt;thead&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;th&gt;书籍编号&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;书籍名称&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;书籍数量&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;书籍详情&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;操作&lt;/th&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">                &lt;/thead&gt;</span><br><span class="line">                &lt;tbody&gt;</span><br><span class="line">                &lt;%-- 书籍从数据库中查询出来，从list中遍历出来：foreach --%&gt;</span><br><span class="line">                &lt;c:forEach <span class="keyword">var</span>=<span class="string">&quot;book&quot;</span> items=<span class="string">&quot;$&#123;list&#125;&quot;</span>&gt;</span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;book.bookID&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;book.bookName&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;book.bookCounts&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;book.detail&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;</span><br><span class="line">                            &lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/book/toUpdateBook?id=$&#123;book.bookID&#125;&quot;</span>&gt;修改&lt;/a&gt;</span><br><span class="line">                            &amp;nbsp; | &amp;nbsp;</span><br><span class="line">                            &lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/book/deleteBook/$&#123;book.bookID&#125;&quot;</span>&gt;删除&lt;/a&gt;</span><br><span class="line">                        &lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line">                &lt;/c:forEach&gt;</span><br><span class="line">                &lt;/tbody&gt;</span><br><span class="line">            &lt;/table&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="页面展示-2"><a href="#页面展示-2" class="headerlink" title="页面展示"></a>页面展示</h3><p><img src="https://s2.loli.net/2022/04/05/HXzuKmAn4T5csRP.png" alt="image-20220405233723558"></p>
<h2 id="5-最终的BookController"><a href="#5-最终的BookController" class="headerlink" title="5. 最终的BookController"></a>5. 最终的BookController</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/book&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;BookServiceImpl&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/allBook&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">list</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        List&lt;Books&gt; list = bookService.queryAllBooks();</span><br><span class="line">        model.addAttribute(<span class="string">&quot;list&quot;</span>, list);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;allBook&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/toAddBook&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toAddBooks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;addBook&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/addBook&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addBook</span><span class="params">(Books books)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;addBook-&gt;&quot;</span> + books);</span><br><span class="line">        bookService.addBook(books);</span><br><span class="line">        <span class="comment">// 重定向请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/book/allBook&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/toUpdateBook&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toUpdateBook</span><span class="params">(Integer id, Model model)</span> &#123;</span><br><span class="line">        <span class="type">Books</span> <span class="variable">books</span> <span class="operator">=</span> bookService.queryBookById(id);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;books&quot;</span>, books);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;updateBook&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/updateBook&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">updateBook</span><span class="params">(Books books)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;books -&gt;&quot;</span> + books);</span><br><span class="line">        <span class="comment">// 真正修改，要靠业务层去修改</span></span><br><span class="line">        bookService.updateBook(books);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/book/allBook&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/deleteBook/&#123;bookId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteBook</span><span class="params">(<span class="meta">@PathVariable(&quot;bookId&quot;)</span>Integer id)</span> &#123;</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        bookService.deleteBookById(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/book/allBook&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/queryBook&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">queryBook</span><span class="params">(String bookName, Model model)</span> &#123;</span><br><span class="line">        <span class="type">Books</span> <span class="variable">books</span> <span class="operator">=</span> bookService.queryBookByName(bookName);</span><br><span class="line">        List&lt;Books&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 如果查询结果为空，显示全部书籍</span></span><br><span class="line">        <span class="keyword">if</span> (books == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// return list(model);</span></span><br><span class="line">            list = bookService.queryAllBooks();</span><br><span class="line">            model.addAttribute(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;未查到&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list.add(books);</span><br><span class="line">        &#125;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;list&quot;</span>, list);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;allBook&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>bootstrap将页面分为12等份。</p>
<p>运行时抛出NoSuchMethodError错误，根本原因是，应用程序直接或间接依赖了同一个类的多个版本，并且在运行时执行了缺少方法的版本。</p>
<p>本质上是由于编译时类路径与运行时类路径不一致。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;c:forEach&gt; 标签相当于Java中的<span class="keyword">for</span>循环语句，用来迭代一个集合中的对象。</span><br><span class="line"> 语法：   </span><br><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">&quot;name&quot;</span> items=<span class="string">&quot;Collection&quot;</span> varStatus=<span class="string">&quot;statusName&quot;</span> begin=<span class="string">&quot;begin&quot;</span> end=<span class="string">&quot;end&quot;</span> step=<span class="string">&quot;step&quot;</span>&gt;&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220417145457652.png" alt="image-20220417145457652"></p>
]]></content>
      <tags>
        <tag>SSM整合</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机是怎么跑起来的</title>
    <url>/2022/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/</url>
    <content><![CDATA[<h1 id="Chapter-1-计算机的三大原则"><a href="#Chapter-1-计算机的三大原则" class="headerlink" title="Chapter 1 计算机的三大原则"></a>Chapter 1 计算机的三大原则</h1><h2 id="1-1-计算机的三个根本性基础"><a href="#1-1-计算机的三个根本性基础" class="headerlink" title="1.1 计算机的三个根本性基础"></a>1.1 计算机的三个根本性基础</h2><ol>
<li>计算机是执行输入、运算、输出的机器</li>
<li>程序是指令和数据的集合</li>
<li>计算机的处理方式有时与人的思维习惯不同</li>
</ol>
<h2 id="1-2-第一条原则"><a href="#1-2-第一条原则" class="headerlink" title="1.2 第一条原则"></a>1.2 第一条原则</h2><p>输入、运算、输出是硬件的基础。</p>
<p>计算机的硬件有大量的IC(集成电路)组成。每块IC上都带有引脚。IC会在其内部对外部输入的信息进行运算，并把运算结果输出到外部。</p>
<h3 id="输入、运算和输出三者密不可分"><a href="#输入、运算和输出三者密不可分" class="headerlink" title="输入、运算和输出三者密不可分"></a>输入、运算和输出三者密不可分</h3><p><img src="https://s2.loli.net/2022/04/02/M4ujvFR7QyE8XVD.png" alt="image-20220402002835433"></p>
<h2 id="1-3-第二条原则"><a href="#1-3-第二条原则" class="headerlink" title="1.3 第二条原则"></a>1.3 第二条原则</h2><p>软件是指令和数据的集合。</p>
<p>程序不过就是指令和数据的集合。</p>
<h2 id="1-4-第三条原则"><a href="#1-4-第三条原则" class="headerlink" title="1.4 第三条原则"></a>1.4 第三条原则</h2><p>对计算机来说，什么都是数字。</p>
<p>计算机内部会先把文字转换成相应的数字再做处理，这样的数字叫作“字符编码”。总之计算机会把什么都用数字来表示。</p>
<h2 id="1-7-preview"><a href="#1-7-preview" class="headerlink" title="1.7 preview"></a>1.7 preview</h2><p>计算机内部的主要IC元件：CPU、内存以及I/O。</p>
<p>CPU是计算机的大脑，在其内部可对数据执行运算并控制内存和I/O。内存用于存储指令和数据。I/O负责把键盘、鼠标、显示器等周边设备和主机连接在一起，实现数据的输入与输出。</p>
<p><img src="https://s2.loli.net/2022/04/02/8u3GHAwXfSp6Dnd.png" alt="image-20220402004346468"></p>
<h1 id="Chapter-2-试着制造一台计算机吧"><a href="#Chapter-2-试着制造一台计算机吧" class="headerlink" title="Chapter 2 试着制造一台计算机吧"></a>Chapter 2 试着制造一台计算机吧</h1><h2 id="2-1-制作微型计算机的元件"><a href="#2-1-制作微型计算机的元件" class="headerlink" title="2.1 制作微型计算机的元件"></a>2.1 制作微型计算机的元件</h2><p>制作微型计算机的基础元件只有三个：CPU、内存和I/O。</p>
<h2 id="2-2-电路图的读法"><a href="#2-2-电路图的读法" class="headerlink" title="2.2 电路图的读法"></a>2.2 电路图的读法</h2><p><img src="https://s2.loli.net/2022/04/02/nOdesPvU2gz6HTN.png" alt="image-20220402215306676"></p>
<p>在表示IC的矩形符号中写上表明该引脚作用的代号。</p>
<p>如，RD(Read)表示执行读取操作，WR(Write)表示执行写入操作。</p>
<h2 id="2-3-连接电源、数据和地址总线"><a href="#2-3-连接电源、数据和地址总线" class="headerlink" title="2.3 连接电源、数据和地址总线"></a>2.3 连接电源、数据和地址总线</h2><p>首先连接电源。IC与普通电器一样，只有接通了电源才能工作。</p>
<p>将+5V连接到各个IC的VCC引脚上，然后将0V连接到各个IC的GND引脚上。</p>
<p>计算机以CPU为中心运转。CPU可以与内存或I/O进行数据的输入输出。</p>
<h3 id="TC5517"><a href="#TC5517" class="headerlink" title="TC5517"></a>TC5517</h3><p>作为内存的TC5517上也有地址总线引脚(A0-A10)和数据总线引脚(D0~D7)。一块TC5517上可以存储2048各8比特的数据。</p>
<p><img src="C:\Users\LISHANSHAN\AppData\Roaming\Typora\typora-user-images\image-20220402220149922.png" alt="image-20220402220149922"></p>
<h2 id="2-4-连接I-O"><a href="#2-4-连接I-O" class="headerlink" title="2.4 连接I/O"></a>2.4 连接I/O</h2><p>取Z80 PIO作为I/O。</p>
<p>寄存器是位于CPU和I/O中的数据存储器。Z80 PIO上共有4个寄存器。2个用于设定PIO本身的功能，2个用于存储与外部设备进行输入输出的数据。</p>
<h3 id="4个寄存器"><a href="#4个寄存器" class="headerlink" title="4个寄存器"></a>4个寄存器</h3><p>这四个寄存器分别叫做端口A控制、端口A数据、端口B控制和端口B数据。</p>
<p><img src="https://s2.loli.net/2022/04/02/PDXLzNupUt4iBGg.png" alt="image-20220402220648632"></p>
<h2 id="2-5-连接时钟信号"><a href="#2-5-连接时钟信号" class="headerlink" title="2.5 连接时钟信号"></a>2.5 连接时钟信号</h2><p>Z80 CPU和Z80 PIO的运转离不开时钟信号。</p>
<p>为了传输时钟信号，就需要把时钟发生器的8号引脚和Z80 CPU的CLK （CLK即Clock，时钟）引脚、Z80 PIO的CLK引脚分别连接起来。时钟发生器的8号引脚与+5V之间的电阻用于清理时钟信号。</p>
<h2 id="2-6-连接用于区分读写对象是内存还是I-O的引脚"><a href="#2-6-连接用于区分读写对象是内存还是I-O的引脚" class="headerlink" title="2.6 连接用于区分读写对象是内存还是I/O的引脚"></a>2.6 连接用于区分读写对象是内存还是I/O的引脚</h2><p>至此，已经先后把Z80 CPU连接到了TC5517和Z80 PIO上，这两次连接都使用了地址总线引脚A0和A1。</p>
<p>但仅仅这样连接，就会导致CPU无法区分访问的是TC5517中的存储单元，还是Z80 PIO中的寄存器了。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>Z80 CPU上的$\overline{MREQ}$（即Memory Request， 内存请求)引脚和$\overline{IORQ}$(即I/O Request，I/O请求)引脚解决了上述问题。</p>
<p>当Z80 CPU和内存之间有数据输入输出时，$\overline{MREQ}$引脚上的值为0，反之是1；</p>
<p>当Z80 CPU和I/O之间有数据输入输出时，$\overline{IORQ}$引脚上的值是0，反之是1。</p>
<h3 id="选通芯片"><a href="#选通芯片" class="headerlink" title="选通芯片"></a>选通芯片</h3><p>$\overline{CE}$引脚设为0，则TC5517在电路中被激活，若设成1，则从电路中隔离，因为此时它进入了高阻抗状态，所以即便它上面的引脚已经接入了电路也不会接受任何电信号。</p>
<p>在Z80 PIO中，则是通过将$\overline{CE}$引脚和$\overline{IORQ}$引脚同时设为0或1，来达到与TC5517的$\overline{CE}$引脚同样的效果。</p>
<h3 id="输入or输出数据"><a href="#输入or输出数据" class="headerlink" title="输入or输出数据"></a>输入or输出数据</h3><p>对内存和I/O而言，必须要分清CPU是要输入还是输出数据。</p>
<p>要用到Z80 CPU的$\overline{RD}$(Read，为0时执行输入)和$\overline{WR}$(即Write，为0时执行输出)引脚。</p>
<p><img src="https://s2.loli.net/2022/04/03/BcRMJIsHZGyFPtY.png" alt="image-20220403165246522"></p>
<h2 id="2-7-连接剩余的控制引脚"><a href="#2-7-连接剩余的控制引脚" class="headerlink" title="2.7 连接剩余的控制引脚"></a>2.7 连接剩余的控制引脚</h2><p>之所以这样命名，是因为这些引脚桑输入输出的电信号具有控制IC的功能。</p>
<h3 id="同步和中断"><a href="#同步和中断" class="headerlink" title="同步和中断"></a>同步和中断</h3><p>首先把Z80 CPU的$\overline{M1}$引脚（即Machine Cycle 1，机器周期1）和$\overline{INT}$引脚（即Interrupt，中断）与Z80 PIO上标有相同代号的引脚连接起来。$\overline{M1}$是用于同步的引脚，$\overline{INT}$引脚是用于从Z80 PIO向Z80 CPU发出中断请求的引脚。</p>
<h3 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h3><p>一旦把Z80 CPU的$\overline{RESET}$引脚（即Reset，重置）上的值先设成0再还原成1, CPU就会被重置，重新从内存0号地址上的指令开始顺序往下执行。</p>
<p>重置CPU可以通过按键开关完成。</p>
<h4 id="电容"><a href="#电容" class="headerlink" title="电容"></a>电容</h4><p>连接在$\overline{RESET}$引脚上有一个电容，用于在电路接通电源时，自动重置CPU。</p>
<p>电容就好像一个充电电池，具有储存电荷的功能，在通电后的一刹那，由于电容正在充电，所以$\overline{RESET}$引脚上的电压并不会立刻上升到+5V.而充电完成后，会变为+5V，相当于$\overline{RESET}$引脚的值从0变成了1，重置了一次CPU。</p>
<h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>总线是连接到CPU中数据引脚、地址引脚、控制引脚上的电路的统称。</p>
<p><img src="https://s2.loli.net/2022/04/03/IH7msyo231JnRS6.png" alt="image-20220403171633742"></p>
<p><img src="https://s2.loli.net/2022/04/03/HUDiXaNJolzK94I.png" alt="image-20220403172119763"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://s2.loli.net/2022/04/03/wn8o24GC1aQXfJk.png" alt="image-20220403172201225"></p>
<h2 id="2-8-通过DMA输入程序"><a href="#2-8-通过DMA输入程序" class="headerlink" title="2.8 通过DMA输入程序"></a>2.8 通过DMA输入程序</h2><p>向地址总线引脚和数据总线引脚发送电信号，通过DMA将数据总线上的数据存储到内存中。</p>
<p>一旦打开了Z80 CPU的$\overline{BUSRQ}$引脚连接着的开关，就可以通过$\overline{BUSAK}$引脚输出0得知CPU进入了DMA状态，就可以通过DMA向内存写入数据了。</p>
<h2 id="2-9-连接用于输入输出的外部设备"><a href="#2-9-连接用于输入输出的外部设备" class="headerlink" title="2.9 连接用于输入输出的外部设备"></a>2.9 连接用于输入输出的外部设备</h2><p>当微型计算机运行起来之后，指拨开关可用于从外部输入数据，LED可用于向外部输出数据。</p>
<p>最后，输入机器语言，来验证连线的正确性。</p>
<h1 id="Chapter-3-手工汇编"><a href="#Chapter-3-手工汇编" class="headerlink" title="Chapter 3 手工汇编"></a>Chapter 3 手工汇编</h1><p>所谓手工汇编也就是将汇编语言编好的程序，通过手工作业转换成CPU可以直接执行的机器语言。</p>
<h2 id="3-1-从程序员的角度看硬件"><a href="#3-1-从程序员的角度看硬件" class="headerlink" title="3.1 从程序员的角度看硬件"></a>3.1 从程序员的角度看硬件</h2><p><img src="https://s2.loli.net/2022/04/04/v4RXZnEDtQLJaB5.png" alt="image-20220404005258541"></p>
<h3 id="CPU信息"><a href="#CPU信息" class="headerlink" title="CPU信息"></a>CPU信息</h3><ul>
<li>CPU的种类(CPU的种类不同，对机器语言的解释就不同。)</li>
<li>时钟信号的频率(是时钟发生器发送给CPU的电信号的频率。)</li>
</ul>
<h3 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h3><ul>
<li>地址空间(每个地址都标示着一个内存中的数据存储单元，这些地址构成的范围)</li>
<li>每个地址中可以存储多少比特的信息</li>
</ul>
<h3 id="I-O信息"><a href="#I-O信息" class="headerlink" title="I/O信息"></a>I/O信息</h3><ul>
<li>I/O的种类(连接着微型计算机和周边设备的I/O的种类)</li>
<li>地址空间(用于指定I/O寄存器的地址范围)</li>
<li>连接着何种周边设备</li>
</ul>
<h2 id="3-2-机器语言和汇编语言"><a href="#3-2-机器语言和汇编语言" class="headerlink" title="3.2 机器语言和汇编语言"></a>3.2 机器语言和汇编语言</h2><p>汇编语言的语法只有一个，即把”标签”、”操作码(指令)”和”操作数(指令的对象)”并排写在一行上，仅此而已。</p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>标签的作用是为该行代码对应的内存地址起一个名字。</p>
<p>在汇编语言编程时可以在任何需要标签的地方”贴上”名称任意的标签。</p>
<h3 id="内存和I-O"><a href="#内存和I-O" class="headerlink" title="内存和I/O"></a>内存和I/O</h3><p>Z80 CPU的$\overline{MREQ}$引脚和$\overline{IORQ}$引脚实现了一种能区分输入输出对象的机制，可以区分出使用着相同内存地址的内存和I/O。</p>
<p>在汇编语言中，读写内存的指令不同于读写I/O的指令。</p>
<p>一旦执行了读写内存的指令，如LD，$\overline{MREQ}$引脚上的值就会变为0，于是内存就被选为输入输出的对象；</p>
<p>而一旦执行了读写I/O的指令，比如IN或OUT指令，$\overline{IORQ}$引脚上的值就会变为0，于是I/O被选为输入输出的对象。</p>
<h2 id="3-3-Z80-CPU的寄存器结构"><a href="#3-3-Z80-CPU的寄存器结构" class="headerlink" title="3.3 Z80 CPU的寄存器结构"></a>3.3 Z80 CPU的寄存器结构</h2><p>CPU中的寄存器和I/O中的寄存器不一样，CPU的寄存器不仅能存储数据，还具备对数据进行运算的能力。CPU带有什么样的寄存器取决于CPU的种类。</p>
<p>寄存器的用途取决于它的类型。</p>
<p>A寄存器：累加器，是运算的核心。</p>
<p>F寄存器：标志寄存器。</p>
<p>SP寄存器：栈顶指针，用于在内存中创建出一块称为”栈”的临时数据存储区域。</p>
<h3 id="指令分析"><a href="#指令分析" class="headerlink" title="指令分析"></a>指令分析</h3><p><img src="https://s2.loli.net/2022/04/08/5Jc1M68VTmWEI4o.png" alt="image-20220408201307569"></p>
<p>像(2)这样用括号括起来的数字，表示的是地址编号。端口A控制寄存器的I/O地址是2号。</p>
<p><img src="https://s2.loli.net/2022/04/08/ZKFAxzPWnTHItXC.png" alt="image-20220408201554695"></p>
<h4 id="LOOP等"><a href="#LOOP等" class="headerlink" title="LOOP等"></a>LOOP等</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOOP：IN A, (0)</span><br><span class="line">	 OUT (1), A</span><br><span class="line">	 JP LOOP</span><br></pre></td></tr></table></figure>
<p>IN A, (0)：把数据从端口A数据寄存器(I/O地址是0号)输入到CPU的寄存器A。</p>
<p>OUT (1), A：把寄存器A的值输出到端口B数据寄存器(I/O地址为1号)上。</p>
<p>JP LOOP：使程序的流程跳转到LOOP标签所表示的指令上。</p>
<p>当把标签作为JP指令的操作数时，标签名的结尾不需要冒号“:”，但是在设定标签时，标签名的结尾则需要加上一个冒号，这一点请诸位注意。</p>
<h2 id="3-5-尝试手工汇编"><a href="#3-5-尝试手工汇编" class="headerlink" title="3.5 尝试手工汇编"></a>3.5 尝试手工汇编</h2><p><img src="https://s2.loli.net/2022/04/08/dKGcMhSjUNOgFtw.png" alt="image-20220408203257679"></p>
<p>在将一个2字节的数据存储到内存时，存储顺序是低8位在前、高8位在后(也就是逆序存储)，即小端序。</p>
<p>将数据由高位到低位顺序地存储到内存的存储顺序，则叫做大端序。</p>
]]></content>
      <tags>
        <tag>笔记整理</tag>
      </tags>
  </entry>
  <entry>
    <title>程序是怎么跑起来的</title>
    <url>/2022/03/17/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/</url>
    <content><![CDATA[<h1 id="Chapter-1-对程序员来说CPU是什么"><a href="#Chapter-1-对程序员来说CPU是什么" class="headerlink" title="Chapter 1 对程序员来说CPU是什么"></a>Chapter 1 对程序员来说CPU是什么</h1><p>CPU是英文Central Processing Unit(中央处理器)的缩写，相当于计算机的大脑，它的内部有数百万至数亿个晶体管构成。</p>
<h2 id="1-1-CPU的内部结构解析"><a href="#1-1-CPU的内部结构解析" class="headerlink" title="1.1 CPU的内部结构解析"></a>1.1 CPU的内部结构解析</h2><p>CPU和内存是由许多晶体管组成的电子部件，通常称为IC （Integrated Circuit，集成电路）。</p>
<h3 id="程序运行流程示例"><a href="#程序运行流程示例" class="headerlink" title="程序运行流程示例"></a>程序运行流程示例</h3><ol>
<li>程序员用高级语言编写程序 -&gt; 2. 将程序编译后转换为机器语言的EXE文件 -&gt; 3. 程序运行时，在内存中生成EXE文件的副本 -&gt; 4. CPU解释并执行程序内容</li>
</ol>
<p>在这一流程中，<strong>CPU所负责的就是解释和运行最终转换为机器语言的程序内容。</strong></p>
<h3 id="CPU的结构"><a href="#CPU的结构" class="headerlink" title="CPU的结构"></a>CPU的结构</h3><ul>
<li><p>寄存器：暂存指令、数据等处理对象</p>
</li>
<li><p>控制器：负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机</p>
</li>
<li><p>运算器：负责运算从内存中读入寄存器的数据</p>
</li>
<li><p>时钟：发出CPU开始计时的时钟信号。(也有些时钟位于CPU的外部。)</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/18/5xKCZlJ89djuimP.png" alt="image-20220318110922481"></p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存指的是计算机的主存储器，通过控制芯片等与CPU相连，主要负责存储指令和数据。</p>
<p>主存由可读写的元素构成，每个字节都带有一个地址编号。CPU可以通过该地址读取主存中的指令和数据，当然也可以写入数据。</p>
<p><strong>但主存中存储的指令和数据会随着计算机的关机而自动清除。</strong></p>
<h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p>程序启动后，根据时钟信号，控制器会从主存中读取指令和数据。通过对这些指令加以解释和运行，运算器就会对数据进行运算，控制器根据该运算结果来控制计算机。</p>
<h2 id="1-2-CPU是寄存器的集合体"><a href="#1-2-CPU是寄存器的集合体" class="headerlink" title="1.2 CPU是寄存器的集合体"></a>1.2 CPU是寄存器的集合体</h2><p>CPU的四个构成部分中，程序员只需要了解寄存器即可，其余三个都不用太过关注。</p>
<p>程序是把寄存器作为对象来描述的。</p>
<h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p>汇编语言(assembly)采用助记符(memonic)来编写程序，每一个原本是电气信号的机器语言指令都会有一个与其相应的助记符。</p>
<p>助记符通常为指令功能的英语单词的简写。例如，mov和add分别是数据的存储（move）和相加（addition）的简写。汇编语言和机器语言基本上是一一对应的。</p>
<p>汇编语言是80386以上的CPU所使用的语言。</p>
<p>通常将汇编语言编写的程序转换成机器语言的过程称为汇编；</p>
<p>反之，机器语言程序转化为汇编语言程序的过程则称为反汇编。</p>
<p><img src="https://s2.loli.net/2022/03/18/9cbyBfMWgrKm2AZ.png" alt="image-20220318115348860"></p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>代码中，eax和ebp表示的都是寄存器。</p>
<p><strong>内存的存储场所通过地址编号来区分，而寄存器的种类则通过名字来区分。</strong></p>
<p>不同类型的CPU，其内部寄存器的数量、种类以及寄存器存储的数值范围都是不同的。</p>
<p>不过，根据功能的不同，我们可以将寄存器大致划分为八类。</p>
<p><img src="https://s2.loli.net/2022/03/18/lnz7YXjiymSpgqB.png" alt="image-20220318115709060"></p>
<h4 id="寄存器存储内容"><a href="#寄存器存储内容" class="headerlink" title="寄存器存储内容"></a>寄存器存储内容</h4><p>寄存器中存储的内容可以是指令也可以是数据。</p>
<p>数据又可以分为”用于运算的数值”和”表示内存地址的数值”两种。</p>
<p>数据种类不同，存储该数值的寄存器也不同。用于运算的数值放在累加寄存器中存储，表示内存底子好的数值则放在基址寄存器和变址寄存器中存储。</p>
<p>eax：累加寄存器；ebp：基址寄存器。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>CPU是具有各种功能的寄存器的集合体。其中，程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其他的寄存器一般有多个。</p>
<p><img src="https://s2.loli.net/2022/03/18/SePdzoWYvMEXqxf.png" alt="image-20220318120303663"></p>
<h2 id="1-3-程序计数器"><a href="#1-3-程序计数器" class="headerlink" title="1.3 程序计数器"></a>1.3 程序计数器</h2><p>用户发出启动程序的指示后，Windows等操作系统会把硬盘中保存的程序复制到内存中。</p>
<p>存储指令和数据的内存，是通过地址来划分的。</p>
<p>CPU的控制器会参照程序计数器的数值，从内存中读取命令并执行。</p>
<p>也就是说，程序计数器决定着程序的流程。</p>
<h2 id="1-4-条件分支和循环机制"><a href="#1-4-条件分支和循环机制" class="headerlink" title="1.4 条件分支和循环机制"></a>1.4 条件分支和循环机制</h2><p>程序的流程分为顺序执行、条件分支和循环三种。</p>
<p>顺序执行是指按照地址内容的顺序执行指令。</p>
<p>条件分支是指根据条件执行任意地址的指令。</p>
<p>循环是指重复执行同一地址的指令。</p>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p>“跳转到0104地址”这个指令，间接执行了“将程序计数器设定成0104地址”这个操作。</p>
<p>条件分支和循环中使用的跳转指令，会参照当前执行的运算结果来判断是否跳转。</p>
<h4 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h4><p>无论当前累加寄存器的运算结果是负数、零还是正数，标记寄存器都会将其保存(也负责存放溢出和奇偶校验的结果)。</p>
<p>CPU在进行运算时，标志寄存器的数值会根据运算结果自动设定。</p>
<p>条件分支在跳转指令前会进行比较运算。而是否跳转，由CPU在参考标志寄存器的数值后进行判断，运算结果的正、零、负三种状态由标志寄存器的三个位表示。</p>
<p><img src="https://s2.loli.net/2022/03/18/KAti4WQE8Xdzapu.png" alt="image-20220318121336116"></p>
<h4 id="CPU中的比较-减法"><a href="#CPU中的比较-减法" class="headerlink" title="CPU中的比较=减法"></a>CPU中的比较=减法</h4><p>假设要比较累加寄存器中存储的XXX值和通用寄存器中存储的YYY值，执行比较的指令后，CPU的运算装置就会在内部（暗中）进行XXX-YYY的减法运算。</p>
<p>而无论减法运算的结果是正数、零还是负数，都会保存到标志寄存器中。结果为正表示XXX比YYY大，零表示XXX和YYY相等，负表示XXX比YYY小。</p>
<p><strong>程序中的比较指令，就是在CPU内部做减法运算。</strong> </p>
<h2 id="1-5-函数的调用机制"><a href="#1-5-函数的调用机制" class="headerlink" title="1.5 函数的调用机制"></a>1.5 函数的调用机制</h2><p>函数调用处理也是通过<strong>把程序计数器的值设定为函数的存储地址</strong>来实现的。</p>
<p>函数的调用需要在完成函数内部的处理后，处理流程再返回到函数调用点(函数调用指令的下一条指令)。</p>
<p><img src="https://s2.loli.net/2022/03/18/hkx9enzWYfSTXVm.png" alt="image-20220318121836115"></p>
<p><strong>由于一行C语言程序在编译后通常会变成多行的机器语言，所以图中的地址是离散的。</strong></p>
<p>函数的调用原点（0132地址）和被调用函数（0260地址）之间的数据传递，可以通过内存或寄存器来实现。</p>
<h3 id="call指令和return命令"><a href="#call指令和return命令" class="headerlink" title="call指令和return命令"></a>call指令和return命令</h3><p>函数调用使用的是call指令，而不是跳转指令。</p>
<p>在函数的入口地址设定到程序计数器之前，call指令会把调用函数后要执行的指令地址存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行return命令。return命令的功能是把保存在栈中的地址设定到程序计数器中。</p>
<h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><h5 id="执行call指令"><a href="#执行call指令" class="headerlink" title="执行call指令"></a>执行call指令</h5><p><img src="https://s2.loli.net/2022/03/18/gtCnirZWEwaxB97.png" alt="image-20220318122514204"></p>
<h5 id="执行return指令"><a href="#执行return指令" class="headerlink" title="执行return指令"></a>执行return指令</h5><p><img src="https://s2.loli.net/2022/03/18/AEJYl9jKUVab4kO.png" alt="image-20220318122717400"></p>
<p>函数调用的处理会转换成call指令，函数结束的处理则会转换成return指令。</p>
<h2 id="1-6-通过地址和索引实现数组"><a href="#1-6-通过地址和索引实现数组" class="headerlink" title="1.6 通过地址和索引实现数组"></a>1.6 通过地址和索引实现数组</h2><p>例如，查看10000000地址～1000FFFF地址时，如图所示，可以将10000000存入基址寄存器，并使变址寄存器的值在00000000～0000FFFF变化。</p>
<p>CPU则会把基址寄存器+变址寄存器的值解释为实际查看的内存地址。</p>
<p><strong>变址寄存器的值就相当于高级编程语言程序中数组的索引功能。</strong></p>
<p><img src="https://s2.loli.net/2022/03/18/KVeUZ95HLSD2dig.png" alt="image-20220318123038828"></p>
<h2 id="1-7-CPU的处理其实很简单"><a href="#1-7-CPU的处理其实很简单" class="headerlink" title="1.7 CPU的处理其实很简单"></a>1.7 CPU的处理其实很简单</h2><p><img src="https://s2.loli.net/2022/03/18/NXjMqKV8JmBlHI9.png" alt="image-20220318123305339"></p>
<h1 id="Chapter-2-数据是用二进制数表示的"><a href="#Chapter-2-数据是用二进制数表示的" class="headerlink" title="Chapter 2 数据是用二进制数表示的"></a>Chapter 2 数据是用二进制数表示的</h1><p>要想对程序的运行机制形成一个大致印象，就要了解信息（数据）在计算机内部是以怎样的形式来表现的，又是以怎样的方法进行运算的。</p>
<h2 id="2-1-二进制表示信息"><a href="#2-1-二进制表示信息" class="headerlink" title="2.1 二进制表示信息"></a>2.1 二进制表示信息</h2><p>8位二进制数被称为一个字节。</p>
<p>字节是最基本的信息计量单位。位是最小单位，字节是基本单位。</p>
<p>内存和磁盘都使用字节单位来存储和读写数据，使用位单位则无法读写数据。因此，字节是信息的基本单位。</p>
<p><img src="https://s2.loli.net/2022/03/18/ptjEIbRe7lmv5sY.png" alt="image-20220318124340185"></p>
<p><img src="https://s2.loli.net/2022/03/18/Yw9udDHa284kXqy.png" alt="image-20220318124453697"></p>
<h1 id="Chapter-3-小数运算出错的原因"><a href="#Chapter-3-小数运算出错的原因" class="headerlink" title="Chapter 3 小数运算出错的原因"></a>Chapter 3 小数运算出错的原因</h1><h2 id="3-1-用二进制表示小数"><a href="#3-1-用二进制表示小数" class="headerlink" title="3.1 用二进制表示小数"></a>3.1 用二进制表示小数</h2><p><img src="https://s2.loli.net/2022/03/18/GmBI3Rnloi28Qwf.png" alt="image-20220318151900327"></p>
<h2 id="3-4-什么是浮点数"><a href="#3-4-什么是浮点数" class="headerlink" title="3.4 什么是浮点数"></a>3.4 什么是浮点数</h2><p>浮点数是指用符号、尾数、基数和指数这四部分来表示的小数。</p>
<p>由于基数必然是2，所以实际数据中往往不考虑基数，只用符号、尾数、指数这三部分来表示浮点数。</p>
<h3 id="IEEE标准"><a href="#IEEE标准" class="headerlink" title="IEEE标准"></a>IEEE标准</h3><p>IEEE标准中，尾数部分将”将小数点前面的值固定为1的正则表达式”。</p>
<p>指数部分用的是”EXCESS系统表现”。</p>
<h4 id="EXCESS系统表现"><a href="#EXCESS系统表现" class="headerlink" title="EXCESS系统表现"></a>EXCESS系统表现</h4><p>通过将指数部分表示范围的中间值设为0，使得负数不需要用符号来表示。</p>
<p>也就是说，</p>
<p>当指数部分是8位单精度浮点数时，最大值11111111=255的1/2，即01111111=127(小数部分舍弃)表示的是0</p>
<p>指数部分是11位双精度浮点数时，11111111111=2047的1/2，即01111111111=1023(小数部分舍弃)表示的是0</p>
<h2 id="3-7-如何避免计算机计算出错"><a href="#3-7-如何避免计算机计算出错" class="headerlink" title="3.7 如何避免计算机计算出错"></a>3.7 如何避免计算机计算出错</h2><ol>
<li>回避策略，即无视这些错误</li>
<li>把小数转换成整数来计算，例如0.1相加100次这一计算，就可以转换为将0.1扩大10倍后再将1相加100次的计算，最后把结果除以10就可以了</li>
</ol>
<h1 id="Chapter-4-熟练使用有棱有角的内存"><a href="#Chapter-4-熟练使用有棱有角的内存" class="headerlink" title="Chapter 4 熟练使用有棱有角的内存"></a>Chapter 4 熟练使用有棱有角的内存</h1><p>物理内存是以字节为单位进行数据存储的。</p>
<p>内存IC中有电源、地址信号、数据信号、控制信号等用于输入输出的大量引脚(IC的引脚)，通过为其指定地址，来进行数据的读写。</p>
<p><img src="https://s2.loli.net/2022/03/18/nEowaSU8vutsQjG.png" alt="image-20220318230029334"></p>
<p>WR：write；RD：read，这样可以让IC运行的信号，称为控制信号。当WR和RD同时为0时，写入和读出的操作都无法进行。</p>
<h2 id="4-2-内存的逻辑模型是楼房"><a href="#4-2-内存的逻辑模型是楼房" class="headerlink" title="4.2 内存的逻辑模型是楼房"></a>4.2 内存的逻辑模型是楼房</h2><p>编程语言中的数据类型表示存储的是何种类型的数据。从内存来看，就是占用的内存大小（占有的楼层数）的意思。</p>
<p>通过使用变量，即便不指定物理地址，也可以在程序中对内存进行读写，这是因为，在程序运行时，Windows等操作系统会自动决定变量的物理地址。</p>
<h2 id="4-4-数组是高效使用内存的基础"><a href="#4-4-数组是高效使用内存的基础" class="headerlink" title="4.4 数组是高效使用内存的基础"></a>4.4 数组是高效使用内存的基础</h2><p>数组是指多个同样数据类型的数据在内存中连续排列的形式。</p>
<p>作为数组元素的各个数据会通过连续的编号被区分开来，这个编号称为索引。</p>
<p>指定索引后，就可以对该索引所对应地址的内存进行读写操作。<strong>而索引和内存地址的变换工作则是由编译器自动实现的。</strong></p>
<p>数组的定义中所指定的数据类型，也表示一次能够读写的内存大小。</p>
<p>之所以说，数组是内存的使用方法的基础，<strong>是因为数组和内存的物理构造是一样的。</strong>特别是1字节类型的数组，它和内存的物理构造完全一致。</p>
<p><img src="https://s2.loli.net/2022/03/18/N69LykWPUFgGhwQ.png" alt="image-20220318232440056"></p>
<h2 id="4-5-栈、队列以及环形缓冲区"><a href="#4-5-栈、队列以及环形缓冲区" class="headerlink" title="4.5 栈、队列以及环形缓冲区"></a>4.5 栈、队列以及环形缓冲区</h2><p>栈[插图]和队列，都可以不通过指定地址和索引来对数组的元素进行读写。</p>
<p>需要临时保存计算过程中的数据、连接在计算机上的设备或者输入输出的数据时，都可以通过这些方法来使用内存。</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>为了实现临时保存数据的目的，使用这种类似于干草堆的机制是非常方便的。而这种机制体现在内存上，就是栈。当我们需要暂时舍弃当前的数据，随后再原貌还原时，会使用栈。</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列一般是以环形缓冲区(ring buffer)的方式来实现，也就是本章标题中所说的”熟练使用有棱有角的内存”。</p>
<h3 id="环形缓冲区模型"><a href="#环形缓冲区模型" class="headerlink" title="环形缓冲区模型"></a>环形缓冲区模型</h3><p><img src="https://s2.loli.net/2022/03/18/zbK4sIcDvrtjl1e.png" alt="image-20220318234128245"></p>
<h2 id="4-6-链表"><a href="#4-6-链表" class="headerlink" title="4.6 链表"></a>4.6 链表</h2><p>在数组的各个元素中，除了数据的值以外，通过为其附带上下一个元素的索引，即可实现链表。数据的值和下一个元素的索引组合在一起，就构成了数组的一个元素。</p>
<p><img src="https://s2.loli.net/2022/03/18/zQaPuIGqt9Oi6e1.png" alt="image-20220318234504095"></p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>当第2个元素的下一个元素变成第4个元素后，第3个元素就被删除了。虽然第3个元素在物理内存上还残留着，但在逻辑上确实被删除了。</p>
<p><img src="https://s2.loli.net/2022/03/18/2EjNsywBTI5fmxc.png" alt="image-20220318234736654"></p>
<h3 id="追加操作"><a href="#追加操作" class="headerlink" title="追加操作"></a>追加操作</h3><p><img src="https://s2.loli.net/2022/03/19/juDk9Yn2voKTgWq.png" alt="image-20220319003420940"></p>
<h2 id="4-7-二叉查找树"><a href="#4-7-二叉查找树" class="headerlink" title="4.7 二叉查找树"></a>4.7 二叉查找树</h2><p><strong>二叉查找树</strong>是指在链表的基础上往数组中追加元素时，考虑到数据的大小关系，将其分成左右两个方向的表现形式。</p>
<p><img src="https://s2.loli.net/2022/03/19/YodkWDlQU6cijx9.png" alt="image-20220319003533853"></p>
<p><img src="https://s2.loli.net/2022/03/19/tGMzZCbY6fhwnWl.png" alt="image-20220319003627199"></p>
<p><img src="https://s2.loli.net/2022/03/19/KkdbxOmCesJZatH.png" alt="image-20220319003652423"></p>
<p>而使用二叉查找树时，当目标数据比现在读出来的数据小时就可以转到左侧，反之目标数据较大时即可转到链表的右侧，这样就加快了找到目标数据的速度。</p>
<p><strong>数组是进行这些处理的基础。</strong></p>
<h1 id="Chapter-5-内存和磁盘的亲密关系"><a href="#Chapter-5-内存和磁盘的亲密关系" class="headerlink" title="Chapter 5 内存和磁盘的亲密关系"></a>Chapter 5 内存和磁盘的亲密关系</h1><p>磁盘缓存是指，把从磁盘中读出的数据存储在内存中，当该数据再次被读取时，不是从磁盘而是直接从内存中高速读出。</p>
<p>从都具有存储程序命令和数据这点来看，内存和磁盘的功能是相同的。在计算机的5大部件(即，输入装置、输出装置、存储器、运算器和控制器)中，内存和磁盘也都被归类为存储部件。</p>
<p>不过，利用电流来实现存储的内存，同利用磁效应来实现存储的磁盘，还是有差异的。而从存储容量来看，内存是高速高价，而磁盘则是低速廉价。</p>
<h2 id="5-1-不读入内存就无法运行"><a href="#5-1-不读入内存就无法运行" class="headerlink" title="5.1 不读入内存就无法运行"></a>5.1 不读入内存就无法运行</h2><p>如今，程序保存在存储设备中，通过有序地被读出来实现运行，这一机制称为存储程序方式(程序内置方式)。</p>
<p>计算机中主要的存储部件是内存和磁盘。</p>
<p>磁盘中存储的程序，必须要加载到内存后才能运行。在磁盘中保存的原始程序是无法直接运行的。这是因为，负责解析和运行程序内容的CPU，需要通过内部程序计数器来指定内存地址，然后才能读出程序。</p>
<h3 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h3><p><img src="https://s2.loli.net/2022/03/20/zNZeMdm5kFXwURA.png" alt="image-20220320000805561"></p>
<h2 id="5-2-磁盘缓存加快访问速度"><a href="#5-2-磁盘缓存加快访问速度" class="headerlink" title="5.2 磁盘缓存加快访问速度"></a>5.2 磁盘缓存加快访问速度</h2><p>磁盘缓存是指把从磁盘中读出的数据存储到内存空间中的方式。</p>
<p>当接下来需要读取同一数据时，就不需要通过实际的磁盘，而是从磁盘缓存中把内存读出，改善访问速度。</p>
<p><strong>把低速设备的数据保存在高速设备中，需要时可以直接将其从高速设备中读出。</strong></p>
<h3 id="小栗子"><a href="#小栗子" class="headerlink" title="小栗子"></a>小栗子</h3><p>由于Web浏览器是通过网络来获取远程Web服务器的数据并将其显示出来的，因此，在显示较大的图片等文件时，会花费不少时间。于是，Web浏览器就可以把获取的数据暂时保存在磁盘中，然后在需要时再显示磁盘中的数据。</p>
<p>也就是说，把低速的网络数据保存到相对高速的磁盘中。</p>
<h2 id="5-3-虚拟内存把磁盘作为部分内存来使用"><a href="#5-3-虚拟内存把磁盘作为部分内存来使用" class="headerlink" title="5.3 虚拟内存把磁盘作为部分内存来使用"></a>5.3 虚拟内存把磁盘作为部分内存来使用</h2><p>虚拟内存是指把磁盘的一部分作为假想内存来使用，这与磁盘缓存是假象的磁盘(实际上是内存)相对，虚拟内存是假想的内存(实际上是磁盘)。</p>
<h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p>虚拟内存虽说是把磁盘作为内存的一部分来使用，但实际上<strong>正在运行的程序部分，在这个时间点上是必须存在在内存中的</strong>。</p>
<p>也就是说，为了实现虚拟内存，就必须<strong>把实际内存的内容，和磁盘上的虚拟内存的内容进行部分置换</strong>，并同时运行程序。</p>
<h3 id="Windows下的分页式"><a href="#Windows下的分页式" class="headerlink" title="Windows下的分页式"></a>Windows下的分页式</h3><p>虚拟内存的方法有<strong>分页式</strong>和<strong>分段式</strong>两种。</p>
<p>Windows采用的是分页式。</p>
<p>该方式是指，在不考虑程序构造的情况下，把运行的程序按照一定大小的页进行分割，并以页为单位在内存和磁盘间进行置换。</p>
<p>在分页式中，我们把磁盘的内容读出到内存称为Page In，把内存的内容写入磁盘称为Page Out。一般情况下，Windows计算机的页的大小是4KB。也就是说，把大程序用4KB的页来进行切分，并以页为单位放入磁盘（虚拟内存）或内存中。</p>
<p><img src="https://s2.loli.net/2022/03/20/TlwoKpLfUdX1Nms.png" alt="image-20220320010617832"></p>
<p>为了实现虚拟内存功能，Windows在磁盘上提供了虚拟内存用的文件（pagefile，页文件）。该文件由Windows自动做成和管理。</p>
<p>文件的大小也就是虚拟内存的大小，通常是实际内存的相同程度至两倍程度。</p>
<h2 id="5-4-节约内存的编程方法"><a href="#5-4-节约内存的编程方法" class="headerlink" title="5.4 节约内存的编程方法"></a>5.4 节约内存的编程方法</h2><p>虚拟内存可以避免因内存不足导致的应用无法启动。不过，由于使用虚拟内存时发生的Page In和Page Out往往伴随着低速的磁盘访问，因此会导致应用的运行变得迟钝起来。</p>
<p>所以，虚拟内存无法彻底解决内存不足的问题！</p>
<p><strong>为了从根本上解决内存不足的问题，需要增加内存的容量，或者尽量把运行的应用文件变小。</strong></p>
<h3 id="通过DLL文件实现函数共有"><a href="#通过DLL文件实现函数共有" class="headerlink" title="通过DLL文件实现函数共有"></a>通过DLL文件实现函数共有</h3><p>动态链接</p>
<p>DLL(Dynamic Link Library)文件，是在程序运行时可以动态加载Library（函数和数据的集合）的文件。</p>
<p>另外，多个应用可以共有同一个DLL文件。而通过共有同一个DLL文件则可以达到节约内存的效果。</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>例如，假设我们编写了一个具有某些处理功能的函数MyFunc()。应用A和应用B都会使用这个函数。<strong>在各个应用的运行文件中内置函数MyFunc()（这个称为StaticLink，静态链接）后同时运行这两个应用</strong>，内存中就存在了具有同一函数的两个程序。但这会导致内存的利用效率降低。所以，有两个同样的函数，还是有点浪费。</p>
<p><img src="https://s2.loli.net/2022/03/20/lwFIq6ykK9S58Cd.png" alt="image-20220320012110001"></p>
<p>那么，如果函数MyFunc()是独立的DLL文件，由于同一个DLL文件的内容在运行时可以被多个应用共有，因此内存中存在的函数MyFunc()的程序就只有1个。这样一来，内存的利用效率也就提高了。</p>
<p><img src="https://s2.loli.net/2022/03/20/etGFhK5ZQJdDWcm.png" alt="image-20220320012157243"></p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>Windows的操作系统本身也是多个DL文件的集合体。</p>
<p>有时在安装新应用时，DLL文件也会被追加。应用则会通过利用这些DLL文件的功能来运行。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>像这样，之所以要利用多个DLL文件，其中一个原因就是可以节约内存。</p>
<p>而且DLL文件还有一个优点就是，在不变更EXE文件的情况下，只通过升级DLL文件就可以更新。</p>
<h3 id="通过调用-stdcall来减小程序文件的大小"><a href="#通过调用-stdcall来减小程序文件的大小" class="headerlink" title="通过调用_stdcall来减小程序文件的大小"></a>通过调用_stdcall来减小程序文件的大小</h3><p>C语言中，在调用函数后，需要执行栈清理处理指令。</p>
<h4 id="栈清理处理指令"><a href="#栈清理处理指令" class="headerlink" title="栈清理处理指令"></a>栈清理处理指令</h4><p>栈清理处理是指，把不需要的数据从接收和传递函数的参数时使用的内存上的栈区域中清理出去。该命令不是程序记述的，而是在程序编译时由编译器自动附加到程序中的。编译器默认将该处理附加在函数调用方。</p>
<p>在同一个程序中，同样的函数可能会被多次反复调用。而如果是同样的函数，栈清理处理的内容也是一样的。由于该处理是在调用函数一方，因此就会导致同一处理被反复进行。这就造成了内存的浪费。</p>
<h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p><img src="https://s2.loli.net/2022/03/20/MuU1tQR5Ii9orYE.png" alt="image-20220320012924316"></p>
<p>栈清理处理，比起在函数调用方进行，在反复被调用的函数一方进行时，程序整体要小一些。</p>
<p>这时所使用的就是_stdcall。在函数前加上 _stdcall，就可以把栈清理处理变为在被调用函数一方进行。</p>
<p>把代码清单5-1中的int MyFunc(int a, int b)部分转成int _stdcall MyFunc(int a, int b)进行再编译后，和代码清单5-2中add esp, 8同样的处理就会在函数MyFunc()一方执行。</p>
<p><strong>栈清理处理指令执行的次数是一样的，但是所占的内存数目减小了。</strong></p>
<p><img src="https://s2.loli.net/2022/03/20/1UkOxdqpnric2tM.png" alt="image-20220320013148120"></p>
<h2 id="5-5-磁盘的物理结构"><a href="#5-5-磁盘的物理结构" class="headerlink" title="5.5 磁盘的物理结构"></a>5.5 磁盘的物理结构</h2><p>磁盘是通过把其物理表面划分成多个空间来使用的。</p>
<p>划分的方式</p>
<p>有扇区方式和可变长方式两种，前者是指将磁盘划分为固定长度的空间，后者则是指把磁盘划分为长度可变的空间。</p>
<h3 id="Windows中的磁盘"><a href="#Windows中的磁盘" class="headerlink" title="Windows中的磁盘"></a>Windows中的磁盘</h3><p>一般的Windows计算机所使用的硬盘和软盘，采用的都是扇区方式。扇区方式中，把磁盘表面分成若干个同心圆的空间就是磁道，把磁道按照固定大小（能存储的数据长度相同）划分而成的空间就是扇区。</p>
<p>扇区是对磁盘进行物理读写的最小单位。Windows中使用的磁盘，一般1个扇区是512字节。</p>
<p>Windows在逻辑方面（软件方面）对磁盘进行读写的单位是<strong>扇区整数倍——簇</strong>。</p>
<p>根据磁盘容量的不同，1簇可以是512字节（1簇=1扇区）、1KB（1簇=2扇区）、2KB、4KB、8KB、16KB、32KB（1簇=64扇区）。磁盘的容量越大，簇的容量也越大。</p>
<p>不过，在软盘中，<strong>1簇=512字节=1扇区，簇和扇区的大小是相等的</strong>。</p>
<p>不管是硬盘还是软盘，不同的文件是不能存储在同一簇中的，否则就会导致存在一方的文件不能被删除。</p>
<p>因此，不管是多小的文件，都会占用一簇的空间。这样一来，所有的文件都会占用一簇的整数倍的磁盘空间。</p>
<h3 id="一簇为单位"><a href="#一簇为单位" class="headerlink" title="一簇为单位"></a>一簇为单位</h3><p><img src="https://s2.loli.net/2022/03/20/YizIZRHfkq8J94m.png" alt="image-20220320014053998"></p>
<p>虽然文件的大小只有1字节，但使用空间却变成了512字节。</p>
<p><strong>以簇为单位进行读写时，1簇中没有填满的区域会保持不被使用的状态。虽然这看起来是有点浪费，不过该机制就是如此规定的。</strong></p>
<p>另外，如果减少簇的容量，磁盘访问次数就会增加，就会导致读写文件的时间变长。</p>
<p>由于在磁盘表面上，表示扇区区分的领域是必要的，因此，如果簇的容量过小，磁盘的整体容量也会减少。</p>
<p><strong>扇区和簇的大小，是由处理速度和存储容量的平衡来决定的。</strong></p>
<h1 id="Chapter-6-尝试压缩数据"><a href="#Chapter-6-尝试压缩数据" class="headerlink" title="Chapter 6 尝试压缩数据"></a>Chapter 6 尝试压缩数据</h1><p>文件存储的基本单位是字节。</p>
<h2 id="6-1-文件以字节为单位保存"><a href="#6-1-文件以字节为单位保存" class="headerlink" title="6.1 文件以字节为单位保存"></a>6.1 文件以字节为单位保存</h2><p>文件就是字节数据的集合。</p>
<p>在任何情况下，文件中的字节数据都是连续存储的。</p>
<p><img src="https://s2.loli.net/2022/03/23/lHTg9zSs2wDAWLX.png" alt="image-20220323104144532"></p>
<h2 id="6-2-RLE算法的机制"><a href="#6-2-RLE算法的机制" class="headerlink" title="6.2 RLE算法的机制"></a>6.2 RLE算法的机制</h2><p>数据×重复次数：RLE(Run Length Encoding，行程长度编码)</p>
<p><img src="https://s2.loli.net/2022/03/23/XhIiBwMevtEAq13.png" alt="image-20220323104437547"> </p>
<h2 id="6-4-哈夫曼算法"><a href="#6-4-哈夫曼算法" class="headerlink" title="6.4 哈夫曼算法"></a>6.4 哈夫曼算法</h2><p>哈夫曼算法的关键就在于，”多次出现的数据用小于8位的字节数来表示，不常用的数据则可以用超过8位的字节数来表示”。</p>
<p>注意，不管是不满8位的数据，还是超过8位的数据，最终都以8位为单位保存到文件中。</p>
<p>用哈夫曼算法压缩过的文件中，存储着哈夫曼编码信息和压缩过的数据。</p>
<p><img src="https://s2.loli.net/2022/03/23/34OxLYWDKMBHAPu.png" alt="image-20220323110407423"></p>
<p>AAAAAABBCDDEEEEEF，结果为0000000000001001001101011010101010101111,40位=5字节</p>
<p>压缩比率：5/17</p>
<h2 id="6-7-可逆压缩和非可逆压缩"><a href="#6-7-可逆压缩和非可逆压缩" class="headerlink" title="6.7 可逆压缩和非可逆压缩"></a>6.7 可逆压缩和非可逆压缩</h2><p>Windows的标准图像数据形式是BMP，是完全未压缩的。由于显示器及打印机输出的bit是可以直接映射(mapp-ing)的，所以便有了BMP=bitmap这一名称。</p>
<p>把能还原到压缩前状态的压缩称为可逆压缩，无法还原到压缩前状态的压缩称为非可逆压缩.</p>
<p>JPEG格式的文件是非可逆压缩，因此还原后的图像信息有一部分是模糊的。</p>
<p>而GIF格式的文件虽然是可逆压缩，但因为有色数不能超过256色的限制，所以还原后颜色信息会有一些缺失，进而导致了图像模糊。</p>
<h1 id="Chapter-7-程序是在何种环境中运行的"><a href="#Chapter-7-程序是在何种环境中运行的" class="headerlink" title="Chapter 7 程序是在何种环境中运行的"></a>Chapter 7 程序是在何种环境中运行的</h1><p>应用的运行环境，指的是操作系统和计算机本身(硬件)的种类。</p>
<h2 id="7-1-运行环境-操作系统-硬件"><a href="#7-1-运行环境-操作系统-硬件" class="headerlink" title="7.1 运行环境=操作系统+硬件"></a>7.1 运行环境=操作系统+硬件</h2><h2 id="7-2-Windows克服了CPU以外的硬件差异"><a href="#7-2-Windows克服了CPU以外的硬件差异" class="headerlink" title="7.2 Windows克服了CPU以外的硬件差异"></a>7.2 Windows克服了CPU以外的硬件差异</h2><p>在Windows的应用软件中，键盘输入、显示器输出等并不是直接向硬件发送指令，而是通过向Windows发送指令来间接实现的。</p>
<p><img src="https://s2.loli.net/2022/03/23/YizVoUaGcBeprjI.png" alt="image-20220323112404880"></p>
<p>但Windows应用软件，都是用特定的CPU的本地代码来完成的。</p>
<h2 id="7-3-不同操作系统的API不同"><a href="#7-3-不同操作系统的API不同" class="headerlink" title="7.3 不同操作系统的API不同"></a>7.3 不同操作系统的API不同</h2><p>CPU的类型不同，所对应的机器语言也不同，同样的道理，操作系统的类型不同，应用程序向操作系统传递指令的途径也不同。</p>
<p>应用程序向操作系统传递指令的途径，称为API(Application Programming Interface)(也称系统调用，是应用调用操作系统功能的手段)，Windows及Unix系列操作系统的API，提供了任何应用程序都可以利用的函数组合。</p>
<h2 id="7-4-FreeBSD-Port"><a href="#7-4-FreeBSD-Port" class="headerlink" title="7.4 FreeBSD Port"></a>7.4 FreeBSD Port</h2><p>Unix系列操作系统FreeBSD中，存在一种名为Ports的机制。该机制能够结合当前运行的硬件环境来编译应用的源代码，进而得到可以运行的本地代码系统。如果目标应用的源代码没有在硬件上的话，Ports会自动使用FTP连接到相关站点来下载代码。</p>
<h2 id="7-6-Java虚拟机"><a href="#7-6-Java虚拟机" class="headerlink" title="7.6 Java虚拟机"></a>7.6 Java虚拟机</h2><p>Java的两个层面的意思，一个是作为编程语言的Java，另一个是作为程序运行环境的Java。</p>
<p>从操作系统方面来看，Java虚拟机是一个应用，而从Java应用方面来看，Java虚拟机就是运行环境。</p>
<h2 id="7-7-BIOS和引导"><a href="#7-7-BIOS和引导" class="headerlink" title="7.7 BIOS和引导"></a>7.7 BIOS和引导</h2><p>BIOS存储在ROM中，是预先内置在计算机主机内部的程序。BIOS除了键盘、磁盘、显卡等基本控制程序外，还有启动”引导程序”的功能。</p>
<h3 id="引导程序"><a href="#引导程序" class="headerlink" title="引导程序"></a>引导程序</h3><p>引导程序是存储在启动驱动器起始区域的小程序。</p>
<p>操作系统的启动驱动器一般是硬盘，不过有时也可以是CD-ROM或软盘。</p>
<h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>开机后，BIOS会确认硬件是否正常运行，没有问题的话就会启动引导程序。</p>
<p>引导程序的功能是把在硬盘等记录的OS加载到内存中运行。</p>
<p>虽然启动应用是OS的功能，但OS并不能自己启动自己，而是通过引导程序来启动。</p>
<p>（Bootstrap的原意是指靴子上部的“拔靴带”。BIOS这样小的程序（拔靴带），可以带动（启动）操作系统这样的大程序（靴子），所以由此得名。虽然操作系统运行以后，程序员就不用再关注BIOS及引导程序了，但需要知道它们的存在。）</p>
<h1 id="Chapter-8-从源文件到可执行文件"><a href="#Chapter-8-从源文件到可执行文件" class="headerlink" title="Chapter 8 从源文件到可执行文件"></a>Chapter 8 从源文件到可执行文件</h1><p>链接器会从库文件中抽取出必要的目标文件并将其结合到EXE文件中。</p>
<h2 id="8-1-计算机只能运行本地代码"><a href="#8-1-计算机只能运行本地代码" class="headerlink" title="8.1 计算机只能运行本地代码"></a>8.1 计算机只能运行本地代码</h2><p>本地（native）这个术语有“母语的”意思。</p>
<p>对CPU来说，母语就是机器语言，而转换成机器语言的程序就是本地代码。用任何编程语言编写的源代码，最后都要翻译成本地代码（图8-2），否则CPU就不能理解。</p>
<h2 id="8-2-本地代码的内容"><a href="#8-2-本地代码的内容" class="headerlink" title="8.2 本地代码的内容"></a>8.2 本地代码的内容</h2><p>Windows中EXE文件的程序内容，使用的就是本地代码。</p>
<p>将EXE文件Dump后(Dump是指把文件的内容，每个字节用2位十六进制数来表示的方式)，可以发现本地代码就是各种数值的罗列。</p>
<h2 id="8-3-编译器负责转换源代码"><a href="#8-3-编译器负责转换源代码" class="headerlink" title="8.3 编译器负责转换源代码"></a>8.3 编译器负责转换源代码</h2><p>编译器首先读入代码的内容，然后再把源代码转换成本地代码。编译器中就好像有一个源代码同本地代码的对应表。但实际上，读入的源代码，还要经过语法解析、句法解析、语义解析等，才能生成本地代码。</p>
<p>根据CPU类型的不同，本地代码的类型也不同。因而，编译器不仅和编程语言的种类有关，和CPU的类型是也是相关的。</p>
<p><img src="https://s2.loli.net/2022/03/23/6JhA7YPEO2nbjvH.png" alt="image-20220323183804354"></p>
<p><img src="https://s2.loli.net/2022/03/23/ChVr2B69KcRDukP.png" alt="image-20220323183924787"></p>
<h2 id="8-4-仅靠编译无法得到可执行文件的"><a href="#8-4-仅靠编译无法得到可执行文件的" class="headerlink" title="8.4 仅靠编译无法得到可执行文件的"></a>8.4 仅靠编译无法得到可执行文件的</h2><p>编译器转换源代码之后，就会生成本地文件。不过，本地文件是无法直接运行的。为了得到可运行的EXE文件，编译之后还需要进行”链接”处理。</p>
<h3 id="未完成"><a href="#未完成" class="headerlink" title="未完成"></a>未完成</h3><p>在Windows的命令提示符中，运行下列命令后，由C语言编写的代码Sample1.c就会被编译。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bcc32 -W -c Sample1.c</span><br></pre></td></tr></table></figure>
<p>“-W-c”是用来指定编译Windows用的程序的选项。选项是对编译器的指示。有时也称为”开关”。</p>
<p>编译后生成的不是EXE文件，而是扩展名为“.obj”的目标文件。Sample1.c编译后，就生成了Sample1.obj目标文件。虽然目标文件的内容是本地代码，但却无法直接运行。那么这是为什么呢？原因就是当前程序还处于未完成状态。</p>
<p><img src="https://s2.loli.net/2022/03/23/Q7SwKs4MqazWmGo.png" alt="image-20220323184915391"></p>
<p>如该代码所示：</p>
<p>sprintf和MessageBox在源代码中，都没有记述这些函数的处理内容。因此，就必须将存储着sprintf()和MessageBox( )的处理内容的目标文件同Sample1.obj结合，否则处理不完整,EXE文件也无法完成。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>把多个目标文件结合，生成1个EXE文件的处理就是链接，运行链接的程序就成为链接器。</p>
<p>Windows下，运行以下命令，程序所需的目标文件就会被全部链接生成Sample1.exe这个EXE文件。</p>
<p><img src="https://s2.loli.net/2022/03/23/KvLJexZhjpVbToC.png" alt="image-20220323185423760"></p>
<h2 id="8-5-启动及库文件"><a href="#8-5-启动及库文件" class="headerlink" title="8.5 启动及库文件"></a>8.5 启动及库文件</h2><p>链接选项“-Tpe-c-x-aa”是指定生成Windows用的EXE文件的选项。</p>
<p>在这些选项之后，会指定结合的目标文件。而该命令行中就指定了c0w32.obj、Sample1.obj这两个目标文件。</p>
<h3 id="1-c0w32-obj"><a href="#1-c0w32-obj" class="headerlink" title="1. c0w32.obj"></a>1. c0w32.obj</h3><p>c0w32.obj这个目标文件记述的是同所有程序起始位置相结合的处理内容，称为程序的启动。因而，即使程序不调用其他目标文件的函数，也必须要进行链接，并和启动结合起来。</p>
<p>在链接的命令行末尾，存在着拓展名为”.lib”的import32.lib和cw32.lib这两个文件。这是因为sprintf()的目标文件在cw32.lib中，MessageBox()的目标文件在import32.lib中（实际上，MessageBox()的目标文件在user32. dll这个DLL文件中。）</p>
<h3 id="2-库文件"><a href="#2-库文件" class="headerlink" title="2. 库文件"></a>2. 库文件</h3><p>像import32.lib及cw32.lib这样的文件称为库文件。</p>
<p>库文件指的是把多个目标文件集成保存到一个文件中的形式。链接器指定库文件后，就会从中把需要的目标文件抽取出来，并同其他目标文件结合生成EXE文件。</p>
<h3 id="3-如果不指定呢？"><a href="#3-如果不指定呢？" class="headerlink" title="3. 如果不指定呢？"></a>3. 如果不指定呢？</h3><p>Sample1.obj是尚未完成的本地代码，其中包含有“链接时请结合sprintf()及MessageBox()”这样的信息。意思是如果不存在其他函数的话，程序就无法运行。</p>
<p>下面，我们就来做一个尝试，看看在不指定这两个库文件的情况下进行链接会发生什么。</p>
<p><img src="https://s2.loli.net/2022/03/24/qZnrhKfJtaPTVER.png" alt="image-20220324011320494"></p>
<p>外部符号指的是，其他目标文件中的变量或函数。错误消息“无法解析的外部符号”表示的是无法找到记述着目的变量及函数的目标文件，因而无法进行链接的意思。</p>
<h4 id="标准函数"><a href="#标准函数" class="headerlink" title="标准函数"></a>标准函数</h4><p>sprintf()等函数，不是通过源代码形式而是通过库文件形式和编译器一起提供的。这样的函数称为标准函数。</p>
<p>之所以使用库文件，是为了简化为链接器的参数指定多个目标文件这个过程，因为使用存储着多个目标文件的库文件的话，只需在链接器的命令行中指定几个库文件就可以。</p>
<p>通过以目标文件的形式或集合多个目标文件的库文件形式来提供函数，就可以不用公开标准函数的源代码内容。</p>
<h2 id="8-6-DLL文件及导入库"><a href="#8-6-DLL文件及导入库" class="headerlink" title="8.6 DLL文件及导入库"></a>8.6 DLL文件及导入库</h2><p>Windows以函数的形式为应用提供了各种功能。这些形式的函数称为API(Application Programming Interface)。MessageBox()，他并不是C语言的标准函数，而是Windows提供的API的一种。MessageBox( )提供了显示消息框的功能。</p>
<h3 id="1-导入库"><a href="#1-导入库" class="headerlink" title="1. 导入库"></a>1. 导入库</h3><p>Windows中，API的目标文件，并不是存储在通常的库文件中，而是存储在名为DLL(Dynamic Link Library) 文件的特殊库文件中。DLL是程序运行时动态结合的文件。</p>
<h4 id="import32-lib"><a href="#import32-lib" class="headerlink" title="import32.lib"></a>import32.lib</h4><p>实际上，import32.lib中仅仅存储着两个信息，<strong>一是MessageBox( )在user32.dll这个DLL文件中，另一个是存储着DLL文件的文件夹信息，MessageBox( )的目标文件的实体实际上并不存在。把类似于import32.lib这样的库文件称为导入库。</strong></p>
<h3 id="2-静态链接库"><a href="#2-静态链接库" class="headerlink" title="2. 静态链接库"></a>2. 静态链接库</h3><p>与此相反，存储着目标文件的实体，并直接和EXE文件结合的库文件形式称为<strong>静态链接库</strong>。</p>
<p>存储着sprintf()的目标文件的cw32lib就是静态链接库。</p>
<h3 id="3-形成EXE过程"><a href="#3-形成EXE过程" class="headerlink" title="3. 形成EXE过程"></a>3. 形成EXE过程</h3><p>通过结合导入库文件，执行时从DLL文件中调出的MessageBox( )函数这一信息就会与EXE文件进行结合。这样链接器链接时，就不会再出现错误消息，从而就可以顺利编写EXE文件。</p>
<p><img src="https://s2.loli.net/2022/03/24/iw9uTjJgSMtabEk.png" alt="image-20220324205047519"></p>
<p><img src="https://s2.loli.net/2022/03/24/cYzTlwUoGE2Lb5k.png" alt="image-20220324205124089"></p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ol>
<li><p>编译是将.c变成.obj，再结合启动信息，链接所需目标文件，才能得到最终可执行的的EXE文件。</p>
</li>
<li><p>也就是说，导入库中存的是目标文件所在的DLL文件名，以及DLL文件的位置，需要将目标文件调出DLL再结合；而静态链接库存的是目标文件的实体，直接可以与EXE结合。</p>
</li>
</ol>
<h2 id="8-7-可执行文件运行机制"><a href="#8-7-可执行文件运行机制" class="headerlink" title="8.7 可执行文件运行机制"></a>8.7 可执行文件运行机制</h2><p>EXE文件是作为单独的文件存储在硬盘里的。</p>
<p>通过资源管理器找到并双击EXE文件，就会把EXE文件中的内容加载到内存中运行。</p>
<p>本地代码在对程序记述的变量进行读写时，是参照数据存储的内存地址来运行命令的。</p>
<p>在调用函数时，程序的处理流程就会跳转到存储着函数处理内容的内存地址上。<strong>EXE文件作为本地代码的程序，并没有指定变量及函数的实际内存地址。</strong>每次运行时，程序内的变量及函数被分配到的内存地址都是不同的。如何表示实际内存地址？</p>
<h3 id="再配置信息"><a href="#再配置信息" class="headerlink" title="再配置信息"></a>再配置信息</h3><p>EXE文件中给变量及函数分配了虚拟的内存地址。在程序运行时，虚拟的内存地址会转换成实际的内存地址。</p>
<p><strong>链接器会在EXE文件的开头，追加转换内存地址所需的必要信息。这个信息称为再配置信息</strong>。</p>
<h4 id="相对地址"><a href="#相对地址" class="headerlink" title="相对地址"></a>相对地址</h4><p><strong>EXE文件的再配置信息，就成为了变量和函数的相对地址。</strong></p>
<p>相对地址表示的是相对于基点地址的偏移量，也就是相对距离。实现相对地址，也是需要花费一番心思的。</p>
<p>在源代码中，虽然变量及函数是在不同位置分散记述的，<strong>但在链接后的EXE文件中，变量及函数就会变成一个连续排列的组。</strong></p>
<p>这样一来，各变量的内存地址就可以用相对于变量组起始位置这一基点的偏移量来表示，同样，各函数的内存地址也可以用相对于函数组起始位置这一基点的偏移量来表示。而各组基点的内存地址则是在程序运行时被分配的。</p>
<h4 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h4><p><img src="https://s2.loli.net/2022/03/24/NlSFoiLGPDvtTmQ.png" alt="image-20220324210321653"></p>
<p>函数之类的信息，已经放在了EXE文件中，而且EXE文件只保存各信息相对基点的偏移量，即相对地址。</p>
<p>也就是说，在程序运行时，会分配基点地址，之后根据再配置信息中的偏移量，确定实际的数据和函数地址，从而进行调用。</p>
<h2 id="8-8-程序加载时会生成栈和堆"><a href="#8-8-程序加载时会生成栈和堆" class="headerlink" title="8.8 程序加载时会生成栈和堆"></a>8.8 程序加载时会生成栈和堆</h2><p>EXE文件的内容分为再配置信息、变量组和函数组。</p>
<h3 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h3><p>不过，当程序加载到内存后，除此之外还会额外生成两个组，那就是栈和堆。</p>
<p>栈是用来存储函数内部临时使用的变量(局部变量)，以及函数调用时所用的参数的内存区域。</p>
<p>堆是用来存储程序运行时的任意数据及对象的内存领域。</p>
<p><img src="https://s2.loli.net/2022/03/24/XTrBjWiwxou1H4n.png" alt="image-20220324211037907"></p>
<h3 id="内存中的程序"><a href="#内存中的程序" class="headerlink" title="内存中的程序"></a>内存中的程序</h3><p>EXE文件中并不存在栈及堆的组。</p>
<p>栈和堆需要的内存空间是在EXE文件加载到内存后开始运行时得到分配的。</p>
<p>因而，内存中的程序，就是<strong>由用于变量的内存空间、用于函数的内存空间、用于栈的内存空间、用于堆的内存空间这4部分构成的。</strong></p>
<h3 id="堆和栈的释放"><a href="#堆和栈的释放" class="headerlink" title="堆和栈的释放"></a>堆和栈的释放</h3><p>栈中对数据进行存储和舍弃的代码，是由编译器自动生成的，不需要程序员参与。每次函数被调用时，会得到申请分配，函数处理完毕会自动释放。</p>
<p>堆的内存空间，要根据程序员编写的程序，来明确进行申请分配(malloc、new)或释放(free、delete)。</p>
<h2 id="8-9-一些Q-amp-A"><a href="#8-9-一些Q-amp-A" class="headerlink" title="8.9 一些Q&amp;A"></a>8.9 一些Q&amp;A</h2><p>Q：编译器和解释器有什么不同？</p>
<p>A：编译器是在运行前对所有源代码进行解释处理的。而解释器则是在运行时对源代码的内容一行一行地进行解释处理的。</p>
<p>Q：“分割编译”指的是什么？</p>
<p>A：将整个程序分为多个源代码来编写，然后分别进行编译，最后链接成一个EXE文件。这样每个源代码都相对变短，便于程序管理。</p>
<p>Q：使用DLL文件的好处是什么？</p>
<p>A:DLL文件中的函数可以被多个程序共用。因此，借助该功能可以节约内存和磁盘。此外，在对函数的内容进行修正时，还不需要重新链接（静态链接）使用这个函数的程序[插图]。</p>
<h1 id="Chapter-9-操作系统和应用的关系"><a href="#Chapter-9-操作系统和应用的关系" class="headerlink" title="Chapter 9 操作系统和应用的关系"></a>Chapter 9 操作系统和应用的关系</h1><h2 id="9-1-操作系统功能的历史"><a href="#9-1-操作系统功能的历史" class="headerlink" title="9.1 操作系统功能的历史"></a>9.1 操作系统功能的历史</h2><p>用机器语言编写程序，然后再使用开关将程序输入，这一过程非常麻烦。</p>
<h3 id="1-监控程序"><a href="#1-监控程序" class="headerlink" title="1. 监控程序"></a>1. 监控程序</h3><p>于是，开发出了仅具有加载和运行功能的监控程序，这就是操作系统的原型。通过事先启动监控程序，程序员就可以根据需要将各种程序加载到内存中运行。</p>
<p><img src="https://s2.loli.net/2022/03/24/IlqjdzLpksGYJgR.png" alt="image-20220324212332747"></p>
<h3 id="2-添加基本输入输出"><a href="#2-添加基本输入输出" class="headerlink" title="2. 添加基本输入输出"></a>2. 添加基本输入输出</h3><p>由于很多程序都有共通的部分，如果没编写一个新的程序都要记述相同的处理的话，很浪费时间，所以就把基本的输入输出部分的程序追加到了监控程序中。</p>
<p><img src="https://s2.loli.net/2022/03/24/eO3tTkC426cAzLj.png" alt="image-20220324212727454"></p>
<h3 id="3-现代操作系统"><a href="#3-现代操作系统" class="headerlink" title="3. 现代操作系统"></a>3. 现代操作系统</h3><p>操作系统本身并不是单独的程序，而是多个程序的集合体。</p>
<p><img src="https://s2.loli.net/2022/03/24/WojkBhzTEriQNnl.png" alt="image-20220324212803056"></p>
<h2 id="9-2-操作系统的存在"><a href="#9-2-操作系统的存在" class="headerlink" title="9.2 操作系统的存在"></a>9.2 操作系统的存在</h2><p>在操作系统诞生以后，就没有必要再编写直接控制硬件的程序了。这样一来，制作应用的程序员就逐渐同硬件隔离开来了。</p>
<p>但，掌握基本的硬件知识，并借助操作系统进行抽象化，可以大大提高编程效率。</p>
<h3 id="如何控制硬件？"><a href="#如何控制硬件？" class="headerlink" title="如何控制硬件？"></a>如何控制硬件？</h3><p>应用的可执行文件指的是，计算机的CPU可以直接解释并运行的本地代码。不过这些代码是无法直接控制计算机中配置的时钟IC及显示器用的I/O等硬件的。那么，为什么代码清单9-1的应用能够控制硬件呢？</p>
<p>在操作系统这个运行环境下，应用并不是直接控制硬件，而是通过操作系统来间接控制硬件的。</p>
<p>变量定义中涉及的内存的申请分配，以及time()和printf()这些函数的运行结果，都不是面向硬件而是面向操作系统的。操作系统收到应用发出的指令后，首先会对该指令进行解释，然后会对时钟IC（实时时钟[插图]）和显示器用的I/O进行控制。</p>
<p><img src="https://s2.loli.net/2022/03/24/RicNoX28njIQMbf.png" alt="image-20220324213032802"></p>
<h2 id="9-3-系统调用和高级编程语言的移植性"><a href="#9-3-系统调用和高级编程语言的移植性" class="headerlink" title="9.3 系统调用和高级编程语言的移植性"></a>9.3 系统调用和高级编程语言的移植性</h2><h3 id="1-系统调用"><a href="#1-系统调用" class="headerlink" title="1. 系统调用"></a>1. 系统调用</h3><p>操作系统的硬件控制功能，通常是通过一些小的函数集合体的形式来提供的。</p>
<p>这些函数及调用函数的行为统称为系统调用（system call），也就是应用对操作系统（system）的功能进行调用（call）的意思。</p>
<p>在Windows操作系统中，提供返回当前日期和时刻，以及在显示器中显示字符串等功能的系统调用的函数名，并不是time()和printf()。系统调用是在time()和printf()函数的内部执行的。</p>
<h3 id="2-为什么可移植？"><a href="#2-为什么可移植？" class="headerlink" title="2. 为什么可移植？"></a>2. 为什么可移植？</h3><p>高级编程语言的机制就是，使用独自的函数名，然后再在编译时将其转换成相应操作系统的系统调用（也有可能是多个系统调用的组合）。</p>
<p>也就是说，用高级编程语言编写的应用在编译后，就转换成了利用系统调用的本地代码。</p>
<h2 id="9-4-硬件抽象化"><a href="#9-4-硬件抽象化" class="headerlink" title="9.4 硬件抽象化"></a>9.4 硬件抽象化</h2><p>通过使用操作系统提供的系统调用，程序员就没必要编写直接控制硬件的程序了。而且，通过使用高级编程语言，有时甚至也无需考虑系统调用的存在。这是因为操作系统和高级编程语言能够使硬件抽象化。</p>
<h3 id="文件？"><a href="#文件？" class="headerlink" title="文件？"></a>文件？</h3><p>文件是操作系统对磁盘媒介空间的抽象化。</p>
<p>（作为硬件的磁盘媒介，就如同树木的年轮一样，被划分为了多个扇区，并以扇区为单位对磁盘进行读写。如果直接对硬件进行操作的话，那就变成了通过向磁盘用的I/O指定扇区位置来对数据进行读写了。）</p>
<p>磁盘媒介的读写采用了文件这个概念，将整个流程抽象化成了打开文件用的fopen()、写入文件用的fputs()、关闭文件用的fclose()。</p>
<p><img src="https://s2.loli.net/2022/03/24/P8ExlM6eCAyUuNs.png" alt="image-20220324213629602"></p>
<h2 id="9-5-Windows操作系统的特征"><a href="#9-5-Windows操作系统的特征" class="headerlink" title="9.5 Windows操作系统的特征"></a>9.5 Windows操作系统的特征</h2><p>所谓32位操作系统，32位指的是处理效率最高的数据大小。</p>
<h3 id="1-API"><a href="#1-API" class="headerlink" title="1. API"></a>1. API</h3><p>Windows是通过名为API的函数集来提供系统调用的。API是联系应用程序和操作系统之间的接口。所以称为API（Application Programming Interface，应用程序接口）。API通过多个DLL文件来提供。各API的实体都是用C语言编写的函数。</p>
<h3 id="2-多任务"><a href="#2-多任务" class="headerlink" title="2. 多任务"></a>2. 多任务</h3><p>多任务指的是同时运行多个程序的功能。Windows是通过时钟分割技术来实现多任务功能的。时钟分割指的是在短时间间隔内，多个程序切换运行的方式。</p>
<p><img src="https://s2.loli.net/2022/03/24/RE7LGkU6TmNnwxB.png" alt="image-20220324213845895"></p>
<h3 id="3-中间件"><a href="#3-中间件" class="headerlink" title="3. 中间件"></a>3. 中间件</h3><p>网络功能和数据库功能，虽并不是操作系统本身不可欠缺的功能，但因为它们和操作系统很接近，所以被统称为中间件而不是应用。</p>
<p>意思是处于操作系统和应用的中间（middle）。操作系统和中间件合在一起，也称为系统软件。</p>
<p><img src="https://s2.loli.net/2022/03/24/i1TOZtfs8kMEQ9e.png" alt="image-20220324213943480"></p>
<h3 id="4-即插即用"><a href="#4-即插即用" class="headerlink" title="4. 即插即用"></a>4. 即插即用</h3><p>即插即用（Plug-and-Play）指的是新的设备连接（Plug）后立刻就可以使用（Play）的机制。新的设备连接到计算机后，系统就会自动安装和设定用来控制该设备的设备驱动程序。</p>
<p>程序是操作系统、中间件、应用等所有软件的统称。因此，通常程序员制作的应该都是应用，而不是操作系统。不过，既然是应用，那么就肯定会通过某种形式来利用操作系统的功能。</p>
<h1 id="Chapter-10-汇编语言"><a href="#Chapter-10-汇编语言" class="headerlink" title="Chapter 10 汇编语言"></a>Chapter 10 汇编语言</h1><p>助记符：本地代码指令的功能缩写。</p>
<h2 id="10-1-汇编语言和本地代码一一对应"><a href="#10-1-汇编语言和本地代码一一对应" class="headerlink" title="10.1 汇编语言和本地代码一一对应"></a>10.1 汇编语言和本地代码一一对应</h2><p>如果直接打开本地代码看的话，只能看到数值的罗列。如果直接使用这些数值来编写程序的话，不易理解。所以，就在各本地代码中，附带上表示其功能的英语单词的缩写，即助记符，使用助记符的编程语言称为汇编语言。</p>
<p>即使使用汇编语言编写的代码，最终也必须要转换成本地代码才能运行。负责转换工作的程序称为汇编器，转换这一处理本身称为汇编。在将源代码转换成本地代码这个功能方面，汇编器和编译器是同样的。</p>
<h2 id="10-3-伪指令"><a href="#10-3-伪指令" class="headerlink" title="10.3 伪指令"></a>10.3 伪指令</h2><p>汇编语言的源代码，是由转换成本地代码的指令（后面讲述的操作码）和针对汇编器的伪指令构成的。</p>
<p>伪指令负责把程序的构造及汇编的方法指示给汇编器（转换程序）。不过伪指令本身是无法汇编转换成本地代码的。</p>
<p><img src="https://s2.loli.net/2022/03/24/zOEVMsRFBmC6KyA.png" alt="image-20220324221023218"></p>
<h3 id="1-段定义"><a href="#1-段定义" class="headerlink" title="1. 段定义"></a>1. 段定义</h3><p>由伪指令segment和ends围起来的部分，是给构成程序的命令和数据的集合体加上一个名字得到的，称为段定义。</p>
<p>段定义的英文表达segment具有“区域”的意思。在程序中，段定义指的是命令和数据等程序的集合体的意思。一个程序由多个段定义构成。</p>
<h3 id="2-TEXT等"><a href="#2-TEXT等" class="headerlink" title="2. _TEXT等"></a>2. _TEXT等</h3><p>源代码的开始位置，定义了3个名称分别为<code>_TEXT、_DATA、_BSS</code>的段定义。</p>
<p><code>_TEXT</code>是指令的段定义，<code>_DATA</code>是被初始化（有初始值）的数据的段定义，<code>_BSS</code>是尚未初始化的数据的段定义。</p>
<p>类似于这种段定义的名称及划分方法是Borland C++的规定，是由Borland C++的编译器自动分配的。<strong>因而程序段定义的配置顺序就成了<code>_TEXT、_DATA、_BSS</code>，这样也确保了内存的连续性。</strong></p>
<p><strong>group这一伪指令，表示的是把<code>_BSS和_DATA</code>这两个段定义汇总为名为DGROUP的组。</strong></p>
<p>此外，栈和堆的内存空间会在程序运行时生成，</p>
<h3 id="3-整齐的本地代码"><a href="#3-整齐的本地代码" class="headerlink" title="3. 整齐的本地代码"></a>3. 整齐的本地代码</h3><p>围起<code>_AddNum和_MyFun的_TEXT segment和_TEXT ends</code>，表示<code>_AddNum和_MyFunc</code>是属于_TEXT这一段定义的。因此，即使在源代码中指令和数据是混杂编写的，经过编译或者汇编后，也会转换成段定义划分整齐的本地代码。</p>
<p><code>_AddNum proc和_AddNum endp</code>围起来的部分，以及<code>_MyFunc proc和_MyFunc endp</code>围起来的部分，分别表示AddNum函数和MyFunc函数的范围。</p>
<h3 id="4-过程"><a href="#4-过程" class="headerlink" title="4. 过程"></a>4. 过程</h3><p>伪指令proc和endp围起来的部分，表示的是过程（procedure）的范围。在汇编语言中，这种相当于C语言的函数的形式称为过程。末尾的end伪指令，表示的是源代码的结束。</p>
<h2 id="10-2-操作码-操作数"><a href="#10-2-操作码-操作数" class="headerlink" title="10.2 操作码+操作数"></a>10.2 操作码+操作数</h2><p>在汇编语言中，1行表示对CPU的一个指令。</p>
<p>汇编语言指令的语法结构是操作码+操作数（也存在只有操作码没有操作数的指令）。操作码表示的是指令动作，操作数表示的是指令对象。</p>
<h3 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h3><p>CPU内的寄存器是用eax及ebx这些名称来区分的。</p>
<p><img src="https://s2.loli.net/2022/03/24/SsXo7zyPnDTEdMa.png" alt="image-20220324222353929"></p>
<h2 id="10-5-mov指令"><a href="#10-5-mov指令" class="headerlink" title="10.5 mov指令"></a>10.5 mov指令</h2><h3 id="mov-a，b"><a href="#mov-a，b" class="headerlink" title="mov a，b"></a>mov a，b</h3><p><strong>mov指令的两个操作数，分别用来指定数据的存储地和读出源。</strong></p>
<p>操作数中可以指定寄存器、常数、标签（附加在地址前），以及用方括号（[]）围起来的这些内容。</p>
<p><strong>如果指定了没有用方括号围起来的内容，就表示对该值进行处理；如果指定了用方括号围起来的内容，方括号中的值则会被解释为内存地址，然后就会对该内存地址对应的值进行读写操作。</strong></p>
<p><img src="https://s2.loli.net/2022/03/24/MRa1UiNLu6SOzn2.png" alt="image-20220324222506242"></p>
<p>mov ebp, esp中，esp寄存器中的值被直接存储在了ebp寄存器中。esp寄存器的值是100时ebp寄存器的值也是100。</p>
<p>而在mov eax, dword ptr [ebp+8]的情况下，ebp寄存器的值加8后得到的值会被解释为内存地址。</p>
<p>如果ebp寄存器的值是100的话，那么eax寄存器中存储的就是100 + 8=108地址的数据。</p>
<h3 id="dword-ptr"><a href="#dword-ptr" class="headerlink" title="dword ptr"></a>dword ptr</h3><p>dword ptr（double word pointer）表示的是从指定内存地址读出4字节的数据。像这样，有时也会在汇编语言的操作数前附带dword ptr这样的修饰语。</p>
<h2 id="10-6-栈的push和pop"><a href="#10-6-栈的push和pop" class="headerlink" title="10. 6 栈的push和pop"></a>10. 6 栈的push和pop</h2><h3 id="栈的模型"><a href="#栈的模型" class="headerlink" title="栈的模型"></a>栈的模型</h3><p>数据在存储时是从内存的<strong>下层（大的地址编号）逐渐往上层（小的地址编号）累积</strong>，读出时则是按照从上往下的顺利进行。<img src="https://s2.loli.net/2022/03/24/U8rpBat2qVYue6c.png" alt="image-20220324222823432"></p>
<h3 id="push和pop"><a href="#push和pop" class="headerlink" title="push和pop"></a>push和pop</h3><p>push指令和pop指令中只有一个操作数。</p>
<p>该操作数表示的是“push的是什么及pop的是什么”，而不需要指定“对哪一个地址编号的内存进行push或pop”。</p>
<p>这是因为，对栈进行读写的内存地址是由esp寄存器（栈指针）进行管理的。</p>
<p><strong>push指令和pop指令运行后，esp寄存器的值会自动进行更新（push指令是-4, pop命令是+4）。</strong></p>
<h2 id="10-7-函数调用机制"><a href="#10-7-函数调用机制" class="headerlink" title="10.7 函数调用机制"></a>10.7 函数调用机制</h2><p><img src="https://s2.loli.net/2022/03/24/Vbmd6jgt8RuIO4C.png" alt="image-20220324223044548"></p>
<h3 id="3-6"><a href="#3-6" class="headerlink" title="3~6"></a>3~6</h3><p>在C语言的源代码中，虽然记述为函数AddNum(123, 456)，但入栈时则会按照456、123这样的顺序，也就是位于后面的数值先入栈。这是C语言的规定。</p>
<p>(5)的call指令，把程序流程跳转到了操作数中指定的AddNum函数所在的内存地址处。</p>
<p>在汇编语言中，函数名表示的是函数所在的内存地址。</p>
<p>AddNum函数处理完毕后，程序流程必须要返回到编号(6)这一行。</p>
<h4 id="栈清理处理"><a href="#栈清理处理" class="headerlink" title="栈清理处理"></a>栈清理处理</h4><p>(6)部分会把栈中存储的两个参数(456和123)进行销毁处理，也就是栈清理处理。</p>
<p>虽然通过使用两次pop指令也可以实现，不过采用esp寄存器加8的方式会更有效率(处理1次即可)。对栈进行数值的输入输出时，数值的单位是4字节。因此，通过在负责栈地址管理的esp寄存器中加上4的2倍8，就可以达到运行两次pop命令同样的效果。</p>
<p>和运行两次pop命令同样的效果。虽然内存中的数据实际上还残留着，但只要把esp寄存器的值更新为数据存储地址前面的数据位置，该数据也就相当于被销毁了。</p>
<p><img src="https://s2.loli.net/2022/03/24/rU7uWGPznvb3BVq.png" alt="image-20220324232932014"></p>
<h3 id="最优化功能"><a href="#最优化功能" class="headerlink" title="最优化功能"></a>最优化功能</h3><p>最优化功能是编译器在本地代码上费尽功夫实现的，其目的是让编译后的程序运行速度更快、文件更小。</p>
<p>在代码清单10-1中，由于存储着AddNum函数返回值的变量c在后面没有被用到，因此编译器就会认为“该处理没有意义”，进而也就没有生成与之对应的汇编语言代码。</p>
<h2 id="10-8-函数内部的处理"><a href="#10-8-函数内部的处理" class="headerlink" title="10.8 函数内部的处理"></a>10.8 函数内部的处理</h2><p><img src="https://s2.loli.net/2022/03/24/gnIv1SjJ2dpWBXE.png" alt="image-20220324233336246"></p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>ebp寄存器的值在（1）中入栈，在（5）中出栈。</p>
<p>这主要是为了把函数中用到的ebp寄存器的内容，恢复到函数调用前的状态。在进入函数处理之前，无法确定ebp寄存器用到了什么地方，但由于函数内部也会用到ebp寄存器，所以就暂时将该值保存了起来。</p>
<p>CPU拥有的寄存器是有数量限制的。</p>
<p>在函数调用前，调用源有可能已经在使用ebp寄存器了。因而，在函数内部利用的寄存器，要尽量返回到函数调用前的状态。</p>
<p>为此，我们就需要将其暂时保存在栈中，然后再在函数处理完毕之前出栈，使其返回到原来的状态。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>(2)中把负责管理栈地址的esp寄存器的值赋值到了ebp寄存器中。这是因为，在mov指令中方括号内的参数，是不允许指定esp寄存器的。</p>
<p>因此，这里就采用了不直接通过esp，而是用ebp寄存器来读写栈内容的方法。</p>
<h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>(3)是用[ebp+8]指定栈中存储的第1个参数123，并将其读出到eax寄存器中。像这样，不使用pop指令，也可以查看栈的内容。</p>
<p>而之所以从多个寄存器中选择了eax寄存器，是因为eax寄存器是负责运算的累加寄存器。</p>
<h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>通过(4)的add指令，把当前eax寄存器的值同第2个参数相加后的结果存储在eax寄存器中。[ebp+12]是用来指定第2个参数456的。</p>
<p>在C语言中，函数的返回值必须通过eax寄存器返回，这也是规定。不过，和ebp寄存器不同的是，eax寄存器的值不用还原到原始状态。</p>
<p>至此，我们进行了很多细节的说明，其实就是希望大家了解“<strong>函数的参数是通过栈来传递，返回值是通过寄存器来返回的</strong>”这一点。</p>
<h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><p>(6)中ret指令运行后，函数返回目的地的内存地址会自动出栈，据此，程序流程就会跳转返回到代码清单10-4的（6）（Call _AddNum的下一行）。</p>
<h3 id="栈状态变化"><a href="#栈状态变化" class="headerlink" title="栈状态变化"></a>栈状态变化</h3><p>由于（a）状态时处理跳转到AddNum函数，因此（a）和（b）是同样的。同理，在（d）状态时，处理跳转到了调用源，因此（d）和（e）是同样的。在（f）状态时则进行了清理处理。栈的最高位的数据地址，是一直存储在esp寄存器中的。</p>
<p><img src="https://s2.loli.net/2022/03/24/2CfyJbQYeW3ivcq.png" alt="image-20220324233510024"></p>
<h2 id="10-9-始终确保全局变量用的内存空间"><a href="#10-9-始终确保全局变量用的内存空间" class="headerlink" title="10.9 始终确保全局变量用的内存空间"></a>10.9 始终确保全局变量用的内存空间</h2><p>C语言中，在函数外部定义的变量称为全局变量，在函数内部定义的变量称为局部变量。</p>
<p><img src="https://s2.loli.net/2022/03/24/WFJrw3Nbu12Re6D.png" alt="image-20220324234352980"></p>
<p><img src="https://s2.loli.net/2022/03/24/eCMH7byilYdfLct.png" alt="image-20220324234510447"></p>
<p><img src="https://s2.loli.net/2022/03/24/FhQZCzgR4y7VPid.png" alt="image-20220324234601096"></p>
<p>编译后的程序，会被归类到名为段定义的组。初始化的全局变量，会像(2)那样被汇总到名为_BSS的段定义中。</p>
<p>指令则会像(3)那样被汇总到名为_TEXT的段定义中。</p>
<p><code>_DATA segment和_DATA ends、_BSS segment和_BSS ends、_TEXT segment和_TEXT ends</code>，这些都是表示各段定义范围的伪指令。</p>
<h3 id="DATA"><a href="#DATA" class="headerlink" title="_DATA"></a>_DATA</h3><h4 id="4-1"><a href="#4-1" class="headerlink" title="4"></a>4</h4><p>(4)中定义了_a1这个标签。标签表示的是相对于段定义起始位置的位置。由于它在开头位置，所以相对位置是0.</p>
<p>_a1就相当于全局变量a1。编译后的函数名和变量名前会附加一个下划线，这也是Borland C++的规定。</p>
<h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p>(5)中的dd 1指的是，申请分配了4字节的内存空间，存储着1这个初始值。dd(define double word)表示的是顶一个双字(double word)，而每个字的长度是2个字节，也就是申请了一个4字节的内存空间。由于int类型的长度是4字节，因此汇编器就把int a1 = 1；变换成了_a1 label dword和dd 1.</p>
<p>同样，这里定义了全部变量a2~a5的标签，各自的初始值也被存储在了4字节的领域中。</p>
<h3 id="BSS"><a href="#BSS" class="headerlink" title="_BSS"></a>_BSS</h3><p>这里定义了相当于全局变量b1～b5的标签<code>_b1～_b5</code>。</p>
<h4 id="6-1"><a href="#6-1" class="headerlink" title="6"></a>6</h4><p>(6)的db 4 dup(?)表示的是申请分配了4字节的领域，但值尚未确定(这里用？来表示)的意思。db(define byte)表示有1个长度是1字节的内存空间。因而，db 4 dup(? )的情况下，就是4字节的内存空间。</p>
<p>要注意不要和dd 4混淆了。db 4 dup(? )表示的是4个长度是1字节的内存空间。而dd 4表示的则是双字（4 byte）的内存空间中存储的值是4。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在<code>_DATA和_BSS</code>的段定义中，全局变量的内存空间都得到了确保，程序运行时没有初始化的全局变量的领域（_BSS段定义）都会被设定为0进行初始化。</p>
<p>可见，通过汇总，初始化很容易实现，只要把内存的特定范围全部设定为0就可以了。</p>
<h2 id="10-10-临时确保局部变量的内存空间"><a href="#10-10-临时确保局部变量的内存空间" class="headerlink" title="10.10 临时确保局部变量的内存空间"></a>10.10 临时确保局部变量的内存空间</h2><p>局部变量是保存在寄存器和栈中的。</p>
<p>函数内部利用栈，在函数处理完毕后会恢复到初始状态，因此局部变量的值也就被销毁了，而寄存器也可能会被用于其他目的。</p>
<p>因此，局部变量只是在函数处理运行期间临时存储在寄存器和栈上。</p>
<p>在代码清单10-6中定义了10个局部变量。这是为了表示存储局部变量的不仅仅是栈，还有寄存器。为确保c1～c10所需的领域，寄存器空闲时就使用寄存器，寄存器空间不足的话就使用栈。</p>
<h3 id="TEXT"><a href="#TEXT" class="headerlink" title="_TEXT"></a>_TEXT</h3><h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><p>(7)表示的是MyFunc函数的范围。</p>
<p>在MyFunc函数中定义的局部变量所需要的内存领域，会被尽可能地分配在寄存器中。</p>
<p>大家可能会认为用高性能的寄存器来代替普通的内存是很奢侈的事情，不过编译器不会这么认为，只要寄存器有空间，编译器就会使用它。因为与内存相比，使用寄存器时访问速度会高很多，这样就可以更快速地进行处理。</p>
<p>局部变量利用寄存器，是Borland C++编译器最优化的运行结果。旧的编译器没有类似的最优化功能，局部变量就可能会仅仅使用栈。</p>
<h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><p>(8)表示的是往寄存器中分配局部变量的部分。仅仅对局部变量进行定义是不够的，只有在给局部变量赋值时，才会被分配到寄存器的内存区域。（8）就相当于给5个局部变量c1～c5分别赋予数值1～5这一处理。</p>
<p>在这种情况下，寄存器只是被单纯地用于存储变量的值，和其本身的角色没有任何关系。</p>
<p>其中空闲的，最多也只有几个。因而，局部变量数目很多的时候，可分配的寄存器就不够了。这种情况下，局部变量就会申请分配栈的内存空间。</p>
<h4 id="11"><a href="#11" class="headerlink" title="11"></a>11</h4><p>（11）中的mov ebp,esp这一处理，指的是把当前esp寄存器的值复制到ebp寄存器中。之所以需要（11）这一处理，是为了通过在函数出口处的（12）这一move esp, ebp的处理，把esp寄存器的值还原到原始状态，从而对申请分配的栈空间进行释放，这时栈中用到的局部变量就消失了。这也是栈的清理处理。在使用寄存器的情况下，局部变量则会在寄存器被用于其他用途时自动消失</p>
<p><img src="https://s2.loli.net/2022/03/25/NHk9i8DIpCP17Gu.png" alt="image-20220325225716319"></p>
<h4 id="9"><a href="#9" class="headerlink" title="9"></a>9</h4><p>（9）中的mov dword ptr [ebp - 4], 6表示的就是，从申请分配的内存空间的下端（ebp寄存器指示的位置）开始往前4字节的地址（[ebp -4]）中，存储着6这一4字节的数据。</p>
<p><img src="https://s2.loli.net/2022/03/25/XfAdjbv7IWrHShC.png" alt="image-20220325225803158"></p>
<h2 id="10-11-循环处理的实现方法"><a href="#10-11-循环处理的实现方法" class="headerlink" title="10.11 循环处理的实现方法"></a>10.11 循环处理的实现方法</h2><p><img src="https://s2.loli.net/2022/03/25/LFOE9sJIVd1yiqa.png" alt="image-20220325225949853"></p>
<p>在汇编的源代码中，循环是通过比较指令(cmp)和跳转指令(jl)来实现的。</p>
<h3 id="汇编代码解析"><a href="#汇编代码解析" class="headerlink" title="汇编代码解析"></a>汇编代码解析</h3><h4 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h4><p>MyFunc函数中用到的局部变量只有i，变量i申请分配了ebx寄存器的内存空间。for语句的括号中的i=0；被转换成了xor ebx, ebx这一处理。xor指令会对左起第一个操作数和右起第二个操作数进行XOR运算，然后把结果存储在第一个操作数中。(xor这个异或要快于使用mov置零)</p>
<h4 id="jl"><a href="#jl" class="headerlink" title="jl"></a>jl</h4><p>汇编语言中有多个跳转指令，这些跳转指令会根据标志寄存器的值来判定是否需要跳转。</p>
<p>最后一行的jl，是jump on less than（小于的话就跳转）的意思。也就是说，jl short @4的意思就是，前面运行的比较指令的结果若“小”的话就跳转到@4这个标签。</p>
<h2 id="10-12-条件分支的实现方法"><a href="#10-12-条件分支的实现方法" class="headerlink" title="10.12 条件分支的实现方法"></a>10.12 条件分支的实现方法</h2><p><img src="https://s2.loli.net/2022/03/25/35sadGzSF1WuCxN.png" alt="image-20220325230254465"></p>
<h3 id="代码简析"><a href="#代码简析" class="headerlink" title="代码简析"></a>代码简析</h3><p>三种跳转指令，分别是比较结果小或相等时跳转的jle（jump on less or equal）、大或相等时跳转的jge（jump on greater orequal）、不管结果怎样都无条件跳转的jmp。</p>
<h2 id="10-13-程序运行方式"><a href="#10-13-程序运行方式" class="headerlink" title="10.13 程序运行方式"></a>10.13 程序运行方式</h2><p><img src="https://s2.loli.net/2022/03/25/rFd6aVWwhCnvB95.png" alt="image-20220325230503744"></p>
<p>counter <em>=2；这一个指令的部分，在汇编语言源代码，也就是实际运行的程序中，分成了3个指令。如果只是看counter </em>=2；的话，就会以为counter的数值被直接扩大为了原来的2倍。然而，实际上执行的却是“把counter的数值读入eax寄存器”“将eax寄存器的数值变成原来的2倍”“把eax寄存器的数值写入counter”这3个处理。</p>
<h3 id="多线程下的bug"><a href="#多线程下的bug" class="headerlink" title="多线程下的bug"></a>多线程下的bug</h3><p><img src="https://s2.loli.net/2022/03/25/3IpyrhkW9YZJBqc.png" alt="image-20220325230609855"></p>
<h1 id="Chapter-11-硬件控制方法"><a href="#Chapter-11-硬件控制方法" class="headerlink" title="Chapter 11 硬件控制方法"></a>Chapter 11 硬件控制方法</h1><p>所有连接到计算机的外围设备都会分配一个I/O地址编号。</p>
<h2 id="11-2-IN指令和OUT指令"><a href="#11-2-IN指令和OUT指令" class="headerlink" title="11.2 IN指令和OUT指令"></a>11.2 IN指令和OUT指令</h2><p>IN指令通过指定端口号的端口输入数据，并将其存储在CPU内部的寄存器中。OUT指令则是把CPU寄存器中存储的数据，输出到指定端口号的端口。</p>
<p><img src="https://s2.loli.net/2022/03/25/rZUCXkT27Kwb38a.png" alt="image-20220325230816504"></p>
<h3 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I/O控制器"></a>I/O控制器</h3><p>计算机主机中，附带了用来连接显示器及键盘等外围设备的连接器。而各连接器的内部，都连接有用来交换计算机主机同外围设备之间电流特性的IC。这些IC，统称为I/O 控制器。</p>
<p>由于电压不同，数字信号及模拟信号的电流特性也不同，计算机主机和外围设备是无法直接连接的。为了解决这个问题，I/O控制器就很有必要了。</p>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>I/O控制器中有用于临时保存输入输出数据的内存，这个内存就是端口。</p>
<p>I/O寄存器内部的内存，也成为寄存器，用来临时存储数据。</p>
<p>一个I/O控制器既可以控制一个外围设备，也可以控制多个外围设备。各端口之间通过端口号进行区分。端口号也称为I/O地址。</p>
<p>IN指令和OUT指令在端口号指定的端口和CPU之间进行数据的输入输出。这和通过内存地址来进行主内存的读写是一样的道理。</p>
<p><img src="https://s2.loli.net/2022/03/25/pxlUNtISDPGXZje.png" alt="image-20220325231134226"></p>
<p>端口是内存。</p>
<h2 id="11-4-中断请求"><a href="#11-4-中断请求" class="headerlink" title="11.4 中断请求"></a>11.4 中断请求</h2><p>IRQ是用来暂停当前正在执行的程序，并跳转到其他程序运行的必要机制。该机制称为中断处理。</p>
<h3 id="中断编号"><a href="#中断编号" class="headerlink" title="中断编号"></a>中断编号</h3><p>实施中断请求的是连接外围设备的I/O控制器，负责实施中断处理程序的是CPU。</p>
<p>为了进行区分，外围设备的中断请求会使用不同于I/O端口的其他编号，该编号称为中断编号。</p>
<h3 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h3><p>在I/O控制器和CPU中间加入名为中断控制器的IC来进行缓冲。中断控制器会把从多个外围设备发出的中断请求有序地传递给CPU。</p>
<p><img src="https://s2.loli.net/2022/03/25/DWMmlNCHuEQbqFG.png" alt="image-20220325231614331"></p>
<h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><p>中断处理程序的第一步处理，就是把CPU所有寄存器的数值保存到内存的栈中。在中断处理程序中完成外围设备的输入输出后，把栈中保存的数值还原到CPU寄存器中，然后再继续进行对主程序的处理。</p>
<p><img src="https://s2.loli.net/2022/03/25/Ci1rszRGx2cnhIm.png" alt="image-20220325231704128"></p>
<h2 id="11-5-用中断来实现实时处理"><a href="#11-5-用中断来实现实时处理" class="headerlink" title="11.5 用中断来实现实时处理"></a>11.5 用中断来实现实时处理</h2><h2 id="11-6-DMA"><a href="#11-6-DMA" class="headerlink" title="11.6 DMA"></a>11.6 DMA</h2><p>DMA（Direct Memory Access），DMA是指在不通过CPU的情况下，外围设备直接和主内存进行数据传送。</p>
<p>磁盘等都用到了这个DMA机制。通过利用DMA，无需经过CPU，大量数据就可以在短时间内转送到主内存。之所以这么快速，是因为CPU作为中介的时间被节省了。</p>
<p>在资源标签中有DMA设定，可以看出此处该设定为02。</p>
<p>02这个编号称为DMA通道。CPU借助DMA通道，来识别是哪一个外围设备使用了DMA。</p>
<p><img src="https://s2.loli.net/2022/03/25/FyGRcALuqYtD9Nn.png" alt="image-20220325231859355"></p>
<h3 id="识别外围设备"><a href="#识别外围设备" class="headerlink" title="识别外围设备"></a>识别外围设备</h3><p>I/O端口号、IRQ、DMA通道可以说是识别外围设备的3点组合。(不过，IRQ和DMA通道并不是所有的外围设备都必须具备的。)</p>
<p><strong>计算机主机通过软件控制硬件时所需要的信息的最低限，是外围设备的I/O端口号。</strong></p>
<p>IRQ只对需要中断处理的外围设备来说是必需的，DMA通道则只对需要DMA机制的外围设备来说是必需的。</p>
<h2 id="11-7-显示机制"><a href="#11-7-显示机制" class="headerlink" title="11.7 显示机制"></a>11.7 显示机制</h2><p>显示器显示文字及图形的机制</p>
<p>如果用一句话来简单地概括该机制，那就是显示器中显示的信息一直存储在某内存中。</p>
<p>该内存称为VRAM（Video RAM）。在程序中，只要往VRAM中写入数据，该数据就会在显示器中显示出来。</p>
<p>实现该功能的程序，是由操作系统或BIOS提供，并借助中断来进行处理的。</p>
]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架</title>
    <url>/2022/04/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="一、-引言"><a href="#一、-引言" class="headerlink" title="一、 引言"></a>一、 引言</h1><h2 id="1-常用的集合"><a href="#1-常用的集合" class="headerlink" title="1. 常用的集合"></a>1. 常用的集合</h2><p>集合相关类的接口都在java.util中，主要分为3种：List(列表)、Map(映射)、Set(集)</p>
<p>其中，Collection是集合List、Set的父接口，Map是另外的接口，是键值对映射结构的集合。</p>
<p>List：存储的元素有序，可重复；</p>
<p>Set：存储的元素不无序，不可重复。</p>
<h1 id="二、List"><a href="#二、List" class="headerlink" title="二、List"></a>二、List</h1><h2 id="1-ArrayList和LinkedList"><a href="#1-ArrayList和LinkedList" class="headerlink" title="1. ArrayList和LinkedList"></a>1. ArrayList和LinkedList</h2><p>ArrayList基于数组实现</p>
<p>Linked基于双向链表实现</p>
]]></content>
      <tags>
        <tag>Java集合框架等</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux_HSP</title>
    <url>/2022/04/15/Linux-HSP/</url>
    <content><![CDATA[<h1 id="Content-Introduction"><a href="#Content-Introduction" class="headerlink" title="Content Introduction"></a>Content Introduction</h1><h2 id="1-vmtools"><a href="#1-vmtools" class="headerlink" title="1. vmtools"></a>1. vmtools</h2><p>在主机Windows和虚拟机Linux上进行文件共享所需的工具。</p>
<p>对于共享的部分，若Windows在其中新建文件夹，Linux上可以看到；同时，Linux对文件进行修改，Windows也可以看到。</p>
<p>即，Windows和Linux对文件都有读写的权限，并且都对修改可见。</p>
<h3 id="1-过程"><a href="#1-过程" class="headerlink" title="1. 过程"></a>1. 过程</h3><ol>
<li>虚拟机—&gt;安装/重新安装vmtools(若桌面存在CentOS 7.6的光盘映像，需要先删除)，之后桌面会出现vmtools的光盘映像。</li>
<li>打开光盘映像，将其中的那个压缩包复制到主文件夹中的/opt中，之后解压</li>
<li><img src="https://s2.loli.net/2022/04/15/cLDbF7enZyXwtSm.png" alt="image-20220214163517194"></li>
</ol>
<p>​        Tab键 可以补全文件名。</p>
<ol>
<li><p><img src="https://s2.loli.net/2022/02/14/NlkhROvnQUgWi1B.png" alt="image-20220214163726657"></p>
<p> 一直按回车(Enter)即可。</p>
</li>
<li><p><img src="https://s2.loli.net/2022/02/14/73uglCqi19ZnkVh.png" alt="image-20220214163938458"></p>
</li>
</ol>
<p>如图，成功。</p>
<ol>
<li><p><img src="https://s2.loli.net/2022/02/14/2BaFDIeRYsh3V1Z.png" alt="image-20220214164203664"></p>
</li>
<li><p>之后在D:\myshare(Windows)和主文件夹\其他位置\计算机\mnt\hgfs\myshare(Linux)中，双方任意一方进行增加、修改文件等操作的结果，双方都可见。</p>
</li>
</ol>
<h3 id="2-tips"><a href="#2-tips" class="headerlink" title="2. tips"></a>2. tips</h3><p>但在实际开发中，一般远程登陆后，进行上传下载文件，不通过这种方式进行共享。</p>
<h2 id="3-Linux目录结构-重要"><a href="#3-Linux目录结构-重要" class="headerlink" title="3. Linux目录结构(重要)"></a>3. Linux目录结构(重要)</h2><h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><p><strong>Linux会把硬件映射成一个文件来管理。</strong></p>
<ol>
<li>Linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录”/“，然后在此目录下再创建别的目录。</li>
<li>规定了每个目录下存放的文件类型(如/bin下存常用命令等)。</li>
<li><strong>在Linux世界里，一切皆文件。</strong></li>
</ol>
<p><img src="https://s2.loli.net/2022/02/14/F9d6KWpel8MHOzb.png" alt="image-20220214170022218"></p>
<p><img src="https://s2.loli.net/2022/02/14/f7gNkTUv8CYZ15o.png" alt="image-20220214170142179"></p>
<p><img src="https://s2.loli.net/2022/02/14/Mmp7T63CSWsV4fw.png" alt="image-20220214170244070"></p>
<h3 id="2-详解"><a href="#2-详解" class="headerlink" title="2. 详解"></a>2. 详解</h3><p><img src="https://s2.loli.net/2022/02/14/MdZyBbiCIKmz1rs.png" alt="image-20220214171223656"></p>
<p><img src="https://s2.loli.net/2022/02/14/U4ysVScpb5zXmft.png" alt="image-20220214171437594"></p>
<p><img src="https://s2.loli.net/2022/02/14/ylqvWwxmTgcAtNS.png" alt="image-20220214171313425"></p>
<p><strong>/proc和/srv和/sys存放系统文件，如果乱动，极大可能会导致系统崩溃。</strong></p>
<p><img src="https://s2.loli.net/2022/02/14/2hWHTMim3tKdGUz.png" alt="image-20220214172749215"></p>
<p><img src="https://s2.loli.net/2022/02/14/l6OD2K7oQFiEIkB.png" alt="image-20220214172650483"></p>
<h2 id="4-远程登录Linux"><a href="#4-远程登录Linux" class="headerlink" title="4. 远程登录Linux"></a>4. 远程登录Linux</h2><p>不在同一台主机上的登录行为.</p>
<h3 id="1-原因"><a href="#1-原因" class="headerlink" title="1. 原因"></a>1. 原因</h3><ol>
<li>Linux服务器是开发小组共享</li>
<li>正式上线的项目是运行在公网</li>
<li>因此程序员需要远程登录到Linux进行项目管理或者开发</li>
<li>简单的网络拓扑示意图</li>
</ol>
<p><img src="https://s2.loli.net/2022/02/20/oDN1d3QuYSHXyAE.png" alt="image-20220220184654829"></p>
<ol>
<li>远程登录客户端有Xshell(远程登录)，Xftp(文件远程上传下载)等。</li>
</ol>
<h4 id="2-Xshell"><a href="#2-Xshell" class="headerlink" title="2. Xshell"></a>2. Xshell</h4><p><img src="https://s2.loli.net/2022/02/20/96wWaNZoYtFzu4j.png" alt="image-20220220182621199"></p>
<p>输入reboot，可以控制Linux去重启。</p>
<h4 id="3-Xftp"><a href="#3-Xftp" class="headerlink" title="3. Xftp"></a>3. Xftp</h4><p><img src="https://s2.loli.net/2022/02/20/S6HibfG2MyIrkCE.png" alt="image-20220220184936249"></p>
<p><img src="https://s2.loli.net/2022/02/20/6xa2dzDHhGyQAgr.png" alt="image-20220220183955314"></p>
<h2 id="5-vi和vim"><a href="#5-vi和vim" class="headerlink" title="5. vi和vim"></a>5. vi和vim</h2><p>实际工作以XShell为主</p>
<h3 id="1-基本介绍-1"><a href="#1-基本介绍-1" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><p>Linux会内置vi文本编辑器</p>
<p>Vim具有程序编辑的能力，可以看作是vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能丰富。</p>
<h4 id="1-正常模式"><a href="#1-正常模式" class="headerlink" title="1. 正常模式"></a>1. 正常模式</h4><p>以vim打开一个档案就直接进入一般模式(这是默认的模式)。在这个模式中，可以使用按键来移动光标，可以使用删除字符和删除整行来处理档案内容，也可以复制粘贴。</p>
<h4 id="2-插入模式"><a href="#2-插入模式" class="headerlink" title="2. 插入模式"></a>2. 插入模式</h4><p>可以增加文字进入档案。</p>
<h4 id="3-命令行模式"><a href="#3-命令行模式" class="headerlink" title="3. 命令行模式"></a>3. 命令行模式</h4><p>可以完成读取、存盘、替换、离开vim，显示行号等操作。</p>
<p><strong>先输入esc，表示退出，再输入”:“后，即可从插入模式进入命令行模式。</strong></p>
<p>那么，输入“:wq”：进入命令行模式，之后write写入，再quit退出。</p>
<p><img src="https://s2.loli.net/2022/03/05/Y2tnZp5ICXJ4WBe.png" alt="image-20220305215742256"></p>
<p>再次进入只需 vim Hello.java。</p>
<h3 id="2-快捷键"><a href="#2-快捷键" class="headerlink" title="2. 快捷键"></a>2. 快捷键</h3><p><img src="https://s2.loli.net/2022/02/20/u3EeAhDqC1i4SW2.png" alt="image-20220220222642750"></p>
<h4 id="1-常用的7个快捷键"><a href="#1-常用的7个快捷键" class="headerlink" title="1. 常用的7个快捷键"></a>1. 常用的7个快捷键</h4><p>在一般模式下输入才是快捷键，在编辑模式输入就是插入字符。</p>
<ol>
<li>先yy再p，粘贴。</li>
<li>/ 切换到命令模式，此时输入想要查找的关键字即可。即/a。</li>
<li>直接输入: ，再直接输入set nu即可</li>
<li></li>
</ol>
<p><img src="https://s2.loli.net/2022/02/20/1p6URexnwAgZTt8.png" alt="image-20220220225039845"></p>
<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>若是想转而查找别的单词，输入”/“+其他关键字即可。</p>
<p>找不到的话，会有提示信息：</p>
<p><img src="https://s2.loli.net/2022/02/20/kwvJVs9gUMAcxjC.png" alt="image-20220220223825590"></p>
<h5 id="设置行号"><a href="#设置行号" class="headerlink" title="设置行号"></a>设置行号</h5><p>nu：number</p>
<p>效果图如下：(若想删除行号，输入”:set nonu”)</p>
<p><img src="https://s2.loli.net/2022/02/20/J1mLkXNTyC7zSwQ.png" alt="image-20220220224009345"></p>
<h4 id="2-tips："><a href="#2-tips：" class="headerlink" title="2. tips："></a>2. tips：</h4><h5 id="先退回一般模式"><a href="#先退回一般模式" class="headerlink" title="先退回一般模式"></a>先退回一般模式</h5><p><strong>注意部分快捷键是要退回一般模式后使用的！</strong></p>
<p>在插入模式下，首先输入”:”，使得下方没有命令显示，只有”:”时，再按ESC退回到一般模式。</p>
<h5 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h5><p>其他还有很多快捷键，但是没必要。实际开发大型项目时，还是先在熟悉的windows环境中将代码写好，然后上传到Linux中，但不可避免的，肯定也会有远程登录，然后修改代码等的情况，所以快捷键还是要掌握一些，比如列出的7种，一定要掌握的。</p>
<h2 id="6-关机-amp-重启"><a href="#6-关机-amp-重启" class="headerlink" title="6. 关机&amp;重启"></a>6. 关机&amp;重启</h2><p>shutdown -h now : 立刻进行关机</p>
<p>shutdown -h 1 ：给所有登录到该Linux的用户发送一个通知：1分钟后会关机</p>
<p>shutdown -r now ：现在重启计算机(reboot)</p>
<p>halt ：关机，作用和上边的一样</p>
<p>reboot ：现在重启计算机</p>
<p>sync ：把内存的数据同步到磁盘</p>
<p><strong>不管是重启还是关闭系统，首先要运行sync命令，把内存中的数据写到磁盘中</strong></p>
<p>目前的shutdown/reboot/halt等命令均已经在关机前进行了sync，但所谓小心驶得万年船。</p>
<h2 id="7-登录注销"><a href="#7-登录注销" class="headerlink" title="7. 登录注销"></a>7. 登录注销</h2><h3 id="1-基本介绍-2"><a href="#1-基本介绍-2" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><ol>
<li><p>登录时尽量少用root账号登录(实际开发时少用)，因为它是系统管理员，最大的权限，避免操作失误，可以利用普通用户登录，登录后再用”su - 用户名”(su -root)命令来切换称系统管理员身份。</p>
</li>
<li><p>在提示符下输入logout即可注销(将当前用户退出)</p>
</li>
</ol>
<h3 id="2-使用细节"><a href="#2-使用细节" class="headerlink" title="2. 使用细节"></a>2. 使用细节</h3><ol>
<li>logout注销指令在图形运行级别(图形界面)无效，在运行级别 3下有效</li>
<li>从Phoenix进到root后，一次logout回退到Phoenix</li>
</ol>
<p><img src="https://s2.loli.net/2022/04/15/sfxbgMePiOC9mRy.png" alt="image-20220415172002598"></p>
<p>但之后，再在虚拟机中对Phoenix使用logout无用，并不会注销</p>
<p><img src="https://s2.loli.net/2022/04/15/Jjz5h6NuU8GOH4W.png" alt="image-20220415172038456"></p>
<h2 id="8-用户管理"><a href="#8-用户管理" class="headerlink" title="8. 用户管理"></a>8. 用户管理</h2><p>蓝色的是一个文件夹</p>
<h3 id="1-基本介绍-3"><a href="#1-基本介绍-3" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><p>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须先向系统管理员申请一个账号，然后以这个账号的身份进入系统</p>
<h3 id="2-添加用户"><a href="#2-添加用户" class="headerlink" title="2. 添加用户"></a>2. 添加用户</h3><h4 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h4><p>useradd 用户名</p>
<h4 id="2-应用案例"><a href="#2-应用案例" class="headerlink" title="2. 应用案例"></a>2. 应用案例</h4><p>创建一个用户milan，默认该用户的家目录位于 /home/milan。</p>
<h4 id="3-细节说明"><a href="#3-细节说明" class="headerlink" title="3. 细节说明"></a>3. 细节说明</h4><ol>
<li>当创建用户成功时，会自动地创建位于home下和用户名称一致的家目录，即/home/milan</li>
<li>也可以通过useradd -d 指定目录 用户名 的方式，执行用户的家目录。</li>
</ol>
<h3 id="3-指定-修改密码"><a href="#3-指定-修改密码" class="headerlink" title="3. 指定/修改密码"></a>3. 指定/修改密码</h3><p>pwd：显示当前用户所在目录</p>
<h3 id="4-删除用户"><a href="#4-删除用户" class="headerlink" title="4. 删除用户"></a>4. 删除用户</h3><h4 id="1-删除用户，保留家目录"><a href="#1-删除用户，保留家目录" class="headerlink" title="1. 删除用户，保留家目录"></a>1. 删除用户，保留家目录</h4><p>userdel milan</p>
<h4 id="2-删除用户及家目录"><a href="#2-删除用户及家目录" class="headerlink" title="2. 删除用户及家目录"></a>2. 删除用户及家目录</h4><p>userdel -r king </p>
<p>蓝色是文件</p>
<p><img src="https://s2.loli.net/2022/04/15/tBZ9jygTJAoXPNf.png" alt="image-20220415190600826"></p>
<p>该操作要慎重</p>
<p>一般情况下，建议保留，家目录</p>
<h3 id="5-切换用户"><a href="#5-切换用户" class="headerlink" title="5. 切换用户"></a>5. 切换用户</h3><p>su - 用户名</p>
<p>从权限高的目录切换到权限低的用户无需输入密码，反之则需要输入密码。</p>
<p><img src="https://s2.loli.net/2022/04/15/I2agcf3HD7PEzLd.png" alt="image-20220415190911802"></p>
<h3 id="6-查看当前用户-登录用户"><a href="#6-查看当前用户-登录用户" class="headerlink" title="6. 查看当前用户/登录用户"></a>6. 查看当前用户/登录用户</h3><p>whoami</p>
<p>显示的是第一次登录用户的信息</p>
<p>如图所示，就算从root切换到phoenix，但 who am i 依旧显示的是root的信息。</p>
<p><img src="https://s2.loli.net/2022/04/15/tRAilu86eHfWJ41.png" alt="image-20220415191335840"></p>
<h3 id="7-用户组"><a href="#7-用户组" class="headerlink" title="7. 用户组"></a>7. 用户组</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><p>类似于角色，系统可以对有共性/权限的多个用户进行统一的管理</p>
<h4 id="2-新增组"><a href="#2-新增组" class="headerlink" title="2. 新增组"></a>2. 新增组</h4><p>指令：groupadd 组名</p>
<h4 id="3-删除组"><a href="#3-删除组" class="headerlink" title="3. 删除组"></a>3. 删除组</h4><p>指令：groupdel 组名</p>
<p>如果在新增用户时，没有指定所在分组，那么会自动生成一个和用户名同名的组，并将该用户放入组中</p>
<p><img src="https://s2.loli.net/2022/04/15/rXRFyYe4IL79aVN.png" alt="image-20220415192321658"></p>
<h4 id="4-指定用户所在的组"><a href="#4-指定用户所在的组" class="headerlink" title="4. 指定用户所在的组"></a>4. 指定用户所在的组</h4><p>useradd -g 组名 用户名</p>
<p><img src="https://s2.loli.net/2022/04/15/tmQRShGI8XlAJ3C.png" alt="image-20220415193058481"></p>
<h4 id="5-修改用户组"><a href="#5-修改用户组" class="headerlink" title="5. 修改用户组"></a>5. 修改用户组</h4><p>usermod -g 组名 用户名</p>
<p>前提是，该组要存在。</p>
<p><img src="https://s2.loli.net/2022/04/15/gGQZPvYrN6BDbxS.png" alt="image-20220415193452289"></p>
<h4 id="6-用户和组相关的文件"><a href="#6-用户和组相关的文件" class="headerlink" title="6. 用户和组相关的文件"></a>6. 用户和组相关的文件</h4><h5 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h5><p>用户的配置文件，记录用户的各种信息。</p>
<p>每行含义：用户名：口令(密码不显示，是x)：用户标识号(uid)：组标识号(gid)：注释性描述：主目录：登录Shell</p>
<h6 id="Shell？"><a href="#Shell？" class="headerlink" title="Shell？"></a>Shell？</h6><p><img src="https://s2.loli.net/2022/04/15/RnHmNPbGI8fzySX.png" alt="image-20220415194900802"></p>
<p>bash：bashell</p>
<p><img src="https://s2.loli.net/2022/04/15/Bt392sVWxzICNeP.png" alt="image-20220415195705150"></p>
<h5 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h5><p>口令的配置文件</p>
<p>每行：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</p>
<p>就第一个和第二个可见端倪，别的看不懂</p>
<p><img src="https://s2.loli.net/2022/04/15/4PxE28kTSKqeRXG.png" alt="image-20220415195952714"></p>
<p>！是因为没设密码</p>
<h2 id="3-etc-group"><a href="#3-etc-group" class="headerlink" title="3## /etc/group"></a>3## /etc/group</h2><p>组group的配置文件，记录Linux包含的组的信息</p>
<p>组名：口令：组标识号：组内用户列表</p>
<p><img src="https://s2.loli.net/2022/04/15/54TqiQapYt6LyXc.png" alt="image-20220415200224876"></p>
<h2 id="9-运行级别"><a href="#9-运行级别" class="headerlink" title="9. 运行级别"></a>9. 运行级别</h2><h3 id="1-指定用户级别"><a href="#1-指定用户级别" class="headerlink" title="1. 指定用户级别"></a>1. 指定用户级别</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>0：关机</p>
<p>1：单用户(可以帮助找回丢失密码)</p>
<p>2：多用户状态没有网络服务(用的少)</p>
<p>3：多用户状态有网络服务(用的最多)</p>
<p>4：系统未使用保留给用户(保留的，用的少)</p>
<p>5：图形界面(用得多)</p>
<p>6：系统重启(用得多)</p>
<p>常用运行级别是3和5，也可以指定默认运行级别。</p>
<h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>init [0123456]</p>
<p>通过init来切换运行级别</p>
<p>获取默认的运行级别:图形化界面，即级别5</p>
<p><img src="https://s2.loli.net/2022/04/15/TFCdfipaUkmocV9.png" alt="image-20220415203016696"></p>
<p>设置默认的运行级别</p>
<p>systemctl set-default multi-user.target //切换到多用户有网络界面，即级别3</p>
<p><strong>在工作中使用级别3！</strong></p>
<h2 id="10-找回root密码"><a href="#10-找回root密码" class="headerlink" title="10. 找回root密码"></a>10. 找回root密码</h2><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>如何找回root密码</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><img src="https://s2.loli.net/2022/04/15/jM38n25AlmTXfLz.png" alt="image-20220415204510572"></p>
<p><img src="https://s2.loli.net/2022/04/15/PnS62d1QGL5wzND.png" alt="image-20220415204535880"></p>
<p><img src="https://s2.loli.net/2022/04/15/L7I2gXtKoqPAsOH.png" alt="image-20220415204559201"></p>
<h2 id="11-帮助信息"><a href="#11-帮助信息" class="headerlink" title="11. 帮助信息"></a>11. 帮助信息</h2><h3 id="man指令"><a href="#man指令" class="headerlink" title="man指令"></a>man指令</h3><p>获得帮助信息</p>
<p>man [指令或配置文件]，如man ls(按空格键文件会继续往下)</p>
<p>选项可以组合使用，如：ls -la</p>
<p>在Linux下，隐藏的文件是以 .开头的。</p>
<p>退出输入 q 即可。</p>
<h3 id="help指令"><a href="#help指令" class="headerlink" title="help指令"></a>help指令</h3><p>获得shell内置命令的帮助信息</p>
<p>help 命令</p>
<h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3>]]></content>
      <tags>
        <tag>Linux入门</tag>
      </tags>
  </entry>
</search>
