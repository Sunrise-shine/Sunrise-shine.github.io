<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>After-reading</title>
    <url>/2021/12/12/After-reading/</url>
    <content><![CDATA[<h1 id="认知觉醒"><a href="#认知觉醒" class="headerlink" title="认知觉醒"></a>认知觉醒</h1><h2 id="上篇"><a href="#上篇" class="headerlink" title="上篇"></a>上篇</h2><h3 id="第一章-大脑：一切问题的根源"><a href="#第一章-大脑：一切问题的根源" class="headerlink" title="第一章 大脑：一切问题的根源"></a>第一章 大脑：一切问题的根源</h3><h4 id="第一节-大脑：重新认识你自己"><a href="#第一节-大脑：重新认识你自己" class="headerlink" title="第一节 大脑：重新认识你自己"></a>第一节 大脑：重新认识你自己</h4><p>大脑主要包括本能脑(约3.6亿年)、情绪脑(约2亿年)和理智脑(约250万年)。</p>
<p>由于理智脑出现时间最短，对大脑的掌控能力很弱，所以，<strong>我们在生活中做的大部分决策，往往源于本能和情绪，而非理智</strong>。</p>
<p>情绪脑和本能脑，是为了适应远古时期的生活，而具有目光短浅和及时满足的特性。</p>
<h5 id="突出的"><a href="#突出的" class="headerlink" title="突出的"></a>突出的</h5><ul>
<li><strong>趋易避难</strong>——只做简单和舒适的事，喜欢在核心区域周边打转，待在舒适区内逃避真正的困难。</li>
<li><strong>急于求成</strong>——凡事希望立即看到结果，对不能马上看到结果的事往往缺乏耐心，非常容易放弃。</li>
</ul>
<p>这就导致，<strong>大多数时候，我们以为自己在思考，其实都是在对自身的行为和欲望合理化。</strong></p>
<p>习惯之所以难以改变，就是因为他是自我巩固的——越用越强，越强越用。要想从既有的习惯中跳出俩，最好的方法不是依靠自制力，而是依靠知识。</p>
<h4 id="第二节-焦虑：焦虑的根源"><a href="#第二节-焦虑：焦虑的根源" class="headerlink" title="第二节 焦虑：焦虑的根源"></a>第二节 焦虑：焦虑的根源</h4><p>事实上，我们应该跟过去的自己比，哪怕好那么一点点，也是值得的。而不是要去跟所谓的成功人士比。</p>
<h5 id="焦虑的几种形式"><a href="#焦虑的几种形式" class="headerlink" title="焦虑的几种形式"></a>焦虑的几种形式</h5><ul>
<li>完成焦虑。日程安排太慢，每天都活在deadline前。</li>
<li>定位焦虑。在零基础阶段就知识该领域的能人们现在的所作所为。</li>
<li>选择焦虑。想做的事情太多，选择太多。</li>
<li>环境焦虑。有些事不想做，却必须花大量的时间去做。有些事想做却做不了。</li>
<li>难度焦虑。有些东西就是很难学。真正能让你变强的东西，其核心困难是无法回避的。</li>
</ul>
<h5 id="焦虑的根源"><a href="#焦虑的根源" class="headerlink" title="焦虑的根源"></a>焦虑的根源</h5><p>焦虑的原因，就两条：<strong>想同时做很多事，又想立即看到效果</strong>。自己的欲望大于能力，又极度缺乏耐心。</p>
<ul>
<li>急于求成：想同时做很多事</li>
<li>避难趋易：想不怎么努力就看到结果</li>
</ul>
<h5 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h5><ul>
<li>克制欲望，不要让自己同时做很多事</li>
<li>面对现实，看清自己真实的能力水平</li>
<li>要事优先，想办法只做最重要的事</li>
<li>接受环境，在局限中做力所能及的事</li>
<li>直面核心，狠狠逼自己一把去突破它</li>
</ul>
<h4 id="第三节-耐心：得耐心者得天下"><a href="#第三节-耐心：得耐心者得天下" class="headerlink" title="第三节 耐心：得耐心者得天下"></a>第三节 耐心：得耐心者得天下</h4><p><strong>要想有所成就，必须保持耐心，延迟满足。</strong>要想保持出色，就必须经受长时间的磨练。</p>
<h5 id="原因和规律"><a href="#原因和规律" class="headerlink" title="原因和规律"></a>原因和规律</h5><p>很多时候，我们对困难事物缺乏耐心是因为看不到全局、不知道自己身在何处，所以总拿着天性这把短视之尺去到处衡量。牢记复利曲线。<img src="https://s2.loli.net/2021/12/22/36EnLCdeK9V2suZ.png" alt="image-20211212153853571"></p>
<p>无论个体还是群体，其能力都以”舒适区—拉伸区—困难区“的形式分布。要想让自己高效成长，必须让自己始终处于舒适区的边缘。</p>
<p><img src="https://s2.loli.net/2021/12/22/OHVMN58ufSXTktL.png" alt="image-2127"></p>
<p>首先要认识到，成长权重对比。</p>
<p>对于学习而言，学习之后的思考，思考之后的行动，行动之后的改变更重要，如果不叮嘱内层的改变量，那么在表层投入再多的学习量也会事倍功半，因此，从权重上看，改变量&gt;行动量&gt;思考量&gt;学习量.</p>
<p>很多人之所以痛苦焦虑，就是因为只盯着表层的学习量。它们读了很多书，报了很多课，天天打卡，日日坚持，但就是没有深入关注过自己的思考、行动和改变。原因仍然是我们的天性在作祟，因为单纯保持学习输入事件单的。</p>
<p>停在表层，我们就会陷入欲望漩涡，什么都想学，什么都想要，忙忙碌碌却收效甚微；若是能深入底层，盯住实际改变，就能跳出盲目、焦虑、浮躁的怪圈。</p>
<p>另一个值得关注的规律就是，学习的平台期。</p>
<p>学习进展和时间的关系并不是想象中的线性关系(学多少是多少)，而是波浪式上升曲线。</p>
<p>当我们清楚了上述规律之后，就能在面对长期的冷寂或挫折失败时做出与他人不同的选择。各自所处的阶段不同，只要持续创造价值，别人的今天就是自己的明天。</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ul>
<li><p><strong>首先，面对天性，放下心理包袱，坦然接纳自己。</strong></p>
<p>从现在开始，对于自己表现出的任何急躁、焦虑和不耐烦，都不要感到自责和内疚，一旦感觉到失去耐心了，就温和地对自己说：”你看，身体里的那个原始人又出来了，让他离开丛林到城市生活，确实挺不容易的，要理解他。“不要指望一下子就能变得很有耐心，如果对自己不能立即变好这件事感到焦虑，着本身就是缺乏耐心的表现。</p>
</li>
<li><p><strong>其次，面对诱惑，学会延迟满足，变对抗为沟通</strong></p>
<p>和自己对话“该有的享受一点都不会少，只是不是现在享受，而是完成重要的事情之后。”  “暂时忍耐一下，先做重要的事情，之后会有专门的半个小时到一个小时的时间，专门玩手机，想怎么玩都行。”</p>
<p><strong>将享乐的快感建立在完成重要任务之后的成就感</strong>上，很放松，很踏实，就像一种奖赏。</p>
</li>
<li><p><strong>最后，面对困难，主动改变视角，赋予行动意义</strong></p>
<p>别人能持之以恒，一个重要原因是，他们更擅长探索原理，会主动改变认知视角，来找到行动的意义和好处。比如当我们知道阅读的本质和意义，我们就更有可能放下手机，主动拿起书本。想办法去看清那些想做之事的意义和好处。</p>
</li>
</ul>
<p>想办法让本能脑和情绪脑感受到困难事物的乐趣并上瘾，这才是理智脑最高级的策略。</p>
<h3 id="第二章-潜意识：生命留给我们的彩蛋"><a href="#第二章-潜意识：生命留给我们的彩蛋" class="headerlink" title="第二章 潜意识：生命留给我们的彩蛋"></a>第二章 潜意识：生命留给我们的彩蛋</h3><h4 id="第一节-模糊：人生是一场消除模糊的比赛"><a href="#第一节-模糊：人生是一场消除模糊的比赛" class="headerlink" title="第一节 模糊：人生是一场消除模糊的比赛"></a>第一节 模糊：人生是一场消除模糊的比赛</h4><h5 id="引证"><a href="#引证" class="headerlink" title="引证"></a>引证</h5><p>领域内的精英无不是比其他人了解的知识更多，他们的盲区更小，认知更清晰，因而也更具影响力。</p>
<p>学习知识的目的是“消除模糊”，而获取知识的方法也是“消除模糊”。</p>
<p>思考力的本质就是：丢弃所有已经消化的信息，让问题的核心浮出水面。</p>
<p>《刻意练习》中的核心方法论是：不要重复练习已经会的，要不断需找那些稍有难度的部分。</p>
<p>《超越感觉》一书，要想拥有清晰的逻辑，就坚持一点：凡事不要凭模糊的感觉判断，而是要寻找清晰的证据。</p>
<p>提升思考能力的方法正是不断明确核心困难和心得感悟，并专注于此。</p>
<p>“学霸”的错题本：他们更愿意花时间明确错误，并集中精力攻克；即谁愿意做高耗能的事——消除模糊，制造清晰。</p>
<h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>人不喜欢主动耗能，所以，多数人为了逃避真正的思考，愿意做任何事。</p>
<p>然而回避痛苦并不会使痛苦消失，反而会使其转入潜意识，变成模糊的感觉。<strong>而具体事件一旦变模糊，其边界就会无限扩大，原本并不困难的小事，也会在模糊的潜意识里变得难以解决。</strong></p>
<p><strong>真正的困难总比想象中的要小很多</strong>。人们拖延、纠结、位居的根本原因往往不是事情本身有多难，而是内心的想法变得模糊。记住，任何痛苦事件都不会自动消失，哪怕再小的事情也是如此。</p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>要想不受其困扰，唯一的办法就是主动正视它、拆解它、看清它，不给它进入潜意识的机会，不给它变模糊的机会；即使已经进入潜意识，也要想办法将它挖出来。所以，当你感到心里有说不清、道不明的难受时，赶紧坐下来，向自己提问。</p>
<ul>
<li>到底是什么让自己烦躁不安？是上台演讲、会见某人，还是思绪纷乱？</li>
<li>具体是什么让自己恐惧担忧？是能力不足，准备不够，还是害怕某事发生？</li>
<li>面对困境，我能做什么？不能做什么？如果做不到或搞砸了，最坏的结果是什么？</li>
</ul>
<h5 id="里清外明，消除行为模糊"><a href="#里清外明，消除行为模糊" class="headerlink" title="里清外明，消除行为模糊"></a>里清外明，消除行为模糊</h5><p>行动力不足的真正原因是选择模糊。</p>
<p>当我们没有清晰的指令或者目标时，就很容易选择享乐，放弃那些本该坚持但比较烧脑的选项。</p>
<p><strong>要想让自己更胜一筹，就必须学会花费更多的脑力和心力去思考如何拥有足够清晰的目标。我们要把目标和过程细化、具体化，在诸多可能性中建立一条单行通道，让自己始终处于“没得选”的状态。</strong></p>
<p>消除认知、情绪和行动上的模糊，主动反本能。</p>
<h4 id="第二节-感性"><a href="#第二节-感性" class="headerlink" title="第二节 感性"></a>第二节 感性</h4><p>潜意识没有思维，只关心眼前的事物，喜欢即刻、确定、简单、舒适，这是属于天性的部分。但他处理信息的速度又极快，<strong>至少可达11,000,000次每秒</strong>，能极其敏锐地感知很多不易察觉的信息。</p>
<p>而意识，即我们的理性思考，处理信息的速度<strong>只有40次每秒</strong>。</p>
<p>二者具有天壤之别！</p>
<h5 id="凭感觉学习"><a href="#凭感觉学习" class="headerlink" title="凭感觉学习"></a>凭感觉学习</h5><p><strong>所谓“熔断不读书法”，意思就是在读书时一旦看到有启发的内容，就触发熔断点，立刻停止阅读，对自己进行提问。</strong></p>
<ul>
<li>为什么刚才这个点让我有启发？</li>
<li>我能够把这个启发点用在3个不同的事情上吗？</li>
<li>这个启发点有没有其他类似的知识？</li>
</ul>
<p>不管是生活中还是学习上，凡是被某件事击中，“动了感情”，就要有意识地追问原因：</p>
<ul>
<li>为什么这个电影桥段让我感动？发生了什么？</li>
<li>为什么这个产品让我这么喜欢？是什么让它这么与众不同？</li>
<li>为什么我不由自主沉溺于这段剧情了？</li>
</ul>
<p>这就是方法：<strong>先用感性能力帮自己选择，再用理性能力帮助自己思考。</strong>这背后的原理就是通过捕捉潜意识发出的信号进行感知。</p>
<p>”只有那种大致能看出点思路，但又要动点脑筋的题目，一定要多做。这个就是中间地带，是你能够进步最快的地方。”</p>
<p>看出端倪没？“凭感觉”之所以被称为顶级的方法，是因为它能帮我们感知真正适合自己并需要的东西，让自己处于学习的“拉伸区”。</p>
<h5 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h5><p>更好的读书方法，或许就是你在读完整本书后，过几天再问自己：<strong>现在你印象最深的触动点是什么？牢牢抓住这个触动点，去关联、去实践，就会获得最大的收获</strong>，而其他的内容则可以先放到一边。这也是我自己的读书方法——<strong>只取一个全书最触动自己的点，然后尽可能去实践、改变</strong>。这样读书不仅收获更大，而且也不会焦虑。</p>
<h5 id="确立人生目标"><a href="#确立人生目标" class="headerlink" title="确立人生目标"></a>确立人生目标</h5><ul>
<li><p>这个世界有很多事情可以做，你最想帮助哪些人？</p>
</li>
<li><p>什么事让你废寝忘食？</p>
</li>
<li><p>你在做什么事情的时候最让自己感动？</p>
</li>
<li><p>你最让人感动的时刻是什么？</p>
</li>
<li><p>如果没有任何经济压力，你会如何度过余生？</p>
</li>
<li><p>闲暇的时候，你关注最多的是哪方面的信息？</p>
<p><strong>我们需要用心去感受什么事情让自己最触动，而不是用脑去思考什么事情最有利</strong>。</p>
</li>
<li><p>设想你即将离开世界，回首一生会为什么事情而后悔？</p>
</li>
<li><p>想一想你最喜欢的人物是谁？</p>
</li>
<li><p>你年轻的时候是怎么度过闲暇时光的？</p>
<p>回答这3个问题同样需要我们动用感知力而不是思考力</p>
</li>
</ul>
<h5 id="捕捉感知"><a href="#捕捉感知" class="headerlink" title="捕捉感知"></a>捕捉感知</h5><ol>
<li><strong>“最”字法</strong>。关注那些最触动自己的点：让你眼前一亮、心中泛起波澜的人和事，脑中灵光乍现的想法，遭遇的痛苦，等等。学会捕捉它们，并深入分析挖掘，往往会有丰厚的收获。</li>
<li><strong>“总”字法</strong>。平时脑子里总是不自觉地跳出来的某些重复念头，或是心里总是挥之不去的事，这些通常都是我们心中最放不下的事，是情绪波动的源头。当我们有意识地去审视并消除它时，自己会变得更加平和。</li>
<li><strong>无意识的第一反应</strong>。关注自己第一次见到某个人、第一次走进某个房间、第一次做某件事时，心中出现的瞬间反应或第一个念头。</li>
<li><strong>梦境</strong>。梦境是潜意识传递信息的一种方式，它可能是内心真实想法的展示，也可能是灵感的启发。</li>
<li><strong>直觉</strong>。丘吉尔。</li>
</ol>
<h3 id="第三章-元认知—人类的终极能力"><a href="#第三章-元认知—人类的终极能力" class="headerlink" title="第三章 元认知—人类的终极能力"></a>第三章 元认知—人类的终极能力</h3><h4 id="第一节-元认知"><a href="#第一节-元认知" class="headerlink" title="第一节 元认知"></a>第一节 元认知</h4><p><img src="https://s2.loli.net/2022/02/05/vzZM9AcLdiUuKGy.png" alt="image-20220205131103870"></p>
<h5 id="反观，是元认知的起点。"><a href="#反观，是元认知的起点。" class="headerlink" title="反观，是元认知的起点。"></a>反观，是元认知的起点。</h5><p>你能意识到自己在想什么，进而意识到这些想法是否明智，再进一步纠正那些不明智的想法，最终做出更好的选择。</p>
<p>缺乏自我意识的人，只能无意识地顺着感觉和喜好行事，无论是生理上还是精神上，都会不自觉地追求眼前的舒适和简单，觉察不到自己当前的思维和行为有什么不妥，直到碰壁。</p>
<p>高级的元认知—时刻帮你从高处、深处、远处看待现在的自己，让自己保持清醒、不迷失，保持动力、不懈怠，保持平和、不冲动。</p>
<p><img src="https://s2.loli.net/2022/02/05/V9dTtGp3mFAosZu.png" alt="image-20220205132904267"></p>
<h5 id="如何获取"><a href="#如何获取" class="headerlink" title="如何获取"></a>如何获取</h5><p>第一，提升元认知能力的工具，需要从“过去”端获取，包括学习前人的智慧和反思自己的经历。</p>
<p>前人的智慧有很多，大多可以从书籍中获取。学习前人的智慧，可以让我们拥有更广的全局视角(高度)、掌握更深的底层规律(深度)，帮我们从无知中跳出来，做出更加正确的选择。</p>
<p>尤其值得关注的是，脑科学和认知科学。</p>
<p>第二，自身的经历更是一种独特的财富。我们每天的生活像河水一样流过，如不做停留则很难攫取生活中的智慧，而反思复盘可以让我们有机会思考有什么经验可以获得、有什么教训可以汲取。</p>
<p>第三，主动运用元认知。</p>
<p>我们总是，一开始就想找一根绳子，最后却牵出一头大象。这都是元认知能力不足的表现—顺着自己的本性做喜欢和舒服的事，精力发散，缺乏觉知，任何偶发的干扰都会分散注意力。</p>
<p>如果有个“灵魂伴侣”一直在监控你，你就能审视自己的行为，从过程中跳出来，告诉自己：“这个事情可做可不做，还是先忍一下，等做完重要的事情再说；停下来，先想清楚什么事情是最重要的，不能盲目地做那些容易但是不重要的事情。”</p>
<p>第四、冥想。冥想就是那种只要静坐在某处，然后放松身体，把注意力完全集中到呼吸和感受上的活动。如果过程中觉察到自己走神了，我们只需柔和地将注意力拉回来。</p>
<p>现在再联系之前提到的“灵魂伴侣”，不难发现这些活动本质上都在做同一件事：监控自己的注意力，然后将其集中到自己需要关注的地方。</p>
<p>反馈是这个世界的进化机制。有反馈，并形成回路，就可能使任何系统开始自我进化，无论机械设计还是软件系统都是如此。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>想拥有和掌握元认知能力并不容易，这需要不断地练习、练习、再练习。</p>
<p>很多时候，你发现自己做得并不好，没关系，重新再来。用不了多久，你就会发现，自己慢慢变得和以前不一样了。</p>
<h4 id="第二节-自控力：我们生而为人就是为了称为思维舵手"><a href="#第二节-自控力：我们生而为人就是为了称为思维舵手" class="headerlink" title="第二节 自控力：我们生而为人就是为了称为思维舵手"></a>第二节 自控力：我们生而为人就是为了称为思维舵手</h4><p>元认知能力就是觉察力和自控力的组合。</p>
<p>从实用角度而言，元认知能力可以被重新定义为：自我审视、主动控制、防止被潜意识左右的能力。</p>
<h5 id="成长就是为了主动控制"><a href="#成长就是为了主动控制" class="headerlink" title="成长就是为了主动控制"></a>成长就是为了主动控制</h5><p>教育的意义就是，教你在遇到一件事的时候如何看待它。当你对这件事进行反应的时候，总是有你自己的天性在里面，比如说有人骂你，你就想骂回去，<strong>但是你在这个反应当中会有一个哪怕是零点几秒的间隔去思考或者审视，这个间隔就是你获得的教育或者经历的意义。</strong></p>
<p>如果你希望自己能从娱乐中抽身，<strong>只需提前告诉自己：“这个视频结束后暂停几秒。”</strong>一旦理智脑拥有了审视和反思的时间，我们通常都能控制住自己。</p>
<p><strong>每当遇到需要选择的情况时，我们要是能先停留几秒思考一下，就有可能激活自己的理智脑，启用元认知来审视当前的思维，然后做出不一样的选择。</strong></p>
<h5 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h5><p>有的人能看到事物更多的意义，赋予目标强烈的价值，因此他们比其他人的专注力、执行力和意志力更强；</p>
<p>有的人能觉察他人的想法，克制自己的言行，从而显得情商更高。</p>
<p>他们真正的竞争力不在于学习能力，而在于强大的元认知能力。</p>
<h5 id="所以"><a href="#所以" class="headerlink" title="所以"></a>所以</h5><p>一定要在选择节点上多花“元时间”。</p>
<h5 id="成为自己人生的思维舵手"><a href="#成为自己人生的思维舵手" class="headerlink" title="成为自己人生的思维舵手"></a>成为自己人生的思维舵手</h5><p>所有面临选择的时间节点，都可以被称作“元时间”。</p>
<p>在元时间要做的只有一件事：想清楚。</p>
<p>应对策略：在选择节点审视自己的第一反应，并产生清晰明确的主张。</p>
<h5 id="一些例子-1"><a href="#一些例子-1" class="headerlink" title="一些例子"></a>一些例子</h5><p>脱口而出的话往往出自本能，如果我们能在那句话说出口前先停一两秒，用理智脑再审视一遍，或许马上就会改变主意、换一种说法，甚至选择保持沉默，毕竟有时候最好的回答就是不回答。</p>
<p>同样，早上醒来的那一瞬间、拿起手机的那一瞬间、回到家的那一瞬间……我们都要面临新的选择，要主动消耗脑力去审视它们。</p>
<p>要想清楚，不仅要有审视第一反应，同时还要有清晰明确的主张。</p>
<p>原能力强的一个突出表现是：对模糊零容忍。也就是，想尽一切办法，让自己找出那个最重要的、唯一的选项，让自己在某一个时间段里，只有一条路可走。</p>
<p>犹豫不决，什么都想做又什么都做不好，才是最大的损失。</p>
<p>自己行动力弱的时候，脑子里对未来的具体行动肯定是模糊不清的。在这个时候，最好的自救方法就是把所有想做的事情都列出来，进行排序，找出最重要的那件事，让脑子清醒。</p>
<p>焦虑的人很少有“元时间”的意识，他们习惯不动脑子、直接行动，喜欢用饱和的行动来感动自己，想与做的时间配比差距悬殊，他们甚至连一丁点儿深入思考的时间都不愿意花，任由本能欲望让自己迷失在自我满足的行动里。</p>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ul>
<li>针对当下的时间，保持觉知，审视第一反应，产生明确的主张；</li>
<li>针对全天的日程，保持清醒，时刻明确下一步要做的事情；</li>
<li>针对长远的目标，保持思考，想清楚长远意义和内在动机。</li>
</ul>
<p>元认知能力强的人就是这样：无论是当下的注意力、当天的日程安排，还是长期的人生目标，他们都力求想清楚意义、进行自我审视和主动控制，而不是随波逐流。</p>
<p>每一次克制自己，就意味着比以前更强大。</p>
<h2 id="下篇-外观世界，借力而行"><a href="#下篇-外观世界，借力而行" class="headerlink" title="下篇 外观世界，借力而行"></a>下篇 外观世界，借力而行</h2><h3 id="第四章-专注力：情绪和智慧的交叉地带"><a href="#第四章-专注力：情绪和智慧的交叉地带" class="headerlink" title="第四章 专注力：情绪和智慧的交叉地带"></a>第四章 专注力：情绪和智慧的交叉地带</h3>]]></content>
      <tags>
        <tag>一篇读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer_Network</title>
    <url>/2021/12/22/Computer-Network/</url>
    <content><![CDATA[<h1 id="Computer-Network"><a href="#Computer-Network" class="headerlink" title="Computer Network"></a>Computer Network</h1><h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h5 id="计算机网络涉及通信与计算机两个领域，它的发展过程是计算机与通信融合的过程。"><a href="#计算机网络涉及通信与计算机两个领域，它的发展过程是计算机与通信融合的过程。" class="headerlink" title="计算机网络涉及通信与计算机两个领域，它的发展过程是计算机与通信融合的过程。"></a>计算机网络涉及通信与计算机两个领域，它的发展过程是计算机与通信融合的过程。</h5><h3 id="大致总结"><a href="#大致总结" class="headerlink" title="大致总结"></a>大致总结</h3><h4 id="1-四个阶段"><a href="#1-四个阶段" class="headerlink" title="1.四个阶段"></a>1.四个阶段</h4><p>计算机网络的发展经历了四个阶段：</p>
<ol>
<li>第一阶段：<strong>面向终端</strong>的计算机网络(以单个计算机为中心的远程联机系统)，特点为连接。</li>
<li>第二阶段：<strong>互不兼容</strong>的计算机网络(多台计算机通过通信线路互联的计算机网络，完成了网络体系结构与协议的研究)(协议是计算机之间沟通的基本规则)(通过网关实现SNA和DNA之间的通信，适合异种网络规模较小的场合)</li>
<li>第三阶段：<strong>标准的开放的</strong>计算机网络(具有统一的网络体系结构，遵循国际通信标准化协议的计算机网络，提出了开放系统互联参考模型与协议)</li>
<li>第四阶段：Internet发展和普及阶段(计算机网络向互联、高速、智能化方向发展，获得广泛应用)</li>
</ol>
<blockquote>
<p>在计算网络的发展过程中，最具代表性的是20世纪70年代美国国防部高级研究计划局的<strong>ARPANET(ARPA网)</strong>，采用了<strong>“存储转发-分组交换”</strong>原理，标志着计算机网络的兴起。</p>
</blockquote>
<h4 id="2-定义"><a href="#2-定义" class="headerlink" title="2.定义"></a>2.定义</h4><p>国外经典：计算机网络是自主计算机的互联集合。(就这个吧)</p>
<p>谢希仁：一些相互连接的、自治的计算机集合。</p>
<p>书上：计算机网络是通过通信设施(通信网络)，将地理上分散的<strong>具有自治功能的多个计算机系统(主体)互连起来(形式)</strong>，进行信息交换，实现资源共享、互操作和协同工作的系统。</p>
<h4 id="3-模型"><a href="#3-模型" class="headerlink" title="3.模型"></a>3.模型</h4><p><strong>1984年，ISO正式颁布了一个称为“开放系统互联基本参考模型”的国际标准ISO7498，简称OSI/RM。该模型分为7个层次，有时也称OSI7层模型</strong>。<img src="https://s2.loli.net/2021/12/22/tsJdIEiZFnVfwu7.png" alt="image-20211222154318373"></p>
<ol>
<li><p>第一层：<strong>物理层</strong></p>
<ul>
<li>是整个OSI参考模型的最低层，提供物理连接。</li>
<li>其功能是在物理媒体上<strong>透明地传输原始比特流(进行二进制传输)</strong></li>
</ul>
</li>
<li><p>第二层：<strong>数据链路层</strong></p>
<ul>
<li>建立在物理传输能力的基础上，以<strong>帧为单位</strong>传输数据</li>
<li>主要功能包括：成帧、差错控制、流量控制和传输管理等。主要考虑相邻节点之间的数据交换</li>
</ul>
</li>
<li><p>第三层：<strong>网络层</strong></p>
<ul>
<li>通过网络连接交换运输层实体发出的数据，以<strong>分组</strong>为传送单位。</li>
<li>主要功能：选择合适的路由，使发送站的传输层传下来的分组能够正确无误地按照地址找到目的站，并交付目的站的运输层，以及实现拥塞控制、网络互连等功能。</li>
</ul>
</li>
<li><p>第四层：<strong>运输层(传输层)</strong></p>
<ul>
<li>在底层服务的基础上，提供一种通用的传输服务。</li>
<li>运输层向上一层提供一个可靠的端到端的服务，使会话层不知道运输层以下的数据通信的细节。运输层只存在于端系统(主机)种，运输层以上的层不再考虑信息传输的问题。</li>
<li>主要功能：传输地址到网络地址的映射、多路复用与分用、传输连接的建立与释放、分段与重新组装、组块与分块。</li>
</ul>
</li>
<li><p>第五层：<strong>会话层</strong></p>
<ul>
<li><p>不参与具体的数据传输，但管理数据，为相互合作的表示层进程之间提供一套会话设施。会话的意思是，两个应用进程之间为交换面向进程的信息而按一定规则建立起来的一个暂时联系</p>
</li>
<li><p>主要功能：会话连接到传输连接的映射、数据传送、会话连接的恢复和释放、会话管理、令牌管理和活动管理。</p>
</li>
</ul>
</li>
<li><p>第六层：<strong>表示层</strong></p>
<ul>
<li>表示层为异种计算机通信提供了一种公共语言，完成应用层数据所需的任何转换，以便能进行互操作。</li>
<li>主要功能：数据语法转换、语法表示、表示层连接管理、数据加密和数据压缩。</li>
</ul>
</li>
<li><p>第七层：<strong>应用层</strong></p>
<ul>
<li>应用层是OSI体系结构的最高层。这一层的协议直接为端用户服务，提供分布式处理环境。</li>
<li>应用层不仅要提供应用进程所需要的信息变换和远程操作，而且还要作为相互作用的应用进程的用户代理，来完成一些进行语义上有意义的信息的交换所必需的功能。</li>
</ul>
</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/22/EzOWNewC9PLvM18.png" alt="image-20211222165453663"></p>
<blockquote>
<p>下层是通信服务的提供者，上层是通信服务的使用者。</p>
<p>N-1层使用N-2层提供的服务以及本层的功能。</p>
</blockquote>
<p><strong>1977~1979年，ARPANET推出TCP/IP体系结构和协议(传输控制协议/网际协议为代表的协议栈)</strong>。</p>
<p><img src="https://s2.loli.net/2021/12/22/s1fY2Eqt8jU7p5x.png" alt="image-20211222170621802"></p>
<h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><h4 id="按地理位置分"><a href="#按地理位置分" class="headerlink" title="按地理位置分"></a>按地理位置分</h4><ul>
<li>广域网</li>
<li>城域网</li>
<li>局域网</li>
<li>个人区域网</li>
</ul>
<h4 id="按网络拓扑结构分"><a href="#按网络拓扑结构分" class="headerlink" title="按网络拓扑结构分"></a>按网络拓扑结构分</h4><ul>
<li>星型</li>
<li>环型</li>
<li>总线型</li>
</ul>
<h4 id="按传输介质分"><a href="#按传输介质分" class="headerlink" title="按传输介质分"></a>按传输介质分</h4><ul>
<li>有线网络</li>
<li>无线网络</li>
</ul>
<h4 id="按交换技术分"><a href="#按交换技术分" class="headerlink" title="按交换技术分"></a>按交换技术分</h4><ul>
<li><p>电路交换网络(适用于持续通信，不适于具有突发性的计算机网络)</p>
<ol>
<li><p>连接建立</p>
</li>
<li><p>数据传送</p>
</li>
<li><p>连接释放</p>
</li>
</ol>
</li>
<li><p>报文交换网络(存储-转发，处理时间长)</p>
</li>
<li><p>分组交换网络(报文较小，会增大目的地址量，降低效率)</p>
</li>
</ul>
<h3 id="制定网络协议的组织"><a href="#制定网络协议的组织" class="headerlink" title="制定网络协议的组织"></a>制定网络协议的组织</h3><p>记几个常见的名称</p>
<p><img src="https://s2.loli.net/2021/12/22/BX6n83tPNiIUGph.png" alt="image-20211222171450997"></p>
<h3 id="服务质量"><a href="#服务质量" class="headerlink" title="服务质量"></a>服务质量</h3><p><img src="https://s2.loli.net/2021/12/22/LE5Hq69c2ROuXJs.png" alt="image-20211222172217157"></p>
<h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><h2 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h2><p><strong>物理层位于OSI参考模型的最低层，直接面向实际承担数据传输的物理介质</strong>(即信道)。它的功能是激活、维持和释放数据链路层实体之间进行比特传输的物理连接(就是，<strong>传输比特流</strong>)。</p>
<h3 id="通信速率和信道容量"><a href="#通信速率和信道容量" class="headerlink" title="通信速率和信道容量"></a>通信速率和信道容量</h3><h4 id="传输速率"><a href="#传输速率" class="headerlink" title="传输速率"></a>传输速率</h4><p>数据传输速率是指每秒能传输的二进制信息位数，单位为“位/秒”，记作“b/s”。表示为：</p>
<script type="math/tex; mode=display">
S=\frac{1}{T} \times log_2M(b/s)</script><h4 id="信号传输速率（码元速率、调制速率、波特率"><a href="#信号传输速率（码元速率、调制速率、波特率" class="headerlink" title="信号传输速率（码元速率、调制速率、波特率)"></a>信号传输速率（码元速率、调制速率、波特率)</h4><p>一个数字脉冲也称为一个码元，M为一个码元所取的有效离散值个数，也成为调制电平数，M一般取2的整数次方值。若一个码元能取M种离散值，则该码元便能携带 $log_2 M$位二进制信息。</p>
<p>表示单位时间内通过信道传输的码元个数，也就是信号经调制后的传输速率(每秒信号变几次)，单位为baud(波特)。若信号码元的宽度为T(信号的持续时间s)，则码元速率定义为</p>
<script type="math/tex; mode=display">
B=\frac{1}{T} (baud)</script><p><strong>调制速率和数据传输速率</strong>的对应关系为：</p>
<script type="math/tex; mode=display">
S=B log_2 M(b/s)\quad或\quad B = \frac{S}{log_2 M} (baud)</script><h4 id="信道容量"><a href="#信道容量" class="headerlink" title="信道容量"></a>信道容量</h4><h5 id="奈奎斯特公式-重要！！！"><a href="#奈奎斯特公式-重要！！！" class="headerlink" title="奈奎斯特公式(重要！！！)"></a>奈奎斯特公式(重要！！！)</h5><script type="math/tex; mode=display">
码元速率的极限值和信道带宽的关系： \\B=2W\quad(baud)\\（W是信道带宽，也称为频率范围，即信道上下限频率的差值，单位是Hz）。
\\表示信道数据传输能力的奈奎斯特公式为：\\C=2W log_2 M\quad(b/s) \\M为携带数据的码元可能取的离散值个数，C为该信道最大的传输速率。</script><h5 id="香农公式-重要！！！"><a href="#香农公式-重要！！！" class="headerlink" title="香农公式(重要！！！)"></a>香农公式(重要！！！)</h5><script type="math/tex; mode=display">
计算信道容量的香农公式：\\C=W log_2(1+\frac{S}{N})\quad(b/s)
\\S为信号功率，N为噪声功率，S/N为信噪比。
\\由于实际使用的信道的信噪比都要足够大，故常表示成10lg(\frac{S}{N})，并以分贝为单位来计量。如30dB对应的是S/N的1000倍。\\(随机热噪声与温度有关，随温度升高，噪声增大)</script><p>误码率</p>
<script type="math/tex; mode=display">
P_e = \frac{N_e}{N}</script><p><img src="https://s2.loli.net/2021/12/27/6YMz8QbIyhuJvEw.png" alt="image-20211227180309974"></p>
<p><img src="https://s2.loli.net/2021/12/27/HKAYq5XcE1tiu2r.png" alt="image-20211227180332179"></p>
<p><img src="https://s2.loli.net/2021/12/27/PYhdymXRw92MsG3.png" alt="image-20211227180401257"></p>
<h3 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h3><h4 id="特殊的方式"><a href="#特殊的方式" class="headerlink" title="特殊的方式"></a>特殊的方式</h4><p>烽火、空气、公路</p>
<h4 id="有线的方式"><a href="#有线的方式" class="headerlink" title="有线的方式"></a>有线的方式</h4><h5 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h5><ul>
<li>屏蔽（周围干扰较大/信号较弱的场所）</li>
<li>非屏蔽（通常是100米左右，在楼层之内）</li>
</ul>
<h5 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h5><ul>
<li>细缆（10Mb/s，185米，层间）</li>
<li>粗缆（10Mb/s，500米，楼间）</li>
</ul>
<h5 id="光缆"><a href="#光缆" class="headerlink" title="光缆"></a>光缆</h5><ul>
<li>多模（550米/1000M/模块成本低）</li>
<li>单模（1000米/1000M/模块成本高）</li>
</ul>
<h4 id="无线的方式"><a href="#无线的方式" class="headerlink" title="无线的方式"></a>无线的方式</h4><ul>
<li>无线局域网（2.4GHz/5GHz）</li>
<li>微波天线与卫星通信</li>
<li>红外线通信</li>
<li>激光通信（OPALS）</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>布设的便利性/通信的抗干扰能力</p>
<h3 id="编码与识别"><a href="#编码与识别" class="headerlink" title="编码与识别"></a>编码与识别</h3><h4 id="基本调制技术"><a href="#基本调制技术" class="headerlink" title="基本调制技术"></a>基本调制技术</h4><p>数字数据调制技术在发送端将数字信号转换成模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。（数字信号加载到载波信号）</p>
<h5 id="调制方法-最基本的二元调制"><a href="#调制方法-最基本的二元调制" class="headerlink" title="调制方法(最基本的二元调制)"></a>调制方法(最基本的二元调制)</h5><ol>
<li>振幅调制</li>
<li>频率调制</li>
<li>相位调制</li>
<li>多进制调制</li>
</ol>
<p><strong>PCM基于奈奎斯特采样定理：如果在规定的时间间隔内，以有效信号f(t)最高频率的2倍或2倍以上的速率对该信号进行采样，则这些采样值包含了无混叠而又便于分离的全部原始信息。</strong></p>
<h4 id="不归零编码"><a href="#不归零编码" class="headerlink" title="不归零编码"></a>不归零编码</h4><h4 id="曼彻斯特码"><a href="#曼彻斯特码" class="headerlink" title="曼彻斯特码"></a>曼彻斯特码</h4><h5 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h5><p>一种双相码</p>
<p><strong>用高电平到低电平的转换边表示1，用低电平到高电平的转换边表示0。(高到低为1；低到高为0)</strong></p>
<h4 id="差分曼彻斯特码"><a href="#差分曼彻斯特码" class="headerlink" title="差分曼彻斯特码"></a>差分曼彻斯特码</h4><h5 id="编码格式-1"><a href="#编码格式-1" class="headerlink" title="编码格式"></a>编码格式</h5><p>一种双相码</p>
<p>数据表示为在每一位开始处是否有电平转换：<strong>有电平转换表示0，无电平转换表示1，在信号中间强制转换(翻转)。(1不变，0变化，中间强制变化(以避免出现连续的高电平、低电平))</strong></p>
<p><img src="https://s2.loli.net/2021/12/27/sNz9wp76Ourfqng.png" alt="image-20211227173107104"></p>
<p>差分曼彻斯特编码比曼彻斯特编码的变化要小，因此更适合于传输高速的信息。</p>
<h4 id="其他编码"><a href="#其他编码" class="headerlink" title="其他编码"></a>其他编码</h4><ul>
<li><p>百兆双绞线的4B/5B</p>
</li>
<li><p>光纤的8B/10B</p>
</li>
</ul>
<h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>为了有效地利用数据传输系统，人们希望通过同时携带多个信号来高效率地使用传输介质，这成为多路复用。多路复用连接器连接许多低速线路，并将它们各自所需的传输容量组合在一起后，在一条速度较高的线路上传输。</p>
<h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><ul>
<li><p>频分多路复用</p>
</li>
<li><p>时分多路复用</p>
</li>
<li><p>波分多路复用</p>
</li>
<li><p>码分多路复用</p>
</li>
</ul>
<h2 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h2><h5 id="相邻主机-广播域内主机-之间的通信"><a href="#相邻主机-广播域内主机-之间的通信" class="headerlink" title="相邻主机(广播域内主机)之间的通信"></a>相邻主机(广播域内主机)之间的通信</h5><h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><h4 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h4><ul>
<li><p>水平/垂直效验码：检错码</p>
</li>
<li><p>水平垂直校验码：纠错码</p>
</li>
</ul>
<h4 id="循环冗余码-CRC必考"><a href="#循环冗余码-CRC必考" class="headerlink" title="循环冗余码(CRC必考)"></a>循环冗余码(CRC必考)</h4><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>任何一个由二进制数位串组成的代码，都可以唯一地与一个只含有0和1两个系数的多项式建立一一对应的关系。例如，代码1010111对应的多项式是 $X^6 + X^4+ X^2+X^1+1$。</p>
<p>在发送方编码和接收方校验时，都可以利用事先约定的多项式$G(X)$来得到CRC码，k位待发送信息位对应于一个k-1次多项式$K(X)$，r位冗余位对应于一个r-1次多项式R(X)，由k位信息位后面加上r次冗余位组成的$n=k+r$位码字则对应于一个$n-1$次多项式$T(X)=X^rK(X)+R(X)$。</p>
<p>仍以$K(X)=X^6+X^4+X^3+1(信息位为1011001)(待发送信息)$为例，若$G(X)=X^4+X^3+1(事先约定)(11001)$，则$r=4$，$X^4K(X)=X^{10}+X^8+X^7+X^4(10110010000)$.由模2除法求余式$R(X)$的过程如图所示。</p>
<p><img src="https://s2.loli.net/2022/01/10/Co9XIdpf1bv58Mq.png" alt="image-20220110151925039"></p>
<p>最后得到的余数是1010，就是冗余位，对应于$R(X)=X^3+X$。由于$R(X)$是$X^rK(X)$除以$G(X)$的余式，那么必然满足：</p>
<script type="math/tex; mode=display">
X^rK(X)=G(X)Q(X)+R(X)</script><p>式中，$Q(X)$为商式，根据模2运算法则，$R(X)+R(X)=0$，所以可将上式改记为</p>
<script type="math/tex; mode=display">
\frac{X^rK(X)+R(X)}{G(X)}=Q(X)</script><p>即，$\frac{T(X)}{G(X)}=Q(X)$</p>
<p><strong>由此可见，信道上发送的码字多项式$T(X)=X^rK(X)+R(X)$，若传输过程无错，则接收方接收到的码字也对应于此多项式，也就是说接收到的码字多项式能被$G(X)$整除。因此，接收方的校验过程就是将接收到的码字多项式除以$G(X)$的过程，若余式为0，则认为传输无差错，若余式不为0，则传输有差错。</strong></p>
<p><img src="https://s2.loli.net/2022/01/10/jLYbRSkWFs79EzH.png" alt="image-20220110162900726"></p>
<p><img src="https://s2.loli.net/2022/01/10/4YrCuwzTZGfWOAj.png" alt="image-20220110162950640"></p>
<p><img src="https://s2.loli.net/2022/01/10/wm59PKXcYJgb1I4.png" alt="image-20220110165636498"></p>
<h3 id="0比特填充技术"><a href="#0比特填充技术" class="headerlink" title="0比特填充技术"></a>0比特填充技术</h3><h4 id="标志字段-F"><a href="#标志字段-F" class="headerlink" title="标志字段 F"></a>标志字段 F</h4><p>物理层向数据链路层交付的是所收到的一连串的位流，在一个帧的开头和结尾各放入一个字节的特殊标记“01111110”作为一个帧的边界，这个标记称为标志字段F(Flag)，共8位。</p>
<p>在接收方，只要找到两个标志字段，那么在这两个标志字段之间的位流就是一个帧的信息。</p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>如果在两个标志字段之间的位流中，出现与标志字段F相同的比特模式时，就会被误认为是帧的边界，从而破坏帧的同步。</p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>为避免这种情况，采用<strong>0比特填充技术</strong>，即发送方在比特流中一旦发现5个连续的1，就在其后填入一个0，从而保证在传输的比特流中不会出现F标志。</p>
<blockquote>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>在接收一个帧时，在F字段确定的帧的边界之间，若比特流有5个连续1，则将这5个连续1后的一个0删除，将比特流还原。这样，不管出现什么样的比特组合，都不会引起对帧边界的错误判断。</p>
<p><strong>具有这种特点的传输称为透明传输。</strong></p>
</blockquote>
<h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><h4 id="差错控制与流量控制"><a href="#差错控制与流量控制" class="headerlink" title="差错控制与流量控制"></a>差错控制与流量控制</h4><p>对数据传输进行差错控制和流量控制是数据链路层的关键功能。</p>
<p>目前，进行差错控制和流量控制的基本策略是<strong>反馈机制</strong>，即发送方通过接收方反馈回来的能否继续接受或是否正确收到帧等信息来进行下一步的操作。</p>
<p>差错控制的基本思想是：差错检测、接受确认和出错重传。</p>
<p>流量控制的基本思想是：是接收方能够控制发送方发送帧的速率。</p>
]]></content>
      <tags>
        <tag>复习计算机网络啦！</tag>
      </tags>
  </entry>
  <entry>
    <title>DataBase</title>
    <url>/2021/12/22/DataBase/</url>
    <content><![CDATA[<h1 id="DataBase"><a href="#DataBase" class="headerlink" title="DataBase"></a>DataBase</h1><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="1-1-数据库系统概论"><a href="#1-1-数据库系统概论" class="headerlink" title="1.1 数据库系统概论"></a>1.1 数据库系统概论</h3><h4 id="4个基本概念"><a href="#4个基本概念" class="headerlink" title="4个基本概念"></a>4个基本概念</h4><ol>
<li><h5 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h5></li>
</ol>
<p>是数据库中存储的基本对象。</p>
<p><strong>描述事物的符号记录称为数据</strong>。</p>
<p>数据的含义称为数据的语义，数据与其语义是不可分的。</p>
<ol>
<li><h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h5><p>数据库是<strong>长期储存</strong>在计算机内、<strong>有组织的</strong>、<strong>可共享的</strong>大量数据的集合。</p>
<p>数据库的基本特征：</p>
<ul>
<li>数据按一定的数据规模组织、描述和储存</li>
<li>可为各种用户共享</li>
<li>冗余度较小</li>
<li>数据独立性较高</li>
<li>易拓展</li>
</ul>
</li>
<li><h5 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h5><ul>
<li><p>位于用户与操作系统之间的一层数据管理软件</p>
</li>
<li><p>是基础软件，是一个大型复杂的软件系统</p>
</li>
<li>可以科学地组织和存储数据、高效地获取和维护数据</li>
</ul>
</li>
<li><h5 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h5><p>由数据库、数据库管理系统、应用程序、数据库管理员四部分构成。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库...</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2021/11/12/Git/</url>
    <content><![CDATA[<h1 id="The-introduction-of-Git"><a href="#The-introduction-of-Git" class="headerlink" title="The introduction of Git"></a>The introduction of Git</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>要把文档还原到<strong>编辑前</strong>的状态，就需要提前备份且做好命名工作，否则就会乱了套。但每次都要事先复制，而且命名也无法体现修改内容，容易出错。</p>
<p>若是共享文档，还应该加上编辑者的名字。而且，若是多个人同时编辑，后来者会覆盖掉前一个人的编辑内容。</p>
<h2 id="Advantage"><a href="#Advantage" class="headerlink" title="Advantage"></a>Advantage</h2><p>使用Git进行分布式版本管理，可以解决以上问题。</p>
<p>Git可以在任何时间点，把文档的状态作为更新记录保存起来。因此可以把编辑过的文档复原到以前的状态，也可以显示编辑前后的内容差差异。</p>
<p>而且，编辑旧文件后，试图覆盖新的文件的时候（即上传文件到服务器时），系统会发出警告，因此可以避免在无意中覆盖他人的编辑内容。</p>
<h2 id="Premise"><a href="#Premise" class="headerlink" title="Premise"></a>Premise</h2><h3 id="数据库-Repository"><a href="#数据库-Repository" class="headerlink" title="数据库(Repository)"></a>数据库(Repository)</h3><p>数据库是记录文件或目录状态的地方，存储着内容修改的历史记录。在数据库的管理下，把文件和目录修改的历史记录放在对应的目录下。</p>
<p>分为<strong>远程数据库</strong>和<strong>本地数据库</strong>两种：</p>
<p>本地数据库：为了方便用户个人使用，在自己的机器上配置的数据库。</p>
<p>远程数据库：配有给专用的服务器，为了多人共享而建立的数据库。</p>
<h3 id="Submit"><a href="#Submit" class="headerlink" title="Submit"></a>Submit</h3><p>若要把文件或目录的添加和变更保存到数据库，就需要进行提交。</p>
<p>执行提交后，数据库中会生成上次提交的状态与当前状态的差异记录（也叫revision)。</p>
<p>提交是以时间顺序排列状态被保存到数据库中的。凭借该提交和最新的文件状态，就可以知道过去的修改记录以及内容。</p>
<p>不同类型的修改（如bug的修复和功能的添加)要尽量分开提交，方便以后从历史记录中查找特定的修改内容。用心填写提交时的修改信息，方便别人和自己理解。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Git的标准注解</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一行：提交修改内容的摘要</td>
</tr>
<tr>
<td>第二行：空行</td>
</tr>
<tr>
<td>第三行：修改的理由</td>
</tr>
</tbody>
</table>
</div>
<h3 id="工作树和索引"><a href="#工作树和索引" class="headerlink" title="工作树和索引"></a>工作树和索引</h3><p>在Git管理下，大家实际操作的目录被称为工作树。</p>
<p>在数据库和工作树之间有索引，索引是为了向数据库提交做准备的区域。</p>
<p><strong>工具树</strong> ——- <em>注册</em> ——- <strong>索引</strong> ——-<em>提交</em> ——- <strong>数据库</strong></p>
<p>没有加入索引的档案不能被提交。</p>
<p>Git在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库。因此，要提交文件，首先需要被文件加入索引区域中。这样，可以避免不必要的提交，还可以将文件修改内容的一部分加入索引区域提交。</p>
<h3 id="共享数据库"><a href="#共享数据库" class="headerlink" title="共享数据库"></a>共享数据库</h3><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>为了将本地数据库的修改记录共享到远程数据库，必须上传本地数据库中存储的修改记录。</p>
<p>为此，需要在Git执行推送(Push)操作。</p>
<p>执行Push后，本地的修改记录会被上传到远程数据库。所以远程数据库的修改记录就会和本地的数据库修改记录保持同步。</p>
<h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><p>进行克隆(Clone)操作就可以复制远程数据库。</p>
<p>执行克隆后，远程数据库的全部内容都会被下载，包括本地数据库的变更履历。之后就可以像原始数据库一样进行查看记录或其它操作。</p>
<h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><p>若是共享的远程数据库由多人共同作业，那么作业完毕后，所有人都要把修改推送到远程数据库。然后，自己的本地数据库也需要更新其他人推送的变更内容。</p>
<p>进行拉取(pull)操作就可以把远程数据库的内容更新到本地数据库。</p>
<p>进行拉取(pull)操作，就是从远程数据库下载最近的变更日志，并覆盖自己本地数据库的相关内容。相当于是下载。</p>
<h3 id="共享数据库常用操作"><a href="#共享数据库常用操作" class="headerlink" title="共享数据库常用操作"></a>共享数据库常用操作</h3><h4 id="取别名"><a href="#取别名" class="headerlink" title="取别名"></a>取别名</h4><p>$ git remote add <name> <url></p>
<p>如：$ git remote add origin <a href="https://github.com/Phoenix-Nrvn/Ming.git">https://github.com/Phoenix-Nrvn/Ming.git</a></p>
<h4 id="push修改内容"><a href="#push修改内容" class="headerlink" title="push修改内容"></a>push修改内容</h4><p>$ git push <repository> <refspec>…</p>
<p>如：$ git push -u origin master</p>
<p>可以向远程数据库”origin”进行推送。当执行命令时，如果指定了-u选项，那么下一次推送时，就可以省略分支名称。但是，首次运行指令，向空的远程数据库推送时，必须指定远程数据库名称和分支名称。</p>
<h4 id="克隆-1"><a href="#克隆-1" class="headerlink" title="克隆"></a>克隆</h4><p>$ git clone <repository> <directory></p>
<p>将仓库复制到本地指定的文件夹</p>
<h4 id="提交更改"><a href="#提交更改" class="headerlink" title="提交更改"></a>提交更改</h4><p>$ git add sample.txt(更改信息后，重新提交sample)</p>
<p>$ git commit -m “添加add的说明”</p>
<p>$ git push</p>
<h4 id="拉取-1"><a href="#拉取-1" class="headerlink" title="拉取"></a>拉取</h4><p>$ git pull <repository> <refspec>…</p>
<p>$ git pull origin(仓库名) master(分支名)</p>
<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p>$ git log</p>
<h4 id="合并记录"><a href="#合并记录" class="headerlink" title="合并记录"></a>合并记录</h4><p>进行一次pull之后，在进行下一次push之前，如果有其他人对远程数据库进行了更改，那么在对其进行pull之前，所有的push都会被拒绝，即防止他人的push被覆盖。</p>
<p>在这种情况下，需要读取他人push的变更并进行合并操作。一般而言，合并时，Git会自动合并已有的变更点。</p>
<p>若更改的是同一个地方，那么git无法确定选用的内容，即需要手动修改以进行手动合并。</p>
]]></content>
      <tags>
        <tag>It&#39;s time to begin git!</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Learing 2</title>
    <url>/2021/05/31/Java-Learing-2/</url>
    <content><![CDATA[<blockquote>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="一、关于Java中的数据类型"><a href="#一、关于Java中的数据类型" class="headerlink" title="一、关于Java中的数据类型:"></a>一、关于Java中的数据类型:</h2><h4 id="1-简单数据类型，即基本数据类型，有固定的存储长度"><a href="#1-简单数据类型，即基本数据类型，有固定的存储长度" class="headerlink" title="1.简单数据类型，即基本数据类型，有固定的存储长度"></a>1.简单数据类型，即基本数据类型，有固定的存储长度</h4><h6 id="包括整数类型，浮点类型，字符类型，布尔类型"><a href="#包括整数类型，浮点类型，字符类型，布尔类型" class="headerlink" title="包括整数类型，浮点类型，字符类型，布尔类型"></a>包括整数类型，浮点类型，字符类型，布尔类型</h6><h4 id="2-复杂数据类型，又名引用类型"><a href="#2-复杂数据类型，又名引用类型" class="headerlink" title="2.复杂数据类型，又名引用类型"></a>2.复杂数据类型，又名引用类型</h4><h6 id="包括数组，类，接口-interface-，其存储空间取决于组成内容-由几个基本数据类型，或几个复合数据类型组成"><a href="#包括数组，类，接口-interface-，其存储空间取决于组成内容-由几个基本数据类型，或几个复合数据类型组成" class="headerlink" title="包括数组，类，接口(interface)，其存储空间取决于组成内容(由几个基本数据类型，或几个复合数据类型组成)"></a>包括数组，类，接口(interface)，其存储空间取决于组成内容(由几个基本数据类型，或几个复合数据类型组成)</h6><hr>
<h2 id="二、数据类型之间的转换"><a href="#二、数据类型之间的转换" class="headerlink" title="二、数据类型之间的转换"></a>二、数据类型之间的转换</h2><h5 id="byte-1-→short-2-→char-2-→int-4-→long-8-→float-4-→double-8"><a href="#byte-1-→short-2-→char-2-→int-4-→long-8-→float-4-→double-8" class="headerlink" title="byte(1)→short(2)→char(2)→int(4)→long(8)→float(4)→double(8)"></a>byte(1)→short(2)→char(2)→int(4)→long(8)→float(4)→double(8)</h5><p><strong><em>特别注意，布尔类型(boolean)(只包括true,false)不与其他类型进行转换</em></strong></p>
<p><strong>在Java中，所有数据类型所占字节数量与平台无关。</strong></p>
<p><strong>此外，Java没有任何无符号的(unsigned)形式的int, long, short或byte类型。</strong></p>
</blockquote>
<hr>
<hr>
<blockquote>
<h1 id="amp-amp-输入输出"><a href="#amp-amp-输入输出" class="headerlink" title="&amp;&amp;输入输出"></a>&amp;&amp;输入输出</h1><h2 id="一、标准输入流输入数据"><a href="#一、标准输入流输入数据" class="headerlink" title="一、标准输入流输入数据:"></a>一、标准输入流输入数据:</h2><p>  <code>byte System.in.read()</code>(即所获取数据为字节类型)</p>
<p>字符串输入:</p>
</blockquote>
<p><code>BufferedReader in = new BufferedReader(new InputStreamReader(System.in))(经过对System.in的层层修饰)</code></p>
<p><code>String s = in.readLine();</code></p>
<blockquote>
<p>  常用:</p>
<p><code>Scanner  sc = new Scanner(System.in);</code></p>
</blockquote>
<p><code>String sr = sc.nextLine();</code></p>
<p><code>int a = sc.nextInt();</code></p>
<p><code>String s = sc.next();</code></p>
<blockquote>
<p>  <code>swing对话框:</code></p>
</blockquote>
<p><code>String s = JOptionPane.showInputDialog(Message)</code></p>
<p><code>int i = Integer.parseInt(s);</code></p>
<blockquote>
<h2 id="二、输出数据"><a href="#二、输出数据" class="headerlink" title="二、输出数据:"></a>二、输出数据:</h2></blockquote>
<ul>
<li><p><code>System.out.println(x);//输出后带换行</code></p>
</li>
<li><p><code>System.out.print(x);//输出后无换行</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（以上两者可用String.format(&quot;%.2f&quot;,x)替换x，以控制x输出格式）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>System.out.printf()(可加输出格式控制，类似C语言中printf)</code></li>
</ul>
]]></content>
      <tags>
        <tag>数据类型与输入输出</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2021/12/17/JDBC/</url>
    <content><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JDBC(Java DataBase Connectivity)是Java程序操作数据库的API，<strong>是Java操作数据库的规范</strong>，由一组<strong>Java语言编写的类和接口组成</strong>，它对数据库的操作提供基本方法，但对于数据库的细节操作由数据库厂商实现，使用JDBC操作数据库，<strong>需要数据库厂商提供数据库的驱动程序</strong>。</p>
<p><img src="https://s2.loli.net/2021/12/22/PaYeSMCIfRs6H3o.png" alt="image-20211217224940532"></p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li><h3 id="注册数据库驱动"><a href="#注册数据库驱动" class="headerlink" title="注册数据库驱动"></a>注册数据库驱动</h3><p>将数据库厂商提供的数据库驱动类注册到JDBC的驱动管理器中。</p>
<p><strong><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></strong></p>
<p><strong>Class的forName( )方法的作用是将指定字符串名的类加载到JVM中，实例中调用该方法来加载数据库驱动，在加载后，数据库驱动程序会把驱动类自动注册到驱动管理器中。</strong></p>
</li>
<li><h3 id="构建数据库连接URL"><a href="#构建数据库连接URL" class="headerlink" title="构建数据库连接URL"></a>构建数据库连接URL</h3><p>基本格式，即”JDBC协议+IP地址或域名+端口+数据库名称”。</p>
<p><strong><code>MySQL: &quot;jdbc:mysql://localhost:3306/db_database10&quot;;</code></strong></p>
<p><code>SQL Server: &quot;jdbc:sqlserver://localhost:1433;databaseName=db_database10&quot;;</code></p>
</li>
<li><h3 id="获取Connection对象"><a href="#获取Connection对象" class="headerlink" title="获取Connection对象"></a>获取Connection对象</h3><p>Connection对象是JDBC封装的数据库连接对象，语法：</p>
<p><strong><code>DriverManager.getConnection(url, username, password);</code></strong></p>
<p>Connection对象的获取需要用到DriverManager对象，DriverManager的getConnection( )</p>
</li>
</ol>
<p>方法通过数据库连接URL、数据库用户名及数据库密码创建Connection对象。</p>
<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line">   <span class="type">String</span> <span class="variable">Driver</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>; </span><br><span class="line">   Class.forName(Driver);<span class="comment">//加载数据库驱动，注册到驱动管理器</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db_database10&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;654321&quot;</span>;</span><br><span class="line">   <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(URL, userName, password);<span class="comment">//创建数据库连接</span></span><br><span class="line">   <span class="keyword">if</span>(conn != <span class="literal">null</span>) &#123;<span class="comment">//判断数据库连接是否为空</span></span><br><span class="line">   out.println(<span class="string">&quot;数据库连接成功!&quot;</span>);</span><br><span class="line">   conn.close()</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   out.println(<span class="string">&quot;数据库连接失败! &quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(ClassNotFoundException cn) &#123;</span><br><span class="line">  cn.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span>(SQLException se) &#123;</span><br><span class="line">se.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="Connection-接口"><a href="#Connection-接口" class="headerlink" title="Connection 接口"></a>Connection 接口</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Connection接口位于java.sql包中，是与特定数据库的连接会话，只有获得特定数据库的连接对象，才能访问数据库、v奥做数据库中的数据表、视图和存储过程等。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="void-close-throws-SQLException"><a href="#void-close-throws-SQLException" class="headerlink" title="void close( ) throws SQLException"></a>void close( ) throws SQLException</h5><p>立即释放此Connection对象的数据库连接占用的JDBC资源。在操作数据库后，应立即调用此方法。</p>
<h5 id="Statement-createStatement-throws-SQLException"><a href="#Statement-createStatement-throws-SQLException" class="headerlink" title="Statement createStatement( ) throws SQLException"></a>Statement createStatement( ) throws SQLException</h5><p>创建一个Statement对象来将SQL语句发送到数据库，此方法返回Statement对象。</p>
<h3 id="DriverManager-类"><a href="#DriverManager-类" class="headerlink" title="DriverManager 类"></a>DriverManager 类</h3><p>使用JDBC操作数据库，需要使用数据库厂商提供的驱动。该类主要作用于用户和驱动程序之间，管理数据库厂商提供的驱动程序，并建立应用程序与数据库之间的连接。<strong>此类的getConnection(String url, String user, String password) throws SQLException根据指定的数据库连接url等，建立数据库连接的Connection对象。</strong></p>
<h3 id="Statement接口"><a href="#Statement接口" class="headerlink" title="Statement接口"></a>Statement接口</h3><p>在创建了数据库连接之后，就可以通过程序来调用SQL语句对数据库进行操作，<strong>而该接口就提供了执行语句和获取查询结果的基本方法</strong>。</p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>boolean execute(String sql) throws SQLException执行指定的SQL语句，如果SQL语句返回结果，此方法返回true，否则返回false。</li>
<li>int executeQuery(String sql) throws SQLException执行SQL语句中的DML类型(insert\update\delete)的SQL语句，返回影响的行数。</li>
<li>ResultSet executeQuery(String sql) throws SQLException执行查询类型的SQL语句，返回查询所获取的结果集ResultSet对象。</li>
</ul>
<h3 id="PreparedStatement接口"><a href="#PreparedStatement接口" class="headerlink" title="PreparedStatement接口"></a>PreparedStatement接口</h3><p>继承于Statement接口，拥有Statement接口中的方法，而且针对带有参数的SQL语句的执行操作进行了拓展。</p>
<h4 id="与上区别"><a href="#与上区别" class="headerlink" title="与上区别"></a>与上区别</h4><ul>
<li><p><strong>应用于PreparedStatement接口中的SQL语句，可以使用占位符”?”来代替SQL语句中的参数，然后再对其进行赋值。</strong></p>
</li>
<li><p>会先初始化SQL，先把这个SQL提交到数据库进行预处理，多次使用可提高效率；createStatement不会初始化，没有预处理，每次都是从0开始执行SQL。</p>
</li>
<li>PreparedStatement是预编译的，对于批量处理可以大大提高效率，也叫JDBC存储过程。当在对数据库进行一次性存取的时候，用createStatement对象进行。</li>
</ul>
<h3 id="ResultSet接口"><a href="#ResultSet接口" class="headerlink" title="ResultSet接口"></a>ResultSet接口</h3><p>在JDBC中使用Resultset对象来接收查询结果集。<strong>ResultSet包含了符合SQL语句的所有行</strong>。zhenduiJava中的数据类型，提供了Getxxx的方法，可以获得每一行的数据。</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul>
<li><p><strong>==其中数据其实放在ResultSet结果集的中间部分，第一行和最后一行都是空的。==</strong></p>
</li>
<li><p><strong>默认情况下，ResultSet的光标位置在第一行数据之前，故在第一次获取数据时就需要移动光标位置。</strong></p>
</li>
</ul>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p><strong>INSERT语句</strong>，语句中的参数可以使用占位符“？”代替，然后通过PreparedStatement对其赋值并执行SQL</p>
<p><code>String sql=&quot;INSERT INTO tb_account(username, password) VALUES (?,?)&quot;;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Config config)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into category values(null,?,?)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DBUtil.getConnection();</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> c.prepareStatement(sql);</span><br><span class="line">            ps.setString(<span class="number">1</span>, config.key);</span><br><span class="line">            ps.setString(<span class="number">2</span>, config.value);</span><br><span class="line">            ps.execute();</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.getGeneratedKeys();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line">                config.id = id;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DBUtil.getConnection();</span><br><span class="line">            <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from category where id = &quot;</span> + id ;</span><br><span class="line">            s.execute(sql);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><em>在AddBook.jsp页面中，首先通过&lt; jsp:useBean &gt;实例化JavaBean对象Book，并通过&lt; jsp:setProperty &gt;对Book对象中的属性赋值，在构建了图书对象后通过JDBC技术，将其写入数据库。</em></p>
<p><strong>&lt; jsp:setProperty &gt;标签的property属性的值可以设置为”<em>“，它的作用是将与表单中同名称的属性值赋给JavaBean对象中的同名属性(\</em>为快速赋值)。</strong></p>
<p><strong>使用PreparedStatement对象给SQL语句的占位符参数赋值，==其参数的下标值不是0，而是1==，与数组的下标有所区别。</strong></p>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p><strong>SELECT语句</strong>，使用JDBC查询数据需要通过一个ResultSet对象来装载查询结果集，从数据表中所查询到的数据都放置在这个集合中。</p>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p><strong>Update语句</strong></p>
<h3 id="删除语句"><a href="#删除语句" class="headerlink" title="删除语句"></a>删除语句</h3><p><strong>DELETE语句</strong></p>
<h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>为了解决数据库频繁连接、关闭操作的问题，JDBC的批处理提供很好的解决方案，批量将SQL语句一次性发送到数据库中进行执行。</p>
<p>代码待补充……</p>
]]></content>
      <tags>
        <tag>Somthing of JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_Ending</title>
    <url>/2021/12/26/Java-Ending/</url>
    <content><![CDATA[<h1 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h1><p><img src="https://s2.loli.net/2021/12/26/AcuBF8l3NnZyqLT.png" alt="image-20211226201329697"></p>
<h2 id="部署的三种选择："><a href="#部署的三种选择：" class="headerlink" title="部署的三种选择："></a>部署的三种选择：</h2><h3 id="本机"><a href="#本机" class="headerlink" title="本机"></a>本机</h3><p>整个程序都在用户的计算机上以独立、可携的GUI执行，并以可执行的Jar来部署。</p>
<h4 id="把程序包进JAR"><a href="#把程序包进JAR" class="headerlink" title="把程序包进JAR"></a>把程序包进JAR</h4><p>JAR就是Java ARchive。这种文件是个pkzip格式的文件，能把一组类文件包装起来，所以交付时只需要一个用jar整理的JAR文件。</p>
<p>问题是用户拿JAR怎么办？</p>
<p>要创建出可执行的JAR！</p>
<p><strong>可执行的JAR代表用户不需要把文件抽出来就能运行。程序可以在类文件保存在JAR的情况下执行。秘诀在于创建出manifest文件，它会带有JAR的信息，告诉Java虚拟机那个类中含有main( )这个方法。</strong></p>
<p><img src="https://s2.loli.net/2021/12/26/k2BsEUqT91JSjAF.png" alt="image-20211226202235036"></p>
<p><img src="https://s2.loli.net/2021/12/26/sGPyLlScK4pIjZU.png" alt="image-20211226202446339"></p>
<p><img src="https://s2.loli.net/2021/12/26/iuhzUtRKg6Wwl32.png" alt="image-20211226202747131"></p>
<h4 id="防止包命名冲突"><a href="#防止包命名冲突" class="headerlink" title="防止包命名冲突"></a>防止包命名冲突</h4><p>Sun建议的命名规则能够大幅降低冲突的可能性——加上你所取得的域名称。即反向使用domain</p>
<p><img src="https://s2.loli.net/2021/12/26/Evz9lf7GkeOdiPZ.png" alt="image-20211226203047748"></p>
<p><img src="https://s2.loli.net/2021/12/26/LbZEgFcA3N1yj9D.png" alt="image-20211226203530158"></p>
<p><img src="https://s2.loli.net/2021/12/26/oxzSFOIr5aswMJ1.png" alt="image-20211226203551529"></p>
<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><p><img src="https://s2.loli.net/2021/12/26/VGsw5lEaxBMZOeK.png" alt="image-20211226203617583"></p>
<h3 id="两者的组合"><a href="#两者的组合" class="headerlink" title="两者的组合"></a>两者的组合</h3><p>应用程序被分散成用户本地系统运行的客户端，连接到执行应用程序服务的服务器部分。</p>
<h3 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h3><p>整个应用程序都在服务器端执行，客户端通过非Java形式，可能是浏览器的装置来存取。 </p>
]]></content>
      <tags>
        <tag>Here comes the end of Head First of Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Learning</title>
    <url>/2021/05/29/Java-Learing/</url>
    <content><![CDATA[<p>It’s time to begin the learning of Java!</p>
<blockquote>
<p>​    关于Java的命令行编译运行方式：</p>
<p>​        1.利用记事本/Notepad++建立一个文件，之后重命名为.java文件，<strong><em>Win + R</em></strong>，输入cmd，打开命令行窗口，转换至java文件储存的文件夹内。如：在E盘建立Test.java文件，则在命令行输入E:，转至E盘,转至子文件，则输入<em>cd 子文件名</em></p>
<p>​        2.输入<strong><em>javac Test.java</em>（中有空格，拓展名.java一定要加上）</strong>编译.java文件，此步会生成Test.class这个字节码文件（.java文件中类的数量决定了字节码文件的数量）</p>
<p>​        3.在命令行窗口输入<strong><em>java Test</em>（中有空格，注意不加拓展名.class)</strong>运行字节码文件，即可得运行结果。</p>
<p>​        <em>注：编译过程使用javac.exe（Java编译器），故而编译时要输入指令javac；运行过程使用java.exe（虚拟机）。</em></p>
<p>在Java中，所有数据类型所占字节数量与平台无关。</p>
<p>此外，Java没有任何无符号的(unsigned)形式的int, long, short或byte类型。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Java Learning 3</title>
    <url>/2021/06/04/Java-Learning-3/</url>
    <content><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="常见集合"><a href="#常见集合" class="headerlink" title="常见集合"></a>常见集合</h2><p>ArrayList是最常用的API，但不是唯一的。</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p> 以有序的状态保持并可防止重复。</p>
<p>但是如果没有需要让清单保持有序的状态，TreeSet的成本会比想付出的还要多—-每当插入新项目，都要花时间找到合适的位置，而ArrayList只要把项目放在最后面就好。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>可用成对的name/value来保存与取出</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>针对经常插入或删除中间元素所涉及的高效率集合。（实际上ArrayList还是比较实用）</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>防止重复的集合，可快速地找寻相符的元素。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>类似HashMap，但可记住元素插入的顺序，也可以设定成按照元素上次存取的先后来排序。</p>
<p><img src="https://s2.loli.net/2021/12/26/RjgciyJoDFGkQIN.png" alt="image-20211226110456330"></p>
<h2 id="Perface"><a href="#Perface" class="headerlink" title="Perface"></a>Perface</h2><h3 id="Collections-sort"><a href="#Collections-sort" class="headerlink" title="Collections.sort( )"></a>Collections.sort( )</h3><p>鉴于ArrayList是最常用的集合，而且实现了List接口。恰巧，Collections这个类中存在sort( )方法，要用到List。所以多亏了多态机制，可以把ArrayList传给用到了List的方法。也就是说，可以使用Collections.sort( )方法来实现排序。</p>
<p>当歌曲的类型，由String变为Song时，可以明显发现编译器报错。也就是，ArrayList<String> 和 ArrayList<Song>之间的差异导致。</p>
<p><img src="https://s2.loli.net/2021/12/26/XJNW7FbSmytRw39.png" alt="image-20211226115014403"></p>
<h2 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h2><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><h4 id="泛型意味着更好的类型安全性。"><a href="#泛型意味着更好的类型安全性。" class="headerlink" title="泛型意味着更好的类型安全性。"></a>泛型意味着更好的类型安全性。</h4><p>几乎所有会以泛型写的程序都与处理集合有关。虽然泛型也可以用在其他地方，但它的<strong>主要目的还是让你能够写出有安全类型的集合</strong>。也就是，<strong>让编译器能够帮助防止把Dog加到一群Cat中。</strong></p>
<p>在泛型功能出现之前，编译器无法注意到加入集合中的东西是什么，因为所有的集合都写成处理Object类型，可以把任何东西放进ArrayList中，就类似于ArrayList<Object>。<strong>运用泛型，可以创建类型安全更好的集合</strong>，让问题尽可能在编译器就能抓到。</p>
<p><img src="https://s2.loli.net/2021/12/26/9Ph7AzNUo4eEMCm.png" alt="image-20211226120001237"></p>
<p><img src="https://s2.loli.net/2021/12/26/n6eZXf32TVu5sRK.png" alt="image-20211226120459538"></p>
<h4 id="泛型的本质为参数化类型，即程序中的数据类型被指定为一个参数E-Element-。"><a href="#泛型的本质为参数化类型，即程序中的数据类型被指定为一个参数E-Element-。" class="headerlink" title="泛型的本质为参数化类型，即程序中的数据类型被指定为一个参数E(Element)。"></a>泛型的本质为参数化类型，即程序中的数据类型被指定为一个参数E(Element)。</h4><p><strong>E代表用来创建与初始ArrayList的类型。</strong>在编译时，E会被指定的真正类型所取代(又称为类型参数)。这也是为何add( )这个方法无法加入与E所指定类型不兼容的引用的原因。若创建出ArrayList<Dog>, 则add( )会变成add(Dog o)。</p>
<p>其在定义时，不指明参数类型，在用时确定。</p>
<h3 id="运用泛型的方法"><a href="#运用泛型的方法" class="headerlink" title="运用泛型的方法"></a>运用泛型的方法</h3><p>泛型的类代表类的声明用到类型参数，泛型的方法代表方法的声明特征用到类型参数。</p>
<p>在方法中的类型参数有两种不同的运用方式。</p>
<h4 id="使用定义在类声明的类型参数"><a href="#使用定义在类声明的类型参数" class="headerlink" title="使用定义在类声明的类型参数"></a>使用定义在类声明的类型参数</h4><p><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;...&#123;</code></p>
<p><code>public boolean add(E o)</code> //只能在此使用E，因为已经被定义为类的一部分</p>
<p><code>&#125;</code></p>
<p><strong>当声明类的类型参数时，就可以把该类或接口类型用在任何地方。参数的类型声明基本上会以用来初始化类的类型来取代。</strong></p>
<h4 id="使用未定义在类声明的类型参数"><a href="#使用未定义在类声明的类型参数" class="headerlink" title="使用未定义在类声明的类型参数"></a>使用未定义在类声明的类型参数</h4><p><code>public &lt;T extends Animal&gt; void takeThing(ArrayList&lt;T&gt; list)</code></p>
<p><strong>如果类本身没有使用类型参数，可通过在一个不寻常但可行的位置上指定给方法—-在返回类型之前。这意味着T可以是”任何一种Animal”。</strong></p>
<p>附：</p>
<p><img src="https://s2.loli.net/2021/12/26/l7UROxS1a5siVTu.png" alt="image-20211226122852024"></p>
<h3 id="回到引出的那个问题："><a href="#回到引出的那个问题：" class="headerlink" title="回到引出的那个问题："></a>回到引出的那个问题：</h3><p><img src="https://s2.loli.net/2021/12/26/VPBtOAGQiLpyNm6.png" alt="image-20211226123237186"></p>
<p>也就是说，sort( )方法只能接受Comparable对象的list。而Song不是Comparable的子型，所以不能。</p>
<p>但是，根据String的说明：</p>
<p><code>public final class String extends Object implements Serializable, Comparable&lt;String&gt;, CharSequence...</code></p>
<p>也就是说，<strong>String没有继承过Comparable，只有实现，因为Comparable是个接口</strong>，那为什么会是extends？</p>
<h4 id="以泛型的观点来说，extend代表extend或implement。"><a href="#以泛型的观点来说，extend代表extend或implement。" class="headerlink" title="以泛型的观点来说，extend代表extend或implement。"></a>以泛型的观点来说，extend代表extend或implement。</h4><p><strong>对一个泛型而言，extends这个关键词代表“是一个……”，且不管接口或类都能使用。也就是说，适用于extends和implements。</strong></p>
<h4 id="SO"><a href="#SO" class="headerlink" title="SO"></a>SO</h4><p><strong>Song类必须实现Comparable！</strong></p>
<p>只有在这种情况下，才能把ArrayList<Song>传给sort( )方法，因为这个方法就是如此声明的。况且，也需要确定两个Song如何比较的大小。</p>
<p><img src="https://s2.loli.net/2021/12/26/sMv1TYhmF2oknrd.png" alt="image-20211226124605060"></p>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20211226124953490.png" alt="image-20211226124953490"></p>
<p>但是，如果想用多几种进行排序呢?</p>
<p>可以引出另一种sort( )方法—-取用Comparator参数。</p>
<h4 id="Another"><a href="#Another" class="headerlink" title="Another"></a>Another</h4><p>使用自制的Comparator，这是独立于所比较元素类型之外的——它是独立的类！因此，可以有各种不同的比较方法~~</p>
<p>取用Comparator版的sort( )方法会用Comparator而不是元素内置的CompareTo( )方法来比较顺序。也就是说，如果sort( )方法带有Comparator，就不会调用元素的CompareTo( )，而会去调用Comparator的Compare( )方法。</p>
<p><img src="https://s2.loli.net/2021/12/26/NHnioReGCWIEVJj.png" alt="image-20211226171420009"></p>
<h4 id="处理重复"><a href="#处理重复" class="headerlink" title="处理重复"></a>处理重复</h4><h5 id="LIST：对付顺序的好帮手"><a href="#LIST：对付顺序的好帮手" class="headerlink" title="LIST：对付顺序的好帮手"></a>LIST：对付顺序的好帮手</h5><p>一种知道索引位置的集合。</p>
<p>List直到某物在系列集合中的位置。可以有多个元素引用相同的对象。</p>
<h5 id="SET：注重独一无二的性质"><a href="#SET：注重独一无二的性质" class="headerlink" title="SET：注重独一无二的性质"></a>SET：注重独一无二的性质</h5><p>不允许重复的集合。</p>
<p>知道某物是否已经存在于集合中。不会有多个元素引用相同的对象。</p>
<h5 id="MAP：-用key来搜索的专家。"><a href="#MAP：-用key来搜索的专家。" class="headerlink" title="MAP： 用key来搜索的专家。"></a>MAP： 用key来搜索的专家。</h5><p>使用成对的键值和数据值。</p>
<p>Map会维护与key有关联的值。<strong>两个key可以引用相同的对象，但key不能重复</strong>，典型的key是String，但也可以是其他任何对象。</p>
<blockquote>
<p>泛型规则和限制：</p>
<ul>
<li>泛型的类型参数只能是类类型，不能是简单类型</li>
<li>泛型的参数类型可以有多个，如Map<K, V></li>
<li>泛型的参数类型可以使用extends语句，如<T extends M>，但此处的extends并非继承，而是类型限制，即在M范围内的T。</li>
<li>也可以使用通配符类型，即类似于&lt;? Extends M&gt;，是指在M范围内的某个类型，此处的?代表不定型。</li>
</ul>
</blockquote>
<h3 id="Collection-API"><a href="#Collection-API" class="headerlink" title="Collection API"></a>Collection API</h3><p><strong>接口Collection位于Collection API的最高层，定义了所有底层接口或类的公共方法。</strong></p>
<p><img src="https://s2.loli.net/2021/12/26/34MHN52sn7tSmUO.png" alt="image-20211226175620388"></p>
<p><img src="https://s2.loli.net/2021/12/26/4gLxYnumoHhwtPd.png" alt="image-20211226175744747"></p>
<p>所以，此处<strong>使用HashSet取代ArrayList</strong>。</p>
<h3 id="对象的相等"><a href="#对象的相等" class="headerlink" title="对象的相等"></a>对象的相等</h3><h4 id="引用相等性"><a href="#引用相等性" class="headerlink" title="引用相等性"></a>引用相等性</h4><p>堆上同一个对象的两个引用。</p>
<p>引用到堆上同一个对象的两个引用是相等的。如果对两个引用调用hashCode( )，会得到相同的结果。</p>
<blockquote>
<p>如果没有被覆盖的话，hashCode( )默认的行为会返回每个对象特有的序号(大部分Java版本是依据内存位置计算此序号，所以不会有相同的hashcode。)</p>
</blockquote>
<p><strong>要知道两个引用是否相等，可以使用==来比较变量上的字节组合</strong>。如果是相同的对象，字节组合也一样。</p>
<h4 id="对象相等性"><a href="#对象相等性" class="headerlink" title="对象相等性"></a>对象相等性</h4><p>堆上的不同两个对象在意义上是相同的。</p>
<p>如果你想要把两个不同的Song对象视为相等的,就必须覆盖过从Object继承下来的hashCode( )方法与equals()方法。就因为上面所说的内存计算问题, 所以你必须覆盖过hashCode( )才能确保两个对象有相同的hashcode, 也要确保以另一个对象为参数的equals( )调用会返回true。</p>
<p><img src="https://s2.loli.net/2021/12/26/rNl1MoT3asIdGPA.png" alt="image-20211226181219247"></p>
<p><img src="https://s2.loli.net/2021/12/26/ylYvh4RZu2q6CMI.png" alt="image-20211226181200357"></p>
<p><img src="https://s2.loli.net/2021/12/26/MFyzxri8KOEkcDW.png" alt="image-20211226181806418"></p>
<p><img src="https://s2.loli.net/2021/12/26/vMrlW1eN4mhXkwn.png" alt="image-20211226182244389"></p>
<p>API文件有对对象的状态制定出必须遵守的规则:</p>
<p>(1）如果两个对象相等,则hashcode必须也是相等的。</p>
<p>(2）如果两个对象相等, 对其中一个对象调用equals()必须返回true。也就是说,若a.equals(b).则b.equals(a).</p>
<p>(3）如果两个对象有相同的hashcode值, 它们也不一定是相等的。但若两个对象相等, 则hashcode值一定是相等的。</p>
<p>(4）若equals()被覆盖过，则hashCode()也必须被覆盖。</p>
<p>(5) hashCode()的默认行为是对在heap上的对象产生独特的值。如果你没有override过hashCode(),则该class的两个对象怎样都不会被认为是相同的。</p>
<p>(6)equals()的默认行为是执行==的比较。也就是说会去测试两个引用是否对上heap上同一个对象。如果equals()没有被覆盖过,两个对象永远都不会被视为相同的,因为不同的对象有不同的字节组合。</p>
<p><img src="https://s2.loli.net/2021/12/26/BSQdlC9kRIVxru1.png" alt="image-20211226182512343"></p>
<h4 id="Something-About-TreeSet"><a href="#Something-About-TreeSet" class="headerlink" title="Something About TreeSet"></a>Something About TreeSet</h4><p><img src="https://s2.loli.net/2021/12/26/gIQXAxSnyqZz5v2.png" alt="image-20211226182608504"></p>
<p><img src="https://s2.loli.net/2021/12/26/PkmZnsKwjTtXGaQ.png" alt="image-20211226185927531"></p>
<h4 id="1-Collection-接口"><a href="#1-Collection-接口" class="headerlink" title="1. Collection 接口"></a>1. Collection 接口</h4><h5 id="常用的方法："><a href="#常用的方法：" class="headerlink" title="常用的方法："></a>常用的方法：</h5><p>​    boolean add(E obj)</p>
<p>​    boolean isEmpty()</p>
<p>​    Iterator<E> iterator() : 获取手机的Iterator接口实例</p>
<p>​    Object[] toArray() : 将收集变为对象数组</p>
<h5 id="关于Iterator接口"><a href="#关于Iterator接口" class="headerlink" title="关于Iterator接口:"></a>关于Iterator接口:</h5><ol>
<li><p>boolean hasNext(): 是否存在下一个元素</p>
</li>
<li><p>Object next(): 返回要访问的下一个元素，若无，引发异常</p>
</li>
</ol>
<h4 id="2-Set-接口"><a href="#2-Set-接口" class="headerlink" title="2. Set 接口"></a>2. Set 接口</h4><p>特点：不含重复元素，且无序，其中的SortedSet接口用于描述按“自然顺序”组织元素的收集，即其中对象有序。</p>
<p>其判断集合中重复元素的标准为按对象值比较，即使用equals()方法。</p>
<p>迭代器：Iterator it = Set.iterator();</p>
<h4 id="3-List-接口"><a href="#3-List-接口" class="headerlink" title="3. List 接口"></a>3. List 接口</h4><p>特点：其中可含重复元素，且有序。包括ArrayList与LinkedList两个类。</p>
<p>常用方法：</p>
<p>​    void add(E e) : 在尾部添加元素</p>
<p>​    void add(int pos, E e) : 在指定位置添加元素</p>
<p>​    E get(int pos) : 返回指定位置的元素</p>
<p>​    E set(int pos, E e) : 更改指定位置的元素</p>
<p>​    E remove(int pos) : 删除指定位置的元素</p>
<p>ArrayList 与 LinkedList区别：</p>
<p>​    前者使用数组存储元素，可以实现快速访问元素；后者使用双向链表，可以实现快速插入，删除元素。</p>
<h4 id="4-Map-接口"><a href="#4-Map-接口" class="headerlink" title="4. Map 接口"></a>4. Map 接口</h4><h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><p>public Set<K> keySet(): 关键字的集合</p>
<p>public Collection<V> values() : 值的集合</p>
<p>public Set<Map.Entry<K, V> &gt;entrySet : 关键字和值的映射关系的集合</p>
<p>public V get(K key) : 获取关键字对应的值</p>
<p>public V put(K key, V val) : 加入新的映射；若已经存在，修改映射的值，返回原映射的值，否则，返回null</p>
<p>public V remove(Object key) : 删除关键字多对应的映射，返回值同上。</p>
<p>public boolean equals(Object obj) : 判断Map对象与参数对象是否等价，两个相同的Map，其映射关系集合应当一致</p>
<p>public boolean containsKey(Object key): 是否存在于关键值匹配的映射关系</p>
<p>public boolean containsValues(Object value) : 是否存在与键值匹配的映射关系</p>
<h6 id="另："><a href="#另：" class="headerlink" title="另："></a>另：</h6><p>​    <code>通过与Set接口的结合，可以实现由值取关键字。即首先将关键字通过keySet()提取出来进入Set s中，而后通过迭代器for(Iterator it = s.iterator();it.hasNext();),  匹配m.get(it.next()).equals(V value)或 for(T s : s) 遍历(T为Set中元素的数据类型），m.get(s).equals(V value)来查找值对应的关键字</code></p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在普通数组的情况下，Dogs[ ]可以调用Animals[ ]的方法，即可以将其作为参数传入以Animal为参数的方法中。</p>
<p>但在泛型中，这是不允许的。</p>
<p>吃个栗子：<img src="https://s2.loli.net/2021/12/26/MVXCheT5z6G8LQ3.png" alt="image-20211226192723304"></p>
<p>很显然的是，就普通数组而言，不可调用add方法，也就是说，不会出现这种添加情况，编译不会通过。但泛型中存在这种情况，如果允许Dogs[ ]传入，会导致在dog中混入一只cat，这显然不合理。</p>
<p>其实，数组也能进行相应的操作的哦。</p>
<p><strong>数组的类型是在运行期间检查的，但集合的类型检查只会发生在编译期间。</strong></p>
<p>这也就是为何数组这样操作，可以逃过编译(但运行的时候会出错)，而集合却不能。</p>
<p>如果把方法的参数设定为ArrayList<Animal>，那么Array<Cat>和Array<Dog>都不可用。</p>
<h3 id="万用字符"><a href="#万用字符" class="headerlink" title="万用字符"></a>万用字符</h3><p>这样设定方法的参数为ArrayList<Animal>时，就可以接收Animal子型参数了。</p>
<p><img src="https://s2.loli.net/2021/12/26/nwfPWjNJMEtukZ9.png" alt="image-20211226194114402"></p>
<p>但是，注意：</p>
<p><strong>在这种情况下，只能使用list中任何元素的方法，不能在list中新增元素!!!</strong></p>
<p>也就是说，可以操作集合元素，但不能新增集合元素。如此才能保障执行期间的安全性，因为编译器会阻止执行期的恐怖行动。</p>
<p><code>for(Animal a:animals) &#123;</code></p>
<p><code>a.eat();&#125; //可以的</code></p>
<p><code>for (Animal a:animals) &#123;</code> </p>
<p><code>a.add(new Cat());&#125;// 不可以！</code></p>
<p><img src="https://s2.loli.net/2021/12/26/HYxVAqajiUOR1cl.png" alt="image-20211226194715004"></p>
]]></content>
      <tags>
        <tag>Java Learning 3</tag>
      </tags>
  </entry>
  <entry>
    <title>plus</title>
    <url>/2021/10/08/Java-Learning-3%20plus/</url>
    <content><![CDATA[<h1 id="ArrayList与一般数组"><a href="#ArrayList与一般数组" class="headerlink" title="ArrayList与一般数组"></a>ArrayList与一般数组</h1><p>​        相同点：</p>
<ul>
<li><p>二者都为对象，都保存在堆上</p>
</li>
<li><p>二者都可保存数据引用和primitive主数据类型</p>
</li>
<li><p>创建时指定类型</p>
<p>不同点：</p>
<p>| 对比 | 一般数组                                       | ArrayList                                                    |<br>| —— | ——————————————————————— | —————————————————————————————— |<br>| 创建 | 需要指定大小                                   | 只需创建出该类型对象即可，无需指定大小（在增加或删除时，自行调整大小） |<br>| 方法 | 并无方法可调用，最多使用如length这样的实例变量 | 建立的是一个类对象，可以使用“.”运算符来调用其方法            |<br>| 存放 | 必须指定位置，若下标溢出，执行会抛出异常       | 无需指定索引值，可使用add方法，让其自行管理大小              |<br>| 语法 | 可使用特殊语法[ ]来调用数组元素                | 普通对象，不可使用[ ]这样的特殊语法                          |</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Java API extension</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Learning-5</title>
    <url>/2021/11/12/Java-Learning-5/</url>
    <content><![CDATA[<h1 id="Java中的继承"><a href="#Java中的继承" class="headerlink" title="Java中的继承"></a>Java中的继承</h1><h2 id="例：设计动物仿真程序的继承树"><a href="#例：设计动物仿真程序的继承树" class="headerlink" title="例：设计动物仿真程序的继承树"></a>例：设计动物仿真程序的继承树</h2><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li>找出具有共同属性和行为的对象</li>
<li>设计代表共同状态与行为的类</li>
<li>决定子列是否需要让某项行为(也就是方法的实现)有特定不同的运作方式</li>
<li>通过寻找使用共同行为的子类来找出更多抽象化的机会</li>
<li>完成类的继承层次</li>
</ol>
<h4 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h4><p>以Wolf类为例，其包括继承自Animal和Canine两类在内，一共四个方法。具体在调用对象引用的方法时，会调用到与该对象类型最接近的方法。换句话说，最低阶的会胜出！即，Java虚拟机会从继承树最底层(层次树的最下方)Wolf开始，若有符合Wolf版的方法，则直接进行调用。若无，则继续向上，去查找Animal中相应的方法，依此类推，直到找到为止。</p>
]]></content>
      <tags>
        <tag>Extends</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Learning-4</title>
    <url>/2021/08/27/Java-Learning-4/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">design</span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		EventQueue.invokeLater(() -&gt; <span class="comment">// 事件分派线程中的执行代码</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotHelloFrame</span>();</span><br><span class="line">			frame.setTitle(<span class="string">&quot;What you buy&quot;</span>);</span><br><span class="line">				frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">			frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotHelloFrame</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">NotHelloFrame</span><span class="params">()</span> &#123;</span><br><span class="line">		add(<span class="keyword">new</span> <span class="title class_">NotHelloComponent</span>());</span><br><span class="line">		pack();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotHelloComponent</span> <span class="keyword">extends</span> <span class="title class_">JComponent</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MESSAGE_X</span> <span class="operator">=</span> <span class="number">75</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MESSAGE_Y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_WIDTH</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_HEIGHT</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paintComponent</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">		g.drawString(<span class="string">&quot;What are you want?&quot;</span>, MESSAGE_X, MESSAGE_Y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Dimension <span class="title function_">getPreferredSize</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dimension</span>(DEFAULT_WIDTH, DEFAULT_HEIGHT);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>绘制图像框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_Thread</title>
    <url>/2021/12/14/Java-Thread/</url>
    <content><![CDATA[<p>The beginning of thread.</p>
<p>Java 有多个线程但只有一种Thread类。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="Some-Basic-Concepts"><a href="#Some-Basic-Concepts" class="headerlink" title="Some Basic Concepts"></a>Some Basic Concepts</h2><p>线程是独立的线程，他代表独立的执行空间。</p>
<p>Thread是Java中用来表示线程的类，要建立线程就得创建Thread。</p>
<p>每一个Java应用程序会启动一个主线程—将main( )放在自己执行空间的最开始出。Java虚拟机会负责主线程的启动(如垃圾回收所需的系统用线程)。程序员要负责启动自己建立的线程。</p>
<h2 id="What-does-having-more-than-one-executing-space-symbolize"><a href="#What-does-having-more-than-one-executing-space-symbolize" class="headerlink" title="What does having more than one executing space symbolize?"></a>What does having more than one executing space symbolize?</h2><p>当有超过一个以上的执行空间时，看起来好像是有好几件事同时发生。但实际上，执行动作可以在执行空间中快速地来回切换。<strong>Java也只是个在底层操作系统上执行的进程</strong>。一旦轮到Java执行时，Java虚拟机会执行<strong>目前执行空间最上面的</strong>。</p>
<p>线程要记录的一项事务是<strong>目前线程执行空间做到哪里</strong>。</p>
<p>举个栗子：</p>
<p>Java虚拟机调用main( )主线程。</p>
<p>main( )中建立了一个Thread对象t，并启动了新线程t.start( )。则此时，堆上新增线程t.start( )，另起一执行空间，启动自建线程中的run( )，在新线程启动期间，main( )会暂停执行。</p>
<p>之后，会在主线程和用户自建线程之间来回切换，直到二者全部执行完毕。</p>
<h2 id="如何启动新的线程？"><a href="#如何启动新的线程？" class="headerlink" title="如何启动新的线程？"></a>如何启动新的线程？</h2><ol>
<li><p>建立Runnable对象(线程的任务)</p>
<p><code>Runnable threadJob = new MyRunnable();</code></p>
</li>
<li><p>建立Thread对象(执行工人)并赋值Runnable(任务)</p>
<p><code>Thread myThread = new Thread(threadJob);</code></p>
<p>把Runnable对象传给Thread的构造函数。这会告诉Thread对象要把那个方法放在执行空间区运行—Runnable的run( )方法。</p>
</li>
<li><p>启动Thread</p>
<p>myThread.start( );</p>
<p>在还没有调用Thread的start( )方法之前，什么也不会发生。当新的线程启动之后，它会把Runnable对象的方法摆到新的执行空间中。<img src="https://s2.loli.net/2021/12/21/sAT4lDncoZfyLRm.png" alt="image-20211221191525894"></p>
</li>
</ol>
<blockquote>
<p>对于Thread而言，它相当于一个工人，对于Runnable而言，它相当于这个工人要完成的工作。Runnable带有会放在执行空间的第一项的方法：run( )。</p>
</blockquote>
<p>Thread对象需要任务，任务是线程在启动时去执行的工作。<strong>run( )该任务是新线程空间上的第一个方法</strong>，且一点更要长得像下面这样:</p>
<p>public void run( ) {</p>
<p>​    //会被新线程执行的代码</p>
<p>}</p>
<p>Runnable定义了一个协约。因为Runnable是个接口，线程的任务可以被定义在任何实现Runnable的类上。线程只在乎传入给Thread的构造函数的参数是否为实现Runnable的类。当把Runnable传给Thread的构造函数时，实际上就是在给Thread取得run( )的方法，即给了Thread一项任务。Runnable接口只有run( )这一个方法。</p>
<blockquote>
<p>在调用start( )开始执行线程之前，对象只是个Thread实例，并不是真正的线程。</p>
</blockquote>
<p><img src="https://s2.loli.net/2021/12/21/7Tycos9U2SWEKnu.png" alt="image-20211221211338659"></p>
<h3 id="新建线程的三个状态"><a href="#新建线程的三个状态" class="headerlink" title="新建线程的三个状态"></a>新建线程的三个状态</h3><ol>
<li><h4 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h4><p>Thread t = new Thread(r);</p>
</li>
</ol>
<p>Thread的实例已经创建，但还没有启动。也就是说，有Thread对象，没有执行中的线程。</p>
<ol>
<li><h4 id="可执行"><a href="#可执行" class="headerlink" title="可执行"></a>可执行</h4><p>t.start( );</p>
</li>
</ol>
<p>当启动线程时，它会变成可执行的状态。这时，线程已经布置好执行空间。</p>
<ol>
<li><h4 id="执行中-线程的目标"><a href="#执行中-线程的目标" class="headerlink" title="执行中(线程的目标)"></a>执行中(线程的目标)</h4><p>轮到它执行</p>
</li>
</ol>
<p>所有的线程都在等待这一刻，成为正在执行中的那一个。这只能靠Java虚拟机的线程调度机制来决定。有时也能对Java虚拟机选择执行的线程给点意见，但无法强迫它把线程从可执行状态移动到执行中。</p>
<blockquote>
<p>一旦线程进入可执行状态，他会在可执行与执行中两种状态中来来去去，同时也有另一种状态：暂时不可执行(又称为被堵塞状态)。</p>
</blockquote>
<h4 id="典型的可执行-执行中循环："><a href="#典型的可执行-执行中循环：" class="headerlink" title="典型的可执行/执行中循环："></a>典型的可执行/执行中循环：</h4><p>通常线程会在可执行与执行中两种状态中来回交替。因为Java虚拟机的线程调度会把线程跳出来运行又把它踢回去以让其他线程有执行机会。</p>
<h4 id="线程有可能会暂时被挡住"><a href="#线程有可能会暂时被挡住" class="headerlink" title="线程有可能会暂时被挡住"></a>线程有可能会暂时被挡住</h4><p>调度器会因为某些原因把线程送进去关一阵子。例如线程执行到等待Socket输入串流的程序段，但没有数据可供读取。调度器会把线程移出可执行状态等。会导致线程暂时失能。</p>
<h2 id="无法掌控的线程调度器"><a href="#无法掌控的线程调度器" class="headerlink" title="无法掌控的线程调度器"></a>无法掌控的线程调度器</h2><p>无法控制调度，没有API可以可调用调度器。调度器在不同的虚拟机上有不同的行为。最重要的是，调度无法确定。</p>
<p>也就是说，同一个多线程的程序，在不同的主机上运行，会导致不同的结果。甚至于同一个程序在同一台主机上运行的结果也是不确定的。不能让程序依靠调度的特定行为来保持执行的正确性！</p>
<p>吃个栗子：</p>
<p><img src="https://s2.loli.net/2021/12/21/UYbLWgKlOd8PzcT.png" alt="image-20211221215408955"></p>
<blockquote>
<p>调度不能保证任何的执行时间和顺序，所以你不能期待他会完全地平均分配执行，最多只能影响sleep的最小保证时间。</p>
</blockquote>
<p><img src="https://s2.loli.net/2021/12/21/9ZMQnxvV1BYprqX.png" alt="image-20211221222504166"></p>
<p>想要确保其他线程有机会执行的话，就把线程放进睡眠状态。</p>
<p><img src="https://s2.loli.net/2021/12/21/Trw8pfKCkvhcVOL.png" alt="image-20211221223345949"></p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="Ryan和Monica的透支银行余额事件"><a href="#Ryan和Monica的透支银行余额事件" class="headerlink" title="Ryan和Monica的透支银行余额事件"></a>Ryan和Monica的透支银行余额事件</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p><img src="https://s2.loli.net/2021/12/23/CdDtVX8cL95JMjP.png" alt="image-20211223154931306"></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><img src="https://s2.loli.net/2021/12/23/x1CTGOcV2d6nUzN.png" alt="image-20211223154659753"></p>
<p>每个对象都有个锁。大部分时间都没有锁上。对象的锁只会在有同步化的方法上起作用。当对象有一个或多个同步化的方法时，线程只有在取得对象锁的钥匙时，才能进入同步化的方法。</p>
<p>锁不是配在方法上的，而是配在对象上。如果对象有两个同步化的方法，就表示两个线程无法进入同一个方法，也表示两个线程无法进入不同的方法。如果有多个方法可能会操作对象的实例变量，则这些方法都应该有同步化的保护。</p>
<p><strong>同步化的目标是要保护重要的数据。但要注意，锁住的不是数据，而是存取数据的方法。</strong></p>
<p>所以线程在开始执行并遇到同步化的方法时，会认知到他需要对象的钥匙才能进入方法。<strong>他会取得钥匙，这是由Java虚拟机来处理的，没有可以存取对象锁的API。那么此时，他会保护好这把钥匙，直到完成同步化方法。</strong>与此同时，其他线程不可以进入该对象的同步化方法，因为只有这一把钥匙。</p>
<blockquote>
<p>只有当对象具有同步化方法时，才会上锁。而且线程只有取得钥匙后，才能进入该方法。也就是说，线程只有在没有其他线程已经进入的情况下，才能进入。</p>
</blockquote>
<h3 id="“丢失更新”问题"><a href="#“丢失更新”问题" class="headerlink" title="“丢失更新”问题"></a>“丢失更新”问题</h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>这是另一个典型的并行性(concurrency)问题。丢失更新(lost update)有一种特定的过程。</p>
<p>吃个栗子：</p>
<ol>
<li>取得账户余额 <code>int i = balance;</code></li>
<li>将账户余额增加 <code>balance = i + 1;</code></li>
</ol>
<blockquote>
<p>正常情况下，都是直接balance++; 但怎么说呢，偶尔会因为表达式的复杂，只得使用以上方法。</p>
</blockquote>
<p>看上去，这样没什么问题。</p>
<p>那么，若此时有两个线程A和B在执行这个方法。</p>
<p>A：取余额0，增加1，变为1；</p>
<p>​    再取余额1，增加1，变为2；</p>
<p>B：取余额2，增加1，变为3；</p>
<p>​    取余额3，B睡了，此时未增加。</p>
<p>A：取余额3，增加1，变为4；</p>
<p>​    取余额4，增加1，变为5。</p>
<p>B：苏醒，将其的i=3，增加1，余额balance变为4…….</p>
<blockquote>
<p>很明显，B更改了A增加的值，丢失了A进行的更新。</p>
</blockquote>
<p>此时，就需要同步化机制来帮忙，将 <code>int i = balance; balance = i + 1;</code>锁成整体，变得不可分割。</p>
<p><img src="https://s2.loli.net/2021/12/23/VGYbOyUdQhtsCwz.png" alt="image-20211223162430700"></p>
<p><img src="https://s2.loli.net/2021/12/23/OPUaqB8yWInmF3R.png" alt="image-20211223162514844"></p>
<h3 id="死锁现象"><a href="#死锁现象" class="headerlink" title="死锁现象"></a>死锁现象</h3><p>死锁会发生是因为两个线程互相持有对方正在等待的东西。没有方法可以脱离这个情况。所以只好一直等，一直等。</p>
<p>Java中没有处理死锁的机制，甚至它都不知道死锁的发生，所以要小心设计程序。如果经常编写多线程的程序，去看看O’Reilly出版的“Java Thread”。</p>
<p><img src="https://s2.loli.net/2021/12/23/rcYB15efjhOKvI7.png" alt="image-20211223162828317"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Thread.sleep()这个静态方法可以强制线程进入等待状态到过了设定的时间为止。</li>
<li>sleep()方法可能会抛出InterruptedException异常，所以要包在try/catch块中，或者把他也声明出来。</li>
<li>可以用setName来给线程命名，通常是用来除错的。</li>
<li>如果两个或以上线程存取堆上相同的对象可能会出现严重的问题。</li>
<li>如果两个或以上的线程存取相同的对象可能会引发数据的损毁。</li>
<li>使用synchronized这个关键词修饰符，可以防止两个线程同时进入同一个对象的同一个方法。</li>
<li>对象就算是有多个同步化的方法，也还是只有一个锁。一旦某个线程进入该对象的同步化方法，其他线程就无法进入该对象上的任何同步化方法。</li>
<li>不只对象有锁，类本身也是有锁的。也就是说，假如有3个Dog对象，那么此时应该是有4个锁。</li>
<li>故而，对静态变量进行同步化，线程想要进入方法就需要先获得类的锁。</li>
<li>同步化的根本目的是为了防止步骤被分割，也就是指定某段工作要在不能分割的状态下执行。单独的操作并不重要，重要的是拥有多个步骤的一个方法。</li>
</ol>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.print.PrinterJobWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/12/23 16:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleChatClient</span> &#123;</span><br><span class="line">    JTextArea incoming;</span><br><span class="line">    JTextField outgoing;</span><br><span class="line">    BufferedReader reader;</span><br><span class="line">    PrintWriter writer;</span><br><span class="line"></span><br><span class="line">    Socket socket;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleChatClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleChatClient</span>();</span><br><span class="line">        client.go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;Ludicrously Simple Chat Client&quot;</span>);</span><br><span class="line">        <span class="type">JPanel</span> <span class="variable">panel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">        incoming = <span class="keyword">new</span> <span class="title class_">JTextArea</span>(<span class="number">15</span>, <span class="number">50</span>);</span><br><span class="line">        incoming.setLineWrap(<span class="literal">true</span>);</span><br><span class="line">        incoming.setWrapStyleWord(<span class="literal">true</span>);</span><br><span class="line">        incoming.setEditable(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">JScrollPane</span> <span class="variable">scrollPane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JScrollPane</span>(incoming);</span><br><span class="line">        scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);</span><br><span class="line">        scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);</span><br><span class="line">        outgoing = <span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">sendButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Send&quot;</span>);</span><br><span class="line">        sendButton.addActionListener(<span class="keyword">new</span> <span class="title class_">SendButtonActionListener</span>());</span><br><span class="line">        panel.add(scrollPane);</span><br><span class="line">        panel.add(outgoing);</span><br><span class="line">        panel.add(sendButton);</span><br><span class="line">        setUpNetworking();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">readerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">IncomingReader</span>());</span><br><span class="line">        readerThread.start();</span><br><span class="line"></span><br><span class="line">        frame.getContentPane().add(BorderLayout.CENTER, panel);</span><br><span class="line">        frame.setSize(<span class="number">400</span>, <span class="number">500</span>);</span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用socket取得输入/输出串流，进行输入/输出事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setUpNetworking</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(host, port);</span><br><span class="line">            <span class="type">InputStreamReader</span> <span class="variable">streamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream());</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(streamReader);</span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream());</span><br><span class="line">            System.out.println(<span class="string">&quot;networking established&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendButtonActionListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent actionEvent)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.println(outgoing.getText());</span><br><span class="line">                writer.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            outgoing.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            outgoing.requestFocus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IncomingReader</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            String message;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((message = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;read &quot;</span> + message);</span><br><span class="line">                    incoming.append(message + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/12/23 17:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleChatServer</span> &#123;</span><br><span class="line">    ArrayList clientOutputStreams;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        BufferedReader reader;</span><br><span class="line">        Socket socket;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ClientHandler</span><span class="params">(Socket clientSocket)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket = clientSocket;</span><br><span class="line">                <span class="type">InputStreamReader</span> <span class="variable">isReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream());</span><br><span class="line">                reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isReader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            String message;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((message = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;read &quot;</span>+ message);</span><br><span class="line">                    tellEveryone(message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SimpleChatServer</span>().go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        clientOutputStreams = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(clientSocket.getOutputStream());</span><br><span class="line">                clientOutputStreams.add(writer);</span><br><span class="line"></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ClientHandler</span>(clientSocket));</span><br><span class="line">                t.start();</span><br><span class="line">                System.out.println(<span class="string">&quot;got a connection&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tellEveryone</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> clientOutputStreams.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> (PrintWriter) it.next();</span><br><span class="line">                writer.println(message);</span><br><span class="line">                writer.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Something about Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/2022/02/01/Maven/</url>
    <content><![CDATA[<h1 id="Maven：自动化构建工具"><a href="#Maven：自动化构建工具" class="headerlink" title="Maven：自动化构建工具"></a>Maven：自动化构建工具</h1>]]></content>
      <tags>
        <tag>Begin！</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-触发器</title>
    <url>/2021/11/29/MySQL-%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    <content><![CDATA[<h1 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h1><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>MySQL的语句在需要时被执行，包括存储过程也是如此。但是，经常会出现想要某条语句(或某些语句)在事件发生时自动执行的情况。此时，便需要触发器的作用。</p>
<p><strong>触发器</strong> 是MySQL响应以下任意语句而自动执行的一条MySQL语句(或位于BEGIN和END语句之间的一组语句)：<strong>DELETE、UPDATE、INSERT</strong>。其余MySQL语句不支持触发器。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>在创建触发器时，需要给出4条信息：</p>
<ul>
<li><p>唯一的触发器名(每个表唯一，但最好保证整个数据库中唯一)</p>
</li>
<li><p>触发器关联的表</p>
</li>
<li><p>触发器因该相响应的活动(DELETE、INSERT或UPDATE)；</p>
</li>
<li><p>触发器该何时执行(处理之前或之后)。</p>
<p>注意，在触发器中返回结果集是低版本MySQL的做法，书上的代码，不允许触发器返回任何结果，因此使用INTO @变量名，将结果赋值到变量中，用SELECT调用即可。</p>
<p>修改为：</p>
<p>CREATE TRIGGER newp AFTER INSERT ON tb_product</p>
<p>FOR EACH ROW SELECT ‘Product added’ INTO @asd;</p>
<p>可用SELECT @asd；输出变量中结果。</p>
</li>
</ul>
<blockquote>
<p>tips：</p>
<p>触发器按照每个表每个事件定义，单一触发器不能与多个事件或多个表关联。所以，如果你需要一个对INDERT和UPDATE操作执行的触发器，就应该定义两个。</p>
</blockquote>
]]></content>
      <tags>
        <tag>触发器</tag>
      </tags>
  </entry>
  <entry>
    <title>GC</title>
    <url>/2021/11/15/GC/</url>
    <content><![CDATA[<h1 id="构造器与垃圾收集器"><a href="#构造器与垃圾收集器" class="headerlink" title="构造器与垃圾收集器"></a>构造器与垃圾收集器</h1><p>It is time to talk about death!</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Like people， 对象也有生有死。如果你要编写Java程序，就必须创建对象，也早晚会将对象释放掉，不然就会出现内存不足的问题。其实，就你的操作而言，并不是亲自消灭对象，你只是声明了放弃。一旦对象被放弃，那么冷血无情的垃圾收集器(GC)就会将他蒸发掉，回收其所占用的内存空间。</p>
<h2 id="开端"><a href="#开端" class="headerlink" title="开端"></a>开端</h2><h3 id="栈与堆：生存空间"><a href="#栈与堆：生存空间" class="headerlink" title="栈与堆：生存空间"></a>栈与堆：生存空间</h3><p>在Java中，程序员只关心两个区域的空间：堆(heap)和栈(stack)。二者，分别是对象的生存空间和方法调用及部分变量的生存空间。</p>
<p>所有的对象都存活在可以进行垃圾回收的堆上，而具体变量的生存空间取决于其本身是实例变量还是局部变量。后者又称为栈变量，明确保存在栈上。</p>
<blockquote>
<p>tips：</p>
<p><strong>实例变量</strong>：是被声明在类而不是方法里面。他们代表每个独立对象的“字段”(每个实例都能有不同的值)。实例变量存在于所属的对象中。(如每个Duck都可以有一个不同的size)</p>
<p><strong>局部变量</strong>：局部变量和方法的参数都是被声明在方法中。他们是暂时的，且生命周期只限于方法被放在栈上的这段期间(也就是方法调用至执行完毕为止)。</p>
</blockquote>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>当你调用一个方法时，该方法会被放在<strong>调用栈的栈顶</strong>。实际上被堆上栈的是堆栈块，它带有方法的状态，包括执行到<em>哪一行程序</em>以及所有的<em>局部变量的值</em>。(若foo中调用了bar，那么bar会放在foo的顶上)</p>
<p>当一个方法执行完成，那么他的堆栈块就会被释放掉。</p>
<p>若在方法中创建了非primitive的变量(其只是对象的引用变量，而不是对象本身)，那么不管对象是否声明或创建，如果局部变量是对对象的引用，只有该引用变量会在栈上，而对象会在堆上。</p>
<p><img src="https://s2.loli.net/2021/12/22/qRVZxtvmHXEc14D.png" alt="image-02"></p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>对象是存放在堆上的。</p>
<p>实例变量存在于对象所属的堆空间上。</p>
<p>如果实例变量是primitive主数据类型的，则Java会留下其数据类型大小的空间。</p>
<p>若实例变量是一个带有对象引用的变量，那么Java会在类中留出一个引用变量的空间，而不是对象本身所占有的空间。而该引用变量所引用的对象，会在堆上被另外分配空间。即此时，引用和对象都是在堆上。</p>
<p><img src="https://s2.loli.net/2021/12/22/7ZdbjieCXWFo3kR.png" alt="image-03"></p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>声明对象和赋值有3个步骤：声明引用变量、创建对象、连接对象和引用(声明、创建和赋值)。</p>
<p>构造函数卡看起来像方法，感觉上也很像方法，但它并不是方法。它带有new的时候会执行的程序代码，也就是新建一个对象的时候会执行。</p>
<p>构造函数的一项关键特征，即其会在对象被赋值给引用之前就执行。可以在对象被使用之前，介入。</p>
<h4 id="About-super"><a href="#About-super" class="headerlink" title="About super( )"></a>About super( )</h4><p>在创建对象时，父类的构造方法也会被执行。在构造函数中，用<strong>super</strong>来调用父类的构造函数，且这条语句，即<strong>super( )一定位于子类构造函数的第一句</strong>。要记得完整的对象需要也是完整的父类核心。就算Animal上的有些变量Hippo不会用到，但Hippo有可能会有某些继承下来的方法必须读取Animal的实例变量。</p>
<p>构造函数在执行的时候，第一件事是去执行它父类的构造函数，这会连锁反应，一直到Object这个类为止。这样的过程被称作构造函数链。</p>
<p><img src="https://s2.loli.net/2021/12/22/JAijMRaoUqPZIKY.png" alt="image-07"></p>
<p>步骤：</p>
<ol>
<li>执行Hippo的构造函数，其进入最上方的堆栈块。</li>
<li>Hippo的构造函数中，引用了Animal的构造函数，故而父类的构造函数此时被放置在堆栈块顶。</li>
<li>Object的构造函数，由于被Animal的构造函数所引用，此时进入堆栈块最上方。</li>
<li>Object构造函数执行完毕，则弹出堆栈块，则依次是Animal的，Hippo的。</li>
<li>即，Hippo的构造函数最早进入堆栈，却最后弹出。</li>
</ol>
<blockquote>
<p>tips：</p>
<p>父类的构造函数调用super( )，一定要在子类的构造函数的第一句。因为父类与子类的关系，就类似于父母与孩子。父类的对象，一定要在子类的对象开始开始构造之前成型。因为在子类构造过程中，可能会动用从父类中继承下来的东西。所以，一定要在子类构造之前，完成父类的构造函数。</p>
</blockquote>
<h4 id="About-this"><a href="#About-this" class="headerlink" title="About this( )"></a>About this( )</h4><p>另外，如果有某个重载版的构造函数除了不能处理不同类型的参数之外，可以进行其余包括实例变量优化在内的一切工作。而且，为了避免维护的不便利性，不希望相同的代码出现在每一个构造函数中。那么，可以考虑让其余所有的构造函数都先调用该构造函数。即，this( )或this(String)等。</p>
<p>但，需要注意，<strong>this( )必须出现在调用者的第一个语句</strong>，那么这，势必会与super( )的位置产生冲突，故而，有：<strong>super( )和this( )不能同时使用</strong>。</p>
<h2 id="转合"><a href="#转合" class="headerlink" title="转合"></a>转合</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对象的生命周期取决于引用到它的“引用”，如果引用变量还活着，那么对象就继续活在堆上。如果引用死了，对象就随之而去。见下方“引用变量”。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量的生命周期取决于其类型。</p>
<h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><ul>
<li><p>随方法的调用而产生，随方法的弹出堆栈块而结束。</p>
</li>
<li><p>范围只限于声明它的方法中。</p>
</li>
<li>若声明它的方法在调用了其他方法，那么该局部变量的状态会被保存，但是不再起作用。</li>
<li>不能被使用，除非声明它的方法正在执行。</li>
</ul>
<h5 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h5><ul>
<li>属于对象，其寿命于对象相同。</li>
<li>若对象存在，则实例变量也存活在堆上。</li>
</ul>
<h5 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h5><ul>
<li><p>引用变量也只能处于它的范围中才能被引用。也就是说，除非引用变量是在它的范围中，不然就不能使用对象的遥控器。</p>
</li>
<li><p>如果有活着的引用，对象也就活着。如果某个对象的引用已经不在它的范围内，但此引用还是活着的，则此对象就会继续活在堆上，</p>
</li>
<li><p>如果对对象的唯一引用死了，对象就会从堆中被踢开，引用变量会跟堆栈块一起解散，因此被踢开的对象也就正式声明出局。</p>
<p>释放引用变量的方法：</p>
<ul>
<li><p>将其放在方法中</p>
</li>
<li><p>将其重新赋值给别的对象</p>
</li>
<li>将其赋值为NULL</li>
</ul>
</li>
</ul>
<p><strong>如果对象没有引用，那么对象的存在毫无意义，不过是白白浪费空间罢了。</strong></p>
<p>一旦对象失去了它的引用，即其就此无法取得了，那么GC(垃圾收集器)就会知道该如何处理。</p>
]]></content>
      <tags>
        <tag>Talkng about GC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2022/02/01/SpringMVC/</url>
    <content><![CDATA[<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p><img src="https://s2.loli.net/2022/02/01/rqs2WMkTnNxFtGp.png" alt="image-20220201160516467"></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="MVC的定义"><a href="#MVC的定义" class="headerlink" title="MVC的定义"></a>MVC的定义</h2><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分。</p>
<h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>Model，模型层，指工程中的JavaBean，作用是处理数据。</p>
<h4 id="JavaBean的两类"><a href="#JavaBean的两类" class="headerlink" title="JavaBean的两类"></a>JavaBean的两类</h4><p>一类是实体类Bean：专门存储业务数据的属性和实例域，如User类等</p>
<p>一类是业务处理Bean：指Service或Dao对象，专门用于处理业务逻辑和数据访问</p>
<h3 id="V"><a href="#V" class="headerlink" title="V"></a>V</h3><p>View，视图层，指工程中的html或jsp等页面，作用是，直接与用户交互，展示数据</p>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>Controller，控制层，指工程中的Servlet，作用是接受请求和响应浏览器。</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>用户通过View层发送请求到服务器，在服务器中，请求被Controller层接收，调用相应的Model层，处理请求。完毕后，将处理结果返回给Controller层，Controller层再根据请求处理的结果，找到相应的View层，响应给浏览器，展示到用户。</p>
<h2 id="SpringMVC的定义"><a href="#SpringMVC的定义" class="headerlink" title="SpringMVC的定义"></a>SpringMVC的定义</h2><p>SpringMVC是Spring的一个后续产品，是Spring的一个子项目。</p>
<p>其是Spring为表述层开发提供的一个一整套完备的解决方案。</p>
<h3 id="SpringMVC的特点"><a href="#SpringMVC的特点" class="headerlink" title="SpringMVC的特点"></a>SpringMVC的特点</h3><ul>
<li>Spring家族原生产品，与IOC容器等基础设施无缝对接</li>
<li>基于原生的Servlet，通过功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理，不用自己写Servlet语法的代码</li>
<li>表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案</li>
<li>代码简洁，大幅提升开发效率</li>
<li>内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相关组件即可</li>
<li>性能显著</li>
</ul>
<h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><h2 id="1-创建maven工程"><a href="#1-创建maven工程" class="headerlink" title="1. 创建maven工程"></a>1. 创建maven工程</h2><p>pom.xml：</p>
<ul>
<li><p>打包方式</p>
</li>
<li><p>引入依赖</p>
</li>
<li>增加web模块(webapp这个Directory和web.xml)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;TestMaven&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.test.mvc&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springMVC&lt;/artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- SpringMVC --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">5.3</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 日志 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- ServletAPI --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">            &lt;!-- 表示当前的服务器中已经提供了servlet-api，不会存在于整合后的war包中 --&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Spring5和Thymeleaf整合包 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.0</span><span class="number">.12</span>.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;<span class="number">8</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;<span class="number">8</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<!-- 这表示当前的服务器中已经提供了servlet-api，不需要导入，也就是说，他不会存在于整合后的war包中 -->
<pre><code>        &lt;scope&gt;provided&lt;/scope&gt;
</code></pre><h3 id="依赖结果"><a href="#依赖结果" class="headerlink" title="依赖结果"></a>依赖结果</h3><p><img src="https://s2.loli.net/2022/02/01/PQUxFGAhluVaMRC.png" alt="image-20220201223036137"></p>
<h2 id="2-配置web-xml"><a href="#2-配置web-xml" class="headerlink" title="2. 配置web.xml"></a>2. 配置web.xml</h2><p>注册SpringMVC的前端控制器DispatcherServlet</p>
<h3 id="a-默认配置方式"><a href="#a-默认配置方式" class="headerlink" title="a. 默认配置方式"></a>a. 默认配置方式</h3><p>此配置作用下，SpringMVC的配置文件默认为与WEB-INF下，默认名称为<servlet-name>-servlet.xml。</p>
<p>例如，以下配置所对应SpringMVC的配置文件将位于WEB-INF下，文件名为SpringMVC-servlet.xml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        设置SpringMVC的核心控制器所能处理的请求的请求路径</span><br><span class="line">        / 能匹配的请求，可以是类似/login(/a之类)或.html或.js或.css方式的请求路径</span><br><span class="line">        但是不能匹配.jsp请求路径的请求，防止被作为一个普通请求被处理，无法显示.jsp界面</span><br><span class="line">        <span class="string">&quot;/*&quot;</span> 包括.jsp请求在内的所有请求</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<p>位置默认，名称默认，但在maven中，配置文件应当放在resource下，所以：</p>
<h3 id="b-拓展配置方式-常用"><a href="#b-拓展配置方式-常用" class="headerlink" title="b. 拓展配置方式(常用)"></a>b. 拓展配置方式(常用)</h3><p>配置SpringMVC配置文件的位置和名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;web-app xmlns=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="line">         version=<span class="string">&quot;4.0&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">        &lt;!-- 配置SpringMVC配置文件的位置和名称 --&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">        &lt;!-- 将前端控制器的初始化时间提前到服务器启动时，防止第一次访问时因加载过多，而影响访问速度 --&gt;</span><br><span class="line">        &lt;load-on-startup&gt;<span class="number">1</span>&lt;/load-on-startup&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>
<h2 id="3-创建请求控制器"><a href="#3-创建请求控制器" class="headerlink" title="3. 创建请求控制器"></a>3. 创建请求控制器</h2><p>由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理方式，因此需要创建处理具体请求的类，即请求控制器。</p>
<p>请求控制器中每一个处理请求的方法称为控制器方法。</p>
<p>因为SpringMVC的控制器由一个POJO(普通Java类)担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给IOC容器管理，此时SoringMVC才能识别控制器的存在。</p>
<h2 id="4-新建SpringMVC的配置文件"><a href="#4-新建SpringMVC的配置文件" class="headerlink" title="4. 新建SpringMVC的配置文件"></a>4. 新建SpringMVC的配置文件</h2><p>包括视图解析器和组件扫描器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.mvc.controller&quot;</span>&gt;&lt;/context:component-scan&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;!-- 配置Thymeleaf视图解析器 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;viewResolver&quot;</span> class=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 视图解析的优先级 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;order&quot;</span> value=<span class="string">&quot;1&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;characterEncoding&quot;</span> value=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;templateEngine&quot;</span>&gt;</span><br><span class="line">            &lt;bean class=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;templateResolver&quot;</span>&gt;</span><br><span class="line">                    &lt;!-- 解析策略 --&gt;</span><br><span class="line">                    &lt;bean class=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span><br><span class="line">                        &lt;!-- 视图前缀 --&gt;</span><br><span class="line">                        &lt;property name=<span class="string">&quot;prefix&quot;</span> value=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span><br><span class="line">                        &lt;!-- 视图后缀 --&gt;</span><br><span class="line">                        &lt;property name=<span class="string">&quot;suffix&quot;</span> value=<span class="string">&quot;.html&quot;</span>/&gt;</span><br><span class="line">                        &lt;property name=<span class="string">&quot;templateMode&quot;</span> value=<span class="string">&quot;HTML5&quot;</span>/&gt;</span><br><span class="line">                        &lt;property name=<span class="string">&quot;characterEncoding&quot;</span> value=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span><br><span class="line">                    &lt;/bean&gt;</span><br><span class="line">                &lt;/property&gt;</span><br><span class="line">            &lt;/bean&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h2 id="5-测试HelloWorld"><a href="#5-测试HelloWorld" class="headerlink" title="5. 测试HelloWorld"></a>5. 测试HelloWorld</h2><p><img src="https://s2.loli.net/2022/02/02/uBiXqUbThdQwjmL.png" alt="image-20220202220621011"></p>
<p><img src="https://s2.loli.net/2022/02/02/TLouqwFOvmsd3A9.png" alt="image-20220202222041226"></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址与控制器的@RequestMapping注解的value属性值进行匹配。若匹配成功，该注解所标识的控制器方法，就是处理请求的方法。处理请求的方法，需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图对应页面。</p>
<ol>
<li>在pom中配置包名、依赖名和版本号，引入相关依赖</li>
<li>创建webapp这个Directry和web.xml配置文件，并配置SpringMVC配置文件的位置和名称</li>
<li>在SpringMVC中配置前端控制器(和视图解析器)。</li>
<li>建立前端控制器类和相关.html等文件</li>
</ol>
<h1 id="RequestMapping注解"><a href="#RequestMapping注解" class="headerlink" title="@RequestMapping注解"></a>@RequestMapping注解</h1><p>设置的属性越多，要匹配所需的条件越多，匹配得越精确。</p>
<h2 id="注解的功能"><a href="#注解的功能" class="headerlink" title="注解的功能"></a>注解的功能</h2><p>@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系，要保证请求对应的地址是唯一的(只能存在一个@RequestMapping(/target))</p>
<p>SpringMVC接收到指定的请求，就会找到映射关系中对应的控制器方法来处理这个请求。</p>
<h2 id="注解的位置"><a href="#注解的位置" class="headerlink" title="注解的位置"></a>注解的位置</h2><p>@RequestMapping标识一个类：设置映射请求的请求路径的初始信息</p>
<p>@RequestMapping标识一个方法：设置映射请求的请求路径的具体信息</p>
<p><img src="https://s2.loli.net/2022/02/02/3aqkhF9rJLgSlv6.png" alt="image-20220202234334175"></p>
<p><img src="https://s2.loli.net/2022/02/02/XwRgHEvnBlmjo41.png" alt="image-20220202234417856"></p>
<h2 id="注解的value属性"><a href="#注解的value属性" class="headerlink" title="注解的value属性"></a>注解的value属性</h2><p>@RequestMapping注解的value属性，通过请求的请求地址匹配请求映射</p>
<p>@RequestMapping注解的value属性，是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</p>
<p>@RequestMapping注解的value属性，必须设置，至少通过地址匹配请求映射</p>
<p><img src="https://s2.loli.net/2022/02/03/ZeKs7WV69M4CfbO.png" alt="image-20220203232143281"></p>
<h2 id="注解的method属性"><a href="#注解的method属性" class="headerlink" title="注解的method属性"></a>注解的method属性</h2><p>@RequestMapping注解的method属性通过请求的方式(get或post)匹配请求映射(超链接发送的是get请求)</p>
<p>@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能匹配多种请求方式的请求</p>
<p><img src="https://s2.loli.net/2022/02/04/xQWbVFaI2YkeKMr.png" alt="image-20220204182816755"></p>
<p><strong>在默认的情况下，即不设置method属性时，post和get都支持；但设置完之后，只支持设置的那个方式。</strong></p>
<p>若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported</p>
<p><img src="https://s2.loli.net/2022/02/04/OqnPmQxWXDToGHJ.png" alt="image-20220204182905633"></p>
<p><img src="https://s2.loli.net/2022/02/04/Uk1dpJwjV47YToO.png" alt="image-20220204182957386"></p>
<p>上边可行，下边不可行。</p>
<blockquote>
<ol>
<li>对于处理请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解</li>
</ol>
<ul>
<li>处理get请求：@GetMapping</li>
<li>处理post请求：@PostMapping</li>
<li>处理put请求：@PutMapping</li>
<li>处理delete请求：@DeleteMapping</li>
</ul>
<p>常用的请求方式：get、post、put、delete</p>
<ol>
<li>但目前只支持get和post，若设置了其他表单提交的请求方式，则按照默认的get方式处理。</li>
</ol>
</blockquote>
<h2 id="注解的params属性-了解"><a href="#注解的params属性-了解" class="headerlink" title="注解的params属性(了解)"></a>注解的params属性(了解)</h2><p><img src="https://s2.loli.net/2022/02/04/Qt6ZquWkBxh5G9c.png" alt="image-20220204194532789"></p>
<h2 id="SpringMVC支持ant风格的路径"><a href="#SpringMVC支持ant风格的路径" class="headerlink" title="SpringMVC支持ant风格的路径"></a>SpringMVC支持ant风格的路径</h2><h3 id="："><a href="#：" class="headerlink" title="?："></a>?：</h3><p>表示任意的单个字符</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>这个字符不能是?：在地址栏中，?后匹配的是请求参数(也就是get方式提交数据时的情况)，如果是?，那么路径就只剩下请求中前边那个字符了。</p>
<p><img src="https://s2.loli.net/2022/02/04/6xgjGLtJTF9sDh7.png" alt="image-20220204215412314"></p>
<p>也不能是“/”：在路径中是路径分隔符</p>
<h3 id="：-1"><a href="#：-1" class="headerlink" title="*："></a>*：</h3><p>表示任意的0个或多个字符</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>上边两个依旧成立</p>
<h3 id="：-2"><a href="#：-2" class="headerlink" title="**："></a>**：</h3><p>表示任意的一层或多层目录</p>
<h4 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h4><p>使用时，只能用/**/xxx的方式</p>
<p>也就是说，不能是/a**a/xxx这个样子，否则</p>
<p>会被当做两个”*”占位符来使用。</p>
<h2 id="SpringMVC支持路径中的占位符"><a href="#SpringMVC支持路径中的占位符" class="headerlink" title="SpringMVC支持路径中的占位符"></a>SpringMVC支持路径中的占位符</h2><h3 id="原始方式"><a href="#原始方式" class="headerlink" title="原始方式"></a>原始方式</h3><h4 id="deleteUser-id-1"><a href="#deleteUser-id-1" class="headerlink" title="/deleteUser?id=1"></a>/deleteUser?id=1</h4><h3 id="rest方式"><a href="#rest方式" class="headerlink" title="rest方式"></a>rest方式</h3><h4 id="deleteUser-1"><a href="#deleteUser-1" class="headerlink" title="/deleteUser/1"></a>/deleteUser/1</h4><p>SpringMVC路径中的占位符常用于restful风格中，当<strong>请求路径中将某些数据通过路径的方式</strong>传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符(xxx)表示传输的数据，再通过@PathVariable注解，将占位符所表示的数据，赋值给控制方法的形参。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送请求的格式</span></span><br><span class="line">&lt;a th:href=<span class="string">&quot;@&#123;/a1/target/1/admin&#125;&quot;</span>&gt;访问路径占位符**时&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制器中的请求映射格式</span></span><br><span class="line"> <span class="meta">@RequestMapping(&quot;/a1/target/&#123;id&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">target</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id, <span class="meta">@PathVariable(&quot;username&quot;)</span>String username)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id: &quot;</span> + id + <span class="string">&quot; username: &quot;</span> + username);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/02/04/iDfhW1lpAoVa4BQ.png" alt="image-20220204230621610"></p>
<h1 id="SpringMVC获取请求参数"><a href="#SpringMVC获取请求参数" class="headerlink" title="SpringMVC获取请求参数"></a>SpringMVC获取请求参数</h1><h2 id="通过ServletAPI获取-一般不用"><a href="#通过ServletAPI获取-一般不用" class="headerlink" title="通过ServletAPI获取(一般不用)"></a>通过ServletAPI获取(一般不用)</h2><p>因为SpringMVC中，已经封装了相关的ServletAPI的内容，并且提供了更为简洁的方式去调用，所以尽量不用原生的ServletAPI。</p>
<p>将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数，表示封装了当前请求的请求报文的对象。</p>
<p><img src="https://s2.loli.net/2022/02/05/vh9AY3Fa2TO1DwU.png" alt="image-20220205231831742"></p>
<p>因为，DispatcherController会根据当前其所包含数据，自动为控制器方法(@RequestMapping注解的方法)的参数赋值。</p>
<p>但此时，不能使用占位符{}了，因为request.getParameter( )方法，只能根据name来获取value。若是占位符的话，只有值value，没有name，导致方法无法使用。</p>
<h2 id="通过控制器方法的形参获取请求参数"><a href="#通过控制器方法的形参获取请求参数" class="headerlink" title="通过控制器方法的形参获取请求参数"></a>通过控制器方法的形参获取请求参数</h2><p>在控制器方法的形参位置，<strong>设置和请求参数同名的形参</strong>(不同名则无法获取到)，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参。</p>
<p><img src="https://s2.loli.net/2022/02/06/RcNvH2VFSqgTMAD.png" alt="image-20220206233040577"></p>
<p><img src="https://s2.loli.net/2022/02/06/MuETIB9ALP8DOVU.png" alt="image-20220206233218936"></p>
<p><img src="https://s2.loli.net/2022/02/06/nE14u8U29oWLbiF.png" alt="image-20220206233326972"></p>
<p><img src="https://s2.loli.net/2022/02/06/1qiVUuDcRErhCm5.png" alt="image-20220206233236981"></p>
<blockquote>
<h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><p>单个请求参数直接获取即可</p>
<p>若为多个同名的请求参数，可以使用字符串类型(逗号分隔开请求参数的每一个值)或字符串数组类型(用Arrays.toString( )方法输出)。</p>
</blockquote>
<h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2>]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>cache</title>
    <url>/2021/10/31/cache/</url>
    <content><![CDATA[<h1 id="cache存储器"><a href="#cache存储器" class="headerlink" title="cache存储器"></a>cache存储器</h1><h2 id="一-背景"><a href="#一-背景" class="headerlink" title="一  背景"></a>一  背景</h2><p>在计算机系统中，CPU的工作速度远超主存储器的工作速度。一方面，因为高速的静态存储器芯片因为容量小且价格高，并不适合组成大容量的主存储器，故而主存储器一般采用动态存储器实现。但由于其读取速度慢，一定程度上限制了CPU的工作速度。另一方面，通过大量统计发现，程序对存储空间的90%的访问局限于存储空间10%的区域，另外10%的访问则分布在存储空间的90%的区域中。</p>
<p>所谓，时势造英雄。为了中和CPU和主存之间速度的不匹配，诞生了cache这一重要的技术。</p>
<h2 id="二-简介"><a href="#二-简介" class="headerlink" title="二  简介"></a>二  简介</h2><h3 id="1-功能"><a href="#1-功能" class="headerlink" title="1  功能"></a>1  功能</h3><p>cache是介于CPU和主存之间的小容量存储器，存取速度比主存块。它能高速地向CPU提供指令和数据，加快程序的执行速度。它的内容为主存一部分内容的副本。当储存器收到读取指令时，先在cache中查找此信息是否存在，若有，则不经主存，直接从cache中取出，否则直接从主存中取出，同时写出cache，以备再次使用。</p>
<h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2  原理"></a>2  原理</h3><p>CPU与cache之间的数据交换是==以字为单位==，而cache与主存之间的数据交换是==以块为单位==。一个块由若干定长字组成。当CPU读取主存中的一个字时，便发出<strong>此字的地址到cache和主存</strong>。此时cache控制逻辑，依据地址判断此字是否在cache中，若是，此字立即传送给CPU；若非，则用主存读周期把此字从主存读出送到CPU，与此同时，把含有这个字的<strong>整个数据块</strong>从主存读出送到cache中。</p>
<h3 id="3-工作过程"><a href="#3-工作过程" class="headerlink" title="3  工作过程"></a>3  工作过程</h3><p>1.当CPU执行访问指令时，将所要访问的字的地址送到相联存储器(cam)中和主存。</p>
<p>2.在相联存储器中进行地址查找，若相联存储器指出，所要访问的字W在cache中(命中)，则把W直接由cache送入CPU；反之(不命中)，则从主存中读取W，送入CPU，顺便把包含W在内的4个字(一个块)送入cache。(分配给cache的地址，保存在相联存储器(cam)中，它是按照内容寻址的。)</p>
<h3 id="4-cache的命中率"><a href="#4-cache的命中率" class="headerlink" title="4  cache的命中率"></a>4  cache的命中率</h3><p>增加cache的目的，就是在性能上使主存的平均读出时间尽可能接近cache的读出时间。因此，cache的命中率应接近于1。在一个程序执行期间，设Nc表示cache完成存取的次数，Nm表示主存完成存取的总次数，H定义为命中率，则有：</p>
<script type="math/tex; mode=display">
H=Nc/(Nc+Nm)</script><p>若tc表示命中时cache访问时间，tm表示未命中时的主存访问时间，则cache/贮存系统的平均访问时间ta为：</p>
<script type="math/tex; mode=display">
ta=tc*H+(1-H)*tm</script><script type="math/tex; mode=display">
r=tm/tc表示主存慢于cache的倍率，e=tc/ta表示访问效率</script><p>为提高访问效率，命中率H越接近于1越好，r值以5-10为宜，不宜过大。</p>
<p>注：</p>
<ul>
<li>命中率与程序的行为、cache的容量、组织方式、块的大小有关。</li>
<li>程序的行为：程序顺序执行最佳。</li>
<li>cache的容量：容量越大，可存放的部分复本越多，调进调出的动作少。</li>
<li>组织方式：cache与主存的相连方式影响调进调出的次数。</li>
<li>块的大小：块太小，块太大都影响调进调出的次数。</li>
</ul>
<h3 id="5-主存与cache的地址映射"><a href="#5-主存与cache的地址映射" class="headerlink" title="5  主存与cache的地址映射"></a>5  主存与cache的地址映射</h3><p>cache的容量很小，它保存的内容只是主存内容的一个子集，且cache与主存的数据交换是以块为单位。</p>
<p>地址映射即是应用某种方法把主存地址定位到cache中。地址映射的方式有<strong>全相联方式、直接映射方式和组相联方式三种。</strong></p>
<h4 id="1-全相联方式"><a href="#1-全相联方式" class="headerlink" title="1. 全相联方式"></a>1. 全相联方式</h4><p>主存中的一个<strong>块的地址与块的内容</strong>一起存于cache的行中，其中<strong>块地址存于cache行的标记部分</strong>中，是由于此种方式，内存中的块可以映射到cache任意一行中。块的大小 = 行的大小。但注意，若以内存一块256字为例，则cache一行长度不仅保存了内存的地址，还有该地址对应的内容，即其实保存了521字的内容，但其可用大小应为256×行数。因为地址固定时，内容就固定了，没有可变性，故而不能是521×块数，没有那么多可用的。由于其电路设计复杂，更多用于小容量cache。<img src="https://s2.loli.net/2021/12/22/dmGe41p2RknPCAt.png" alt="image-20211031151344855"></p>
<h4 id="2-直接映射方式"><a href="#2-直接映射方式" class="headerlink" title="2. 直接映射方式"></a>2. 直接映射方式</h4><p>这也是一种多对一的映射关系，但一个主存块只能拷贝到cache的一个特定行位置上去。cache的行号i和主存的块号j有如下函数关系：</p>
<script type="math/tex; mode=display">
i=j (mod) m(m为cache的行数)</script><p><img src="https://s2.loli.net/2021/12/22/2AgZ6BmErHPQC1M.png" alt="image-20211031151518192"></p>
<p>注意比较的顺序，另外由于几个内存块对应同一行，容易发生空间冲突。适合于大容量cache。</p>
<h4 id="3-组相联映射"><a href="#3-组相联映射" class="headerlink" title="3.组相联映射"></a>3.组相联映射</h4><p>将cache分为u组，每组v行，主存块存放到哪个组是固定的(直接映射方式)，至于存放到该组哪一行，是灵活的(全相联映射方式)。</p>
<p><img src="https://s2.loli.net/2021/12/22/btAswxjhvFGR92y.png" alt="image-20211031152253327"></p>
<p>注意比较的顺序。</p>
<h3 id="6-替换策略"><a href="#6-替换策略" class="headerlink" title="6  替换策略"></a>6  替换策略</h3><p>cache的工作原理要求其尽可能保存最新的数据，则必然存在将有用的信息从主存调入cache，这样就产生替换。</p>
<blockquote>
<p><strong><em>针对直接映射的cache来说，因为其在cache中的位置是固定的，故而只需把特定位置上的原主存块换出cache即可，将新增信息调进即可。</em></strong></p>
</blockquote>
<p>对<strong>全相联和组相联的cache而言</strong>，就要从允许存放新主存块的若干特定行中选取一行换出，这就涉及到常用的替换算法了。</p>
<h4 id="1-最不长使用法-类似队列先进先出-："><a href="#1-最不长使用法-类似队列先进先出-：" class="headerlink" title="1.最不长使用法(类似队列先进先出)："></a>1.最不长使用法(类似队列先进先出)：</h4><p>将一段时间内，访问次数最少的那行数据换出。即每行设置一计数器，每访问一次，就增加一次计数，最后替换计数最小的一行。</p>
<h4 id="2-近期最少使用法-LRU"><a href="#2-近期最少使用法-LRU" class="headerlink" title="2.近期最少使用法(LRU):"></a>2.近期最少使用法(LRU):</h4><p>将近期长久未被访问过的那行数据换出。即每行设置一计数器，每访问一次，就将所访问者计数器清零，其他计数值加1，最后替换计数最大的一行(可用<em>标记许久未使用的行，<em>*常用</em></em>)。</p>
<h3 id="7-cache的写操作策略"><a href="#7-cache的写操作策略" class="headerlink" title="7  cache的写操作策略"></a>7  cache的写操作策略</h3><p>CPU对cache的写入，更改了cache的内容。为保持主存与cache中信息的一致性，避免CPU在读写过程中，将cache中的新数据遗失，造成错误的读数据，确保cache中数据不会因覆盖而消失，必须将cache中的数据更新及时反映到主存中。</p>
<p>可选用三种写操作策略，以使cache内容和主存内容保持一致。</p>
<h4 id="1-写回法-回写式"><a href="#1-写回法-回写式" class="headerlink" title="1.写回法(回写式)"></a>1.写回法(回写式)</h4><p>​    当CPU写cache命中时，只修改cache内容，而不立即写入内存，只有当此行(块)被换出时，才写回内存。</p>
<p>这种方法减少了CPU访问内存的次数，但存在内存不一致的隐患。</p>
<p>实现这种方法时，每一个cache须设置一个修改位，以反映此行是否被CPU修改过。(常用)</p>
<h4 id="2-全写法-直写式"><a href="#2-全写法-直写式" class="headerlink" title="2.全写法(直写式)"></a>2.全写法(直写式)</h4><p>​    当写cache命中时，cache与主存同时发生写修改，因而较好维护了cache与主存内容的一致性。</p>
<p>当写cache未命中时，直接向主存中写入。cache每行无需设置修改位以及相应的判断逻辑。此时可将修改内容调进cache中，也可不调进。</p>
<p>减弱了cache的效果。</p>
<h4 id="3-写一次法-缓冲直写式"><a href="#3-写一次法-缓冲直写式" class="headerlink" title="3.写一次法(缓冲直写式)"></a>3.写一次法(缓冲直写式)</h4><p>两种方法的结合。写命中与写未命中与写回法相同。只是第一次写命中时，会启动一个存储写周期，即同时写入主存，而其他cache块监听到此周期时，也顺便更新自身该数据块数据。便于维护系统中所有cache的一致性。(奔腾CPU采用)</p>
]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>The-core-of-Java</title>
    <url>/2022/01/01/The-core-of-Java/</url>
    <content><![CDATA[<h1 id="第四章-对象与类"><a href="#第四章-对象与类" class="headerlink" title="第四章 对象与类"></a>第四章 对象与类</h1><h2 id="第一节-面向对象程序设计概述"><a href="#第一节-面向对象程序设计概述" class="headerlink" title="第一节 面向对象程序设计概述"></a>第一节 面向对象程序设计概述</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类使构造对象的模板或蓝图。可以将类想象成制作小甜饼的切割机，将对象想象为小甜饼。由类构造对象的过程称为创建类的实例。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>(有时称为数据隐藏)是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在一个包里，并对对象的使用者隐藏了数据的实现方式。对象中的数据称为实例域，操纵数据的过程成为方法。对每个特定的类实例(对象)都有一组特定的实例域值。这些值的集合就是这个对象的当前状态。不管何时，只要向对象发送一个消息，他的状态就有可能发生改变。</p>
<p><strong>实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。</strong></p>
<p>这意味着一个类可以全面地改变存储数据的方式，只要仍然使用同样的方法操作数据，其他对象就不会知道或介意所发生的变化。</p>
<p>OOP的另一个原则会让用户自定义Java类变得轻而易举，这就是：可以通过扩展一个类来建立另一个新的类。事实上，在Java中，所有的类都源自于一个“超类”，他就是Object。</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="对象的三个主要特性："><a href="#对象的三个主要特性：" class="headerlink" title="对象的三个主要特性："></a>对象的三个主要特性：</h4><ul>
<li>对象的行为(behavior) —— 可以对对象施加哪些操作，或可以对对象施法哪些方法？</li>
<li>对象的状态(state) —— 当施加那些方法时，对象如何响应？</li>
<li>对象标识(identity) —— 如何辨别具有相同行为与状态的不同对象？</li>
</ul>
<p>同一个类的所有对象实例，由于支持相同的行为而具有家族式的相似性。对象的行为是用可调用的方法定义的。</p>
<p>此外，每个对象都保存着描述当前特征的信息。这就是对象的装填。对象状态的改变必须通过调用方法实现(如果不经过方法调用就可以改变对象的状态，只能说明封装性遭到了破坏)。</p>
<p>但是，对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份(identity)。也就是说，作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。</p>
<h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>在类之间，最常见的关系有</p>
<ul>
<li>依赖(“uses-a”)</li>
<li>聚合(“has-a”)</li>
<li>继承(“is-a”)</li>
</ul>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>即”uses-a”关系，是一种最明显的、最常见的关系。例如，Order(订单)类使用Account(账户)类是因为Order对象需要访问Account对象查看信用状态。但是Item类不依赖于Account类，这是因为Item对象与客户账户无关。因此，如果一个类的方法操纵另一个类的对象，就说一个类依赖于另一个类。</p>
<p>应该尽可能地将相互依赖的类减至最少。就是让类之间的耦合度最小。</p>
<h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>即”has-a”关系，是一种具体且易于理解的关系。例如，一个Order对象包含一些Item(商品)类。</p>
<p>聚合关系意味着类A的对象包含类B的对象。</p>
<blockquote>
<p>有些方法学家，会更喜欢使用“关联”这个术语，而不喜欢聚合这个概念。</p>
</blockquote>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>即“is-a”关系，是一种用于表示特殊与一般关系的。例如，RushOrder类由Order类继承而来。在具有特殊性的RushOrder类中包含了一些用于优先处理的特殊方法，以及一个计算运费的不同方法。</p>
<h2 id="第二讲-使用预定义类"><a href="#第二讲-使用预定义类" class="headerlink" title="第二讲 使用预定义类"></a>第二讲 使用预定义类</h2><h3 id="更改器方法与访问器方法"><a href="#更改器方法与访问器方法" class="headerlink" title="更改器方法与访问器方法"></a>更改器方法与访问器方法</h3><p><code>LocalDate aThousandDaysLater = newYearsEve.plusDays(1000);</code></p>
<p>这个调用之后newYearsEve会有什么变化？他会改为1000天之后的日期吗？事实上，并没有。plusDays方法会生成一个新的LocalDate对象，然后把这个新对象赋给aThousandDaysLater变量。原来的对象不做任何改动。也就是说plusDays方法没有更改调用这个方法的对象。</p>
<p>则称，只访问对象而不修改对象的方法为<strong>访问器方法</strong>(accessor method)。</p>
<p><strong>更改器方法</strong>(mutator method)调用后，对象的状态会发生改变。</p>
<h2 id="第三讲-用户自定义类"><a href="#第三讲-用户自定义类" class="headerlink" title="第三讲 用户自定义类"></a>第三讲 用户自定义类</h2><h3 id="隐式参数与显式参数"><a href="#隐式参数与显式参数" class="headerlink" title="隐式参数与显式参数"></a>隐式参数与显式参数</h3><p>方法用于操作对象以及存取它们的实例域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">raiseSalary</span> <span class="params">(<span class="type">double</span> byPercent)</span> &#123;</span><br><span class="line">	<span class="type">double</span> <span class="variable">raise</span> <span class="operator">=</span> salary * byPercent/ <span class="number">100</span>;</span><br><span class="line">    salary = raise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有两个参数。第一个参数称为隐式(implicit)参数，是出现在方法名前面Employee对象。第二个参数是位于方法名后面括号中的数值，这是一个显式(explicit)参数。(隐式参数也就是方法调用的目标或接收者)</p>
<h3 id="封装的优点"><a href="#封装的优点" class="headerlink" title="封装的优点"></a>封装的优点</h3><p><code>public double getSalary() &#123;return salary;&#125;</code></p>
<p>如上是典型的访问器方法。由于它们只返回实例域值，因此又称为域访问器。</p>
<p>那将salary域标记为public，以此来取代独立的访问器方法呢？</p>
<p>假如salary是一个只读域，那么一旦在构造器中设置完毕，就没有任何一个方法可以对它进行修改，这样来确保salary域不会受到外界的破坏。</p>
<p>不过，虽然salary不是只读域，但是它只能用raiseSalary方法修改。特别是一旦这个域值出现了错误，只要调试这个方法就可以了。如果salary域是public的，破坏这个域值的捣乱者有可能会出没在任何地方。</p>
<p>在有些时候，需要获得或设置实例域的值。因此，应该提供下面三项内容：</p>
<ul>
<li>一个私有的数据域；</li>
<li>一个公有的域访问器方法；</li>
<li>一个公有的域更改器方法。</li>
</ul>
<p>这样做要比提供一个简单的公有数据域复杂些。但是却有着下列明显的好处：</p>
<p>首先，可以改变内部实现，除了该类的方法之外，不会影响其他代码。</p>
<p>其次，更改器可以进行错误检查，防止一些不合理的赋值。</p>
<h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><p>尽管大多数方法都被设计为公有的，但在某些特殊的情况下，也可能将它们设定为私有的。有时，可能希望将一个计算代码划分成若干独立的辅助方法。通常，这些辅助方法不应该成为公有方法的一部分，这是由于它们往往与当前的实现机制非常紧密，或者需要一个特别的协议以及一个特别的调用次序，最好将这样的方法设计为private的。</p>
<p>对于私有方法，如果改用其它方法实现相应的操作，则不必保留原有方法。如果数据的表达方式发生了变化，这个方法可能就变得难以实现，或者不再需要。然而，只要方法是private，类的设计者就可以确认，<strong>它不会被外部的其他类操作调用，可以将其删除。</strong></p>
<h3 id="final实例域"><a href="#final实例域" class="headerlink" title="final实例域"></a>final实例域</h3><p>可以将一个实例域定义为final，构建对象时，必须初始化这样的域。也就是说，必须在确保一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。</p>
<p>final修饰符大都应用于基本(primitive)类型域，或不可变(immutable)类的域(如果类中的每个方法都不会改变其对象，这种类就是不可变的类。)。</p>
<p>如果final修饰的是类的话，也就表示，该引用变量不能再指向其他对象，但对象的值可以发生改变。</p>
<h2 id="第四讲-静态域与静态方法"><a href="#第四讲-静态域与静态方法" class="headerlink" title="第四讲 静态域与静态方法"></a>第四讲 静态域与静态方法</h2><h3 id="静态域-类域"><a href="#静态域-类域" class="headerlink" title="静态域(类域)"></a>静态域(类域)</h3><p>如果将域定义为static，每个类中只有一个这样的域。它属于类，而不属于任何一个独立的对象。</p>
<p>每个对象对于类的实例域都有自己的一份拷贝。如，100个对象，会有100个实例域，但只有1个静态域。</p>
<h3 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h3><p>静态变量用的比较少，但静态常量却用的多。例如：</p>
<p><img src="https://s2.loli.net/2022/01/03/A5zFJnPmtY7h64w.png" alt="image-20220103161658620"></p>
<p>一般来说，由于任何对象都可以对公有域进行修改，所以，最好不要将域设计为public，但公有常量(final域)却没有关系，因为此时，不允许再赋其他值给它。</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><strong>静态方法是一种不能向对象实施的方法</strong>。例如，Math类中的pow：<code>Math.pow(x,a)</code>，在运算时，不使用任何的Math对象。换句话说，没有隐式的参数。</p>
<h3 id="使用静态方法"><a href="#使用静态方法" class="headerlink" title="使用静态方法"></a>使用静态方法</h3><p>在下面两种情况下使用静态方法：</p>
<ul>
<li>一个方法不需要访问对象状态，其所需的参数都是通过显示参数提供的</li>
<li>一个方法只需要访问类的静态域</li>
</ul>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>静态方法还有另一个用途，类似LocalDate和NumberFormat的类使用静态工厂方法(factory method)来构造对象。如下所示，生成不同风格的格式化对象：</p>
<p><img src="https://s2.loli.net/2022/01/03/YHGeydBEaxTtRFn.png" alt="image-20220103163937139"></p>
<p>为什么不使用构造器？</p>
<ul>
<li>无法命名构造器。构造器的名字必须和类名相同。但是，这里希望将得到的货币实例和百分比实例采用不同的名字。</li>
<li>当使用构造器时，无法改变所构造的对象类型。而Factory方法将返回一个DecimalFormat类对象，这是NumberFormat的子类。</li>
</ul>
<h2 id="第五讲-方法参数"><a href="#第五讲-方法参数" class="headerlink" title="第五讲 方法参数"></a>第五讲 方法参数</h2><p>方法参数一共有两种类型：</p>
<ul>
<li>基本数据类型</li>
<li>对象引用</li>
</ul>
<p>对于Java而言，总是采用按值调用。</p>
<p>也就是说，一个方法不可能修改一个基本数据类型的参数。</p>
<p><img src="https://s2.loli.net/2022/01/03/py5Tt4QFhe6kUr3.png" alt="image-20220103165356193"></p>
<p>而对象引用作为参数就不同了。</p>
<p><img src="https://s2.loli.net/2022/01/03/gh1LAIFiPGyxBTu.png" alt="image-20220103165431987"></p>
<p>因为对象的空间是固定的，拷贝的是引用，二者同时引用同一个对象，即指向一个固定的堆空间。</p>
<p>但要记住，Java程序设计语言总是采用<strong>按值调用</strong>，不是类似C++中的引用。也就是说，传递的不是地址！若是直接将两个对象引用作为参数进行交换操作，并不能实现对象指向的交换。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>一个方法不能修改一个基本数据类型的参数(数值型或布尔型)</li>
<li>一个方法可以改变一个对象参数的状态</li>
<li>一个方法不能让对象参数引用一个新的对象</li>
</ul>
<h2 id="第六讲-对象构造"><a href="#第六讲-对象构造" class="headerlink" title="第六讲 对象构造"></a>第六讲 对象构造</h2><h3 id="显式域初始化"><a href="#显式域初始化" class="headerlink" title="显式域初始化"></a>显式域初始化</h3><p>通过重载类的构造器方法，可以采用多种形式设置类的实例域的初始状态。确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值，这是一种很好的设计习惯。</p>
<h3 id="调用另一个构造器"><a href="#调用另一个构造器" class="headerlink" title="调用另一个构造器"></a>调用另一个构造器</h3><p>关键字this引用方法的隐式参数。不过这个关键字还有另一个含义。</p>
<p>如果构造器的第一个语句形如this(…)，这个构造器将调用同一个类的另一个构造器。</p>
<p><img src="https://s2.loli.net/2022/01/03/INWmxkURs9B2tCY.png" alt="image-20220103202413693"></p>
<p>在调用这个方法时，该方法将去调用Employee(String, double)构造器。</p>
<p>这种方式使用this关键字非常有用，这样对公共的构造器代码部分只编写一次即可。</p>
<blockquote>
<p>但C++中，一个构造器不能调用另一个构造器。</p>
</blockquote>
<h3 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h3><h4 id="初始化数据域的方法"><a href="#初始化数据域的方法" class="headerlink" title="初始化数据域的方法"></a>初始化数据域的方法</h4><ul>
<li>在构造器中设置值</li>
<li>在声明中赋值</li>
<li>初始化块</li>
</ul>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。</p>
<p><img src="https://s2.loli.net/2022/01/03/7qXQc8sgJHDrL2w.png" alt="image-20220103203502225"></p>
<p>这种机制不是必需的，也不常见。通常会直接将初始化代码放在构造器中。</p>
<p><img src="https://s2.loli.net/2022/01/03/vYbOosAtuxQDmaX.png" alt="image-20220103204013531"></p>
<p>当然，应该精心地组织好初始化代码。</p>
<h3 id="静态域初始化"><a href="#静态域初始化" class="headerlink" title="静态域初始化"></a>静态域初始化</h3><ul>
<li>提供一个初始化值</li>
</ul>
<p><code>private static int nextId = 1;</code></p>
<ul>
<li>使用静态的初始化块</li>
</ul>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20220104011743662.png" alt="image-20220104011743662"></p>
<h3 id="对象析构与finalize方法"><a href="#对象析构与finalize方法" class="headerlink" title="对象析构与finalize方法"></a>对象析构与finalize方法</h3><p>在析构器中，最常见的操作是回收分配给对象的存储空间。由于Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器。</p>
<p>当然，某些对象使用了内存之外的其他资源，例如，文件或使用了系统资源的另一个对象的句柄。在这种情况下，当资源不再需要时，将其回收和再利用将显得十分重要。</p>
<p>可以为类添加一个finalize方法。finalize方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用finalize方法回收任何短缺资源，这是因为很难直到这个方法什么时候才能够调用。</p>
<p><strong>如果某个资源需要在使用完毕后立刻被关闭，那么就需要由人工来管理。对象用完时，可以应用一个close方法来完成相应的清理操作。</strong></p>
<h2 id="第七讲-包"><a href="#第七讲-包" class="headerlink" title="第七讲 包"></a>第七讲 包</h2><h3 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h3><p>Java允许将包(package)将类组织起来。</p>
<p>使用包的主要原因时去确保类名的唯一性。</p>
<p>在包中定位类是编译器(compiler)的工作。类文件中的字节码肯定使用完整的包名来引用其他类。</p>
<blockquote>
<p>关于C++中import和#include弄混。</p>
<p>实际上，这两者之间并没有共同之处。在C++中，必须使用#include将外部特性的声明加载进来，这是因为C++编译器无法查看任何文件的内部，除了正在编译的文件以及在头文件中明确包含的文件。Java编译器可以查看其他文件的内容，只要告诉它到哪里去查看就可以了。</p>
<p>在C++中，与包机制类似的是命名空间(namespace)。在Java中。package与import语句类似于C++中的namespace和using指令。</p>
</blockquote>
<h3 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h3><p>前面已经接触过访问修饰符public和private。标记为public的部分可以被任意的类使用，标记为private的部分只能被定义它们的类使用。</p>
<p><strong>如果没有指定public或private，这个部分(类、方法或变量)可以被同一个包的所有方法访问。</strong></p>
<h3 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1）把类放到一个目录中，例如/home/user/classdir。</p>
<p>需要注意，这个目录是包树状结构的基目录。如果希望将com.horstmann.corejava.Employee类添加到其中，这个Employee.class类文件就必须位于子目录/home/user/classdir/com/horstmann/corejava中。</p>
<p>2）将JAR文件放在一个目录中，例如：/home/user/archives。</p>
<p>3）设置类路径（class path）。类路径是所有包含类文件的路径的集合。</p>
<p>在UNIX环境中，类路径中的不同项目之间采用冒号（:)分隔：</p>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20220105154939555.png" alt="image-20220105154939555"></p>
<p>在上述两种情况中，句点（.）表示当前目录。</p>
<p>类路径包括：</p>
<p>●  基目录/home/user/classdir或c:\classes；</p>
<p>●  当前目录(.)；</p>
<p>●  JAR文件/home/user/archives/archive.jar或c:\archives\archive.jar。</p>
<h2 id="第九讲-文档注释"><a href="#第九讲-文档注释" class="headerlink" title="第九讲 文档注释"></a>第九讲 文档注释</h2><h3 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h3><p>每个方法注释必须放在所描述的方法之前。</p>
<p>除了通用标记之外，还可以使用下面的标记：</p>
<ul>
<li>@param 变量描述</li>
</ul>
<p>这个标记将对当前方法的“param”(参数)部分参加一个条目。这个描述可以占据多行，并可以使用HTML标记。一个方法的所有的@param标记必须放在一起。</p>
<ul>
<li>@return 描述</li>
</ul>
<p>这个标记将对当前添加”return”(返回)部分。这个描述可以跨越多行，并可以使用HTML标记。</p>
<ul>
<li>@throws 类描述</li>
</ul>
<p>这个标记将添加一个注释，用于表示这个方法可能抛出异常。</p>
<p><img src="https://s2.loli.net/2022/01/05/jDElf7oyhQ3ZTrv.png" alt="image-20220105160743393"></p>
<p><img src="https://s2.loli.net/2022/01/05/we6qAjmNELdGviu.png" alt="image-20220105161216316"></p>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20220105161131526.png" alt="image-20220105161131526"></p>
<h3 id="域注释"><a href="#域注释" class="headerlink" title="域注释"></a>域注释</h3><p><img src="https://s2.loli.net/2022/01/05/dGbf7SkvEDAqYpJ.png" alt="image-20220105161654770"></p>
<h3 id="通用注释"><a href="#通用注释" class="headerlink" title="通用注释"></a>通用注释</h3><ul>
<li>@author 姓名</li>
</ul>
<p>这个标记将产生一个”author”(作者)条目。可以使用多个@author标记，每个@author标记对应一个作者。</p>
<ul>
<li>@version 文本</li>
</ul>
<p>这个标记将产生一个“version”(版本)条目。这里的文本可以是对当前版本的任何描述。</p>
<h4 id="下面的标记可以用于所有的文档注释"><a href="#下面的标记可以用于所有的文档注释" class="headerlink" title="下面的标记可以用于所有的文档注释"></a>下面的标记可以用于所有的文档注释</h4><ul>
<li>@since 文本</li>
</ul>
<p>这个标记将产生一个“since”(始于)条目。这里的text可以是对引入特性的版本描述。例如，@since version 1.7.1。</p>
<ul>
<li>@deprecated文本</li>
</ul>
<p>这个标记将对类、方法或变量天机一个不再使用的注释。文本中给出了取代的建议。</p>
<p><img src="https://s2.loli.net/2022/01/05/kG4KaUy9HYEJdMR.png" alt="image-20220105162315965"></p>
<p><img src="https://s2.loli.net/2022/01/05/X3oF6BbLTYkrGgQ.png" alt="image-20220105162409646"></p>
<h2 id="类设计的技巧"><a href="#类设计的技巧" class="headerlink" title="类设计的技巧"></a>类设计的技巧</h2><h3 id="1-一定要保证数据私有"><a href="#1-一定要保证数据私有" class="headerlink" title="1. 一定要保证数据私有"></a>1. 一定要保证数据私有</h3><p>这是最重要的！</p>
<p><strong>绝对不要破坏封装性。有时候，需要编写一个访问器方法或更改器方法，但是最好还是保持实例域的私有性。</strong></p>
<p>很多惨痛的经验告诉我们，数据的表示形式很可能会改变，但他们的使用方式却不会经常发生变化。</p>
<p>当数据保持私有时，他们的表示形式的变化不会对类的使用者产生影响，即使出现bug也易于检测。</p>
<h3 id="2-一定要对数据初始化"><a href="#2-一定要对数据初始化" class="headerlink" title="2. 一定要对数据初始化"></a>2. 一定要对数据初始化</h3><p>Java不对局部变量进行初始化，但是会对对象的实力域进行初始化。最好不要依赖于系统的默认值，而是应该显式地初始化所有的数据。</p>
<p>具体的初始化方式可以是提供默认值，也可以是在所有构造器中设置默认值。</p>
<h3 id="3-不要在类中使用过多的基本类型"><a href="#3-不要在类中使用过多的基本类型" class="headerlink" title="3. 不要在类中使用过多的基本类型"></a>3. 不要在类中使用过多的基本类型</h3><p>就是说，用其他的类代替多个相关的基本类型的使用。</p>
<p>这样会使类更加易于理解且易于修改。</p>
<p><img src="https://s2.loli.net/2022/01/05/J4oiebVBCzvHKFk.png" alt="image-20220105163502555"></p>
<h3 id="4-不是所有的域都需要独立的域访问器和域更改器"><a href="#4-不是所有的域都需要独立的域访问器和域更改器" class="headerlink" title="4. 不是所有的域都需要独立的域访问器和域更改器"></a>4. 不是所有的域都需要独立的域访问器和域更改器</h3><p>或许，需要获得或设置雇员的薪金。而一旦构造了雇员对象，就应该禁止更改雇佣日期，并且在对象中，常常包含一些不希望别人获得或设置的实例域。</p>
<h3 id="5-将职责过多的类进行分解"><a href="#5-将职责过多的类进行分解" class="headerlink" title="5. 将职责过多的类进行分解"></a>5. 将职责过多的类进行分解</h3><p>这样说似乎有点含糊不清。</p>
<p>但是，如果明显地可以将一个复杂的类分解成两个更为简单的类，就应该将其分解。</p>
<h3 id="6-类名和方法名要能够体现它们的职责"><a href="#6-类名和方法名要能够体现它们的职责" class="headerlink" title="6. 类名和方法名要能够体现它们的职责"></a>6. 类名和方法名要能够体现它们的职责</h3><p>与变量应该有一个能够反映其含义的名字一样，类也能如此。</p>
<p>命名类名的良好习惯是采用一个名词(Order)、前面有形容词修饰的名词(RushOrder)或动名词(有“-ing”后缀)修饰名词(例如，BillingAddress)。</p>
<p>对于方法来说，习惯是访问器方法用小写get开头(getSalary)，更改器方法用小写的set开头(setSalary)。</p>
<h3 id="7-优先使用不可变的类"><a href="#7-优先使用不可变的类" class="headerlink" title="7. 优先使用不可变的类"></a>7. 优先使用不可变的类</h3><p>LocalDate类以及java.time包中的其他类是不可变的——没有方法能修改对象的状态。类似plusDays的方法并不是更改对象，而是返回状态已修改的新对象。</p>
<p>更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改。</p>
<p>其结果是不可预料的。如果类是不可变的，就可以安全地在多个线程间共享其对象。</p>
<p>因此，要尽可能让类是不可变的，这是一个很好的想法。对于表示值的类，如一个字符串或一个时间点，这尤其容易。计算会生成新值，而不是更新原来的值。</p>
<p>当然，并不是所有类都应当是不可变的。如果员工加薪时让raiseSalary方法返回一个新的Employee对象，这会很奇怪。</p>
<h1 id="第五章-继承"><a href="#第五章-继承" class="headerlink" title="第五章 继承"></a>第五章 继承</h1><h2 id="第一讲-类、超类和子类"><a href="#第一讲-类、超类和子类" class="headerlink" title="第一讲  类、超类和子类"></a>第一讲  类、超类和子类</h2><p>关键字extends表明正在构造的新类派生于一个已存在的类。</p>
<p><img src="https://s2.loli.net/2022/01/06/w4toM6dX5z7RUcm.png" alt="image-20220106213143904"></p>
<p>然而，这个方法并不能运行。这是因为Manager类的getSalary方法不能直接地访问超类的私有域。也就是说，尽管每个Manager对象都拥有一个名为salary的域，但在Manager类的getSalary方法中并不能够直接地访问salary域。只有Employee类的方法才能够访问私有部分。如果Manager类的方法一定要访问私有域，就必须借助于公有的接口，Employee类的公有方法getSalary正是这样一个接口。</p>
<p>这里需要指出：我们希望调用超类Employee的getSalary方法，而不是当前类的这个方法。为此，可以使用特定的关键字super解决这个问题：</p>
<p><img src="https://s2.loli.net/2022/01/06/qjSvxMA6JmKkXZi.png" alt="image-20220106213904248"></p>
<blockquote>
<h3 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h3><p>有些人认为super与this引用是类似的概念，实际上：</p>
<p><strong>super并不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。</strong></p>
<p>this两个用途：</p>
<ul>
<li>引用隐式参数</li>
<li>调用该类的其他的构造器(第一条语句)</li>
</ul>
<p>super两个用途：</p>
<ul>
<li>调用超类的方法</li>
<li>调用超类的构造器(第一条语句)</li>
</ul>
</blockquote>
<p><img src="https://s2.loli.net/2022/01/06/584HmLGXJPiYanW.png" alt="image-20220106214721586"></p>
<p>当e引用Employee对象时，e.getSalary( )调用的是Employee类中的getSalary方法；当e引用Manager对象时，e.getSalary( )调用的是Manager类中的getSalary方法。</p>
<p>虚拟机知道e实际引用的对象类型，因此能够正确地调用相应的方法。</p>
<p>一个对象变量（例如，变量e）可以指示多种实际类型的现象被称为<strong>多态</strong>（polymorphism）。</p>
<p>在运行时能够自动地选择调用哪个方法的现象称为<strong>动态绑定</strong>（dynamic binding）。</p>
<h3 id="第五节-多态"><a href="#第五节-多态" class="headerlink" title="第五节 多态"></a>第五节 多态</h3><p>在Java程序设计语言里，<strong>对象变量是多态的</strong>。一个Employee变量既可以引用一个Employee类的对象，也可以引用一个Employee类的任何一个子类的对象，如Manager对象。</p>
<p><img src="https://s2.loli.net/2022/01/06/GIFhMEeC9s247LB.png" alt="image-20220106215805539"></p>
<p><img src="https://s2.loli.net/2022/01/06/yJeQb6hGTlD2sfV.png" alt="image-20220106215854899"></p>
<p>因为，staff[0]声明的类型是Employee，而setBonus不是Employee类的方法。</p>
<p><img src="https://s2.loli.net/2022/01/06/8ytxkeBmWQTjna1.png" alt="image-20220106220145915"></p>
<p>在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。</p>
<p><img src="https://s2.loli.net/2022/01/06/GXA2CRPaQkOjech.png" alt="image-20220106220331459"></p>
<p>使用new Manager[10]创建的数组是一个经理数组，如果试图存储一个Employee类型的引用就会引发ArrayStoreException异常。</p>
<h3 id="第六节-理解方法调用用"><a href="#第六节-理解方法调用用" class="headerlink" title="第六节 理解方法调用用"></a>第六节 理解方法调用用</h3><p>弄清楚如何在对象上应用方法调用非常重要。</p>
<p>下面假设要调用x.f(args)，隐式参数x声明为类C的一个对象。</p>
<h4 id="下面是调用过程的详细描述："><a href="#下面是调用过程的详细描述：" class="headerlink" title="下面是调用过程的详细描述："></a>下面是调用过程的详细描述：</h4><p><strong>1）编译器查看对象的声明类型和方法名。</strong></p>
<p>假设调用x.f(param)，且隐式参数x声明为C类的对象。需要注意的是：有可能存在多个名字为f，但参数类型不一样的方法。例如，可能存在方法f(int)和方法f(String)。编译器将会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法（超类的私有方法不可访问）。至此，编译器已获得所有可能被调用的候选方法。</p>
<p><strong>2）接下来，编译器将查看调用方法时提供的参数类型。</strong></p>
<p>如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为重载解析（overloading resolution）。例如，对于调用x.f(“Hello”)来说，编译器将会挑选f(String)，而不是f(int)。由于允许类型转换（int可以转换成double, Manager可以转换成Employee，等等），所以这个过程可能很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。</p>
<p>至此，编译器已获得需要调用的方法名字和参数类型。</p>
<blockquote>
<h4 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h4><p>前面曾经说过，<strong>方法的名字和参数列表称为方法的签名。</strong></p>
<p>例如，f(int)和f(String)是两个具有相同名字，不同签名的方法。如果在子类中定义了一个与超类签名相同的方法，那么子类中的这个方法就覆盖了超类中的这个相同签名的方法。</p>
<p>不过，返回类型不是签名的一部分，因此，在覆盖方法时，一定要保证返回类型的兼容性。</p>
<p>允许子类将覆盖方法的返回类型定义为原返回类型的子类型</p>
</blockquote>
<p><strong>3）如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为静态绑定（static binding）。</strong></p>
<p>与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。在我们列举的示例中，编译器采用动态绑定的方式生成一条调用f (String)的指令。</p>
<p><strong>4）当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。</strong></p>
<p>假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就直接调用它；否则，将在D类的超类中寻找f(String)，以此类推。</p>
<h4 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h4><p>每次调用方法都要进行搜索，时间开销相当大。</p>
<p>因此，虚拟机预先为每个类创建了一个<strong>方法表（method table）</strong>，其中列出了所有方法的签名和实际调用的方法。</p>
<p>这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。</p>
<p>在前面的例子中，虚拟机搜索D类的方法表，以便寻找与调用f(Sting)相匹配的方法。这个方法既有可能是D.f(String)，也有可能是X.f(String)，这里的X是D的超类。这里需要提醒一点，如果调用super.f(param)，编译器将对隐式参数超类的方法表进行搜索。</p>
<p><img src="https://s2.loli.net/2022/01/06/vgGCnimSphPfyWJ.png" alt="image-20220106222122309"></p>
<p>动态绑定有个非常重要的特性：</p>
<p>无需对现存的代码进行修改，就可以对程序进行拓展。假设增加一个新类Executive，并且变量e有可能引用这个类的对象，我们不需要对包含调用e.getSalary()的代码进行重新编译。如果e恰好引用一个Executive类的对象，就会自动地调用Executive.getSalary()方法。</p>
<h3 id="第八讲-强制类型转换"><a href="#第八讲-强制类型转换" class="headerlink" title="第八讲 强制类型转换"></a>第八讲 强制类型转换</h3><p><img src="https://s2.loli.net/2022/01/06/HyVSjae4CBIZvrg.png" alt="image-20220106222959327"></p>
<h4 id="进行的唯一原因"><a href="#进行的唯一原因" class="headerlink" title="进行的唯一原因"></a>进行的唯一原因</h4><p>在暂时忽视对象的实际类型之后，使用对象的全部功能。</p>
<p>例如，我们需要将数组中引用经理的元素复原成Manager类，以便能够访问新增加的所有变量。</p>
<p><strong>将一个值存入变量时，编译器将检查是否允许该操作。</strong></p>
<p><strong>将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检查。</strong></p>
<h4 id="因此"><a href="#因此" class="headerlink" title="因此"></a>因此</h4><p>应该养成这样一个良好的程序设计习惯：</p>
<p>在进行类型转换之前，先查看一下是否能够成功地转换。这个过程简单地使用instanceof操作符就可以实现。</p>
<p><img src="https://s2.loli.net/2022/01/06/P6xaWHNV2iBznck.png" alt="image-20220106223351872"></p>
<p>在一般情况下，应当尽量少用强制类型转换和instanceof。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>只能在继承层次内进行类型转换。</li>
<li>再将超类转换成子类之前，应该使用instanceof进行检查。</li>
</ul>
<h3 id="第九节-抽象类"><a href="#第九节-抽象类" class="headerlink" title="第九节 抽象类"></a>第九节 抽象类</h3><p><img src="https://s2.loli.net/2022/01/06/n57lrmIu4kg2Q9C.png" alt="image-20220106223848993"></p>
<p>在Person中，</p>
<p><img src="https://s2.loli.net/2022/01/06/k9eO1AjQcEUxDNn.png" alt="image-20220106224101130"></p>
<p><strong>许多程序员认为，在抽象类中不能包含具体方法。建议尽量将通用的域和方法（不管是否是抽象的）放在超类（不管是否是抽象类）中。</strong></p>
<p>抽象方法充当着占位的角色，它们的具体实现在子类中。</p>
<h4 id="扩展抽象类可以有两种选择。"><a href="#扩展抽象类可以有两种选择。" class="headerlink" title="扩展抽象类可以有两种选择。"></a>扩展抽象类可以有两种选择。</h4><ul>
<li><p>一种是在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类；</p>
</li>
<li><p>另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。</p>
</li>
</ul>
<p>例如，通过扩展抽象Person类，并实现getDescription方法来定义Student类。由于在Student类中不再含有抽象方法，所以不必将这个类声明为抽象的。类即使不含抽象方法，也可以将类声明为抽象类。</p>
<h4 id="抽象类不能被实例化。"><a href="#抽象类不能被实例化。" class="headerlink" title="抽象类不能被实例化。"></a>抽象类不能被实例化。</h4><p>也就是说，如果将一个类声明为abstract，就不能创建这个类的对象。</p>
<p><strong>需要注意，可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。</strong>例如，</p>
<p><img src="https://s2.loli.net/2022/01/06/pZyfraxLwRIiOUE.png" alt="image-20220106224627968"></p>
<p>这里的p是一个抽象类Person的变量，Person引用了一个非抽象子类Student的实例。</p>
<h3 id="Java用于控制可见性的4个访问修饰符："><a href="#Java用于控制可见性的4个访问修饰符：" class="headerlink" title="Java用于控制可见性的4个访问修饰符："></a>Java用于控制可见性的4个访问修饰符：</h3><ul>
<li>仅对本类可见——private。</li>
<li>对所有类可见——public。</li>
<li>对本包和所有子类可见——protected。</li>
<li>对本包可见——默认（很遗憾），不需要修饰符。</li>
</ul>
<h2 id="第二讲-Object：所有类的超类"><a href="#第二讲-Object：所有类的超类" class="headerlink" title="第二讲 Object：所有类的超类"></a>第二讲 Object：所有类的超类</h2><p>在Java中，只有基本类型不是对象。</p>
<h3 id="第一节-equals-方法"><a href="#第一节-equals-方法" class="headerlink" title="第一节 equals 方法"></a>第一节 equals 方法</h3><p><img src="https://s2.loli.net/2022/01/17/zDTi9tMsyOCfbPg.png" alt="image-20220117213943571"></p>
<blockquote>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p><strong>为了防备name或hireDay可能为null的情况，需要使用Objects.equals方法。</strong></p>
<p>如果两个参数都为null, Objects.equals(a, b)调用将返回true；如果其中一个参数为null，则返回false；否则，如果两个参数都不为null，则调用a.equals(b)。利用这个方法，Employee.equals方法的最后一条语句要改写为：</p>
<p><img src="https://s2.loli.net/2022/01/17/VuKSeBdMj5lN2zc.png" alt="image-20220117225732398"></p>
</blockquote>
<p>在子类中定义equals方法时，首先调用超类的equals。如果检测失败，对象就不可能相等。如果超类中的域都相等，就需要比较子类中的实例域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object otherObject)</span> &#123;</span><br><span class="line">        <span class="comment">// super.equals checked that this and otherObject belong to the same class</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">super</span>.equals(otherObject))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">other</span> <span class="operator">=</span> (Manager) otherObject;</span><br><span class="line">        <span class="type">return</span> <span class="variable">bonus</span> <span class="operator">=</span>= other.bonus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java语言规范要求equals方法具有下列特性：</p>
<ol>
<li><strong>自反性</strong>：对于任何非空引用x,  x.equals(x)应该返回true。</li>
<li><strong>对称性</strong>：对于任何引用x和y，当且仅当y.equals(x)返回true， x.equals(y)也应该返回true。</li>
<li><strong>传递性</strong>：对于任何引用x、y和z，如果x.equals(y)返回true， y.equals(z)返回true， x.equals(z)也应该返回true。</li>
<li><strong>一致性</strong>：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果。</li>
<li><strong>对于任意非空引用x， x.equals(null)应该返回false。</strong></li>
</ol>
<p><img src="https://s2.loli.net/2022/01/17/2pbVS14yPh8EQfC.png" alt="image-20220117232952358"></p>
<h4 id="下面给出编写一个完美的equals方法的建议："><a href="#下面给出编写一个完美的equals方法的建议：" class="headerlink" title="下面给出编写一个完美的equals方法的建议："></a>下面给出编写一个完美的equals方法的建议：</h4><p>1）显式参数命名为otherObject，稍后需要将它转换成另一个叫做other的变量。</p>
<p>2）检测this与otherObject是否引用同一个对象：</p>
<p><code>if (this == otherObject) return true;</code></p>
<p>这条语句只是一个优化。实际上，这是一种经常采用的形式。</p>
<p><strong>因为计算这个等式要比一个一个地比较类中的域所付出的代价小得多。</strong></p>
<p>3）检测otherObject是否为null，如果为null，返回false。这项检测是很必要的。</p>
<p><code>if (otherObject == null) return false;</code></p>
<p>4）比较this与otherObject是否属于同一类。如果equals的语义在每个子类中有所改变，就使用getClass检测：</p>
<p><code>if (getClass() != otherObject.getClass()) return false;</code></p>
<p>如果所有的子类都拥有统一的语义，就使用instanceof检测：</p>
<p><code>if (!(otherObject instanceof ClassName)) return false;</code></p>
<p>5）将otherObject转换为相应的类类型变量：</p>
<p><code>ClassName other = (ClassName) otherObject</code></p>
<p>6）现在开始对所有需要比较的域进行比较了。使用==比较基本类型域，使用equals比较对象域。如果所有的域都匹配，就返回true；否则返回false。</p>
<p><code>return field1 == other.field1 &amp;&amp; Objects.equals(field2, other.fields) &amp;&amp; ...;</code></p>
<p>如果在子类中重新定义equals，就要在其中包含调用super.equals(other)。</p>
<blockquote>
<p>对于数组类型的域，可以使用静态的Arrays.equals方法检测相应的数组元素是否相等。</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/01/18/f19UtvBs7MEOdCH.png" alt="image-20220118001450380"></p>
<h3 id="第二讲-hashcode方法"><a href="#第二讲-hashcode方法" class="headerlink" title="第二讲 hashcode方法"></a>第二讲 hashcode方法</h3><p>散列码(hashcode)是由对象导出的一个整型值。散列码是没有规律的。如果x和y是两个不同的对象，x.hashCode( )与y.hashCode( )基本上不会相同。</p>
<p><img src="https://s2.loli.net/2022/01/18/KBXh3gSZmtCG4Mx.png" alt="image-20220118003233455"></p>
<p><img src="https://s2.loli.net/2022/01/18/rRsCczkHXWQvZ5d.png" alt="image-20220118003328447"></p>
]]></content>
      <tags>
        <tag>核心卷一</tag>
      </tags>
  </entry>
  <entry>
    <title>github</title>
    <url>/2021/12/03/github/</url>
    <content><![CDATA[<blockquote>
<p>首先，喜事：终于成功把第一个小项目放到Github上去啦！</p>
<p>戳<a href="https://github.com/Phoenix-Nrvn/Ming">Phoenix-Nrvn/Ming (github.com)</a>即可访问</p>
</blockquote>
<h1 id="更新Github上的代码"><a href="#更新Github上的代码" class="headerlink" title="更新Github上的代码"></a>更新Github上的代码</h1><h2 id="一、克隆自己Github上的项目代码到本地"><a href="#一、克隆自己Github上的项目代码到本地" class="headerlink" title="一、克隆自己Github上的项目代码到本地"></a>一、克隆自己Github上的项目代码到本地</h2><p>原因嘛，Github上不能删除文件夹的，只能把项目拉到本地删除再更新</p>
<ol>
<li><p>首先随便创建一个文件夹(存放下载下来的代码)</p>
</li>
<li><p>输入指令克隆自己的代码</p>
<p><code>git clone https://github.com/用户名/仓库名.git</code></p>
</li>
</ol>
<h2 id="二、查看一下仓库状态"><a href="#二、查看一下仓库状态" class="headerlink" title="二、查看一下仓库状态"></a>二、查看一下仓库状态</h2><p><code>git status</code></p>
<p>注意要先切换到存储原来GitHub本地代码的位置，不是刚刚下载代码才建的文件夹。</p>
<h2 id="三、更新"><a href="#三、更新" class="headerlink" title="三、更新"></a>三、更新</h2><ol>
<li><p>直接在本地，把改好的文件替换原来的相应部分就好</p>
<p><code>git add *--表示更新全部</code></p>
</li>
<li><p>添加更新说明，commit只是将其提交到缓存区域</p>
<p><code>git commit -m &quot;update&quot;(可将update替换为别的内容)</code></p>
</li>
<li><p>上传</p>
<p><code>git push origin 分支名 --(若是多人同时开发维护，首先git pull，拉取当前分支最新代码)</code></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>A Good Day</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><p>即虚拟机与外界通讯时，要求与主机处于同一个网段。使用桥接模式，需要为虚拟机单独分配IP地址，但IP地址是有限的，会消耗资源，容易造成IP冲突。</p>
<h4 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h4><p>虚拟机分配的IP地址，不需要与主机在同一网段。而且设置后，主机会生成一个虚拟的网卡，在虚拟机和主机之间，建立联系互通，也可以跟外网通讯，且不造成IP冲突。其为网络地址转换模式。内网可以连接外网，但外网不能返回内网，因为内网可以通信，是因为地址转换，即通过了主机代理。</p>
<h4 id="主机模式"><a href="#主机模式" class="headerlink" title="主机模式"></a>主机模式</h4><p>即一个独立的系统，不和外部发生联系，想怎么配怎么配。</p>
]]></content>
  </entry>
  <entry>
    <title>DataBase-System</title>
    <url>/2022/01/06/DataBase-System/</url>
    <content><![CDATA[<h1 id="第一章-数据库系统世界"><a href="#第一章-数据库系统世界" class="headerlink" title="第一章 数据库系统世界"></a>第一章 数据库系统世界</h1><p>数据库的能力来自于已发展了数十年的知识和技术，这些知识和技术蕴藏在名为<strong>数据库管理系统(Database Management System)</strong> 的软件中。该软件也叫DBMS，或更通俗地称为“数据库系统”。</p>
<h2 id="第二节-数据库管理系统概述"><a href="#第二节-数据库管理系统概述" class="headerlink" title="第二节 数据库管理系统概述"></a>第二节 数据库管理系统概述</h2><p>如图所示，是一个完整的DBMS结构，其中单线框表示系统构成，双线框表示内存中的数据结构，实线表示控制和数据流，虚线只表示数据流。</p>
<p>首先，在顶部有两个命令源将命令发给DBMS：</p>
<ol>
<li>通常的用户和应用程序，发出查询数据或修改数据命令。</li>
<li>数据库管理员(Administrator)，一个人或一批人，负责数据库结构或模式。</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/06/drTh2xNimCMFBlg.png" alt="image-20220106211555051"></p>
<h3 id="数据定义语言命令"><a href="#数据定义语言命令" class="headerlink" title="数据定义语言命令"></a>数据定义语言命令</h3><p><img src="https://s2.loli.net/2022/01/07/gQmTNBluVt7sIpr.png" alt="image-20220107003044094"></p>
<h3 id="查询处理概述"><a href="#查询处理概述" class="headerlink" title="查询处理概述"></a>查询处理概述</h3><p>与DBMS交互最重要的工作使沿着图所示左边的路径。</p>
<p>用户或应用程序使用数据库操作语言(DML)启动一些不影响数据库模式的操作，但是这些操作可能会影响数据库的内容，或者是从数据库中抽取数据。DML语言由两个独立的子系统处理。</p>
<h4 id="查询处理"><a href="#查询处理" class="headerlink" title="查询处理"></a>查询处理</h4><p>查询通过查询编译器(query compiler)完成语法分析和优化。</p>
<p>编译的结果使查询计划(query plan)或是由DBMS执行并获得查询结果的操作序列，它们将被送给执行引擎(execution engine)。执行引擎向资源管理器发出一系列获取小块数据的请求，典型的小块数据关系是记录或元组。</p>
<p><strong>资源管理器知道数据文件(data file, 存放关系的条件)、数据文件的格式和记录大小以及索引文件(index file)等。</strong>这些信息对于快速从数据文件中找到响应数据元素是有用的。</p>
<p>数据请求又被传送给缓冲区管理器(buffer manager)。缓冲区管理器的任务是从二级存取器(通常是磁盘，永久地保存数据)中获取数据送入主存缓冲区中。</p>
<p>一般情况下，页或“磁盘块”是缓冲区和磁盘间的传送单位。</p>
<p>为了从磁盘中得到数据，缓冲区管理器与存储器管理器进行通信。存储器管理器可能包含操作系统命令，但是最典型的是DBMS直接向磁盘控制器发命令。</p>
<h4 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h4><p>查询或其他DML操作被组织成事务(transaction)。事务是必须原子性执行的单位，执行中的事务之间还必须相互隔离。任何一个查询或修改操作本身，就可以是一个事务。另外，事务的执行必须持久(durable)，也就是说任何已完成事务的作用必须被保持，即使是事务刚刚完成系统就失败时也应如此。是五处理器被分成两个主要部分：</p>
<ol>
<li>并发控制管理器(concurrency-control manager)或调度器(scheduler)，保证事务的原子性和独立性。</li>
<li>日志(logging)和恢复管理器(recovery manager)，负责事务的持久性。</li>
</ol>
<h3 id="存储器和缓冲区管理器"><a href="#存储器和缓冲区管理器" class="headerlink" title="存储器和缓冲区管理器"></a>存储器和缓冲区管理器</h3><p>数据库数据平常存储在二级存储器中。计算机系统中的“二级存储器”一般指磁盘。可是，对数据的操作只能在主存中执行。存储器管理器( storage manager）的任务就是控制数据在磁盘上的位置存放和在磁盘与主存间的移动。</p>
<p>在一个简单数据库系统中，存储器管理器可以就是操作系统下的文件系统。可是，为了提高效率，DBMS常常直接控制磁盘上的存储，至少是在某些环境下如此。存储器管理器保持跟踪磁盘上的文件位置，根据请求从缓冲区管理器中获取含有请求文件的一个或多个磁盘块。</p>
<p><strong>缓冲区管理器负责把可用主存分割成缓冲区(buffer)</strong>，缓冲区是包含若干个页面的区域，其中可以传输磁盘块。于是，所有需要从磁盘中获取信息的DBMS组件，都或是直接或是通过执行引擎的方式，与缓冲区和缓冲区管理器交互。</p>
<h4 id="各个组件可能需要的信息种类有"><a href="#各个组件可能需要的信息种类有" class="headerlink" title="各个组件可能需要的信息种类有:"></a>各个组件可能需要的信息种类有:</h4><ol>
<li>数据：数据库本身的内容</li>
<li>元数据：描述数据库结构及其约束的数据库模式</li>
<li>日志记录：对数据库新近修改的信息，该信息支持数据库的持久性</li>
<li>统计数据：由DBMS手机和存储的关于数据特征的数据。例如，数据库大小、数据库中的值、数据库中的各种关系和其他成分。</li>
<li>索引：支持对数据库中数据有效存取的数据结构。</li>
</ol>
<h3 id="事务处理-1"><a href="#事务处理-1" class="headerlink" title="事务处理"></a>事务处理</h3><p>通常将一个或一组数据库操作组成一个事务。</p>
<p>事务的执行满足原子性，并且与其他事务的执行互相隔离。另外，DBMS还要保证事务的持久性:已完成事务的工作永不丢失。</p>
<p>事务管理器（(transaction manager）接收来自应用的事务命令( transaction command)，这些命令告诉事务管理器事务何时开始，何时结束，以及应用期望的信息（例如，某些应用可能不需要原子性)。</p>
<p>事务处理器执行如下一些任务:</p>
<ol>
<li><p><strong>记日志(logging): </strong>为了保证持久性，数据库的每一个变化都单独地记录在磁盘上。</p>
<p>日志管理器( tog manager）遵循一种设计原则，无论何时系统失败或“崩溃”，恢复管理器都能够通过检查日志中的修改记录，把数据库恢复到某个一致状态。</p>
<p>日志管理器先把日志写人缓冲区，然后与缓冲区管理器协商以确保缓冲区在合适的时间被写入磁盘（磁盘数据可以在系统崩溃后幸存下来)。</p>
</li>
<li><p><strong>并发控制(concurrency control):事务必须独立执行。</strong></p>
<p>但是在大多数系统中，很多事务都是同时在执行。因此，调度器（并发控制管理器）必须保证多个事务的单个动作是按某个次序在执行，按该次序执行的效果应该与系统一次只执行一个事务一样。</p>
<p>典型的调度器是通过在数据库的某些片断上加锁（lock)的方式工作。锁将防止两个事务用不正确的交互方式对同一数据片段存取。如图1-1所示，锁通常保存在主存的锁表(lock table)中，调度器通过阻止执行引擎对已加锁的数据库内容的存取来影响查询和其他数据库操作。</p>
</li>
<li><p><strong>消除死锁（deadlock resolution): </strong>当事务通过调度器获取锁以竞争其所需的资源时，系统可能会陷人一种状态。</p>
<p><strong>在该状态中，因为每个事务需要的资源都被另一个事务占有，所以没有一个事务能够继续执行。</strong></p>
<p>此时，事务管理器有责任调解，并删除（“回滚”或“终止”)一个或多个事务，以便其他事物可以继续执行。<br><img src="https://s2.loli.net/2022/01/07/jZcvXrLtJOzDWFI.png" alt="image-20220107012544181"></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库系统基础教程</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb</title>
    <url>/2022/01/09/JavaWeb/</url>
    <content><![CDATA[<h1 id="JavaWeb基础"><a href="#JavaWeb基础" class="headerlink" title="JavaWeb基础"></a>JavaWeb基础</h1><h2 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>一个Java项目基本包括：</p>
<ul>
<li>引入的依赖包</li>
<li>项目的目录结构</li>
<li>配置的环境</li>
<li>等等</li>
</ul>
<p>虽难度不大，但琐碎且耗时，所以需要一个标准化的Java项目管理和构建工具。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Maven就是专门为Java打造的管理和构建工具。主要功能：</p>
<ul>
<li>提供了一套标准化的项目结构；</li>
<li>提供了一套标准化的构建流程（编译，测试，打包，发布……）；</li>
<li>提供了一套依赖管理机制。</li>
</ul>
<h3 id="Maven项目结构："><a href="#Maven项目结构：" class="headerlink" title="Maven项目结构："></a>Maven项目结构：</h3><p>一个使用Maven管理的普通的Java项目，它的目录结构默认如下：</p>
<p><img src="https://s2.loli.net/2022/01/14/B9xbAFmDVcwXrGQ.png" alt="image-20220114171600543"></p>
<p><img src="https://s2.loli.net/2022/01/14/gtv5HIKcRPqiFZd.png" alt="image-20220114191840406"></p>
<p>其中，groupId类似Java中的包名，通常是公司或组织名称，artifactId类似Java中的类名，通常是项目名称。再加上version，一个Maven工程就是由groupId、artifactId和version作为唯一标识的。在引用其他方类库时，也是通过这3个变量确定。例如，依赖<code>commons-logging</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>使用<code>&lt;dependency&gt;</code>声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。</p>
<p><img src="https://s2.loli.net/2022/01/14/qkvcp8RU9W7NO4G.png" alt="image-20220114194907705"></p>
<h2 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>在平时的开发当中，一个项目往往包含了大量的方法，可能有成千上万个。如何去保证这些方法产生的结果是我们想要的呢？当然了，最容易想到的一个方式，就是我们通过System.out来输出我们的结果，看看是不是满足我们的需求，但是项目中这些成千上万个方法，我们总不能在每一个方法中都去输出一遍嘛。</p>
<p>还有就是新建一个main()方法，然后编写测试代码。但若待测试的代码过多，就需要很多的main()方法，或者一个庞大的main()方法。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><strong>使用Junit可以帮助我们快速完成单元测试。</strong></p>
<p>其简化单元测试，写一点测一点，在编写以后的代码中，可以较快地追踪到问题的原因，减小回归错误的纠错难度。</p>
<p>junit如何解决这个问题的呢？答案在于内部提供了一个断言机制，他能够将我们预期的结果和实际的结果进行比对，判断出是否满足我们的期望。</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ol>
<li>每一个测试方法上使用@Test修饰</li>
<li>每一个测试方法必须使用public void进行修饰</li>
<li>每一个测试方法不能携带参数</li>
<li>测试代码和源代码在两个不同的项目路径下</li>
<li>测试类的包应该和被测试类保持一致</li>
<li>测试单元中的每个方法必须可以独立测试</li>
</ol>
<p>Junit也建议在每一个测试方法名加上test前缀，表明这是一个测试方法。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://s2.loli.net/2022/01/15/L4V2aGrQxMBjAkv.png" alt="image-20220115000228233"></p>
<p>如图所示：</p>
<p>assertEquals是一个断言的规则，第一个参数表明我们预期的值，第二个参数表明实际运行的值。</p>
<p>如果运行成功，编辑器的控制台不会出现错误信息，如果有就出现failure等信息。</p>
<p>引用：<a href="https://zhuanlan.zhihu.com/p/86624354">Java程序员必须要知道的单元测试框架Junit详解 - 知乎 (zhihu.com)</a></p>
<h2 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>xml是可拓展的标记性语言。</p>
<p>可拓展是说，xml文件中的标签可以自定义。如图：</p>
<p><img src="https://s2.loli.net/2022/01/09/mnxW4zLSDOrE1H3.png" alt="image-20220109202115434"></p>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>xml的主要作用：</p>
<ul>
<li>用来保存数据()，而且这些数据具有自我描述性</li>
<li>它还可以作为项目或模块的配置文件</li>
<li>可以作为网络传输数据的格式(但都是过去啦，现在都用JSON)</li>
</ul>
<h3 id="xml解析技术介绍"><a href="#xml解析技术介绍" class="headerlink" title="xml解析技术介绍"></a>xml解析技术介绍</h3><p>解析：将xml中的数据转换为程序需要的信息。</p>
<p>xml是可拓展的标记语言。不管是html还是xml，都是标记性文档，都可以使用w3c组织制定的dom技术来解析。</p>
<p><img src="https://s2.loli.net/2022/01/09/SlI8J4COk7PEyYx.png" alt="image-20220109211303542"></p>
<p>document对象表示的是整个文档(可以是html文档，也可以是xml文档)。</p>
<h3 id="xml语法"><a href="#xml语法" class="headerlink" title="xml语法"></a>xml语法</h3><ol>
<li>文档声明</li>
<li>元素(标签)</li>
<li>xml属性</li>
<li>xml注释</li>
<li>文本区域(CDATA区)</li>
</ol>
<h4 id="文档声明"><a href="#文档声明" class="headerlink" title="文档声明"></a>文档声明</h4><p>创建一个xml文件</p>
<p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&gt;   xml声明。</code></p>
<!-- xml声明， version是版本的意思，encoding是编码-->
<!-- 而且这个<?xml要连在一起，否则会报错。 -->
<h4 id="XML文档必须要有根元素"><a href="#XML文档必须要有根元素" class="headerlink" title="XML文档必须要有根元素"></a>XML文档必须要有根元素</h4><p>根元素就是顶级元素</p>
<p>没有父标签的元素，叫顶级元素。</p>
<p>根元素是没有父标签的顶级元素，而且是唯一一个才行。</p>
<p><img src="C:/Users/LISHANSHAN/AppData/Roaming/Typora/typora-user-images/image-20220109220730784.png" alt="image-20220109220730784"></p>
<h4 id="XML中的特殊字符"><a href="#XML中的特殊字符" class="headerlink" title="XML中的特殊字符"></a>XML中的特殊字符</h4><p>转化成HTML中的字符。</p>
<p>如：“&gt;”特殊字符，&amp;gt； ；  “&lt;”特殊字符：&amp;lt；</p>
<h4 id="文本区域-CDATA区"><a href="#文本区域-CDATA区" class="headerlink" title="文本区域(CDATA区)"></a>文本区域(CDATA区)</h4><p>CDATA语法可以告诉xml解析器，我CDATA里的文本内容，只是纯文本，不需要xml语法解析</p>
<p>CDATA格式：</p>
<p><code>&lt;![CDATA[这里可以把你输入的字符原样显示，不会解析xml]]&gt;</code></p>
<p><img src="https://s2.loli.net/2022/01/09/iSHNrQ1sWvRT7hg.png" alt="image-20220109221640342"></p>
<p><img src="https://s2.loli.net/2022/01/09/PBAH4aKbRSjdCkn.png" alt="image-20220109221737442"></p>
<h3 id="配置servlet"><a href="#配置servlet" class="headerlink" title="配置servlet"></a>配置servlet</h3><p><img src="https://s2.loli.net/2022/01/09/VNK61QrMv3DCozT.png" alt="image-20220109223034886"></p>
<h3 id="什么是servlet"><a href="#什么是servlet" class="headerlink" title="什么是servlet"></a>什么是servlet</h3><ol>
<li>Servlet是JavaEE规范之一，规范也就是接口的意思。</li>
<li>Servlet是JavaWeb三大组件之一。三大组件分别是：Servlet程序、Filter过滤器、Listener监听器。</li>
<li>Servlet是运行在服务器上的一个java小程序，==它可以接收客户端发送过来的请求，并响应数据给客户端==。</li>
</ol>
<p>手动实现Servlet程序</p>
<ol>
<li>编写一个类去实现Servlet接口</li>
<li>实现service方法，处理请求，并响应数据</li>
<li>在web.xml中去配置Servlet程序的访问地址</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/14/7Ftk8B4l3uK6EwV.png" alt="image-20220114003516156"></p>
<p><img src="https://s2.loli.net/2022/01/14/6y4WUZlRdMNSvTx.png" alt="image-20220114004548054"></p>
<p><img src="https://s2.loli.net/2022/01/14/I7HKBhtumQecaX9.png" alt="image-20220114004704441"></p>
<p>base标签设置页面中所有相对路径工作时，参照的路径，即href属性。</p>
<base href="http://localhost:8080/07_servlet/a_b_c.html">

<p><img src="https://s2.loli.net/2022/01/15/GfJxmqCc2M3Q9rV.png" alt="image-20220115003150399"></p>
<h2 id="JavaEE三层架构"><a href="#JavaEE三层架构" class="headerlink" title="JavaEE三层架构"></a>JavaEE三层架构</h2><p><img src="https://s2.loli.net/2022/01/15/6aWORlNcSgE9bmx.png" alt="image-20220115004626889"></p>
<h3 id="Jdbc-Utils"><a href="#Jdbc-Utils" class="headerlink" title="Jdbc_Utils"></a>Jdbc_Utils</h3><p><img src="https://s2.loli.net/2022/01/15/Rl8OFxPgK4sZJ5I.png" alt="image-20220115010008104"></p>
<p><img src="https://s2.loli.net/2022/01/15/toPDzuvSKcFkCgQ.png" alt="image-20220115010937146"></p>
<p><img src="https://s2.loli.net/2022/01/15/UPxErg1WGwaNLzR.png" alt="image-20220115011020984"></p>
<p><img src="https://s2.loli.net/2022/01/15/RJ8adT4rNfuzm2D.png" alt="image-20220115011610686"></p>
<p><img src="https://s2.loli.net/2022/01/15/uDHnOW2qNFyXESK.png" alt="image-20220115011739243"></p>
<h3 id="专门来复用的Dao抽象类"><a href="#专门来复用的Dao抽象类" class="headerlink" title="专门来复用的Dao抽象类"></a>专门来复用的Dao抽象类</h3><h4 id="选取代码"><a href="#选取代码" class="headerlink" title="选取代码"></a>选取代码</h4><p><img src="https://s2.loli.net/2022/01/15/RMO8Q7DZyKwfL9P.png" alt="image-20220115012311409"></p>
<p><strong>Object … args : 可变长参数</strong>，用来表示sql语句中的作为占位符的？的参数的实际值。</p>
<p>记得增加finally</p>
<h4 id="查询一个："><a href="#查询一个：" class="headerlink" title="查询一个："></a>查询一个：</h4><p><img src="https://s2.loli.net/2022/01/15/vB2mqZOgEAFXCnQ.png" alt="image-20220115012703423"></p>
<h4 id="参数解释及finally"><a href="#参数解释及finally" class="headerlink" title="参数解释及finally"></a>参数解释及finally</h4><p>连接用了之后要及时关闭，不然会占用连接资源，因为sql里边就那几个可用的连接</p>
<p><img src="https://s2.loli.net/2022/01/15/meTfsX4aMkE15b8.png" alt="image-20220115012950145"></p>
<h4 id="查询多个"><a href="#查询多个" class="headerlink" title="查询多个"></a>查询多个</h4><p><img src="https://s2.loli.net/2022/01/15/eWDNHuIlTh7FB9Y.png" alt="image-20220115013250380"></p>
<h4 id="查询一列"><a href="#查询一列" class="headerlink" title="查询一列"></a>查询一列</h4><p><img src="https://s2.loli.net/2022/01/15/MWq3SU6eNI1GP5u.png" alt="image-20220115013448414"></p>
<h3 id="UserDao接口以及其实现类"><a href="#UserDao接口以及其实现类" class="headerlink" title="UserDao接口以及其实现类"></a>UserDao接口以及其实现类</h3><p><img src="https://s2.loli.net/2022/01/15/QNASR3rtDfjzheU.png" alt="image-20220115014005397"></p>
<p><img src="https://s2.loli.net/2022/01/15/nxqjN6HkwLcgzRV.png" alt="image-20220115013925082"></p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Serializable</title>
    <url>/2021/12/11/Serializable/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Java储存对象"><a href="#Java储存对象" class="headerlink" title="Java储存对象"></a>Java储存对象</h2><h3 id="只有自己写的Java程序会用到"><a href="#只有自己写的Java程序会用到" class="headerlink" title="只有自己写的Java程序会用到"></a>只有自己写的Java程序会用到</h3><ol>
<li><h4 id="用序列化-Serialization"><a href="#用序列化-Serialization" class="headerlink" title="用序列化(Serialization)"></a>用序列化(Serialization)</h4></li>
</ol>
<p>将被序列化的对象写到文件中。然后让程序取文件中读取序列化的对象并展开为原来状态</p>
<p>数据需要被其他程序引用</p>
<ol>
<li><h4 id="放文本文件中。"><a href="#放文本文件中。" class="headerlink" title="放文本文件中。"></a>放文本文件中。</h4></li>
</ol>
<p>用其他程序可以解析的特殊字符写到文件中。</p>
<p>将序列化对象</p>
<h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><h2 id="将序列化对象写入文件"><a href="#将序列化对象写入文件" class="headerlink" title="将序列化对象写入文件"></a>将序列化对象写入文件</h2><h3 id="方法步骤"><a href="#方法步骤" class="headerlink" title="方法步骤"></a>方法步骤</h3><ol>
<li><code>创建出FileOutputStream fileStream = new FileOutputStream(&quot;Mygame.txt&quot;);</code> </li>
<li><code>创建出ObjectOutputStream os = new ObjectOutputStream(fileStream);</code> </li>
<li><code>写入对象os.writeObject(characterOne);</code></li>
<li><code>os.close();</code></li>
</ol>
<p>Java的输入/输出API带有连接类型的串流，他代表来源于目的地之间的连接。连接串流将串流与其他串流连接起来。一般来说，串流要两两连接才能做出有意义的事情—其中一个表示连接，另一个则是要被调用方法的。以FileOutputStream为例。它可以由写入字节的方法，但我们通常不会写入字节，而是以对象层次的观点来写入，所以需要高层的连接串流。<img src="https://s2.loli.net/2021/12/22/oEXO6W9umf7NpTl.png" alt="image-20211211160857891-16392102017261"></p>
<h3 id="对象被序列化"><a href="#对象被序列化" class="headerlink" title="对象被序列化"></a>对象被序列化</h3><ol>
<li>在堆上的对象</li>
</ol>
<p>在堆上的对象有状态——实例变量的值。这些值让同一类的不通事理有了不同的意义。</p>
<ol>
<li>被序列化的对象</li>
</ol>
<p>序列化的对象保存了实例变量的值，因此之后可以在堆上带回一模一样的实例。</p>
<p>如，带有两个primitive主数据类型实例变量(高度、宽度)的对象，会将宽度与高度的实例变量值(二进制格式)与Java虚拟机所需的信息(像是类的名称)被保存在foo.ser文件中。</p>
<p><code>Foo myFoo = new Foo();</code></p>
<p><code>myFoo.setWidth(37);</code></p>
<p><code>myFoo.setHeight(70);</code></p>
<p><code>FileOutputStream fs = new FileOutputStream(&quot;foo.ser&quot;);</code></p>
<p><code>ObjectOutputStream os = new ObjectOutputStream(fs);</code></p>
<p><code>os.writeObject(myFoo);</code></p>
<p>当对象被序列化时，被该对象引用的实例变量也会被序列化。即序列化程序会将对象版图上的所有东西存储起来。被对象的实例变量所引用的所有对象都会被序列化。</p>
<h3 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h3><p>如果想让类能够被序列化，就实现Serializable接口。</p>
<p>其又被称为marker或tag接口，因为此接口并没有任何方法需要实现。使用它唯一的目的就是，实现它的类是可以被序列化的。如果某类可以序列化，那么它的子类也自动地可以序列化。</p>
<p>为了保证正确的序列化，整个对象版图中，<strong>所有牵扯到的类都必须实现Serializable接口</strong>。</p>
<p>若是比较特殊的，比如忘记实现序列化，或者动态数据只有在运行的时候求出，不能或不必保存，那么需要标记为transient(瞬时)的。虽然Java函数库中大部分类可以被序列化，你还是无法将网络联机之类的东西保存下来，他得要在执行期当场创建才有意义。</p>
<h2 id="解序列化"><a href="#解序列化" class="headerlink" title="解序列化"></a>解序列化</h2><h3 id="方法步骤-1"><a href="#方法步骤-1" class="headerlink" title="方法步骤"></a>方法步骤</h3><p><code>1. 创建出FileInputStream fileStream = new FileInputStream(&quot;MyGame.txt&quot;);</code></p>
<p><code>2. 创建出ObjectInputStream os = new ObjectInputStream(fileStream);</code></p>
<p><code>3. 读取对象 Object one = os.readObject();</code></p>
<p><code>4. 转换对象类型 characterOne = (MyGame)one;</code></p>
<p><code>5. 关闭ObjectInputStream os.close();</code>  </p>
<h3 id="对象解序列化时"><a href="#对象解序列化时" class="headerlink" title="对象解序列化时"></a>对象解序列化时</h3><p>当对象被解序列化时，Java虚拟机会通过尝试在堆上创建新的对象，让它维持与被序列化时有相同的状态来恢复对象的原状。但这当然不包括transient的变量，它们不是null(对对象引用而言)就是primitive主数据类型的默认值。<img src="https://s2.loli.net/2021/12/22/QNgyWML1BupCnxS.png" alt="image-0918"></p>
<p>新的对象会被分配到堆上，但构造函数不会执行！很显然，我们只是需要对象回到存储时的状态，而不是要一个全新的对象。</p>
<p>如果该对象在继承树上有一个不可序列化的祖先类，则<strong>该不可序列化类以及在它之上的类的构造函数(就算其上的类是可序列化的也一样)就会执行</strong>。一旦构造函数启动之后将无法停止，也就是说，<strong>从第一个不可序列化的父类开始，全部都会重新初始状态</strong>。</p>
<h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ol>
<li>可以通过序列化来存储对象的状态。</li>
<li>使用ObjectOutputStream来序列化对象</li>
<li>Stream是连接串流或是链接用的串流</li>
<li>连接串流用来表示源或目的地、文件、网络套接字连接。</li>
<li>对象必须实现序列化这个接口，才能被序列化。如果父类实现序列化，则子类也就自动地有实现，不管是否有明确的声明。</li>
<li>当对象被序列化时，整个对象版图都会被序列化。这代表他的实例变量引用的对象也会被序列化。</li>
<li>在解序列化时(deserialization)，所有的类必须都能让虚拟机找到。</li>
<li>若该实例变量被标记为transient，则该变量在还原的时候会被赋予null或primitive主数据类型的默认值。</li>
<li>读取对象的顺序必须与写入的顺序相同。</li>
<li>readObject( )的返回类型是Object</li>
<li>静态变量不会被序列化，因为它属于整个类，而不是一个对象。</li>
</ol>
<h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><h3 id="java-io-File-class"><a href="#java-io-File-class" class="headerlink" title="java.io.File  class"></a>java.io.File  class</h3><p>File这个类代表磁盘上的文件，但并不是文件中的内容分。就似乎可以把File对象想象成文件的路径，而不是文件本身。例如。File并没有读写文件的方法。关于File有个很有用的功能就是就是它提供一种比使用字符串文件名来表示文件更安全的方式。举例来说，在构造函数中，可以用File对象来代替字符串表示的文件名，便于检查路径是否合法，之后再将其作为参数传给FileWriter或FileOutputStream等。</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>缓冲区能让你暂时摆一堆东西一直到满为止。用了缓冲区就可以省下好几趟来回。</p>
<p><code>BufferedWriter writer = new BufferedWriter(new FileWriter(file));</code></p>
<p>缓冲区的奥妙之处在于，可以比没有使用缓冲区的效率更好。也可以直接使用FileWriter的write( )，但他每次都直接写进磁盘，而每趟磁盘操作会比内存操作花费更多的时间。通过BufferedWriter和FileWriter的链接，BufferedWriter可以暂存一堆数据，然后到满的时候再实际写入磁盘，可以减少对磁盘操作的次数。flush().</p>
]]></content>
  </entry>
  <entry>
    <title>新概念三</title>
    <url>/2021/06/01/%E6%96%B0%E6%A6%82%E5%BF%B5%E4%B8%89/</url>
    <content><![CDATA[<blockquote>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>True eccentrics never deliberately set out to draw attention to themselves. They disregard social conventions ==without being conscious that== they are doing anything extraordinary. This invariably wins them the love and respect of others, for they add color to the dull routine of everyday life.</p>
<p>   ==Up to== the time of his death, Richard Colson was one of the most notable figures in our town. He was a shrewd and wealthy businessman, but most people in the town hardly knew anything about this side of his life. He was known to us all as Dickie and his eccentricity had become legendary ==long before he died.==</p>
<p>   Dickie disliked snobs intensely. Though he owned a large car, he hardly ever used it, preferring always to go on foot. Even when it was raining heavily, he refused to carry an umbrella. One day, he walked into an expensive shop after having been caught in a particularly heavy shower. He wanted to buy a ￡300 watch for his wife, but he was in such a bedraggled condition that an assistant refused to serve him. Dickie left the shop without a word and returned carrying a large cloth bag. As it was extremely heavy, he dumped it on the counter. The assistant asked him to leave, but Dickie paid no attention to him and requested to see the manager. ==Recognizing who the customer was==, the manager was most apologetic and reprimanded the assistant severely. When Dickie was given the watch, he presented the assistant with the cloth bag. It contained ￡300 in pennies. He ==insisted on the assistant’s counting the money== before he left — 30,000 pennies in all!</p>
<p>   On another occasion, Dickie invited a number of important critics to see his private collection of modern paintings. This exhibition received a great deal of attention in the press, for though the pictures were supposed to be the work of famous artists, they had in fact been painted by Dickie. ==It took him four years to stage== this elaborate joke simply to prove that critics do not always know what they are talking about.</p>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ol>
<li>disregard v.忽视，不顾                                        </li>
<li>deliberately  adv.故意地；从容不迫地(I went to the woods because I wanted to live deliberately.)</li>
<li>invariably adv.一律地；总是                                 </li>
<li>notable adj.值得注意的；显著的</li>
<li>shrewd adj.精明的(emphasizes mental astuteness and practical understanding)</li>
<li>legendary adj.传说的；声名远扬的</li>
<li>snob n.势利小人</li>
<li>bedraggled adj.蓬乱的；衣衫不整的</li>
<li>apologetic adj.认错的；歉疚的；辩解的</li>
<li>reprimand v.谴责；训斥</li>
</ol>
<h3 id="短语"><a href="#短语" class="headerlink" title="短语"></a>短语</h3><p>in the press 在新闻界（媒体）              a great deal of 大量</p>
<p>set out to 试图                                          present sth to sb 把某物赠送/呈现/提交给某人</p>
</blockquote>
]]></content>
      <tags>
        <tag>Lesson 31 A lovable eccentric</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-1</title>
    <url>/2021/08/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">design</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">//若在IDE使用Console, 出错</span></span><br><span class="line">		System.out.println(<span class="string">&quot;请输入数字A&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		System.out.println(<span class="string">&quot;请选择运算符号(+、-、*、/):&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">B</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入数字B:&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">C</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		<span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> Double.parseDouble(C);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (B.equals(<span class="string">&quot;/&quot;</span>) &amp;&amp; c == <span class="number">0</span>) </span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> clclt(Double.parseDouble(A), B, c);</span><br><span class="line">		System.out.println(<span class="string">&quot;The answer is &quot;</span> + ans);</span><br><span class="line">		</span><br><span class="line">		&#125;<span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;您的输入有误,分母不能为零。故为 &quot;</span> + e.getMessage());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">clclt</span><span class="params">(<span class="type">double</span> A, String operator, <span class="type">double</span> C)</span> &#123;</span><br><span class="line">	<span class="type">double</span> <span class="variable">D</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">switch</span>(operator) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;+&quot;</span> :</span><br><span class="line">			D = A + C;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;-&quot;</span> :</span><br><span class="line">			D = A - C;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;*&quot;</span> :</span><br><span class="line">			D = A * C;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;/&quot;</span> :</span><br><span class="line">				D = A / C;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> D;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，此处使用Console进行输入会报错，原因是Java.io.Console只能用在 标准输入、输出流未被重定向 的原始控制台使用，在Eclipse或其他IDE的控制台是用不了的</p>
<p>增加上简单工厂模式后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operationFactory</span> &#123;</span><br><span class="line">	String operator;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">operationFactory</span><span class="params">(String opt)</span> &#123;</span><br><span class="line">		operator = opt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> operation <span class="title function_">creatOperator</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">		<span class="type">operation</span> <span class="variable">op</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">switch</span>(operator) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;+&quot;</span> :</span><br><span class="line">			op = <span class="keyword">new</span> <span class="title class_">operationAdd</span>(a, b);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;-&quot;</span> :</span><br><span class="line">			op = <span class="keyword">new</span> <span class="title class_">operationSub</span>(a, b);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;*&quot;</span> :</span><br><span class="line">			op = <span class="keyword">new</span> <span class="title class_">operationMul</span>(a, b);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;/&quot;</span> :</span><br><span class="line">			op = <span class="keyword">new</span> <span class="title class_">operationDiv</span>(a, b);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> op;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">operation</span> &#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">double</span> A;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">double</span> B;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">operation</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.A = a;</span><br><span class="line">		<span class="built_in">this</span>.B = b;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">GetResult</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;	</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入数字A&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		<span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> Double.parseDouble(A);</span><br><span class="line">		System.out.println(<span class="string">&quot;请选择运算符号(+、-、*、/):&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">B</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入数字B:&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">C</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">		<span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> Double.parseDouble(C);</span><br><span class="line">		<span class="type">operationFactory</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">operationFactory</span>(B);</span><br><span class="line">		<span class="type">operation</span> <span class="variable">prtn</span> <span class="operator">=</span> p.creatOperator(a, c);</span><br><span class="line">		System.out.println(<span class="string">&quot;结果是 &quot;</span> + prtn.GetResult());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operationAdd</span> <span class="keyword">extends</span> <span class="title class_">operation</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">operationAdd</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">GetResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> A + B;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operationSub</span> <span class="keyword">extends</span> <span class="title class_">operation</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">operationSub</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">GetResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> A - B;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operationMul</span> <span class="keyword">extends</span> <span class="title class_">operation</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">operationMul</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">GetResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> A * B;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">operationDiv</span> <span class="keyword">extends</span> <span class="title class_">operation</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">operationDiv</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">GetResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (B == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;输入出错，除数不能为零！&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> A / B;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <tags>
        <tag>代码历程</tag>
      </tags>
  </entry>
</search>
